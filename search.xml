<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[迟来的驾照]]></title>
    <url>%2F2018%2F05%2F24%2Fblog%2F%E8%BF%9F%E6%9D%A5%E7%9A%84%E9%A9%BE%E7%85%A7%2F</url>
    <content type="text"><![CDATA[对于开车这件事儿，貌似没有其他人那么强烈的欲望，所以一拖再拖的到了现在才提上日程。具体萌生出想法是去年冬天，也不知道因为什么，还是受什么刺激，突然想开车了。终于磨了大半年的时间开始行动了。 之前一直的想法是，自己又没有车，考了也没什么用。包括身边好多朋友，驾驶证都快换终身了，除了驾校学习，还没摸过车。也许我就是看到了这种情况，一直提不起去学的兴趣。现在想想还有点小小的后悔，为什么不早点去考呢。之前无论从学费，还是难易程度都比现在好很多。身边的人十之八九都考了好几年了，而我还是一个预备新手。。。 伴随着欲望的愈加强烈，终于在5号上午开启了我的学车之旅： 2018年5月5日 咨询报名资费一气呵成2018年5月25日 经过几个星期的法规学习参加了科一考试（雄心壮志的100分，结果得了94。。。大写的“囧”） 未完，待续。。。]]></content>
      <categories>
        <category>芬芳年华</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[圈圈]]></title>
    <url>%2F2018%2F05%2F03%2Fblog%2F%E5%9C%88%E5%9C%88%2F</url>
    <content type="text"><![CDATA[圈圈是一只被粗心的主人忘记了问出生日期的小泰迪，也是一只坚强的与病魔抗争过小英雄。 圈圈是一只长23高13厘米的呆萌型男，圈圈更是一只集智慧、乖巧等等优点于一身的小伙伴。 圈圈的名字源于它那一身金灿灿的毛发，是它的主人穷尽词汇，浪费了不少脑细胞得来的。 眨眼间，从出生两个多月后来到主人身边已经一个月零两天了。聪明的圈圈已经学会了上厕所、坐下、握手和卖萌。圈圈喜欢粘着主人要抱抱，圈圈也会乖巧在家等待主人的归来。虽然圈圈还是不能听懂很多命令，但它正在努力的去理解！ 虽然圈圈的主人在一个没有计划的下午冲动的把它带回家，但他(她）一直在努力的做的更好，对这个新到来的伙伴负责。因为这是他（她）的第一只自己的宠物，并且他（她）也很爱它。 忘了说，圈圈的生辰被它的糊涂主人定为了腊月初八！ 圈圈欢迎你的到来～ 我们不是一名铲屎官，我们只是它的搬运工！ —— 圈圈的主人]]></content>
      <categories>
        <category>芬芳年华</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[全文检索Sphinx—多索引配置文件]]></title>
    <url>%2F2018%2F04%2F18%2Ftech_stack%2F%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2Sphinx%E4%B9%8B%E7%B4%A2%E5%BC%95%E7%8B%AC%E7%AB%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[[TOC] Sphinx是一个基于SQL的全文检索引擎，可以结合MySQL,PostgreSQL做全文搜索. 开发过程中,可能涉及公共配置和多个索引配置,如果配置在一个文件中将导致文件庞大,难于维护所以考虑拆分配置文件,场景如下: 公共索引配置建立公共索引配置文件(sphinx-base.conf,包括数据源、索引、索引查询等配置) 如下： 12345678910111213141516171819202122232425262728293031323334source main_src&#123; type = mysql sql_host = localhost sql_user = 数据库用户名 sql_pass = 数据库密码 sql_db = 数据库名 sql_port = 3306 # 数据库端口(可选)，默认3306 sql_query_pre = SET NAMES utf8 #数据库编码&#125;indexer&#123; mem_limit = 256M&#125;searchd&#123; listen = 9312 listen = 9306:mysql41 mysql_version_string = 5.0.37 log = /usr/local/sphinx/var/log/searchd.log query_log = /usr/local/sphinx/var/log/query.log read_timeout = 5 max_children = 30 pid_file = /usr/local/sphinx/var/log/searchd.pid seamless_rotate = 1 preopen_indexes = 1 unlink_old = 1 workers = threads # for RT to work binlog_path = /usr/local/sphinx/var/data&#125; 索引一建立博客文章表索引(sphinx-article.conf)如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625source article_src:main_src&#123; sql_query_pre = SET NAMES utf8 #初始化索引记数表 sql_query_pre = REPLACE INTO yy_sphinx_counter SELECT 1,MAX(id) from yy_article #分步查询 sql_query_range = SELECT MIN(id),MAX(id) FROM yy_article sql_range_step = 1000 sql_query = \ SELECT \ a.id, a.titile, a.thumbnail, a.page_view, a.privacy, a.type, a.gmt_create, a.create_by, \ a.destination_id, a.destination_tag_id, b.name destinaiton_name, c.name destination_tag_name, d.content \ FROM yy_article a \ LEFT JOIN yy_destination b ON a.destination_id = b.id \ LEFT JOIN yy_destination_tag c ON a.destination_tag_id = c.id \ LEFT JOIN yy_article_content d ON a.id = d.article_id \ WHERE a.is_deleted = 0 AND a.audit_status = 1 and a.id &gt;= $start and a.id &lt;= $end sql_attr_string = gmt_create sql_attr_string = destinaiton_name sql_attr_string = destination_tag_name sql_attr_string = thumbnail sql_attr_uint = page_view sql_attr_uint = type sql_attr_bigint = create_by sql_attr_bigint = destination_id sql_attr_bigint = destination_tag_id # 被索引字段 sql_field_string = titile sql_field_string = privacy sql_field_string = content &#125;#增量数据源source article_delta_src : article_src&#123; sql_query_pre = REPLACE INTO yy_sphinx_counter SELECT 1,MAX(id) from yy_article sql_query_pre = SET NAMES utf8 #分步查询 sql_query_range = SELECT ( SELECT max_doc_id FROM yy_sphinx_counter WHERE id = 1), (SELECT max(id) FROM yy_article)&#125;index article&#123; source = article_src path = /usr/local/sphinx/var/data/article_index # 索引最小前缀(0表示任意字符) min_infix_len = 0 # 最小索引字符数(1表示每个字符都索引) min_word_len = 1 # 中文编码 charset_table = 0..9, U+27, U+41..U+5a-&gt;U+61..U+7a, U+61..U+7a, \U+aa, U+b5, U+ba, \U+c0..U+d6-&gt;U+e0..U+f6, U+d8..U+de-&gt;U+f8..U+fe, U+df..U+f6, \U+f8..U+ff, U+100..U+12f/2, U+130-&gt;U+69, \U+131, U+132..U+137/2, U+138, \U+139..U+148/2, U+149, U+14a..U+177/2, \U+178-&gt;U+ff, U+179..U+17e/2, U+17f..U+180, \U+181-&gt;U+253, U+182..U+185/2, U+186-&gt;U+254, \U+187..U+188/2, U+189..U+18a-&gt;U+256..U+257, U+18b..U+18c/2, \U+18d, U+18e-&gt;U+1dd, U+18f-&gt;U+259, \U+190-&gt;U+25b, U+191..U+192/2, U+193-&gt;U+260, \U+194-&gt;U+263, U+195, U+196-&gt;U+269, \U+197-&gt;U+268, U+198..U+199/2, U+19a..U+19b, \U+19c-&gt;U+26f, U+19d-&gt;U+272, U+19e, \U+19f-&gt;U+275, U+1a0..U+1a5/2, U+1a6-&gt;U+280, \U+1a7..U+1a8/2, U+1a9-&gt;U+283, U+1aa..U+1ab, \U+1ac..U+1ad/2, U+1ae-&gt;U+288, U+1af..U+1b0/2, \U+1b1..U+1b2-&gt;U+28a..U+28b, U+1b3..U+1b6/2, U+1b7-&gt;U+292, \U+1b8..U+1b9/2, U+1ba..U+1bb, U+1bc..U+1bd/2, \U+1be..U+1c3, U+1c4-&gt;U+1c6, U+1c5..U+1c6/2, \U+1c7-&gt;U+1c9, U+1c8..U+1c9/2, U+1ca-&gt;U+1cc, \U+1cb..U+1dc/2, U+1dd, U+1de..U+1ef/2, \U+1f0, U+1f1-&gt;U+1f3, U+1f2..U+1f5/2, \U+1f6-&gt;U+195, U+1f7-&gt;U+1bf, U+1f8..U+21f/2, \U+220-&gt;U+19e, U+221, U+222..U+233/2, \U+234..U+23a, U+23b..U+23c/2, U+23d-&gt;U+19a, \U+23e..U+240, U+241-&gt;U+294, U+250..U+2c1, \U+2c6..U+2d1, U+2e0..U+2e4, U+2ee, \U+1e96..U+1e9b, U+1ea0..U+1ef9/2, U+3005..U+3006, \U+3031..U+3035, U+303b..U+303c, U+3041..U+3096, \U+309d..U+309f, U+30a1..U+30fa, U+30fc..U+30ff, \U+31f0..U+31ff, U+F900-&gt;U+8C48, U+F901-&gt;U+66F4, \U+F902-&gt;U+8ECA, U+F903-&gt;U+8CC8, U+F904-&gt;U+6ED1, \U+F905-&gt;U+4E32, U+F906-&gt;U+53E5, U+F907-&gt;U+9F9C, \U+F908-&gt;U+9F9C, U+F909-&gt;U+5951, U+F90A-&gt;U+91D1, \U+F90B-&gt;U+5587, U+F90C-&gt;U+5948, U+F90D-&gt;U+61F6, \U+F90E-&gt;U+7669, U+F90F-&gt;U+7F85, U+F910-&gt;U+863F, \U+F911-&gt;U+87BA, U+F912-&gt;U+88F8, U+F913-&gt;U+908F, \U+F914-&gt;U+6A02, U+F915-&gt;U+6D1B, U+F916-&gt;U+70D9, \U+F917-&gt;U+73DE, U+F918-&gt;U+843D, U+F919-&gt;U+916A, \U+F91A-&gt;U+99F1, U+F91B-&gt;U+4E82, U+F91C-&gt;U+5375, \U+F91D-&gt;U+6B04, U+F91E-&gt;U+721B, U+F91F-&gt;U+862D, \U+F920-&gt;U+9E1E, U+F921-&gt;U+5D50, U+F922-&gt;U+6FEB, \U+F923-&gt;U+85CD, U+F924-&gt;U+8964, U+F925-&gt;U+62C9, \U+F926-&gt;U+81D8, U+F927-&gt;U+881F, U+F928-&gt;U+5ECA, \U+F929-&gt;U+6717, U+F92A-&gt;U+6D6A, U+F92B-&gt;U+72FC, \U+F92C-&gt;U+90CE, U+F92D-&gt;U+4F86, U+F92E-&gt;U+51B7, \U+F92F-&gt;U+52DE, U+F930-&gt;U+64C4, U+F931-&gt;U+6AD3, \U+F932-&gt;U+7210, U+F933-&gt;U+76E7, U+F934-&gt;U+8001, \U+F935-&gt;U+8606, U+F936-&gt;U+865C, U+F937-&gt;U+8DEF, \U+F938-&gt;U+9732, U+F939-&gt;U+9B6F, U+F93A-&gt;U+9DFA, \U+F93B-&gt;U+788C, U+F93C-&gt;U+797F, U+F93D-&gt;U+7DA0, \U+F93E-&gt;U+83C9, U+F93F-&gt;U+9304, U+F940-&gt;U+9E7F, \U+F941-&gt;U+8AD6, U+F942-&gt;U+58DF, U+F943-&gt;U+5F04, \U+F944-&gt;U+7C60, U+F945-&gt;U+807E, U+F946-&gt;U+7262, \U+F947-&gt;U+78CA, U+F948-&gt;U+8CC2, U+F949-&gt;U+96F7, \U+F94A-&gt;U+58D8, U+F94B-&gt;U+5C62, U+F94C-&gt;U+6A13, \U+F94D-&gt;U+6DDA, U+F94E-&gt;U+6F0F, U+F94F-&gt;U+7D2F, \U+F950-&gt;U+7E37, U+F951-&gt;U+964B, U+F952-&gt;U+52D2, \U+F953-&gt;U+808B, U+F954-&gt;U+51DC, U+F955-&gt;U+51CC, \U+F956-&gt;U+7A1C, U+F957-&gt;U+7DBE, U+F958-&gt;U+83F1, \U+F959-&gt;U+9675, U+F95A-&gt;U+8B80, U+F95B-&gt;U+62CF, \U+F95C-&gt;U+6A02, U+F95D-&gt;U+8AFE, U+F95E-&gt;U+4E39, \U+F95F-&gt;U+5BE7, U+F960-&gt;U+6012, U+F961-&gt;U+7387, \U+F962-&gt;U+7570, U+F963-&gt;U+5317, U+F964-&gt;U+78FB, \U+F965-&gt;U+4FBF, U+F966-&gt;U+5FA9, U+F967-&gt;U+4E0D, \U+F968-&gt;U+6CCC, U+F969-&gt;U+6578, U+F96A-&gt;U+7D22, \U+F96B-&gt;U+53C3, U+F96C-&gt;U+585E, U+F96D-&gt;U+7701, \U+F96E-&gt;U+8449, U+F96F-&gt;U+8AAA, U+F970-&gt;U+6BBA, \U+F971-&gt;U+8FB0, U+F972-&gt;U+6C88, U+F973-&gt;U+62FE, \U+F974-&gt;U+82E5, U+F975-&gt;U+63A0, U+F976-&gt;U+7565, \U+F977-&gt;U+4EAE, U+F978-&gt;U+5169, U+F979-&gt;U+51C9, \U+F97A-&gt;U+6881, U+F97B-&gt;U+7CE7, U+F97C-&gt;U+826F, \U+F97D-&gt;U+8AD2, U+F97E-&gt;U+91CF, U+F97F-&gt;U+52F5, \U+F980-&gt;U+5442, U+F981-&gt;U+5973, U+F982-&gt;U+5EEC, \U+F983-&gt;U+65C5, U+F984-&gt;U+6FFE, U+F985-&gt;U+792A, \U+F986-&gt;U+95AD, U+F987-&gt;U+9A6A, U+F988-&gt;U+9E97, \U+F989-&gt;U+9ECE, U+F98A-&gt;U+529B, U+F98B-&gt;U+66C6, \U+F98C-&gt;U+6B77, U+F98D-&gt;U+8F62, U+F98E-&gt;U+5E74, \U+F98F-&gt;U+6190, U+F990-&gt;U+6200, U+F991-&gt;U+649A, \U+F992-&gt;U+6F23, U+F993-&gt;U+7149, U+F994-&gt;U+7489, \U+F995-&gt;U+79CA, U+F996-&gt;U+7DF4, U+F997-&gt;U+806F, \U+F998-&gt;U+8F26, U+F999-&gt;U+84EE, U+F99A-&gt;U+9023, \U+F99B-&gt;U+934A, U+F99C-&gt;U+5217, U+F99D-&gt;U+52A3, \U+F99E-&gt;U+54BD, U+F99F-&gt;U+70C8, U+F9A0-&gt;U+88C2, \U+F9A1-&gt;U+8AAA, U+F9A2-&gt;U+5EC9, U+F9A3-&gt;U+5FF5, \U+F9A4-&gt;U+637B, U+F9A5-&gt;U+6BAE, U+F9A6-&gt;U+7C3E, \U+F9A7-&gt;U+7375, U+F9A8-&gt;U+4EE4, U+F9A9-&gt;U+56F9, \U+F9AA-&gt;U+5BE7, U+F9AB-&gt;U+5DBA, U+F9AC-&gt;U+601C, \U+F9AD-&gt;U+73B2, U+F9AE-&gt;U+7469, U+F9AF-&gt;U+7F9A, \U+F9B0-&gt;U+8046, U+F9B1-&gt;U+9234, U+F9B2-&gt;U+96F6, \U+F9B3-&gt;U+9748, U+F9B4-&gt;U+9818, U+F9B5-&gt;U+4F8B, \U+F9B6-&gt;U+79AE, U+F9B7-&gt;U+91B4, U+F9B8-&gt;U+96B8, \U+F9B9-&gt;U+60E1, U+F9BA-&gt;U+4E86, U+F9BB-&gt;U+50DA, \U+F9BC-&gt;U+5BEE, U+F9BD-&gt;U+5C3F, U+F9BE-&gt;U+6599, \U+F9BF-&gt;U+6A02, U+F9C0-&gt;U+71CE, U+F9C1-&gt;U+7642, \U+F9C2-&gt;U+84FC, U+F9C3-&gt;U+907C, U+F9C4-&gt;U+9F8D, \U+F9C5-&gt;U+6688, U+F9C6-&gt;U+962E, U+F9C7-&gt;U+5289, \U+F9C8-&gt;U+677B, U+F9C9-&gt;U+67F3, U+F9CA-&gt;U+6D41, \U+F9CB-&gt;U+6E9C, U+F9CC-&gt;U+7409, U+F9CD-&gt;U+7559, \U+F9CE-&gt;U+786B, U+F9CF-&gt;U+7D10, U+F9D0-&gt;U+985E, \U+F9D1-&gt;U+516D, U+F9D2-&gt;U+622E, U+F9D3-&gt;U+9678, \U+F9D4-&gt;U+502B, U+F9D5-&gt;U+5D19, U+F9D6-&gt;U+6DEA, \U+F9D7-&gt;U+8F2A, U+F9D8-&gt;U+5F8B, U+F9D9-&gt;U+6144, \U+F9DA-&gt;U+6817, U+F9DB-&gt;U+7387, U+F9DC-&gt;U+9686, \U+F9DD-&gt;U+5229, U+F9DE-&gt;U+540F, U+F9DF-&gt;U+5C65, \U+F9E0-&gt;U+6613, U+F9E1-&gt;U+674E, U+F9E2-&gt;U+68A8, \U+F9E3-&gt;U+6CE5, U+F9E4-&gt;U+7406, U+F9E5-&gt;U+75E2, \U+F9E6-&gt;U+7F79, U+F9E7-&gt;U+88CF, U+F9E8-&gt;U+88E1, \U+F9E9-&gt;U+91CC, U+F9EA-&gt;U+96E2, U+F9EB-&gt;U+533F, \U+F9EC-&gt;U+6EBA, U+F9ED-&gt;U+541D, U+F9EE-&gt;U+71D0, \U+F9EF-&gt;U+7498, U+F9F0-&gt;U+85FA, U+F9F1-&gt;U+96A3, \U+F9F2-&gt;U+9C57, U+F9F3-&gt;U+9E9F, U+F9F4-&gt;U+6797, \U+F9F5-&gt;U+6DCB, U+F9F6-&gt;U+81E8, U+F9F7-&gt;U+7ACB, \U+F9F8-&gt;U+7B20, U+F9F9-&gt;U+7C92, U+F9FA-&gt;U+72C0, \U+F9FB-&gt;U+7099, U+F9FC-&gt;U+8B58, U+F9FD-&gt;U+4EC0, \U+F9FE-&gt;U+8336, U+F9FF-&gt;U+523A, U+FA00-&gt;U+5207, \U+FA01-&gt;U+5EA6, U+FA02-&gt;U+62D3, U+FA03-&gt;U+7CD6, \U+FA04-&gt;U+5B85, U+FA05-&gt;U+6D1E, U+FA06-&gt;U+66B4, \U+FA07-&gt;U+8F3B, U+FA08-&gt;U+884C, U+FA09-&gt;U+964D, \U+FA0A-&gt;U+898B, U+FA0B-&gt;U+5ED3, U+FA0C-&gt;U+5140, \U+FA0D-&gt;U+55C0, U+FA10-&gt;U+585A, U+FA12-&gt;U+6674, \U+FA15-&gt;U+51DE, U+FA16-&gt;U+732A, U+FA17-&gt;U+76CA, \U+FA18-&gt;U+793C, U+FA19-&gt;U+795E, U+FA1A-&gt;U+7965, \U+FA1B-&gt;U+798F, U+FA1C-&gt;U+9756, U+FA1D-&gt;U+7CBE, \U+FA1E-&gt;U+7FBD, U+FA20-&gt;U+8612, U+FA22-&gt;U+8AF8, \U+FA25-&gt;U+9038, U+FA26-&gt;U+90FD, U+FA2A-&gt;U+98EF, \U+FA2B-&gt;U+98FC, U+FA2C-&gt;U+9928, U+FA2D-&gt;U+9DB4, \U+FA30-&gt;U+4FAE, U+FA31-&gt;U+50E7, U+FA32-&gt;U+514D, \U+FA33-&gt;U+52C9, U+FA34-&gt;U+52E4, U+FA35-&gt;U+5351, \U+FA36-&gt;U+559D, U+FA37-&gt;U+5606, U+FA38-&gt;U+5668, \U+FA39-&gt;U+5840, U+FA3A-&gt;U+58A8, U+FA3B-&gt;U+5C64, \U+FA3C-&gt;U+5C6E, U+FA3D-&gt;U+6094, U+FA3E-&gt;U+6168, \U+FA3F-&gt;U+618E, U+FA40-&gt;U+61F2, U+FA41-&gt;U+654F, \U+FA42-&gt;U+65E2, U+FA43-&gt;U+6691, U+FA44-&gt;U+6885, \U+FA45-&gt;U+6D77, U+FA46-&gt;U+6E1A, U+FA47-&gt;U+6F22, \U+FA48-&gt;U+716E, U+FA49-&gt;U+722B, U+FA4A-&gt;U+7422, \U+FA4B-&gt;U+7891, U+FA4C-&gt;U+793E, U+FA4D-&gt;U+7949, \U+FA4E-&gt;U+7948, U+FA4F-&gt;U+7950, U+FA50-&gt;U+7956, \U+FA51-&gt;U+795D, U+FA52-&gt;U+798D, U+FA53-&gt;U+798E, \U+FA54-&gt;U+7A40, U+FA55-&gt;U+7A81, U+FA56-&gt;U+7BC0, \U+FA57-&gt;U+7DF4, U+FA58-&gt;U+7E09, U+FA59-&gt;U+7E41, \U+FA5A-&gt;U+7F72, U+FA5B-&gt;U+8005, U+FA5C-&gt;U+81ED, \U+FA5D-&gt;U+8279, U+FA5E-&gt;U+8279, U+FA5F-&gt;U+8457, \U+FA60-&gt;U+8910, U+FA61-&gt;U+8996, U+FA62-&gt;U+8B01, \U+FA63-&gt;U+8B39, U+FA64-&gt;U+8CD3, U+FA65-&gt;U+8D08, \U+FA66-&gt;U+8FB6, U+FA67-&gt;U+9038, U+FA68-&gt;U+96E3, \U+FA69-&gt;U+97FF, U+FA6A-&gt;U+983B, U+FA70-&gt;U+4E26, \U+FA71-&gt;U+51B5, U+FA72-&gt;U+5168, U+FA73-&gt;U+4F80, \U+FA74-&gt;U+5145, U+FA75-&gt;U+5180, U+FA76-&gt;U+52C7, \U+FA77-&gt;U+52FA, U+FA78-&gt;U+559D, U+FA79-&gt;U+5555, \U+FA7A-&gt;U+5599, U+FA7B-&gt;U+55E2, U+FA7C-&gt;U+585A, \U+FA7D-&gt;U+58B3, U+FA7E-&gt;U+5944, U+FA7F-&gt;U+5954, \U+FA80-&gt;U+5A62, U+FA81-&gt;U+5B28, U+FA82-&gt;U+5ED2, \U+FA83-&gt;U+5ED9, U+FA84-&gt;U+5F69, U+FA85-&gt;U+5FAD, \U+FA86-&gt;U+60D8, U+FA87-&gt;U+614E, U+FA88-&gt;U+6108, \U+FA89-&gt;U+618E, U+FA8A-&gt;U+6160, U+FA8B-&gt;U+61F2, \U+FA8C-&gt;U+6234, U+FA8D-&gt;U+63C4, U+FA8E-&gt;U+641C, \U+FA8F-&gt;U+6452, U+FA90-&gt;U+6556, U+FA91-&gt;U+6674, \U+FA92-&gt;U+6717, U+FA93-&gt;U+671B, U+FA94-&gt;U+6756, \U+FA95-&gt;U+6B79, U+FA96-&gt;U+6BBA, U+FA97-&gt;U+6D41, \U+FA98-&gt;U+6EDB, U+FA99-&gt;U+6ECB, U+FA9A-&gt;U+6F22, \U+FA9B-&gt;U+701E, U+FA9C-&gt;U+716E, U+FA9D-&gt;U+77A7, \U+FA9E-&gt;U+7235, U+FA9F-&gt;U+72AF, U+FAA0-&gt;U+732A, \U+FAA1-&gt;U+7471, U+FAA2-&gt;U+7506, U+FAA3-&gt;U+753B, \U+FAA4-&gt;U+761D, U+FAA5-&gt;U+761F, U+FAA6-&gt;U+76CA, \U+FAA7-&gt;U+76DB, U+FAA8-&gt;U+76F4, U+FAA9-&gt;U+774A, \U+FAAA-&gt;U+7740, U+FAAB-&gt;U+78CC, U+FAAC-&gt;U+7AB1, \U+FAAD-&gt;U+7BC0, U+FAAE-&gt;U+7C7B, U+FAAF-&gt;U+7D5B, \U+FAB0-&gt;U+7DF4, U+FAB1-&gt;U+7F3E, U+FAB2-&gt;U+8005, \U+FAB3-&gt;U+8352, U+FAB4-&gt;U+83EF, U+FAB5-&gt;U+8779, \U+FAB6-&gt;U+8941, U+FAB7-&gt;U+8986, U+FAB8-&gt;U+8996, \U+FAB9-&gt;U+8ABF, U+FABA-&gt;U+8AF8, U+FABB-&gt;U+8ACB, \U+FABC-&gt;U+8B01, U+FABD-&gt;U+8AFE, U+FABE-&gt;U+8AED, \U+FABF-&gt;U+8B39, U+FAC0-&gt;U+8B8A, U+FAC1-&gt;U+8D08, \U+FAC2-&gt;U+8F38, U+FAC3-&gt;U+9072, U+FAC4-&gt;U+9199, \U+FAC5-&gt;U+9276, U+FAC6-&gt;U+967C, U+FAC7-&gt;U+96E3, \U+FAC8-&gt;U+9756, U+FAC9-&gt;U+97DB, U+FACA-&gt;U+97FF, \U+FACB-&gt;U+980B, U+FACC-&gt;U+983B, U+FACD-&gt;U+9B12, \U+FACE-&gt;U+9F9C, U+FACF-&gt;U+2284A, U+FAD0-&gt;U+22844, \U+FAD1-&gt;U+233D5, U+FAD2-&gt;U+3B9D, U+FAD3-&gt;U+4018, \U+FAD4-&gt;U+4039, U+FAD5-&gt;U+25249, U+FAD6-&gt;U+25CD0, \U+FAD7-&gt;U+27ED3, U+FAD8-&gt;U+9F43, U+FAD9-&gt;U+9F8E, \U+2F800-&gt;U+4E3D, U+2F801-&gt;U+4E38, U+2F802-&gt;U+4E41, \U+2F803-&gt;U+20122, U+2F804-&gt;U+4F60, U+2F805-&gt;U+4FAE, \U+2F806-&gt;U+4FBB, U+2F807-&gt;U+5002, U+2F808-&gt;U+507A, \U+2F809-&gt;U+5099, U+2F80A-&gt;U+50E7, U+2F80B-&gt;U+50CF, \U+2F80C-&gt;U+349E, U+2F80D-&gt;U+2063A, U+2F80E-&gt;U+514D, \U+2F80F-&gt;U+5154, U+2F810-&gt;U+5164, U+2F811-&gt;U+5177, \U+2F812-&gt;U+2051C, U+2F813-&gt;U+34B9, U+2F814-&gt;U+5167, \U+2F815-&gt;U+518D, U+2F816-&gt;U+2054B, U+2F817-&gt;U+5197, \U+2F818-&gt;U+51A4, U+2F819-&gt;U+4ECC, U+2F81A-&gt;U+51AC, \U+2F81B-&gt;U+51B5, U+2F81C-&gt;U+291DF, U+2F81D-&gt;U+51F5, \U+2F81E-&gt;U+5203, U+2F81F-&gt;U+34DF, U+2F820-&gt;U+523B, \U+2F821-&gt;U+5246, U+2F822-&gt;U+5272, U+2F823-&gt;U+5277, \U+2F824-&gt;U+3515, U+2F825-&gt;U+52C7, U+2F826-&gt;U+52C9, \U+2F827-&gt;U+52E4, U+2F828-&gt;U+52FA, U+2F829-&gt;U+5305, \U+2F82A-&gt;U+5306, U+2F82B-&gt;U+5317, U+2F82C-&gt;U+5349, \U+2F82D-&gt;U+5351, U+2F82E-&gt;U+535A, U+2F82F-&gt;U+5373, \U+2F830-&gt;U+537D, U+2F831-&gt;U+537F, U+2F832-&gt;U+537F, \U+2F833-&gt;U+537F, U+2F834-&gt;U+20A2C, U+2F835-&gt;U+7070, \U+2F836-&gt;U+53CA, U+2F837-&gt;U+53DF, U+2F838-&gt;U+20B63, \U+2F839-&gt;U+53EB, U+2F83A-&gt;U+53F1, U+2F83B-&gt;U+5406, \U+2F83C-&gt;U+549E, U+2F83D-&gt;U+5438, U+2F83E-&gt;U+5448, \U+2F83F-&gt;U+5468, U+2F840-&gt;U+54A2, U+2F841-&gt;U+54F6, \U+2F842-&gt;U+5510, U+2F843-&gt;U+5553, U+2F844-&gt;U+5563, \U+2F845-&gt;U+5584, U+2F846-&gt;U+5584, U+2F847-&gt;U+5599, \U+2F848-&gt;U+55AB, U+2F849-&gt;U+55B3, U+2F84A-&gt;U+55C2, \U+2F84B-&gt;U+5716, U+2F84C-&gt;U+5606, U+2F84D-&gt;U+5717, \U+2F84E-&gt;U+5651, U+2F84F-&gt;U+5674, U+2F850-&gt;U+5207, \U+2F851-&gt;U+58EE, U+2F852-&gt;U+57CE, U+2F853-&gt;U+57F4, \U+2F854-&gt;U+580D, U+2F855-&gt;U+578B, U+2F856-&gt;U+5832, \U+2F857-&gt;U+5831, U+2F858-&gt;U+58AC, U+2F859-&gt;U+214E4, \U+2F85A-&gt;U+58F2, U+2F85B-&gt;U+58F7, U+2F85C-&gt;U+5906, \U+2F85D-&gt;U+591A, U+2F85E-&gt;U+5922, U+2F85F-&gt;U+5962, \U+2F860-&gt;U+216A8, U+2F861-&gt;U+216EA, U+2F862-&gt;U+59EC, \U+2F863-&gt;U+5A1B, U+2F864-&gt;U+5A27, U+2F865-&gt;U+59D8, \U+2F866-&gt;U+5A66, U+2F867-&gt;U+36EE, U+2F868-&gt;U+36FC, \U+2F869-&gt;U+5B08, U+2F86A-&gt;U+5B3E, U+2F86B-&gt;U+5B3E, \U+2F86C-&gt;U+219C8, U+2F86D-&gt;U+5BC3, U+2F86E-&gt;U+5BD8, \U+2F86F-&gt;U+5BE7, U+2F870-&gt;U+5BF3, U+2F871-&gt;U+21B18, \U+2F872-&gt;U+5BFF, U+2F873-&gt;U+5C06, U+2F874-&gt;U+5F53, \U+2F875-&gt;U+5C22, U+2F876-&gt;U+3781, U+2F877-&gt;U+5C60, \U+2F878-&gt;U+5C6E, U+2F879-&gt;U+5CC0, U+2F87A-&gt;U+5C8D, \U+2F87B-&gt;U+21DE4, U+2F87C-&gt;U+5D43, U+2F87D-&gt;U+21DE6, \U+2F87E-&gt;U+5D6E, U+2F87F-&gt;U+5D6B, U+2F880-&gt;U+5D7C, \U+2F881-&gt;U+5DE1, U+2F882-&gt;U+5DE2, U+2F883-&gt;U+382F, \U+2F884-&gt;U+5DFD, U+2F885-&gt;U+5E28, U+2F886-&gt;U+5E3D, \U+2F887-&gt;U+5E69, U+2F888-&gt;U+3862, U+2F889-&gt;U+22183, \U+2F88A-&gt;U+387C, U+2F88B-&gt;U+5EB0, U+2F88C-&gt;U+5EB3, \U+2F88D-&gt;U+5EB6, U+2F88E-&gt;U+5ECA, U+2F88F-&gt;U+2A392, \U+2F890-&gt;U+5EFE, U+2F891-&gt;U+22331, U+2F892-&gt;U+22331, \U+2F893-&gt;U+8201, U+2F894-&gt;U+5F22, U+2F895-&gt;U+5F22, \U+2F896-&gt;U+38C7, U+2F897-&gt;U+232B8, U+2F898-&gt;U+261DA, \U+2F899-&gt;U+5F62, U+2F89A-&gt;U+5F6B, U+2F89B-&gt;U+38E3, \U+2F89C-&gt;U+5F9A, U+2F89D-&gt;U+5FCD, U+2F89E-&gt;U+5FD7, \U+2F89F-&gt;U+5FF9, U+2F8A0-&gt;U+6081, U+2F8A1-&gt;U+393A, \U+2F8A2-&gt;U+391C, U+2F8A3-&gt;U+6094, U+2F8A4-&gt;U+226D4, \U+2F8A5-&gt;U+60C7, U+2F8A6-&gt;U+6148, U+2F8A7-&gt;U+614C, \U+2F8A8-&gt;U+614E, U+2F8A9-&gt;U+614C, U+2F8AA-&gt;U+617A, \U+2F8AB-&gt;U+618E, U+2F8AC-&gt;U+61B2, U+2F8AD-&gt;U+61A4, \U+2F8AE-&gt;U+61AF, U+2F8AF-&gt;U+61DE, U+2F8B0-&gt;U+61F2, \U+2F8B1-&gt;U+61F6, U+2F8B2-&gt;U+6210, U+2F8B3-&gt;U+621B, \U+2F8B4-&gt;U+625D, U+2F8B5-&gt;U+62B1, U+2F8B6-&gt;U+62D4, \U+2F8B7-&gt;U+6350, U+2F8B8-&gt;U+22B0C, U+2F8B9-&gt;U+633D, \U+2F8BA-&gt;U+62FC, U+2F8BB-&gt;U+6368, U+2F8BC-&gt;U+6383, \U+2F8BD-&gt;U+63E4, U+2F8BE-&gt;U+22BF1, U+2F8BF-&gt;U+6422, \U+2F8C0-&gt;U+63C5, U+2F8C1-&gt;U+63A9, U+2F8C2-&gt;U+3A2E, \U+2F8C3-&gt;U+6469, U+2F8C4-&gt;U+647E, U+2F8C5-&gt;U+649D, \U+2F8C6-&gt;U+6477, U+2F8C7-&gt;U+3A6C, U+2F8C8-&gt;U+654F, \U+2F8C9-&gt;U+656C, U+2F8CA-&gt;U+2300A, U+2F8CB-&gt;U+65E3, \U+2F8CC-&gt;U+66F8, U+2F8CD-&gt;U+6649, U+2F8CE-&gt;U+3B19, \U+2F8CF-&gt;U+6691, U+2F8D0-&gt;U+3B08, U+2F8D1-&gt;U+3AE4, \U+2F8D2-&gt;U+5192, U+2F8D3-&gt;U+5195, U+2F8D4-&gt;U+6700, \U+2F8D5-&gt;U+669C, U+2F8D6-&gt;U+80AD, U+2F8D7-&gt;U+43D9, \U+2F8D8-&gt;U+6717, U+2F8D9-&gt;U+671B, U+2F8DA-&gt;U+6721, \U+2F8DB-&gt;U+675E, U+2F8DC-&gt;U+6753, U+2F8DD-&gt;U+233C3, \U+2F8DE-&gt;U+3B49, U+2F8DF-&gt;U+67FA, U+2F8E0-&gt;U+6785, \U+2F8E1-&gt;U+6852, U+2F8E2-&gt;U+6885, U+2F8E3-&gt;U+2346D, \U+2F8E4-&gt;U+688E, U+2F8E5-&gt;U+681F, U+2F8E6-&gt;U+6914, \U+2F8E7-&gt;U+3B9D, U+2F8E8-&gt;U+6942, U+2F8E9-&gt;U+69A3, \U+2F8EA-&gt;U+69EA, U+2F8EB-&gt;U+6AA8, U+2F8EC-&gt;U+236A3, \U+2F8ED-&gt;U+6ADB, U+2F8EE-&gt;U+3C18, U+2F8EF-&gt;U+6B21, \U+2F8F0-&gt;U+238A7, U+2F8F1-&gt;U+6B54, U+2F8F2-&gt;U+3C4E, \U+2F8F3-&gt;U+6B72, U+2F8F4-&gt;U+6B9F, U+2F8F5-&gt;U+6BBA, \U+2F8F6-&gt;U+6BBB, U+2F8F7-&gt;U+23A8D, U+2F8F8-&gt;U+21D0B, \U+2F8F9-&gt;U+23AFA, U+2F8FA-&gt;U+6C4E, U+2F8FB-&gt;U+23CBC, \U+2F8FC-&gt;U+6CBF, U+2F8FD-&gt;U+6CCD, U+2F8FE-&gt;U+6C67, \U+2F8FF-&gt;U+6D16, U+2F900-&gt;U+6D3E, U+2F901-&gt;U+6D77, \U+2F902-&gt;U+6D41, U+2F903-&gt;U+6D69, U+2F904-&gt;U+6D78, \U+2F905-&gt;U+6D85, U+2F906-&gt;U+23D1E, U+2F907-&gt;U+6D34, \U+2F908-&gt;U+6E2F, U+2F909-&gt;U+6E6E, U+2F90A-&gt;U+3D33, \U+2F90B-&gt;U+6ECB, U+2F90C-&gt;U+6EC7, U+2F90D-&gt;U+23ED1, \U+2F90E-&gt;U+6DF9, U+2F90F-&gt;U+6F6E, U+2F910-&gt;U+23F5E, \U+2F911-&gt;U+23F8E, U+2F912-&gt;U+6FC6, U+2F913-&gt;U+7039, \U+2F914-&gt;U+701E, U+2F915-&gt;U+701B, U+2F916-&gt;U+3D96, \U+2F917-&gt;U+704A, U+2F918-&gt;U+707D, U+2F919-&gt;U+7077, \U+2F91A-&gt;U+70AD, U+2F91B-&gt;U+20525, U+2F91C-&gt;U+7145, \U+2F91D-&gt;U+24263, U+2F91E-&gt;U+719C, U+2F91F-&gt;U+243AB, \U+2F920-&gt;U+7228, U+2F921-&gt;U+7235, U+2F922-&gt;U+7250, \U+2F923-&gt;U+24608, U+2F924-&gt;U+7280, U+2F925-&gt;U+7295, \U+2F926-&gt;U+24735, U+2F927-&gt;U+24814, U+2F928-&gt;U+737A, \U+2F929-&gt;U+738B, U+2F92A-&gt;U+3EAC, U+2F92B-&gt;U+73A5, \U+2F92C-&gt;U+3EB8, U+2F92D-&gt;U+3EB8, U+2F92E-&gt;U+7447, \U+2F92F-&gt;U+745C, U+2F930-&gt;U+7471, U+2F931-&gt;U+7485, \U+2F932-&gt;U+74CA, U+2F933-&gt;U+3F1B, U+2F934-&gt;U+7524, \U+2F935-&gt;U+24C36, U+2F936-&gt;U+753E, U+2F937-&gt;U+24C92, \U+2F938-&gt;U+7570, U+2F939-&gt;U+2219F, U+2F93A-&gt;U+7610, \U+2F93B-&gt;U+24FA1, U+2F93C-&gt;U+24FB8, U+2F93D-&gt;U+25044, \U+2F93E-&gt;U+3FFC, U+2F93F-&gt;U+4008, U+2F940-&gt;U+76F4, \U+2F941-&gt;U+250F3, U+2F942-&gt;U+250F2, U+2F943-&gt;U+25119, \U+2F944-&gt;U+25133, U+2F945-&gt;U+771E, U+2F946-&gt;U+771F, \U+2F947-&gt;U+771F, U+2F948-&gt;U+774A, U+2F949-&gt;U+4039, \U+2F94A-&gt;U+778B, U+2F94B-&gt;U+4046, U+2F94C-&gt;U+4096, \U+2F94D-&gt;U+2541D, U+2F94E-&gt;U+784E, U+2F94F-&gt;U+788C, \U+2F950-&gt;U+78CC, U+2F951-&gt;U+40E3, U+2F952-&gt;U+25626, \U+2F953-&gt;U+7956, U+2F954-&gt;U+2569A, U+2F955-&gt;U+256C5, \U+2F956-&gt;U+798F, U+2F957-&gt;U+79EB, U+2F958-&gt;U+412F, \U+2F959-&gt;U+7A40, U+2F95A-&gt;U+7A4A, U+2F95B-&gt;U+7A4F, \U+2F95C-&gt;U+2597C, U+2F95D-&gt;U+25AA7, U+2F95E-&gt;U+25AA7, \U+2F95F-&gt;U+7AEE, U+2F960-&gt;U+4202, U+2F961-&gt;U+25BAB, \U+2F962-&gt;U+7BC6, U+2F963-&gt;U+7BC9, U+2F964-&gt;U+4227, \U+2F965-&gt;U+25C80, U+2F966-&gt;U+7CD2, U+2F967-&gt;U+42A0, \U+2F968-&gt;U+7CE8, U+2F969-&gt;U+7CE3, U+2F96A-&gt;U+7D00, \U+2F96B-&gt;U+25F86, U+2F96C-&gt;U+7D63, U+2F96D-&gt;U+4301, \U+2F96E-&gt;U+7DC7, U+2F96F-&gt;U+7E02, U+2F970-&gt;U+7E45, \U+2F971-&gt;U+4334, U+2F972-&gt;U+26228, U+2F973-&gt;U+26247, \U+2F974-&gt;U+4359, U+2F975-&gt;U+262D9, U+2F976-&gt;U+7F7A, \U+2F977-&gt;U+2633E, U+2F978-&gt;U+7F95, U+2F979-&gt;U+7FFA, \U+2F97A-&gt;U+8005, U+2F97B-&gt;U+264DA, U+2F97C-&gt;U+26523, \U+2F97D-&gt;U+8060, U+2F97E-&gt;U+265A8, U+2F97F-&gt;U+8070, \U+2F980-&gt;U+2335F, U+2F981-&gt;U+43D5, U+2F982-&gt;U+80B2, \U+2F983-&gt;U+8103, U+2F984-&gt;U+440B, U+2F985-&gt;U+813E, \U+2F986-&gt;U+5AB5, U+2F987-&gt;U+267A7, U+2F988-&gt;U+267B5, \U+2F989-&gt;U+23393, U+2F98A-&gt;U+2339C, U+2F98B-&gt;U+8201, \U+2F98C-&gt;U+8204, U+2F98D-&gt;U+8F9E, U+2F98E-&gt;U+446B, \U+2F98F-&gt;U+8291, U+2F990-&gt;U+828B, U+2F991-&gt;U+829D, \U+2F992-&gt;U+52B3, U+2F993-&gt;U+82B1, U+2F994-&gt;U+82B3, \U+2F995-&gt;U+82BD, U+2F996-&gt;U+82E6, U+2F997-&gt;U+26B3C, \U+2F998-&gt;U+82E5, U+2F999-&gt;U+831D, U+2F99A-&gt;U+8363, \U+2F99B-&gt;U+83AD, U+2F99C-&gt;U+8323, U+2F99D-&gt;U+83BD, \U+2F99E-&gt;U+83E7, U+2F99F-&gt;U+8457, U+2F9A0-&gt;U+8353, \U+2F9A1-&gt;U+83CA, U+2F9A2-&gt;U+83CC, U+2F9A3-&gt;U+83DC, \U+2F9A4-&gt;U+26C36, U+2F9A5-&gt;U+26D6B, U+2F9A6-&gt;U+26CD5, \U+2F9A7-&gt;U+452B, U+2F9A8-&gt;U+84F1, U+2F9A9-&gt;U+84F3, \U+2F9AA-&gt;U+8516, U+2F9AB-&gt;U+273CA, U+2F9AC-&gt;U+8564, \U+2F9AD-&gt;U+26F2C, U+2F9AE-&gt;U+455D, U+2F9AF-&gt;U+4561, \U+2F9B0-&gt;U+26FB1, U+2F9B1-&gt;U+270D2, U+2F9B2-&gt;U+456B, \U+2F9B3-&gt;U+8650, U+2F9B4-&gt;U+865C, U+2F9B5-&gt;U+8667, \U+2F9B6-&gt;U+8669, U+2F9B7-&gt;U+86A9, U+2F9B8-&gt;U+8688, \U+2F9B9-&gt;U+870E, U+2F9BA-&gt;U+86E2, U+2F9BB-&gt;U+8779, \U+2F9BC-&gt;U+8728, U+2F9BD-&gt;U+876B, U+2F9BE-&gt;U+8786, \U+2F9BF-&gt;U+45D7, U+2F9C0-&gt;U+87E1, U+2F9C1-&gt;U+8801, \U+2F9C2-&gt;U+45F9, U+2F9C3-&gt;U+8860, U+2F9C4-&gt;U+8863, \U+2F9C5-&gt;U+27667, U+2F9C6-&gt;U+88D7, U+2F9C7-&gt;U+88DE, \U+2F9C8-&gt;U+4635, U+2F9C9-&gt;U+88FA, U+2F9CA-&gt;U+34BB, \U+2F9CB-&gt;U+278AE, U+2F9CC-&gt;U+27966, U+2F9CD-&gt;U+46BE, \U+2F9CE-&gt;U+46C7, U+2F9CF-&gt;U+8AA0, U+2F9D0-&gt;U+8AED, \U+2F9D1-&gt;U+8B8A, U+2F9D2-&gt;U+8C55, U+2F9D3-&gt;U+27CA8, \U+2F9D4-&gt;U+8CAB, U+2F9D5-&gt;U+8CC1, U+2F9D6-&gt;U+8D1B, \U+2F9D7-&gt;U+8D77, U+2F9D8-&gt;U+27F2F, U+2F9D9-&gt;U+20804, \U+2F9DA-&gt;U+8DCB, U+2F9DB-&gt;U+8DBC, U+2F9DC-&gt;U+8DF0, \U+2F9DD-&gt;U+208DE, U+2F9DE-&gt;U+8ED4, U+2F9DF-&gt;U+8F38, \U+2F9E0-&gt;U+285D2, U+2F9E1-&gt;U+285ED, U+2F9E2-&gt;U+9094, \U+2F9E3-&gt;U+90F1, U+2F9E4-&gt;U+9111, U+2F9E5-&gt;U+2872E, \U+2F9E6-&gt;U+911B, U+2F9E7-&gt;U+9238, U+2F9E8-&gt;U+92D7, \U+2F9E9-&gt;U+92D8, U+2F9EA-&gt;U+927C, U+2F9EB-&gt;U+93F9, \U+2F9EC-&gt;U+9415, U+2F9ED-&gt;U+28BFA, U+2F9EE-&gt;U+958B, \U+2F9EF-&gt;U+4995, U+2F9F0-&gt;U+95B7, U+2F9F1-&gt;U+28D77, \U+2F9F2-&gt;U+49E6, U+2F9F3-&gt;U+96C3, U+2F9F4-&gt;U+5DB2, \U+2F9F5-&gt;U+9723, U+2F9F6-&gt;U+29145, U+2F9F7-&gt;U+2921A, \U+2F9F8-&gt;U+4A6E, U+2F9F9-&gt;U+4A76, U+2F9FA-&gt;U+97E0, \U+2F9FB-&gt;U+2940A, U+2F9FC-&gt;U+4AB2, U+2F9FD-&gt;U+29496, \U+2F9FE-&gt;U+980B, U+2F9FF-&gt;U+980B, U+2FA00-&gt;U+9829, \U+2FA01-&gt;U+295B6, U+2FA02-&gt;U+98E2, U+2FA03-&gt;U+4B33, \U+2FA04-&gt;U+9929, U+2FA05-&gt;U+99A7, U+2FA06-&gt;U+99C2, \U+2FA07-&gt;U+99FE, U+2FA08-&gt;U+4BCE, U+2FA09-&gt;U+29B30, \U+2FA0A-&gt;U+9B12, U+2FA0B-&gt;U+9C40, U+2FA0C-&gt;U+9CFD, \U+2FA0D-&gt;U+4CCE, U+2FA0E-&gt;U+4CED, U+2FA0F-&gt;U+9D67, \U+2FA10-&gt;U+2A0CE, U+2FA11-&gt;U+4CF8, U+2FA12-&gt;U+2A105, \U+2FA13-&gt;U+2A20E, U+2FA14-&gt;U+2A291, U+2FA15-&gt;U+9EBB, \U+2FA16-&gt;U+4D56, U+2FA17-&gt;U+9EF9, U+2FA18-&gt;U+9EFE, \U+2FA19-&gt;U+9F05, U+2FA1A-&gt;U+9F0F, U+2FA1B-&gt;U+9F16, \U+2FA1C-&gt;U+9F3B, U+2FA1D-&gt;U+2A600, U+2F00-&gt;U+4E00, \U+2F01-&gt;U+4E28, U+2F02-&gt;U+4E36, U+2F03-&gt;U+4E3F, \U+2F04-&gt;U+4E59, U+2F05-&gt;U+4E85, U+2F06-&gt;U+4E8C, \U+2F07-&gt;U+4EA0, U+2F08-&gt;U+4EBA, U+2F09-&gt;U+513F, \U+2F0A-&gt;U+5165, U+2F0B-&gt;U+516B, U+2F0C-&gt;U+5182, \U+2F0D-&gt;U+5196, U+2F0E-&gt;U+51AB, U+2F0F-&gt;U+51E0, \U+2F10-&gt;U+51F5, U+2F11-&gt;U+5200, U+2F12-&gt;U+529B, \U+2F13-&gt;U+52F9, U+2F14-&gt;U+5315, U+2F15-&gt;U+531A, \U+2F16-&gt;U+5338, U+2F17-&gt;U+5341, U+2F18-&gt;U+535C, \U+2F19-&gt;U+5369, U+2F1A-&gt;U+5382, U+2F1B-&gt;U+53B6, \U+2F1C-&gt;U+53C8, U+2F1D-&gt;U+53E3, U+2F1E-&gt;U+56D7, \U+2F1F-&gt;U+571F, U+2F20-&gt;U+58EB, U+2F21-&gt;U+5902, \U+2F22-&gt;U+590A, U+2F23-&gt;U+5915, U+2F24-&gt;U+5927, \U+2F25-&gt;U+5973, U+2F26-&gt;U+5B50, U+2F27-&gt;U+5B80, \U+2F28-&gt;U+5BF8, U+2F29-&gt;U+5C0F, U+2F2A-&gt;U+5C22, \U+2F2B-&gt;U+5C38, U+2F2C-&gt;U+5C6E, U+2F2D-&gt;U+5C71, \U+2F2E-&gt;U+5DDB, U+2F2F-&gt;U+5DE5, U+2F30-&gt;U+5DF1, \U+2F31-&gt;U+5DFE, U+2F32-&gt;U+5E72, U+2F33-&gt;U+5E7A, \U+2F34-&gt;U+5E7F, U+2F35-&gt;U+5EF4, U+2F36-&gt;U+5EFE, \U+2F37-&gt;U+5F0B, U+2F38-&gt;U+5F13, U+2F39-&gt;U+5F50, \U+2F3A-&gt;U+5F61, U+2F3B-&gt;U+5F73, U+2F3C-&gt;U+5FC3, \U+2F3D-&gt;U+6208, U+2F3E-&gt;U+6236, U+2F3F-&gt;U+624B, \U+2F40-&gt;U+652F, U+2F41-&gt;U+6534, U+2F42-&gt;U+6587, \U+2F43-&gt;U+6597, U+2F44-&gt;U+65A4, U+2F45-&gt;U+65B9, \U+2F46-&gt;U+65E0, U+2F47-&gt;U+65E5, U+2F48-&gt;U+66F0, \U+2F49-&gt;U+6708, U+2F4A-&gt;U+6728, U+2F4B-&gt;U+6B20, \U+2F4C-&gt;U+6B62, U+2F4D-&gt;U+6B79, U+2F4E-&gt;U+6BB3, \U+2F4F-&gt;U+6BCB, U+2F50-&gt;U+6BD4, U+2F51-&gt;U+6BDB, \U+2F52-&gt;U+6C0F, U+2F53-&gt;U+6C14, U+2F54-&gt;U+6C34, \U+2F55-&gt;U+706B, U+2F56-&gt;U+722A, U+2F57-&gt;U+7236, \U+2F58-&gt;U+723B, U+2F59-&gt;U+723F, U+2F5A-&gt;U+7247, \U+2F5B-&gt;U+7259, U+2F5C-&gt;U+725B, U+2F5D-&gt;U+72AC, \U+2F5E-&gt;U+7384, U+2F5F-&gt;U+7389, U+2F60-&gt;U+74DC, \U+2F61-&gt;U+74E6, U+2F62-&gt;U+7518, U+2F63-&gt;U+751F, \U+2F64-&gt;U+7528, U+2F65-&gt;U+7530, U+2F66-&gt;U+758B, \U+2F67-&gt;U+7592, U+2F68-&gt;U+7676, U+2F69-&gt;U+767D, \U+2F6A-&gt;U+76AE, U+2F6B-&gt;U+76BF, U+2F6C-&gt;U+76EE, \U+2F6D-&gt;U+77DB, U+2F6E-&gt;U+77E2, U+2F6F-&gt;U+77F3, \U+2F70-&gt;U+793A, U+2F71-&gt;U+79B8, U+2F72-&gt;U+79BE, \U+2F73-&gt;U+7A74, U+2F74-&gt;U+7ACB, U+2F75-&gt;U+7AF9, \U+2F76-&gt;U+7C73, U+2F77-&gt;U+7CF8, U+2F78-&gt;U+7F36, \U+2F79-&gt;U+7F51, U+2F7A-&gt;U+7F8A, U+2F7B-&gt;U+7FBD, \U+2F7C-&gt;U+8001, U+2F7D-&gt;U+800C, U+2F7E-&gt;U+8012, \U+2F7F-&gt;U+8033, U+2F80-&gt;U+807F, U+2F81-&gt;U+8089, \U+2F82-&gt;U+81E3, U+2F83-&gt;U+81EA, U+2F84-&gt;U+81F3, \U+2F85-&gt;U+81FC, U+2F86-&gt;U+820C, U+2F87-&gt;U+821B, \U+2F88-&gt;U+821F, U+2F89-&gt;U+826E, U+2F8A-&gt;U+8272, \U+2F8B-&gt;U+8278, U+2F8C-&gt;U+864D, U+2F8D-&gt;U+866B, \U+2F8E-&gt;U+8840, U+2F8F-&gt;U+884C, U+2F90-&gt;U+8863, \U+2F91-&gt;U+897E, U+2F92-&gt;U+898B, U+2F93-&gt;U+89D2, \U+2F94-&gt;U+8A00, U+2F95-&gt;U+8C37, U+2F96-&gt;U+8C46, \U+2F97-&gt;U+8C55, U+2F98-&gt;U+8C78, U+2F99-&gt;U+8C9D, \U+2F9A-&gt;U+8D64, U+2F9B-&gt;U+8D70, U+2F9C-&gt;U+8DB3, \U+2F9D-&gt;U+8EAB, U+2F9E-&gt;U+8ECA, U+2F9F-&gt;U+8F9B, \U+2FA0-&gt;U+8FB0, U+2FA1-&gt;U+8FB5, U+2FA2-&gt;U+9091, \U+2FA3-&gt;U+9149, U+2FA4-&gt;U+91C6, U+2FA5-&gt;U+91CC, \U+2FA6-&gt;U+91D1, U+2FA7-&gt;U+9577, U+2FA8-&gt;U+9580, \U+2FA9-&gt;U+961C, U+2FAA-&gt;U+96B6, U+2FAB-&gt;U+96B9, \U+2FAC-&gt;U+96E8, U+2FAD-&gt;U+9751, U+2FAE-&gt;U+975E, \U+2FAF-&gt;U+9762, U+2FB0-&gt;U+9769, U+2FB1-&gt;U+97CB, \U+2FB2-&gt;U+97ED, U+2FB3-&gt;U+97F3, U+2FB4-&gt;U+9801, \U+2FB5-&gt;U+98A8, U+2FB6-&gt;U+98DB, U+2FB7-&gt;U+98DF, \U+2FB8-&gt;U+9996, U+2FB9-&gt;U+9999, U+2FBA-&gt;U+99AC, \U+2FBB-&gt;U+9AA8, U+2FBC-&gt;U+9AD8, U+2FBD-&gt;U+9ADF, \U+2FBE-&gt;U+9B25, U+2FBF-&gt;U+9B2F, U+2FC0-&gt;U+9B32, \U+2FC1-&gt;U+9B3C, U+2FC2-&gt;U+9B5A, U+2FC3-&gt;U+9CE5, \U+2FC4-&gt;U+9E75, U+2FC5-&gt;U+9E7F, U+2FC6-&gt;U+9EA5, \U+2FC7-&gt;U+9EBB, U+2FC8-&gt;U+9EC3, U+2FC9-&gt;U+9ECD, \U+2FCA-&gt;U+9ED1, U+2FCB-&gt;U+9EF9, U+2FCC-&gt;U+9EFD, \U+2FCD-&gt;U+9F0E, U+2FCE-&gt;U+9F13, U+2FCF-&gt;U+9F20, \U+2FD0-&gt;U+9F3B, U+2FD1-&gt;U+9F4A, U+2FD2-&gt;U+9F52, \U+2FD3-&gt;U+9F8D, U+2FD4-&gt;U+9F9C, U+2FD5-&gt;U+9FA0, \U+3042-&gt;U+3041, U+3044-&gt;U+3043, U+3046-&gt;U+3045, \U+3048-&gt;U+3047, U+304A-&gt;U+3049, U+304C-&gt;U+304B, \U+304E-&gt;U+304D, U+3050-&gt;U+304F, U+3052-&gt;U+3051, \U+3054-&gt;U+3053, U+3056-&gt;U+3055, U+3058-&gt;U+3057, \U+305A-&gt;U+3059, U+305C-&gt;U+305B, U+305E-&gt;U+305D, \U+3060-&gt;U+305F, U+3062-&gt;U+3061, U+3064-&gt;U+3063, \U+3065-&gt;U+3063, U+3067-&gt;U+3066, U+3069-&gt;U+3068, \U+3070-&gt;U+306F, U+3071-&gt;U+306F, U+3073-&gt;U+3072, \U+3074-&gt;U+3072, U+3076-&gt;U+3075, U+3077-&gt;U+3075, \U+3079-&gt;U+3078, U+307A-&gt;U+3078, U+307C-&gt;U+307B, \U+307D-&gt;U+307B, U+3084-&gt;U+3083, U+3086-&gt;U+3085, \U+3088-&gt;U+3087, U+308F-&gt;U+308E, U+3094-&gt;U+3046, \U+3095-&gt;U+304B, U+3096-&gt;U+3051, U+30A2-&gt;U+30A1, \U+30A4-&gt;U+30A3, U+30A6-&gt;U+30A5, U+30A8-&gt;U+30A7, \U+30AA-&gt;U+30A9, U+30AC-&gt;U+30AB, U+30AE-&gt;U+30AD, \U+30B0-&gt;U+30AF, U+30B2-&gt;U+30B1, U+30B4-&gt;U+30B3, \U+30B6-&gt;U+30B5, U+30B8-&gt;U+30B7, U+30BA-&gt;U+30B9, \U+30BC-&gt;U+30BB, U+30BE-&gt;U+30BD, U+30C0-&gt;U+30BF, \U+30C2-&gt;U+30C1, U+30C5-&gt;U+30C4, U+30C7-&gt;U+30C6, \U+30C9-&gt;U+30C8, U+30D0-&gt;U+30CF, U+30D1-&gt;U+30CF, \U+30D3-&gt;U+30D2, U+30D4-&gt;U+30D2, U+30D6-&gt;U+30D5, \U+30D7-&gt;U+30D5, U+30D9-&gt;U+30D8, U+30DA-&gt;U+30D8, \U+30DC-&gt;U+30DB, U+30DD-&gt;U+30DB, U+30E4-&gt;U+30E3, \U+30E6-&gt;U+30E5, U+30E8-&gt;U+30E7, U+30EF-&gt;U+30EE, \U+30F4-&gt;U+30A6, U+30AB-&gt;U+30F5, U+30B1-&gt;U+30F6, \U+30F7-&gt;U+30EF, U+30F8-&gt;U+30F0, U+30F9-&gt;U+30F1, \U+30FA-&gt;U+30F2, U+30AF-&gt;U+31F0, U+30B7-&gt;U+31F1, \U+30B9-&gt;U+31F2, U+30C8-&gt;U+31F3, U+30CC-&gt;U+31F4, \U+30CF-&gt;U+31F5, U+30D2-&gt;U+31F6, U+30D5-&gt;U+31F7, \U+30D8-&gt;U+31F8, U+30DB-&gt;U+31F9, U+30E0-&gt;U+31FA, \U+30E9-&gt;U+31FB, U+30EA-&gt;U+31FC, U+30EB-&gt;U+31FD, \U+30EC-&gt;U+31FE, U+30ED-&gt;U+31FF, U+FF66-&gt;U+30F2, \U+FF67-&gt;U+30A1, U+FF68-&gt;U+30A3, U+FF69-&gt;U+30A5, \U+FF6A-&gt;U+30A7, U+FF6B-&gt;U+30A9, U+FF6C-&gt;U+30E3, \U+FF6D-&gt;U+30E5, U+FF6E-&gt;U+30E7, U+FF6F-&gt;U+30C3, \U+FF71-&gt;U+30A1, U+FF72-&gt;U+30A3, U+FF73-&gt;U+30A5, \U+FF74-&gt;U+30A7, U+FF75-&gt;U+30A9, U+FF76-&gt;U+30AB, \U+FF77-&gt;U+30AD, U+FF78-&gt;U+30AF, U+FF79-&gt;U+30B1, \U+FF7A-&gt;U+30B3, U+FF7B-&gt;U+30B5, U+FF7C-&gt;U+30B7, \U+FF7D-&gt;U+30B9, U+FF7E-&gt;U+30BB, U+FF7F-&gt;U+30BD, \U+FF80-&gt;U+30BF, U+FF81-&gt;U+30C1, U+FF82-&gt;U+30C3, \U+FF83-&gt;U+30C6, U+FF84-&gt;U+30C8, U+FF85-&gt;U+30CA, \U+FF86-&gt;U+30CB, U+FF87-&gt;U+30CC, U+FF88-&gt;U+30CD, \U+FF89-&gt;U+30CE, U+FF8A-&gt;U+30CF, U+FF8B-&gt;U+30D2, \U+FF8C-&gt;U+30D5, U+FF8D-&gt;U+30D8, U+FF8E-&gt;U+30DB, \U+FF8F-&gt;U+30DE, U+FF90-&gt;U+30DF, U+FF91-&gt;U+30E0, \U+FF92-&gt;U+30E1, U+FF93-&gt;U+30E2, U+FF94-&gt;U+30E3, \U+FF95-&gt;U+30E5, U+FF96-&gt;U+30E7, U+FF97-&gt;U+30E9, \U+FF98-&gt;U+30EA, U+FF99-&gt;U+30EB, U+FF9A-&gt;U+30EC, \U+FF9B-&gt;U+30ED, U+FF9C-&gt;U+30EF, U+FF9D-&gt;U+30F3, \U+FFA0-&gt;U+3164, U+FFA1-&gt;U+3131, U+FFA2-&gt;U+3132, \U+FFA3-&gt;U+3133, U+FFA4-&gt;U+3134, U+FFA5-&gt;U+3135, \U+FFA6-&gt;U+3136, U+FFA7-&gt;U+3137, U+FFA8-&gt;U+3138, \U+FFA9-&gt;U+3139, U+FFAA-&gt;U+313A, U+FFAB-&gt;U+313B, \U+FFAC-&gt;U+313C, U+FFAD-&gt;U+313D, U+FFAE-&gt;U+313E, \U+FFAF-&gt;U+313F, U+FFB0-&gt;U+3140, U+FFB1-&gt;U+3141, \U+FFB2-&gt;U+3142, U+FFB3-&gt;U+3143, U+FFB4-&gt;U+3144, \U+FFB5-&gt;U+3145, U+FFB6-&gt;U+3146, U+FFB7-&gt;U+3147, \U+FFB8-&gt;U+3148, U+FFB9-&gt;U+3149, U+FFBA-&gt;U+314A, \U+FFBB-&gt;U+314B, U+FFBC-&gt;U+314C, U+FFBD-&gt;U+314D, \U+FFBE-&gt;U+314E, U+FFC2-&gt;U+314F, U+FFC3-&gt;U+3150, \U+FFC4-&gt;U+3151, U+FFC5-&gt;U+3152, U+FFC6-&gt;U+3153, \U+FFC7-&gt;U+3154, U+FFCA-&gt;U+3155, U+FFCB-&gt;U+3156, \U+FFCC-&gt;U+3157, U+FFCD-&gt;U+3158, U+FFCE-&gt;U+3159, \U+FFCF-&gt;U+315A, U+FFD2-&gt;U+315B, U+FFD3-&gt;U+315C, \U+FFD4-&gt;U+315D, U+FFD5-&gt;U+315E, U+FFD6-&gt;U+315F, \U+FFD7-&gt;U+3160, U+FFDA-&gt;U+3161, U+FFDB-&gt;U+3162, \U+FFDC-&gt;U+3163, U+3131-&gt;U+1100, U+3132-&gt;U+1101, \U+3133-&gt;U+11AA, U+3134-&gt;U+1102, U+3135-&gt;U+11AC, \U+3136-&gt;U+11AD, U+3137-&gt;U+1103, U+3138-&gt;U+1104, \U+3139-&gt;U+1105, U+313A-&gt;U+11B0, U+313B-&gt;U+11B1, \U+313C-&gt;U+11B2, U+313D-&gt;U+11B3, U+313E-&gt;U+11B4, \U+313F-&gt;U+11B5, U+3140-&gt;U+111A, U+3141-&gt;U+1106, \U+3142-&gt;U+1107, U+3143-&gt;U+1108, U+3144-&gt;U+1121, \U+3145-&gt;U+1109, U+3146-&gt;U+110A, U+3147-&gt;U+110B, \U+3148-&gt;U+110C, U+3149-&gt;U+110D, U+314A-&gt;U+110E, \U+314B-&gt;U+110F, U+314C-&gt;U+1110, U+314D-&gt;U+1111, \U+314E-&gt;U+1112, U+314F-&gt;U+1161, U+3150-&gt;U+1162, \U+3151-&gt;U+1163, U+3152-&gt;U+1164, U+3153-&gt;U+1165, \U+3154-&gt;U+1166, U+3155-&gt;U+1167, U+3156-&gt;U+1168, \U+3157-&gt;U+1169, U+3158-&gt;U+116A, U+3159-&gt;U+116B, \U+315A-&gt;U+116C, U+315B-&gt;U+116D, U+315C-&gt;U+116E, \U+315D-&gt;U+116F, U+315E-&gt;U+1170, U+315F-&gt;U+1171, \U+3160-&gt;U+1172, U+3161-&gt;U+1173, U+3162-&gt;U+1174, \U+3163-&gt;U+1175, U+3165-&gt;U+1114, U+3166-&gt;U+1115, \U+3167-&gt;U+11C7, U+3168-&gt;U+11C8, U+3169-&gt;U+11CC, \U+316A-&gt;U+11CE, U+316B-&gt;U+11D3, U+316C-&gt;U+11D7, \U+316D-&gt;U+11D9, U+316E-&gt;U+111C, U+316F-&gt;U+11DD, \U+3170-&gt;U+11DF, U+3171-&gt;U+111D, U+3172-&gt;U+111E, \U+3173-&gt;U+1120, U+3174-&gt;U+1122, U+3175-&gt;U+1123, \U+3176-&gt;U+1127, U+3177-&gt;U+1129, U+3178-&gt;U+112B, \U+3179-&gt;U+112C, U+317A-&gt;U+112D, U+317B-&gt;U+112E, \U+317C-&gt;U+112F, U+317D-&gt;U+1132, U+317E-&gt;U+1136, \U+317F-&gt;U+1140, U+3180-&gt;U+1147, U+3181-&gt;U+114C, \U+3182-&gt;U+11F1, U+3183-&gt;U+11F2, U+3184-&gt;U+1157, \U+3185-&gt;U+1158, U+3186-&gt;U+1159, U+3187-&gt;U+1184, \U+3188-&gt;U+1185, U+3189-&gt;U+1188, U+318A-&gt;U+1191, \U+318B-&gt;U+1192, U+318C-&gt;U+1194, U+318D-&gt;U+119E, \U+318E-&gt;U+11A1, U+A490-&gt;U+A408, U+A491-&gt;U+A1B9, \U+4E00..U+9FBB, U+3400..U+4DB5, U+20000..U+2A6D6, \U+FA0E, U+FA0F, U+FA11, \U+FA13, U+FA14, U+FA1F, \U+FA21, U+FA23, U+FA24, \U+FA27, U+FA28, U+FA29, \U+3105..U+312C, U+31A0..U+31B7, U+3041, \U+3043, U+3045, U+3047, \U+3049, U+304B, U+304D, \U+304F, U+3051, U+3053, \U+3055, U+3057, U+3059, \U+305B, U+305D, U+305F, \U+3061, U+3063, U+3066, \U+3068, U+306A..U+306F, U+3072, \U+3075, U+3078, U+307B, \U+307E..U+3083, U+3085, U+3087, \U+3089..U+308E, U+3090..U+3093, U+30A1, \U+30A3, U+30A5, U+30A7, \U+30A9, U+30AD, U+30AF, \U+30B3, U+30B5, U+30BB, \U+30BD, U+30BF, U+30C1, \U+30C3, U+30C4, U+30C6, \U+30CA, U+30CB, U+30CD, \U+30CE, U+30DE, U+30DF, \U+30E1, U+30E2, U+30E3, \U+30E5, U+30E7, U+30EE, \U+30F0..U+30F3, U+30F5, U+30F6, \U+31F0, U+31F1, U+31F2, \U+31F3, U+31F4, U+31F5, \U+31F6, U+31F7, U+31F8, \U+31F9, U+31FA, U+31FB, \U+31FC, U+31FD, U+31FE, \U+31FF, U+AC00..U+D7A3, U+1100..U+1159&#125;#文章增量索引(用于增量更新索引)index article_detal : article&#123; source = article_delta_src path = /usr/local/sphinx/var/data/article_detal&#125; 索引二:建立博客论坛文章索引(sphinx-social-article.conf,此处省略格式同上) 建立sphinx.conf配置文件注意:#!/bin/bash 很重要 12345#!/bin/bash path=/usr/local/sphinx/etc#引入所有索引文件/bin/cat $path/sphinx-base.conf $path/sphinx-article.conf $path/sphinx-social-article.conf 此时,配置工作就已经完成,可以启动sphinx服务,并生成索引文件了. 自动索引用cron定时任务实现自动索引. 建立索引更新脚本: start_index.sh 1234567891011121314#!/bin/shindex=/usr/local/sphinx/bin/indexer#建立索引echo -e &quot;\n\n\n[`date`]建立索引-------------&gt;$1&quot;;$index --rotate $1#pat=detal#echo $1|grep -e $pat &gt; /dev/nullif [ $# -eq 2 ]; then echo -e &quot;[`date`]$1合并增量索引-------------&gt;$2&quot; $index --merge $2 $1 --rotatefi 设置cron定时任务: crontab -e 1234567#sphinx article索引*/1 * * * * /usr/local/sphinx/etc/start_index.sh article_detal article &gt;&gt; /root/sphinx/log/detal.log 2&gt;&amp;1 #增量索引* 2 * * * /usr/local/sphinx/etc/start_index.sh article &gt;&gt; /root/sphinx/log/all.log 2&gt;&amp;1 #全量索引#sphinx social_article索引*/1 * * * * /usr/local/sphinx/etc/start_index.sh social_article_detal social_article &gt;&gt; /root/sphinx/log/detal.log 2&gt;&amp;1 #增量索引* 2 * * * /usr/local/sphinx/etc/start_index.sh social_article &gt;&gt; /root/sphinx/log/all.log 2&gt;&amp;1 #全量索引 参考资料:官方文档:http://sphinxsearch.com/中文资料: Sphinx 配置文件全解析 Sphinx 命令行工具]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>全文检索</tag>
        <tag>Sphinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT学习笔记]]></title>
    <url>%2F2018%2F03%2F29%2FGIT%2FGIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 第一次安装设置123#因为git是分布式,这些就是你在提交commit时的签名。(--global全局设置,不加则设置当前版本库)$ git config [--global] user.name &quot;Your Name&quot;$ git config [--global] user.email &quot;email@example.com&quot; 创建版本仓库12345$ git init #创建版本仓库 $ git add #添加文件到版本仓库(可同时添加多个文件空格分割)$ git commit -m &apos;注释内容&apos; #提交版本 $ git commit (-v) #提交版本,启动编辑器编写注释(-v显示详细变更信息)$ git commit -a #提交版本,跳过使用暂存区(不用git add) 版本比对123456$ git status (-s/--short) #查看版本库状态以及文件修改状态(显示简单信息)1.未修改状态:nothing to commit,working tree clean2.修改后文件已在缓存区:Changes to be commited3.新增文件状态:Untracked files4.修改后文件未在缓存区:Changes not staged for commit3与4状态区别在于3无法用git commit –am命令将文件添加到本地仓库 git status -s符号意义:?? 新添加的未跟踪文件前面A 新添加到暂存区中的文件M 修改过的文件(出现在右边的,表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区) 版本回退 和SVN不一样,GIT每个提交版本的commit id不是1,2,3…的数字而是一个SHA1计算出来的十六进制数字.因为GIT是分布式控制系统,如果用1,2,3…数字表示多人协作会重复. 12345678HEAD #表示最新提交的版本HEAD^ #表示上一个提交版本HEAD~100 #表示往上100个版本(~ 代替多个 ^)|#git reset 版本号$ git reset (--mixed) HEAD^ #回退到上个版本,缓存区和你指定的提交同步，但工作目录不受影响(--mixed是默认选项,可以不加)$ git reset --soft HEAD^ #回退到上个版本,缓存区和工作区都不受影响$ git reset --hard HEAD^ #回退到上个版本,缓存区和工作目录都同步到你指定的提交(危险指令) git reset 后面如果是版本号不用写全,只写前几位就可以了.GIT版本回退非常快,因为GIT在内部有个指向当前版本的HEAD指针,当回退版本时GIT仅仅是把HEAD从指向当前版本改为指向回退版本(如下图),顺便把工作区更新了. 由于git log仅显示从当前版本到历史版本的纪录,如果回退了某个版本,又想还原到最新版本怎么办呢? 12$ git reflog #如果在回退以后又想再次回到之前的版本，git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录 工作区和暂存区 git和其它版本控制系统,如SVN的一个不同之处就是有暂存区的概念.工作区:就是电脑能看到的仓库文件夹目录.版本库:工作区内的隐藏目录.git,这个不算工作区,而是git的版本库.GIT版本库里存了很多东西,其中最重要的就是stage(或者叫index)的暂存区,还有GIT为我们自动创建的第一个分支master,以及一个指向master的指针HEAD.实际上git add就是把所有修改放到暂存区,git commit是把暂缓区的修改提交到分支.因此,修改一个文件后必须要添加(git add)到暂存区,才能提交(git commit)到分支,否则提交无效 撤销修改123$ git commit --amend #撤消上次文件提交的修改,重新提交$ git checkout -- 文件名 #撤销工作区文件的修改(如果没有--应变成了切换分支的命令)$ git reset HEAD 文件名 #撤销暂存区文件修改(HEAD表示撤销到最新版本) 删除文件1$ git rm [--cached] 文件名 #从版本库中删除文件(--cached从缓存区中移除到工作区) GIT删除(git rm)文件后,直接提交(git commit)即可,不需要再添加到暂存区(git add).如果不小心删错了,可以直接撤销修改(git checkout – 文件名)如果文件已经提交到版本库,那么永远不用担心误删,但只能恢复到最新版本库,最新修改将丢失. 文件移动12345$ git mv file_from file_to #重命名文件实际相当于运行下面三个命令$ mv file_from file_to$ git rm file_from$ git add file_to 远程仓库12$ git remote add origin 远程仓库地址 #关联远程仓库(origin是git远程仓库的默认名,可以修改)$ git push #本地内容推送到远程仓库 关联后第一次推送仓库的所有内容使用命令:git push -u origin master此后,每次推送本地修改内容可以使用命令:git push origin master 123$ git clone [-b 分支名] 远程仓库地址 #克隆远程仓库到本地(-b指定分支)$ git fetch 远程仓库名 #从服务器上抓取本地没有的数据，它并不会修改工作目录中的内容, 它只会获取数据然后让你自己合并.$ git pull (--allow-unrelated-histories) #从服务器抓取分支数据并然后尝试合并. 由于git pull命令经常让人困惑,所以通常单独显式地使用 git fetch 与git merge 命令会更好一些。 1234567$ git remote #显示远程仓库名$ git ls-remote #显示远程引用完整列表$ git remote show [remote-name] #查看远程仓库更多信息$ git remote -v #显示远程仓库信息origin git@github.com:WindusL/LearningNotes.git (fetch)origin git@github.com:WindusL/LearningNotes.git (push) 上面显示了可以抓取和推送的origin地址。如果没有推送权限就看不到push的地址。 12$ git remote rename [oldname] [newname] #对远程仓库的简写名称重命名指令$ git remote rm [remote-name] #对远程仓库的简写名称进行移除的命令 分支管理 Git里默认有一个主分支master，其中HEAD严格来说指向的不是提交，而是当前分支，分支才指向提交。 Git创建一个分支只是增加一个指针，然后将HEAD指向新的分支 ，表示在当前分支，工作区的文件没有任何变化。 123456789101112$ git branch 分支名 #创建分支$ git checkout 分支名 #切换分支#上面两个命令相当于$ git checkout -b 分支名 #创建并切换分支(加上-b表示先创建后切换)$ git checkout -b 分支名 远程分支名 ＃拉取远程分支到本地分支((加上-b表示先创建后切换)$ git branch (-a/r) #列出所有本地分支(-a 包括远程分支,-r仅列出远程分支)$ git branch -v|-vv #查看每个分支最后一次的提交(-vv选项会列表更多信息)$ git merge 分支名 #合并指定分支到当前分支$ git branch -d 分支名 #删除已合并本地分支$ git branch -D 分支名 #强制删除未合并的分支$ git branch -m|-M 旧分支名 新分支名 # 分支生命名（-M强制生命名） 重命名远程分支推荐做法:1、删除远程分支2、push本地新分支名到远程 1$ git branch --merged|--no-merged #查看已（未）合并的分支 删除选程分支 12git branch -dr 分支名 # (-r删除远程分支)git push [远程名] :[分支名] 分支-变基分支合并会产生记录,如果想不产生这些记录就可以使用分支变基后再合并. 12345678910$ git rebase 分支名 #把当前分支变基到指定分支#切换到要变基的分支进行变基$ git checkout experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command#回到合并分支进行合并$ git checkout master$ git merge experiment 变基注意事项:只在从未推送至共用仓库的提交上执行变基命令 分支管理策略 通常，合并分支，如果可能Git会用Fast Forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果强制禁用Fast Forward模式，Git会在merge时生成一个新的commit，这样从分支历史上就可以看出分支信息。 1$ git merge --no-ff -m 注释 分支名 #合并分支(--no-ff表示禁用Fast Forward模式，因为要生成一个新的commit所以要加上-m注释参数) Bug分支 当一个分支的工作还没有做完，不能提交，而此时又要及时做其它工作时，可以先把工作区储藏起来,创建bug分支(命名:fixbug-issueId)。 123456789101112$ git stash #储藏工作区(储藏后再用git status查看就是干净的, 除非是没有被git管理的文件)$ git stash save (--keep-index|-u|--patch)注释 #储藏工作区并添加注释(--keep-index #不储藏任何通过 git add 命令已暂存的;-u #储藏任何创建的未跟踪文件--patch #不会储藏所有修改过的任何东西，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中。)$ git stash list #查看stash列表$ git stash apply #恢复stash，但stash不删除$ git stash pop #恢复stash，同时删除stash$ git stash drop #移除stash (会删除储存所有修改,谨慎使用)$ git stash show (-p/--patch) #查看stash(详细)修改 如果多次执行stash后，恢复stash就加上stash名，如：git stash pop/apply stash@{0}默认情况,stash不会存储Untracked files.如果想要存储,要先git add添加到版本库或者使用git stash -u选项,如下: 1git stash -u (--include-untracked) # 存储工作空间包括Untracked files Feature分支 开发新功能时最好创建一个新的分支(命名:feature-x)。 预发布分支 发布正式版本之前（即合并到 Master 分支之前），我们可能需要有一个预发布的版本进行测试(命名:release-版本号)。 推送分支(同远程仓库)1$ git push origin 分支名 #推送分支到远程仓库 跟踪分支 从一个远程分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。跟踪分支是与远程分支有直接关系的本地分支,Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。 1234567#设置跟踪分支(将本地分支与远程库分支时行连接。)$ git branch --set-upstream origin 分支名 #最新版本已被废弃#最新版本命令$ git branch --set-upstream-to=origin/&lt;branch&gt; 分支名 (可简写为 -u)#取消跟踪远程分支$ git branch --unset-upstream 分支名 多人协作 当从远程仓库克隆时，Git自动把本地master分支和远程分支对应起来。并且远程分为默认名是origin。 多人协作的工作模式：1.试图推送分支。2.推送失败则要先抓取远程分支，试图合并。3.合并有冲突，则解决冲突，并在本地提交。4.没有冲突或解决掉了冲突，再推送到远程分支。 标签管理 发布新版本时，通常在版本库打一个标签，来确定打标签时刻的版本。将来无论什么时候，取某个标签的版本就是那个打标签时候的历史版本。所以，标签也相当于版本库的一个快照。Git标签虽然是版本库的快照，但其实就是一个指向commit的指针（与分支类似，但分支可以移动，但标签不能移动）。所以，创建标签也是瞬间完成的。 123456789101112131415$ git tag #查看所有标签$ git tag -l # 用特定的搜索模式列出符合条件的标签#指搜索1.4.2系统标签$ git tag -l &apos;v1.4.2.*&apos;v1.4.2.1v1.4.2.2v1.4.2.3v1.4.2.4$ git tag 标签名 #打标签(轻量标签)$ git tag 标签名 commitId #给指定commit打标签$ git tag -a 标签名 -m 注释 commitId #创建带有说明的标签(附注标签)$ git tag -d 标签名 #删除标签 还可以通过-s用私钥签名一个标签,采用PGP签名必须先安装gpg 1$ git tag -s 标签名 -m 注释 commitId 推送远程标签 12$ git push origin 标签名 #推送指定标签到远程仓库$ git push origin --tags #推送全部尚未推送到远程仓库的标签 删除远程标签 12$ git tag -d 标签名 #先删除本地标签$ git push origin :refs/tags/标签名 #然后删除远程标签 检出标签 1234#在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。#如果你想要工作目录与仓库中特定的标签版本完全一样，可以使在特定的标签上创建一个新分支：语法:git checkout -b [branchname] [tagname] 日志 git log123456789$ git log --stat #显示在每个提交(commit)中哪些文件被修改了$ git log -p #显示每次提交的内容差异$ git log -n #显示最近几条日志$ git log --pretty=oneline|format$ git log --graph #展示分支、合并历史$ git log --author #仅显示指定作者相关的提交。$ git log --committer #仅显示指定提交者相关的提交。$ git log --grep #仅显示含指定关键字的提交$ git log 文件名 #仅显示指定文件提交历史 提交区间 1234567891011121. 双点语法(..)$ git log master..dev #比对dev还没提交到master分支的记录$ git log origin/master..HEAD #输出在你当前分支中而不在远程 origin 中的提交(如果留空了其中的一边， Git 会默认为 HEAD)2. 多点语法(^ 或 --not)$ git log refA refB ^refC #查看所有被 refA 或 refB 包含的但是不被 refC 包含的提交$ git log refA refB --not refC3. 三点语法(...)语法可以选择出被两个引用中的一个包含但又不被两者同时包含的提交$ git log master...experiment #看 master 或者 experiment 中包含的但不是两者共有的提交$ git log --left-right master...experiment(--left-right显示是哪边分支的提交 &quot;&gt;&quot; 或 &quot;&lt;&quot;) git show显示标签、commitId等对象的信息 12git show 标签名 #查看标签信息git show (--stat) commitId #查看指定提交的详细信息(--stat只查看变动文件) 比较 git diff123456git diff &lt;filename&gt;#比较工作区与暂存区的差异 git diff --cached (&lt;commitId&gt;) &lt;filename&gt; #比较暂存区与上次(/指定commitId)提交的差异git diff HEAD/commitId &lt;filename&gt; #比较工作区与(上次/指定commitId)提交的差异git diff commitId commitId #比较Git仓库任意两次 commit 之间的差别git diff --stat #比较统计(如几处删除,几处增加等等)git diff 本地分支 origin/远程分支 #与远程库比对(比对前需先执行git fetch) GIT工具交互式暂存修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交.12$ git add -i #进入交互终端$ git add -p(--patch) #Git暂存文件的特定部分(文件中做了两处修改，但只想要暂存其中的一个) 清理 git clean需要谨慎地使用这个命令，因为它被设计为从工作目录中移除没有忽略的未跟踪文件(任何与 .gitiignore 或其他忽略文件中的模式匹配的文件都不会被移除),可能无法再找回. 12345git clean -f 表示强制清理 -d 后面接要清理的目录 -n 演习删除,显示将要删除的内容 -x 完全干净删除 搜索 git grep从提交历史或者工作目录中查找一个字符串或者正则表达式. 123git grep -n 输出内容所在文件的行号 --count 输出内容所在文件的数量 日志搜索123456789101112git log -S 字符串 #显示新增和删除该字符串的提交 -G 相对于-S更精准,使用正则表达式搜索 -L 展示代码中一行或者一个函数的历史 #找到 ZLIB_BUF_MAX 常量是什么时候引入的$ git log -SZLIB_BUF_MAX --onelinee01503b zlib: allow feeding more than 4GB in one goef49a7a zlib: zlib can only process 4GB at a time #查看 zlib.c 文件中`git_deflate_bound` 函数的每一次变更$ git log -L :git_deflate_bound:zlib.c 忽略文件一般情况,可以使用.gitignore文件添加忽略文件.如果当前文件是已经commit ,push到远程仓库后了，.gitignore里面再配置是不起作用了.此时解决办法有两种: 一种方法是移除文件跟踪,然后将文件添加到.gitignore文件中去(此种方法对其他人影响较大).另一种方法是仅在自己本地忽略: 12345$ git update-index --assume-unchanged 文件名 #忽略文件$ git update-index --no-assume-unchanged 文件名 #取消忽略文件$ git ls-files -v | grep h\&lt;space&gt; #显示本地忽略文件列表(&lt;space&gt; 是表示空格)更多信息使用 --help 自行查阅 –assume-unchanged与–skip-worktree 的区别前者 忽略更改文件,当索引中文件条目变化时则失效（即，此文件变化自上游）后者 忽略更改文件,索引中文件条目变化仍起作用(直至此索引被放弃) 命令自动补全 第一步 下载git官方提供的自动补全git-completion.bash脚本到自己的家目录并重命名为.git-completion.bash 1curl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.git-completion.bash 第二步 将下载的脚本添加到~/.bash_profile文件 1234if [ -f ~/.git-completion.bash ]; then . ~/.git-completion.bash fi # . 符号可以换成source 第三步 编译~/.bash_profile使其立即生效 1source ~/.bash_profile]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GIT</tag>
        <tag>GIT学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim编辑器]]></title>
    <url>%2F2018%2F03%2F27%2FLinux%2Fvim%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[[TOC] vi编辑器的模式一般指令模式用vi 打开一个文件就直接进入一般指令模式,在一般指令模式中可以进行删除、复制、贴上等等的动作. 移动光标方法 按键 说明 h（←） 向左移动一个字符 j（↓） 向下移动一个字符 k（↑） 向上移动一个字符 l（→） 向右移动一个字符 Ctrl+f 屏幕向下移动一页[PageDown] Ctrl+b 屏幕向上移动一页[PageUp] Ctrl+d 屏幕向下移动半页 Ctrl+u 屏幕向上移动半页 + 光标移动到非空白字符的下一行 - 光标移动到非空白字符的上一行 n 按下数字再按空格键向后移动n个字符 0 移动到当前行最前字符处 $ 移动到当前行最后字符处 H 移动到屏幕最上行 M 移动到屏幕中央一行 L 移动到屏幕最下行 G 移动到文件最后一行 nG 移动到第n行 gg 移动到文件第一行(相当于1G) n[Enter] 向下移动n行 搜寻与取代 按键 说明 /word 向下搜索字符串 ?word 向上搜索字符串 n 重复上面搜索动作 N 反向重复上面搜索动作 :n1,n2s/word1/word2/g 在n1到n2行之间寻找word1字符串, 并将该字符串取代为word2(n2可以换成$ 表示到最后一行) :n1,n2s/word1/word2/gc 与上面区别在于替换前加入提示(c–&gt;confirm) 删除/复制/粘贴 按键 说明 x,X x向后删除一个字符;X向前删除一个字符 nx/X 连续 向后 / 向前 删除n个字符 dd 删除当前行 ndd 向下删除n行 d1G 删除光标所在行到第一行的所有数据 dG 删除光标所在行到最后一行的所有数据 d$ 删除该行光标所在行到最后一个字符 d0 删除该行光标所在行到第一个字符 yy 复制光标所在行 nyy 向下复制n行 y1G 复制光标所在行到第一行的所有数据 yG 复制光标所在行到最后一行的所有数据 y0 复制该行光标所在行到最后一个字符 y$ 复制该行光标所在行到第一个字符 p,P p已复制数据在光标下一行粘贴;P已复制数据在光标上一行粘贴 J 光标所在行与下一行合并成一行 c 重复删除多个数据 u 复原前一个动作 Ctrl+r 还原u命令之前动作 . 重复上一个动作 编辑模式一般指令模式下,按i、I、o、O、a、A、r、R等任意一个字母后进入编辑模式. 按Esc返回一般模式. 按键 说明 i,I 进入插入模式（Insert mode）： i 为“从目前光标所在处插入”， I 为“在目前所在行的第一个非空白字符处开始插入”。 a,A 进入插入模式（Insert mode）：a 为“从目前光标所在的下一个字符处开始插入”， A 为“从光标所在行的最后一个字符处开始插入”。 o,O 进入插入模式（Insert mode）：这是英文字母 o 的大小写。o 为“在目前光标所在的下一行处插入新的一行”； O 为在目前光标所在处的上一行插入新的一行！ r,R 进入取代模式（Replace mode）：r只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字， 直到按下 ESC 为止； 命令行模式一般模式下输入/、?、:任意一个符号即可进入到引模式. 按Esc返回一般模式. 按键 说明 :w 将编辑数据写入文件 :w! 将编辑文件强制写入文件(具体与权限有关) :q 离开vim :q! 不存储编辑数据,强制离开vim :wq 保存编辑数据并离开vim ZZ 大写Z,若文件没有修改则不存储离开;若文件有修改,则存储后离开 :w [filename] 将编辑数据存储为另一个新文件 :r [filename] 在编辑数据中读入另一个文件的数据.亦将filename文件内容加到光标所在行的后面. :n1,n2 w [filename] 将n1到n2行的数据存储为另一个新文件 :! command 暂时离开vim到命令行执行commd命令 :set vim环境变更指令.如: :set nu显示行号; :set nonu取消行号 一般指令模式可与编辑模式及命令行界面切换， 但编辑模式与命令行界面之间不可相互切换. vim 暂存盘在使用vim编辑器时,vim会在与被编辑文件目录创建一个名为filename.swap的暂存文件,你对编辑的文件所有动作都会记录到这个文件内.如果vim的文件被不正常中断,导致暂存盘无法借由正常流程结束,所以暂存盘就不会消失.再次打开此文件时,vim会主动判断这个文件可能有的问题: 可能其它人或程序在同时编辑这个文件 由于 Linux 是多用户多任务的环境，因此很可能有很多人同时在编辑同一个文件。如果在多人共同编辑的情况下， 万一大家同时储存，那么这个文件的内容将会变的乱七八糟！为了避免这个问题，因此 vim 会出现这个警告窗口！ 在上次vim编辑过程中可能由于未知原因导致vim中断 在发现暂存盘后,会出现警告信息页面,有六个按钮可供操作,说明如下: （O）pen Read-Only 打开此文件成为只读文件，可以用在你只是想要查阅该文件内容并不想要进行编辑行为时。 （E）dit anyway：还是用正常的方式打开你要编辑的那个文件， 并不会载入暂存盘的内容。不过很容易出现两个使用者互相改变对方的文件等问题！ （R）ecover：就是载入暂存盘的内容，用在你要救回之前未储存的工作。 不过当你救回来并且储存离开 vim 后，还是要手动自行删除那个暂存盘喔！ （D）elete it：你确定那个暂存盘是无用的！那么打开文件前会先将这个暂存盘删除！ 这个动作其实是比较常做的！因为你可能不确定这个暂存盘是怎么来的，所以就删除掉他吧！ （Q）uit：按下 q 就离开 vim ，不会进行任何动作回到命令提示字符。 （A）bort：忽略这个编辑行为，与 quit 非常类似！ 也会送你回到命令提示字符！ 区块选择按键意义: 按键 说明 v 字符选择，会将光标经过的地方反白选择 V 行选择，会将光标经过的行反白选择 Ctrl+v 矩形选择，可以用矩形的方式选择数据 y 将选中地方复制起来 p 将刚刚复制的区块，在光标所在处贴上 d 将选中地方删除 多文件编辑vim后面接多个文件名打开多个文件,此时多个文件内可以各种模式内的命令. 如从一个文件内yy(复制)到另一个文件内pp(粘贴) 按键 说明 :n 编辑上一个文件 :N 编辑下一个文件 :files 列出目前vim打开的所有文件列表 多窗口:sp {filename} 按键 说明 :sp [filename] 打开一个新窗口，如果有加 filename， 表示在新窗口打开一个新文件，否则表示两个窗口为同一个文件内容（同步显示） Ctrl+w+j(↓) 按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j （或向下方向键），则光标可移动到下方的窗口。其它方向按键参考上面移动光标方法按键. Ctrl+w+q 相当于:q离开 DOS与Linxu断行字符在 Linux 下面的指令在开始执行时，他的判断依据是 “Enter”，而 Linux 的 Enter 为 LF 符号， 不过，由于 DOS 的断行符号是 CRLF ，也就是多了一个 ^M 的符号出来， 在这样的情况下，如果是一个 shell script 的程序文件，将可能造成“程序无法执行”的状态～ 因为他会误判程序所下达的指令内容. 解决方法是通过指令将文件转换成Linux字符即可: 123456789101112131415161718192021222324252627282930$ dos2unix [-kn] file [newfile]$ unix2dos [-kn] file [newfile]选项与参数：-k ：保留该文件原本的 mtime 时间格式 （不更新文件上次内容经过修订的时间）-n ：保留原本的旧文件，将转换后的内容输出到新文件，如： dos2unix -n old new#例一:将文件转换成dos断行符$ ll man_db.conf-rw-r--r--. 1 root root 5171 Jun 10 2014 man_db.conf$ unix2dos -k man_db.confunix2dos: converting file man_db.conf to DOS format ...# 屏幕会显示上述的讯息，说明断行转为 DOS 格式了！$ ll man_db.conf-rw-r--r--. 1 dmtsai dmtsai 5302 Jun 10 2014 man_db.conf# 断行字符多了 ^M ，所以容量增加了！#例二:将文件转换成Linux断行符,并保留新文件$ dos2unix -k -n man_db.conf man_db.conf.linuxdos2unix: converting file man_db.conf to file man_db.conf.linux in Unix format ...$ ll man_db.conf*-rw-r--r--. 1 dmtsai dmtsai 5302 Jun 10 2014 man_db.conf-rw-r--r--. 1 dmtsai dmtsai 5171 Jun 10 2014 man_db.conf.linux$ file man_db.conf*man_db.conf: ASCII text, with CRLF line terminators # 很清楚说明是 CRLF 断行！ 语系编码转换123456789$ iconv --list$ iconv -f 原本编码 -t 新编码 filename [-o newfile]选项与参数：--list ：列出 iconv 支持的语系数据-f ：from ，亦即来源之意，后接原本的编码格式；-t ：to ，亦即后来的新编码要是什么格式；-o file：如果要保留原本的文件，那么使用 -o 新文件名，可以创建新编码文件。#可以用file查看文件编码]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux正则与文件格式化]]></title>
    <url>%2F2018%2F03%2F21%2FLinux%2FLinux%E6%AD%A3%E5%88%99%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[[TOC] 基础正则表达式基础正则字符包括:^ $ . \ * [] [n1-n2] [^] \{n,m\} 语系对正则表达式的影响由于不同语系的编码数据并不相同，所以就会造成数据撷取结果的差异。 123456789C和zh_TW.big5语系下,英文大小写的编码顺序:LANG=C 时：0 1 2 3 4 ... A B C D ... Z a b c d ...zLANG=zh_TW 时：0 1 2 3 4 ... a A b B c C d D ... z Z# C语系$ ll -d /etc/[^a-z]* # 正确显示# zh_TW.big5语系(测试zh_CN.UTF-8语系可以正确显示)$ ll -d /etc/[^a-z]* # 显示混乱 上面由于C语系字母是连续的所以正则表达式可以进行匹配,而zh_CN.UTF-8语系字母是非连续排列所以找不到该文件.由于一般正则表达式，使用的是相容于 POSIX 的标准，因此就使用“ C ”这个语系,所以通常使用正则将系统语系设置成C后使用. 12345678910# 搜寻特定字符串(-v表示反向)$ grep -n (-v) &apos;the&apos; regular_express.txt # 利用中括号[]搜寻集合字符$ grep -n &apos;t[ae]st&apos; regular_express.txt$ grep -n &apos;[^a-z]oo&apos; regular_express.txt$ grep -n &apos;[0-9]&apos; regular_express.txt#如上考虑到语系的影响可以使用特殊符号代替连续编码(&quot; - &quot;)$ grep -n &apos;[^[:lower:]]oo&apos; regular_express.txt$ grep -n &apos;[[:digit:]]&apos; regular_express.txt 为了要避免这样编码所造成的英文与数字的撷取问题,所以可以使用特殊符号代替 特殊符号 代表意义 [:alnum:] 代表英文大小写字符及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z [:blank:] 代表空白键与 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表数字而已，亦即 0-9 [:graph:] 除了空白字符 （空白键与 [Tab] 按键） 外的其他所有按键 [:lower:] 代表小写字符，亦即 a-z [:print:] 代表任何可以被打印出来的字符 [:punct:] 代表标点符号 （punctuation symbol），亦即：” ‘ ? ! ; : # $… [:upper:] 代表大写字符，亦即 A-Z [:space:] 任何会产生空白的字符，包括空白键, [Tab], CR 等等 [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字符 sed 工具12345678910111213141516171819[dmtsai@study ~]$ sed [-nefr] [动作]选项与参数：-n ：使用安静（silent）模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。 但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行（或者动作）才会被列出来。-e ：直接在命令行界面上进行 sed 的动作编辑；-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作；-r ：sed 的动作支持的是延伸型正则表达式的语法。（默认是基础正则表达式语法）-i ：直接修改读取的文件内容，而不是由屏幕输出。动作说明： [n1[,n2]]functionn1, n2 ：不见得会存在，一般代表“选择进行动作的行数”，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则“ 10,20[动作行为] ”function 有下面这些：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现（目前的上一行）；p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配正则表达式！ 以行为单位的功能 1234567891011121314# 将/etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除！$ nl /etc/passwd | sed &apos;2,5d&apos; 1 root:x:0:0:root:/root:/bin/bash 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/ shutdown .....（后面省略）..... # 承上，在第二行后（亦即是加在第三行）加上“drink tea?”字样！$ nl /etc/passwd | sed &apos;2a drink tea&apos; 1 root:x:0:0:root:/root:/bin/bash 2 bin:x:1:1:bin:/bin:/sbin/nologin drink tea 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin .....（后面省略）..... 部分数据的搜索与取代功能 sed &#39;s/要被取代的字串(或正则)/新的字串/g 如果想用以行为单位取代 sed &#39;n1,n2s/要被取代的字串(或正则)/新的字串/g 直接修改文件内容（危险动作） -i 选项可以让 sed 直接去修改后面接的文件内容而不是由屏幕输出！ 123456#用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !$ sed -i &apos;s/\.$/\!/g&apos; regular_express.txt#利用 sed 直接在 regular_express.txt 最后一行加 入“# This is a test”$ sed -i &apos;$a # This is a test&apos; regular_express.txt# 由于 $ 代表的是最后一行，而 a 的动作是新增，因此该 文件最后新增！ 延伸正则表达式grep 默认仅支持基础正则表达式，如果要使用延伸型正则表达式，你可以使用 grep -E ， 不过更建议直接使用 egrep 12345#去除空白行与首先为#的行列(需要使用管线命令来搜寻两次)grep -v &apos;^$&apos; | grep -v &apos;^#&apos; regular_express.txt#使用延伸正则表达式(延伸型正则表达式可以通过群组功能“ | ”来进行一次搜寻！)egrep -v &apos;^$|^#&apos; regular_express.txt 延伸正则字符包括:+ ? | () ()+ 文件格式化处理格式化打印12345678910111213141516printf &apos;打印格式&apos; 实际内容选项与参数：关于格式方面的几个特殊样式： \a 警告声音输出 \b 倒退键（backspace） \f 清除屏幕 （form feed） \n 输出新的一行 \r 亦即 Enter 按键 \t 水平的 [tab] 按键 \v 垂直的 [tab] 按键 \xNN NN 为两位数的数字，可以转换数字成为字符。关于 C 程序语言内，常见的变量格式 %ns 那个 n 是数字， s 代表 string ，亦即多少个字符； %ni 那个 n 是数字， i 代表 integer ，亦即多少整数码数； %N.nf 那个 n 与 N 都是数字， f 代表 floating （浮点），如果有小数码数， 假设我共要十个位数，但小数点有两位，即为 %10.2f ！ awk工具]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的Bash]]></title>
    <url>%2F2018%2F03%2F06%2FLinux%2FLinux%E7%9A%84Bash%2F</url>
    <content type="text"><![CDATA[[TOC] Shell/etc/shells记录系统所有shell Bash shell 功能命令编修能力 默认指令记忆功能可以达到1000个记录位置~/.bash_history(当前指令用户指令在内存中,登出后才记录到文件此内) 命令与文件实例功能(tab补全) 命令别名设置功能 工作控制/前景背景控制 程序化脚本shell script 万用字符(*) type指令type 这个指令我们可以知道每个指令是否为 bash 的内置指令。 此外，type只能查找可执行文件. 123456789[dmtsai@study ~]$ type [-tpa] name选项与参数： ：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令-t ：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义： file ：表示为外部指令； alias ：表示该指令为命令别名所设置的名称； builtin ：表示该指令为 bash 内置的指令功能；-p ：如果后面接的 name 为外部指令时，才会显示完整文件名；-a ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias 快速编辑 反斜杠( \ )命令输入太长需要换行,利用反斜杠( \ )[Enter]开启下一行,而不执行命令.注意: [Enter] 按键是紧接着反斜线 （ \ ） 快捷键 组合键 功能与示范 [ctrl]+u/[ctrl]+k 分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k） [ctrl]+a/[ctrl]+e 分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e） Ctrl + C 终止目前命令 Ctrl + D 输入结束(EOF),例如:邮件结束的时候 Ctrl + M 就是Enter Ctrl + S 暂停屏幕输出 Ctrl + Q 恢复屏幕输出 Ctrl + U 在提示字符下，将整列命令删除 Ctrl + Z “暂停”目前的命令 配合fg/bg/jobs命令使用 变量echo 指令显示变量内容,”-e”选项可以格式化打印内容 1[dmtsai@study ~]$ echo $PATH 变量设置规则 变量与变量内容以一个”=”来连接. myname=Windus 等号两边不能直接接空白符. 123#错误myname= Windusmyname=Windus L 变量内容若有空白符可使用双引号或单引号将变量内容结合起来. 1234567#双引号内特殊字符可保持原本特性,如:&quot;$&quot;等var=&quot;lang is $LANG&quot;echo $var --&gt; lang is UTF8#单引号内的特殊字符仅为一般字符(纯文本)var=&apos;lang is $LANG&apos;echo $var --&gt; lang is $LANG 变量名称只能是英文字母与数字,但开头字符不能是数字. 可用跳脱字符” \ “,将特殊符号变成一般符号。(如： [Enter], $, \, 空白字符等） myname=Windus\ L 在一串指令的执行中，还需要借由其他额外的指令所提供的信息时，可以使用反单引号“指令”或 “$（指令） 12version=$（uname -r）echo $version --&gt; 3.10.0-229.el7.x86_64 若该变量为扩增变量内容时，则可用 “\$变量名称” 或 ${变量} 累加内容 123PATH=&quot;$PATH&quot;:/home/bin或PATH=$&#123;PATH&#125;:/home/bin 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量 export PATH 通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断 （纯粹依照使用者兴趣与嗜好,在 Linux 默认的情况中，使用{大写的字母}来设置的变量一般为系统内定需要的变量） 取消变量用unsetunset myname 环境变量 env命令 查看所有环境变量 HOME 使用者主文件夹变量, ~就会读取此变量 SHELL 目前环境使用的SHELL程序(Linux默认:/bin/bash) HISTSIZE 历史命令记录笔数 MAIL 当前用户邮箱文件 PATH 可执行文件搜寻的路径(目录与目录中间:分隔).由于搜寻顺序依据PATH变量内目录顺序,所以目录顺序也是重要的. LANG 语系数据 RANDOM 随机数变量(/dev/random),内容介于0~32767之间. 1234#想要获取指定范围内的数,使用delcare声名数值类型[dmtsai@study ~]$ declare -i number=$RANDOM*10/32768 ; echo $number8 &lt;== 此时会随机取出 0~9 之间的数值喔！ set命令 查看所有变量(含环境变量与自定变量) PS1 提示字符的设置 12345678910111213\d ：可显示出“星期 月 日”的日期格式，如：&quot;Mon Feb 2&quot;\H ：完整的主机名称。举例来说，鸟哥的练习机为“study.centos.vbird”\h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为“study”后面省略\t ：显示时间，为 24 小时格式的“HH:MM:SS”\T ：显示时间，为 12 小时格式的“HH:MM:SS”\A ：显示时间，为 24 小时格式的“HH:MM”\@ ：显示时间，为 12 小时格式的“am/pm”样式\u ：目前使用者的帐号名称，如“dmtsai”；\v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46（1）-release，仅取“4.2”显示\w ：完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以 ~ 取代；\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。\# ：下达的第几个指令。\$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ - \$ 本shell的PID `echo $$` - ? 上个指令的回传值 执行某些指令时， 这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令， 则会回传一个 0 值,如果执行过程发生错误,就会传回错误代码.一般以非0代码取代. export命令 当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是一个称为程序识别码，被称为 PID 的就是。 接下来你在这个 bash 下面所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了. 子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自订变量.所以你在原本 bash 的自订变量在进入了子程序后就会消失不见， 一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！此时,把自定变量变成环境变量就变得很有必要了:export 变量名称 如果export后面不加变量名称,就会将系统所有变量列出来,等同于set命令. 语系变量 查看Linux支持的语系 123456789[dmtsai@study ~]$ locale -a....（前面省略）....zh_TWzh_TW.big5 &lt;==大五码的中文编码zh_TW.euctwzh_TW.utf8 &lt;==万国码的中文编码zu_ZAzu_ZA.iso88591zu_ZA.utf8 修改Linux语系 12345678910locale &lt;==后面不加任何选项与参数即可！LANG=en_US &lt;==主语言的环境LC_CTYPE=&quot;en_US&quot; &lt;==字符（文字）辨识的编码LC_NUMERIC=&quot;en_US&quot; &lt;==数字系统的显示讯息LC_TIME=&quot;en_US&quot; &lt;==时间系统的显示数据LC_COLLATE=&quot;en_US&quot; &lt;==字串的比较与排序等LC_MONETARY=&quot;en_US&quot; &lt;==币值格式的显示等LC_MESSAGES=&quot;en_US&quot; &lt;==讯息显示的内容，如功能表、错误讯息等LC_ALL= &lt;==整体语系的环境....（后面省略）.... 可以逐一设置每个与语系有关的变量数据,可也以直接设置LANG或LC_ALL(其它语系变量会被这两个变量所取代). 系统默认语系文件是: **/etc/locale.conf** 变量范围环境变量可以被子程序引用的原理: 当启动一个shell,系统会分配一个记忆区给shell使用,使此内存内的变量,即环境变量可让子程序使用. 若父程序用export功能,将自定变量内容写到上述内存区块当中(环境变量). 当载入另一个shell时(亦启动一个子程序,离开原本父程序),子程序可以将父shell的环境变量所在记忆区导入自己的环境变量区块当中. 变量键盘读取/阵列与宣告 read命令 程序执行的过程当中，会等待使用者输入 “yes/no” 之类的讯息,和使用者对谈时使用此命令. 1234[dmtsai@study ~]$ read [-pt] variable选项与参数：-p ：后面可以接提示字符！-t ：后面可以接等待的“秒数！”这个比较有趣～不会一直等待使用者啦！ declare/typeset declare 或 typeset 是一样的功能，就是在“宣告变量的类型. 123456789101112131415[dmtsai@study ~]$ declare [-aixr] variable选项与参数：-a ：将后面名为 variable 的变量定义成为阵列 （array） 类型-i ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型-x ：用法与 export 一样，就是将后面的 variable 变成环境变量；-r ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset-p : 仅列出变量类型范例一：让变量 sum 进行 100+300+50 的加总结果[dmtsai@study ~]$ sum=100+300+50[dmtsai@study ~]$ echo $&#123;sum&#125;100+300+50 &lt;==咦！怎么没有帮我计算加总？因为这是文字体态的变量属性啊！[dmtsai@study ~]$ declare -i sum=100+300+50[dmtsai@study ~]$ echo $&#123;sum&#125;450 &lt;==瞭乎？？ 注意: bash环境下,变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。 所以上述第一个执行的结果才会出现那个情况的；bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0； 变量内容删除/取代/替换 暂时跳过 系统限制关系 ulimit12345678910111213141516[dmtsai@study ~]$ ulimit [-SHacdfltu] [配额]选项与参数：-H ：hard limit ，严格的设置，必定不能超过这个设置的数值；-S ：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。 在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 80 而 hard 设置为 100，那么你可以使用到 90 （因为没有超过 100），但介于 80~100 之间时， 系统会有警告讯息通知你！-a ：后面不接任何选项与参数，可列出所有的限制额度；-c ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用）， 这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量。-f ：此 shell 可以创建的最大文件大小（一般可能设置为 2GB）单位为 KBytes-d ：程序可使用的最大断裂内存（segment）容量；-l ：可用于锁定 （lock） 的内存量-t ：可使用的最大 CPU 时间 （单位为秒）-u ：单一使用者可以使用的最大程序（process）数量。-n &lt;文件数目&gt;：指定同一时间最多可开启的文件数； 命令别名与历史命令别名设置 alias / unalias1234#设置别名[dmtsai@study ~]$ alias lm=&apos;ls -al | more#取消别名[dmtsai@study ~]$ unalias lm 设置别名,在机器重启后将丢失,如果想永久存在,需要写在~/.bash_profile文件内 历史命令 history历史命令记录在~/.bash_history文件中,记录的数量由HISTFILESIZE环境变量决定. 12345678[dmtsai@study ~]$ history [-raw] histfiles选项与参数：n ：数字，意思是“要列出最近的 n 笔命令列表”的意思！-c ：将目前的 shell 中的所有 history 内容全部消除-a ：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ， 则默认写入 ~/.bash_history-r ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中；-w ：将目前的 history 记忆内容写入 histfiles 中！ 历史命令的使用: 12345[dmtsai@study ~]$ !选项与参数：number ：执行第几笔指令的意思；command ：由最近的指令向前搜寻“指令串开头为 command”的那个指令，并执行；!! ：就是执行上一个指令（相当于按↑按键后，按 Enter） 同一帐号同时多次登陆的history写入问题 因为这些 bash 在同时以同一个身份登陆， 因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到登出时才会更新记录文件，所以，最后登出的那个 bash 才会是最后写入的数据。如此一来其他 bash 的指令操作就不会被记录下来了 （其实有被记录，只是被后来的最后一个 bash 所覆盖更新了） 。 历史命令时间问题 历史命令还有一个问题，那就是无法记录指令下达的时间。由于这 1000 笔历史命令是依序记录的， 但是并没有记录时间，所以在查询方面会有一些不方便。其实可以通过~/.bash_logout 来进行 history 的记录，并加上 date 来增加时间参数. Bash Shell操作环境Bash 进站欢迎信息 /etc/issue /etc/motd12345678910issue 内的各代码意义: \d 本地端时间的日期； \l 显示第几个终端机接口； \m 显示硬件的等级 （i386/i486/i586/i686...）； \n 显示主机的网络名称； \O 显示 domain name； \r 操作系统的版本 （相当于 uname -r） \t 显示本地端时间的时间； \S 操作系统的名称； \v 操作系统的版本 当我们使用 telnet 连接到主机时，主机的登陆画面就会显示 /etc/issue.net 而不是 /etc/issue/etc/motd 里面显示的则是文字信息 bash环境配置文件login与non-login Shell login shell：取得 bash 时需要完整的登陆流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登陆，需要输入使用者的帐号与密码，此时取得的 bash 就称为“ login shell ” non-login shell：取得 bash 接口的方法不需要重复登陆的举动，举例来说，（1）你以 X window 登陆 Linux 后， 再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入帐号与密码，那个 bash 的环境就称为 non-login shell了。（2）你在原本的 bash 环境下再次下达 bash 这个指令，同样的也没有输入帐号密码， 那第二个 bash （子程序） 也是 non-login shell 。 这两个Shell，读取的配置文件数据并不一样. /etc/profile (login Shell读取)这个配置文件可以利用使用者的识别码 （UID） 来决定很多重要的变量数据， 也是每个使用者登陆取得 bash 时一定会读取的配置文件.所以设置全局环境就要改这个文件! 1234567主要变量:PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；MAIL：依据帐号设置好使用者的 mailbox 到 /var/spool/mail/帐号名；USER：根据使用者的帐号设置此一变量内容；HOSTNAME：依据主机的 hostname 指令决定此一变量内容；HISTSIZE：历史命令记录笔数。CentOS 7.x 设置为 1000 ；umask：包括 root 默认为 022 而一般用户为 002 等！ /etc/profile 还会调用外部的设置数据,主要有如下: /etc/profile.d/*.sh “这个目录内的众多文件！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使用者能够具有 r 的权限， 那么该文件就会被 /etc/profile 调用进来。在 CentOS 7.x 中，这个目录下面的文件规范了 bash 操作接口的颜色、 语系、ll 与 ls 指令的命令别名、vi 的命令别名、which 的命令别名等等。如果你需要帮所有使用者设置一些共享的命令别名时， 可以在这个目录下面自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可！ /etc/locale.conf 这个文件是由 /etc/profile.d/lang.sh 调用进来的！这也是我们决定 bash 默认使用何种语系的重要配置文件！ 文件里最重要的就是 LANG/LC_ALL 这些个变量的设置！ /usr/share/bash-completion/completions/* 这个目录下除前面谈过 [tab] 命令补齐、文件名补齐之外，还可以进行指令的选项/参数补齐功能！那就是从这个目录里面找到相对应的指令来处理的！ 其实这个目录下面的内容是由 /etc/profile.d/bash_completion.sh 这个文件载入的啦！ ~/.bash_profile (login Shell读取)bash 在读完了整体环境设置的 /etc/profile 并借此调用其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是： 1231. ~/.bash_profile2. ~/.bash_login3. ~/.profile 其实 bash 的 login shell 设置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 ~/.bash_profile 存在，那么其他两个文件不论有无存在，都不会被读取。 如果 ~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思。 会有这么多的文件，其实是因应其他 shell 转换过来的使用者的习惯而已。 source 读入环境配置文件指令由于 /etc/profile 与 ~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以， 如果你将自己的偏好设置写入上述的文件后，通常都是得登出再登陆后，该设置才会生效。利用这个指令可以直接生效! 12345[dmtsai@study ~]$ source 配置文件文件名范例：将主文件夹的 ~/.bashrc 的设置读入目前的 bash 环境中[dmtsai@study ~]$ source ~/.bashrc &lt;==下面这两个指令是一样的！[dmtsai@study ~]$ . ~/.bashrc ~/.bashrc （non-login shell 读取）CentOS 7.x 还会主动的调用 /etc/bashrc 这个文件1234/etc/bashrc文件记录内容1. 依据不同的 UID 规范出 umask 的值；2. 依据不同的 UID 规范出提示字符 （就是 PS1 变量）；3. 调用 /etc/profile.d/*.sh 的设置 /etc/bashrc文件是Red Hat系统特有的,如果此文件丢失,可以复制 /etc/skel/.bashrc 到你的主文件夹. 终端机环境设置 stty , setstty命令查阅目前的一些按键内容 123456789101112131415161718192021222324[dmtsai@study ~]$ stty [-a]选项与参数：-a ：将目前所有的 stty 参数列出来；#列出所有的按键与按键内容[dmtsai@study ~]$ stty -aspeed 38400 baud; rows 20; columns 90; line = 0;intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;flush = ^O; min = 1; time = 0;....（以下省略）....#设置按键[dmtsai@study ~]$ stty erase ^h意义:intr : 送出一个 interrupt （中断） 的讯号给目前正在 执行的程序 （就是终止啰！）；quit : 送出一个 quit 的讯号给目前正在执行的程序；erase : 向后删除字符，kill : 删除在目前命令行上的所有文字；eof : End of file 的意思，代表“结束输入”。start : 在某个程序停止后，重新启动他的 outputstop : 停止目前屏幕的输出；susp : 送出一个 terminal stop 的讯号给正在 run 的程序。 set命令 暂无 万用字符与特殊符号万用字符: 1234567* 代表“ 0 个到无穷多个”任意字符? 代表“一定有一个”任意字符[] 同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”[-] 若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！[^] 若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。 特殊字符: 12345678910111213141516# 注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行\ 跳脱符号：将“特殊字符或万用字符”还原成一般字符| 管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；; 连续指令下达分隔符号：连续性命令的界定 （注意:与管线命令并不相同）~ 使用者的主文件夹$ 取用变量前置字符：亦即是变量之前需要加的变量取代值&amp; 工作控制 （job control）：将指令变成背景下工作! 逻辑运算意义上的“非” not 的意思！/ 目录符号：路径分隔的符号&gt;, &gt;&gt; 数据流重导向：输出导向，分别是“取代”与“累加”&lt;, &lt;&lt; 数据流重导向：输入导向 &apos;&apos; 单引号，不具有变量置换的功能 （$ 变为纯文本）&quot;&quot; 具有变量置换的功能！ （$ 可保留相关功能）`` 两个“ ` ”中间为可以先执行的指令，亦可使用 $（ ）() 在中间为子 shell 的起始与结束&#123;&#125; 在中间为命令区块的组合！ 数据流重导向数据流输入/输出标准输出:指的是“指令执行所回传的正确的讯息”标准错误输出:“ 指令执行失败后，所回传的错误讯息” 标准输入 （stdin） ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；标准输出 （stdout）：代码为 1 ，使用 &gt; 或 &gt;&gt; ；标准错误输出（stderr）：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ； /dev/null 垃圾桶黑洞设备与特殊写法/dev/null 可以吃掉任何导向这个设备的信息 2&gt;&amp; | &amp;&gt;123#将指令的数据全部写入名为 list 的文件中(包括错误信息)[dmtsai@study ~]$ find /home -name .bashrc &gt; list 2&gt;&amp;1 [dmtsai@study ~]$ find /home -name .bashrc &amp;&gt; list 标准输入123456789101112131415161718192021222324252627#利用 cat 指令来创建一个文件的简单流程[dmtsai@study ~]$ cat &gt; catfiletestingcat file test&lt;==这里按下 [ctrl]+d 来离开[dmtsai@study ~]$ cat catfiletestingcat file test#用 stdin 取代键盘的输入以创建新文件的简单流程[dmtsai@study ~]$ cat &gt; catfile &lt; ~/.bashrc[dmtsai@study ~]$ ll catfile ~/.bashrc# 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！-rw-r--r--. 1 dmtsai dmtsai 231 Mar 6 06:06 /home/dmtsai/.bashrc-rw-rw-r--. 1 dmtsai dmtsai 231 Jul 9 18:58 catfile#用 cat 直接将输入的讯息输出到 catfile 中， 且当由键盘输入 eof 时，该次输入就结束[dmtsai@study ~]$ cat &gt; catfile &lt;&lt; &quot;eof&quot;&gt; This is a test.&gt; OK now stop&gt; eof &lt;==输入这关键字，立刻就结束而不需要输入 [ctrl]+d[dmtsai@study ~]$ cat catfileThis is a test.OK now stop &lt;==只有这两行，不会存在关键字那一行！ 命令执行的判断依据 ; &amp;&amp; ||不考虑指令相关性的连续指令下达 cmd;cmd1[root@study ~]# sync; sync; shutdown -h now $? （指令回传值） 与 &amp;&amp; 或 ||若前一个指令执行的结果为正确，在 Linux 下面会回传一个 $? = 0 的值 指令 说明 cmd1 &amp;&amp; cmd2 1. 若 cmd1 执行完毕且正确执行（$?=0），则开始执行 cmd2。 2. 若 cmd1 执行完毕且为错误 （$?≠0），则 cmd2 不执行。 cmd1 || cmd2 1. 若 cmd1 执行完毕且正确执行（$?=0），则 cmd2 不执行。 2. 若 cmd1 执行完毕且为错误 （$?≠0），则开始执行 cmd2。 1[dmtsai@study ~]$ ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe Linux 下面的指令都是由左往右执行,上面执行结果:情况一:（1）若 /tmp/abc 不存在故回传 $?≠0，则（2）因为 || 遇到非为 0 的 \$? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc 会成功进行，所以回传 \$?=0（3）因为 &amp;&amp; 遇到 \$?=0 故会执行 touch /tmp/abc/hehe，最终 hehe 就被创建了； 情况二:（1）若 /tmp/abc 存在故回传 $?=0，则（2）因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故（3）因为 &amp;&amp; 遇到 \$?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。 1234ls /tmp/vbirding || echo &quot;not exist&quot; &amp;&amp; echo &quot;exist”#返回结果:not existexist 由于指令是一个接着一个去执行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错(如上面例子).一般来说，假设判断式有三个，也就是：command1 &amp;&amp; command2 || command3 管线命令(pipe)管线命令使用的是“ | ”这个界定符号！ 另外，管线命令与“连续下达命令”是不一样！管线命令“ | ”仅能处理经由前面一个指令传来的正确信息，也就是 standard output 的信息，对于 stdandard error 并没有直接处理的能力.每个管线后面接的第一个数据必定是“指令”喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以是为“管线命令” 撷取命令 cut grepcut将一段讯息的某一段给他“切”出来～ 处理的讯息是以“行”为单位 1234567891011121314151617181920212223242526[dmtsai@study ~]$ cut -d&apos;分隔字符&apos; -f fields &lt;==用于有特定分隔字符[dmtsai@study ~]$ cut -c 字符区间 &lt;==用于排列整齐的讯息选项与参数：-d ：后面接分隔字符。与 -f 一起使用；-f ：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；-c ：以字符 （characters） 的单位取出固定字符区间；[dmtsai@study ~]$ echo $&#123;PATH&#125; | cut -d &apos;:&apos; -f 5 #显示切割后的第5个[dmtsai@study ~]$ echo $&#123;PATH&#125; | cut -d &apos;:&apos; -f 3,5 #显示切割后的3-5个[dmtsai@study ~]$ echo $&#123;PATH&#125; | cut -d &apos;:&apos; -f 3- #显示切割后的3到最后一个#将 export 输出的讯息，取得第 12 字符以后的所有字串[dmtsai@study ~]$ exportdeclare -x HISTCONTROL=&quot;ignoredups&quot;declare -x HISTSIZE=&quot;1000&quot;declare -x HOME=&quot;/home/dmtsai&quot;declare -x HOSTNAME=&quot;study.centos.vbird&quot;.....（其他省略）.....# 注意看，每个数据都是排列整齐的输出！如果我们不想要“ declare -x ”时，就得这么做：[dmtsai@study ~]$ export | cut -c 12-HISTCONTROL=&quot;ignoredups&quot;HISTSIZE=&quot;1000&quot;HOME=&quot;/home/dmtsai&quot;HOSTNAME=&quot;study.centos.vbird&quot;.....（其他省略）..... grep12345678910[dmtsai@study ~]$ grep [-acinv] [--color=auto] &apos;搜寻字串&apos; filename选项与参数：-a ：将 binary 文件以 text 文件的方式搜寻数据-c ：计算找到 &apos;搜寻字串&apos; 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 &apos;搜寻字串&apos; 内容的那一行！--color=auto ：可以将找到的关键字部分加上颜色的显示喔！-A : 后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；-B : 后面可加数字，为 before 的意思，除了列出该行外，前面的 n 行也列出来； 排序命令 sort wc uniqsort12345678910111213141516171819202122[dmtsai@study ~]$ sort [-fbMnrtuk] [file or stdin]选项与参数：-f ：忽略大小写的差异，例如 A 与 a 视为编码相同；-b ：忽略最前面的空白字符部分；-M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；-n ：使用“纯数字”进行排序（默认是以文字体态来排序的）；-r ：反向排序；-u ：就是 uniq ，相同的数据中，仅出现一行代表；-t ：分隔符号，默认是用 [tab] 键来分隔；-k ：以那个区间 （field） 来进行排序的意思#/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？[dmtsai@study ~]$ cat /etc/passwd | sort -t &apos;:&apos; -k 3root:x:0:0:root:/root:/bin/bashdmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bashalex:x:1001:1002::/home/alex:/bin/basharod:x:1002:1003::/home/arod:/bin/bash# 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～# 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：# cat /etc/passwd | sort -t &apos;:&apos; -k 3 -n# 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！ uniq重复的数据仅列出一个显示 12345678910111213141516[dmtsai@study ~]$ uniq [-ic]选项与参数：-i ：忽略大小写字符的不同；-c ：进行计数#使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；[dmtsai@study ~]$ last | cut -d &apos; &apos; -f1 | sort | uniq#承上,继续显示每个帐号登录次数[dmtsai@study ~]$ last | cut -d &apos; &apos; -f1 | sort | uniq -c 1 6 （unknown 47 dmtsai 4 reboot 7 root 1 wtmp wc12345678910[dmtsai@study ~]$ wc [-lwm]选项与参数：-l ：仅列出行；-w ：仅列出多少字（英文单字）；-m ：多少字符；#/etc/man_db.conf 里面到底有多少相关字、行、字符数？[dmtsai@study ~]$ cat /etc/man_db.conf | wc 131 723 5171# 输出的三个数字中，分别代表： “行、字数、字符数 双重导向tee可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理. 123456789[dmtsai@study ~]$ tee [-a] file选项与参数：-a ：以累加 （append） 的方式，将数据加入 file 当中！[dmtsai@study ~]$ ls -l /home | tee ~/homefile | more# 将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！[dmtsai@study ~]$ ls -l / | tee -a ~/homefile | more# 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。 字符转换命令 tr, col, join, paste, expandtrtr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！ 1234567891011[dmtsai@study ~]$ tr [-ds] SET1 ...选项与参数：-d ：删除讯息当中的 SET1 这个字串；-s ：取代掉重复的字符！#将 last 输出的讯息中，所有的小写变成大写字符：[dmtsai@study ~]$ last | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;# 不加单引号也是可以执行的，如：“ last | tr [a-z] [A-Z] ”#将 /etc/passwd 输出的讯息中，将冒号 （:） 删除[dmtsai@study ~]$ cat /etc/passwd | tr -d &apos;:&apos; col用来简单的处理将 [tab] 按键取代成为空白键.(还有其它用途???) 1234567[dmtsai@study ~]$ col [-xb]选项与参数：-x ：将 tab 键转换成对等的空白键#利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白[dmtsai@study ~]$ cat -A /etc/man_db.conf &lt;==此时会看到很多 ^I 的符号，那就是 tab[dmtsai@study ~]$ cat /etc/man_db.conf | col -x | cat -A | more 分区命令 split如果有文件太大，导致一些携带式设备无法复制的问题，split 可以将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了 12345[dmtsai@study ~]$ split [-bl] file PREFIX选项与参数：-b ：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；-l ：以行数来进行分区。PREFIX ：代表前置字符的意思，可作为分区文件的前导文字。 范例一：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？ 123456[dmtsai@study ~]$ cd /tmp; split -b 300k /etc/services services[dmtsai@study tmp]$ ll -k services*-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul 9 22:52 servicesaa-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul 9 22:52 servicesab-rw-rw-r--. 1 dmtsai dmtsai 55893 Jul 9 22:52 servicesac# 那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa, xxxab, xxxac 等方式来创建小文件的！ “范例二：如何将上面的三个小文件合成一个文件，文件名为 servicesback 12#用数据流重导向合成文件[dmtsai@study tmp]$ cat services* &gt;&gt; servicesback 范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件 1234567[dmtsai@study tmp]$ ls -al / | split -l 10 - lsroot[dmtsai@study tmp]$ wc -l lsroot* 10 lsrootaa 10 lsrootab 4 lsrootac 24 total# 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～ 参数代换 xargs(后面貌似不能用alias)12345678[dmtsai@study ~]$ xargs [-0epn] command选项与参数：-0 ：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数 可以将他还原成一般字符。这个参数可以用于特殊状态！-e ：这个是 EOF （end of file） 的意思。后面可以接一个字符串，当 xargs 分析到这个字串时，就会停止继续工作！-p ：在执行每个指令的 argument 时，都会询问使用者的意思；-n ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！ 范例一：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来. 1234567891011121314151617181920[dmtsai@study ~]$ id rootuid=0（root） gid=0（root） groups=0（root） # 这个 id 指令可以查询使用者的 UID/GID 等信息[dmtsai@study ~]$ id $(cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3)# 虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！# 所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | iduid=1000 (dmtsai) gid=1000 (dmtsai) groups=1000 (dmtsai),10(wheel)# 因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | xargs id# 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但id 就接受 1 个参数！[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | xargs -n 1 iduid=0（root） gid=0（root） groups=0（root）uid=1（bin） gid=1（bin） groups=1（bin）uid=2（daemon） gid=2（daemon） groups=2（daemon）# 通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！ 范例二：同上，但是每次执行 id 时，都要询问使用者是否动作？ 123456[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | xargs -p -n 1 idid root ?...yuid=0（root） gid=0（root） groups=0（root）id bin ?...y.....（下面省略）.....# 呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！ 范例三：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串 1234[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | xargs -e&apos;sync&apos; -n 1 id# 仔细与上面的案例做比较。也同时注意，那个 -e&apos;sync&apos; 是连在一起的，中间没有空白键。# 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e&apos;sync&apos; 后，则分析到 sync 这个字串时，# 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！ 很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！ 范例四：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性 123456[dmtsai@study ~]$ find /usr/sbin -perm /7000 | xargs ls -l-rwx--s--x. 1 root lock 11208 Jun 10 2014 /usr/sbin/lockdev-rwsr-xr-x. 1 root root 113400 Mar 6 12:17 /usr/sbin/mount.nfs-rwxr-sr-x. 1 root root 11208 Mar 6 11:05 /usr/sbin/netreport.....（下面省略）.....# 也可以使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！ 减号 “ - “ 的用途管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 “-“ 来替代. 12[root@study ~]# mkdir /tmp/homeback[root@study ~]# tar -cvf - /home | tar -xvf - -C /tmp/homeback 上面这个例子是：“将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - ”。后面的这个 - 则是取用前一个指令的 stdout， 因此，我们就不需要使用 filename 了]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件压缩/打包/备份]]></title>
    <url>%2F2018%2F03%2F02%2FLinux%2F%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%3A%E6%89%93%E5%8C%85%3A%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[[TOC] 压缩文件的技术压缩文件简单原理:目前我们使用的计算机系统中都是使用所谓的 Bytes 单位来计量的！不过，事实上，计算机最小的计量单位应该是 bits 才对啊。此外，我们也知道 1 Byte = 8 bits 。但是如果今天我们只是记忆一个数字，亦即是 1 这个数字呢?由于我们记录数字是 1 ，考虑计算机所谓的二进制喔，如此一来， 1 会在最右边占据 1 个 bit ，而其他的 7 个 bits 将会自动的被填上 0 啰！你看看，其实在这样的例子中，那 7 个 bits 应该是“空的”才对！不过，为了要满足目前我们的操作系统数据的存取，所以就会将该数据转为 Byte 的型态来记录了！而一些聪明的计算机工程师就利用一些复杂的计算方式， 将这些没有使用到的空间“丢”出来，以让文件占用的空间变小！这就是压缩的技术啦！ 另外一种压缩技术也很有趣，他是将重复的数据进行统计记录的。举例来说，如果你的数据为“111….”共有100个1时， 那么压缩技术会记录为“100个1”而不是真的有100个1的位存在！简单的说，你可以将他想成，其实文件里面有相当多的“空间”存在，并不是完全填满的， 而“压缩”的技术就是将这些“空间”填满，以让整个文件占用的容量下降！ 不过，这些“压缩过的文件”并无法直接被我们的操作系统所使用的，因此， 若要使用这些被压缩过的文件数据，则必须将他“还原”回来未压缩前的模样， 那就是所谓的“解压缩 常见的压缩指令 .Z compress 程序压缩的文件； .zip zip 程序压缩的文件；.gz gzip 程序压缩的文件； .bz2 bzip2 程序压缩的文件；.xz xz 程序压缩的文件； .tar tar 程序打包的数据，并没有压缩过；.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩 .tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩*.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩 gzip, zcat/zmore/zless/zgrepgzip是目前应用最广的压缩指令,后缀为*.gz如果压缩的文件是文本文件,压缩后可以使用zcat相关指令读取出来. 1234567[dmtsai@study ~]$ gzip [-cdtv#] 文件名选项与参数：-c ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；-d ：解压缩的参数；-t ：可以用来检验一个压缩文件的一致性～看看文件有无错误；-v ：可以显示出原文件/压缩文件的压缩比等信息；-# ：#为数字的意思，代表压缩等级，-1最快，但是压缩比最差、-9最慢，但是压缩比最好！默认是 -6 gzip压缩默认会删除原文件,如果想保留原文件可以使用如下命令: 12[dmtsai@study tmp]$ gzip -9 -c services &gt; services.gz-c 选项打印出文件到屏幕,然后使用 &gt; 重定向 找出压缩文件中的关键字命令: 12345[dmtsai@study tmp]$ zgrep -n &apos;http&apos; services.gz14:# http://www.iana.org/assignments/port-numbers89:http 80/tcp www www-http # WorldWideWeb HTTP90:http 80/udp www www-http # HyperText Transfer Protocol.....（下面省略）..... bzip2, bzcat/bzmore/bzless/bzgrep与gzip用法类似,比gzip压缩比更好后缀为*.bz2 12345678[dmtsai@study ~]$ bzip2 [-cdkzv#] 文件名选项与参数：-c ：将压缩的过程产生的数据输出到屏幕上！-d ：解压缩的参数-k ：保留原始文件，而不会删除原始的文件喔！-z ：压缩的参数 （默认值，可以不加）-v ：可以显示出原文件/压缩文件的压缩比等信息；-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！ xz, xzcat/xzmore/xzless/xzgrep与gzip,bzip2用法类似,比bzip2压缩比更好后缀为*.xz 12345678[dmtsai@study ~]$ xz [-dtlkc#] 文件名选项与参数：-d ：就是解压缩啊！-t ：测试压缩文件的完整性，看有没有错误-l ：列出压缩文件的相关信息-k ：保留原本的文件不删除～-c ：同样的，就是将数据由屏幕上输出的意思！-# ：同样的，也有较佳的压缩比的意思！” 打包文件虽然 gzip, bzip2, xz 也能够针对目录来进行压缩，不过， 这两个指令对目录的压缩指的是“将目录内的所有文件 “分别” 进行压缩”的动作！而不像在 Windows 的系统，可以使用类似 WinRAR 这一类的压缩软件来将好多数据“包成一个文件”的样式。 tar命令常用选项1234567891011121314151617181920[dmtsai@study ~]$ tar [-z|-j|-J][cv][-f 待创建的新文件名] filename... &lt;==打包与压缩[dmtsai@study ~]$ tar [-z|-j|-J][tv] [-f 既有的 tar文件名] &lt;==察看文件名[dmtsai@study ~]$ tar [-z|-j|-J] [xv] [-f 既有的 tar文件名][-C 目录] &lt;==解压缩选项与参数：-c ：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）-t ：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；-x ：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开 特别留意的是， -c, -t, -x 不可同时出现在一串命令行中。-z ：通过 gzip 的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz-j ：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2-J ：通过 xz 的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串命令行中-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！-f filename：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）-C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。其他后续练习会使用到的选项介绍：-p（小写） ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件-P（大写） ：保留绝对路径，亦即允许备份数据中含有根目录存在之意；--exclude=FILE：在压缩的过程中，不要将 FILE 打包！ tar备份123456789[dmtsai@study ~]$ su - # 因为备份 /etc 需要 root 的权限，否则会出现一堆错误[root@study ~]# time tar -zpcv -f /root/etc.tar.gz /etctar: Removing leading `/&apos; from member names &lt;==注意这个警告讯息/etc/....（中间省略）..../etc/hostname#多了time会显示程序运行时间#加上&quot;-p&quot;选项原因是为了保存原本文件的权限和属性 tar备份默认是没有根目录的,那为什么要拿掉根目录呢？主要是为了安全！我们使用 tar 备份的数据可能会需要解压缩回来使用， 在 tar 所记录的文件名 （就是我们刚刚使用 tar -jtvf 所察看到的文件名） 那就是解压缩后的实际文件名。 如果拿掉了根目录，假设你将备份数据在 /tmp 解开，那么解压缩的文件名就会变成“/tmp/etc/xxx”。 但“如果没有拿掉根目录，解压缩后的文件名就会是绝对路径， 亦即解压缩后的数据一定会被放置到 /etc/xxx 去！”如此一来，你的原本的 /etc/ 下面的数据， 就会被备份数据所覆盖过去了！如果想保存根目录可以使用-P选项 解压tar包内单一文件123456789101112131415161718# 1. 先找到我们要的文件名，假设解开 shadow 文件好了：[root@study ~]# tar -jtv -f /root/etc.tar.bz2 | grep &apos;shadow&apos;---------- root/root 721 2015-06-17 00:20 etc/gshadow---------- root/root 1183 2015-06-17 00:20 etc/shadow----------- root/root 1210 2015-06-17 00:20 etc/shadow &lt;==这是我们要的！---------- root/root 707 2015-06-17 00:20 etc/gshadow-# 先搜寻重要的文件名！其中那个 grep 是“撷取”关键字的功能！我们会在第三篇说明！# 这里您先有个概念即可！那个管线 | 配合 grep 可以撷取关键字的意思！# 2. 将该文件解开！语法与实际作法如下：[root@study ~]# tar -jxv -f 打包档.tar.bz2 待解开文件名[root@study ~]# tar -jxv -f /root/etc.tar.bz2 etc/shadowetc/shadow[root@study ~]# ll etctotal 4----------. 1 root root 1210 Jun 17 00:20 shadow# 很有趣！此时只会解开一个文件而已！不过，重点是那个文件名！你要找到正确的文件名。# 在本例中，你不能写成 /etc/shadow ！因为记录在 etc.tar.bz2 内的并没有 / 之故！ tarfile与tarball使用tar打包的文件称为tarfile如果打包文件同时使用压缩则称为tarball.]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[例行性工作调度]]></title>
    <url>%2F2017%2F12%2F11%2FLinux%2F%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 循环性执行的例行性工作高度循环执行的例行性工作调度由cron(crond)服务 控制.Lnux上有非常多的例行性工作,因此这个服务是默认启动的. 使用者的设置 123/etc/cron.allow 允许使用crontab的用户/etc/cron.deny 不允许使用crontab的用户allow优先级优于deny 当用户使用crontab指令创建工作调度之后,该项工作被纪录到/var/spool/cron里,而且是以账号作为判别的.如:用Windus使用后会纪录到/var/spool/cron/Windus注意:不要使用vim编辑该文件,可能由于输入法错误导致无法执行cron另外,cron执行的每一项任务都纪录到/var/log/cron中. 123456[root@study ~]# crontab [-u username] [-l|-e|-r]选项与参数：-u ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作调度；-e ：编辑 crontab 的工作内容-l ：查阅 crontab 的工作内容-r ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。 每项工作格式都有六个字段,意义为: 代表意义 分 时 日期 月 周 指令 数字范围 0~59 0~23 1~31 1~12 0~7 执行指令 注意:周指令0和7都代表星期天 特殊字符 字符 意义 *(星号) 代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 ， 就代表着“不论何月、何日的礼拜几的 12:00 都执行后续指令”的意思！ ,(逗号) 代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是：0 3,6 command时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！ -(减号) 代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作：20 8-12 command仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！ /n(斜线) 那个 n 代表数字，亦即是“每隔 n 单位间隔”的意思，例如每五分钟进行一次，则：/5 command 用 * 与 /5 来搭配，也可以写成 0-59/5 ，相同意思! crond服务读取配置文件位置 12345- /etc/crontab- /etc/cron.d/*- /var/spool/cron/*前两个跟系统有关的配置文件,后一个跟用户有关]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘与文件管理]]></title>
    <url>%2F2017%2F09%2F29%2FLinux%2F%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] EXT2文件系统 data block 用来放置文件内容数据的地方.在EXT2文件系统中支持block大小有1k 2k 4k.&gt; 每个block大小在与数量在格式化完成后就确定,不能再改变了.(**除非格 式化或使用resize2fs等指令变更文件系统大小**) &gt; 每个block最多只能放一个文件 &gt; 如果文件大于block大小,那文件会占用多个block &gt; 如果文件大小小于block,那么剩余容量就不能再使用了(磁盘空间会浪费). inode table 记录内容: 该文件的存取模式（read/write/excute）该文件的拥有者与群组（owner/group）该文件的容量该文件创建或状态改变的时间（ctime）最近一次的读取时间（atime）最近修改的时间（mtime）定义文件特性的旗标（flag），如 SetUID…该文件真正内容的指向 （pointer）不记录文件名(文件名记录在block上) 特点: 每个 inode 大小均固定为 128 Bytes（新的 ext4 与 xfs 可设置到 256 Bytes）每个文件都仅会占用一个 inode 而已承上，因此文件系统能够创建的文件数量与 inode 的数量有关系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用 者是否符合，若符合才能够开始实际读取 block 的内容。 inode要记录的数据特别多,而只有128Bytes.inode记录一个block号码要4Byte,所以大文件一个inode肯定是不够用的.为此,inode记录block号码区域定义了12个直接,一个间接,一个双间接,一个三间接记录区. 如上图,最左边为 inode 本身 （128 Bytes），里面有 12 个直接指向 block 号码的对照，这 12 笔记录就能够直接取得 block 号码啦！ 至于所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果文件太大时， 就会使用间接的 block 来记录号码。如上图 7.1.4 当中间接只是拿一个 block 来记录额外的号码而已。 同理，如果文件持续长大，那么就会利用所谓的双间接，第一个 block 仅再指出下一个记录号码的 block 在哪里， 实际记录的在第二个 block 当中。依此类推，三间接就是利用第三层 block 来记录号码啦！ 123456789101112inode指定block大小计算(block为1k):- 12 个直接指向： 12*1K=12K 由于是直接,12所以总共可以记录12笔- 1 个间接： 256*1K=256K 每笔 block 号码的记录会花去 4Bytes，因此 1K 的大小能够记录 256 笔记录- 1 个双间接: 256*256*1K=2562K 第一层 block 会指定256个第二层,每个第二层可以指定 256个号码- 1 个三间接： 256*256*256*1K=2563K 第一层 block 会指定256个第二层,每个第二层可以指定256个第三层，每个第三层可以指定 256 个号码得到:12 + 256 + 256*256 + 256*256*256 （K） = 16GB 上面方法不能用在2k及4k block大小计算中,因为大于2k block将会受到EXT2文件系统本身的限制,所以计算结果会不太符合之故. super block 记录整个文件系统信息,没有它就没有文件系统 记录信息 block 与 inode 的总量未使用与已使用的 inode / block 数量block 与 inode 的大小（block为1,2,4K,inode为 128Bytes或 256Bytes）filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 （fsck） 的时间等文件系统的相关信息一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 superblock大小为1024Bytes,文件系统除了第一个block group含有superblock以外,后续的block group都不一定含有supperblock,若含有则是对第一个block group的备份. block bitmap (区块对照表)文件修改时,记录block是否被占用. inode bitmap (inode对照表)与block bitmap功能类似,记录inode占用情况. Filesystem Description （文件系统描述说明）这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 （superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间。 dumpe2fs 查询 Ext 家族 superblock 信息的指令 由于目前centos7以xfs为默认文件系统,所以这个指令无法使用. 1234[root@study ~]# dumpe2fs [-bh] 设备文件名选项与参数：-b ：列出保留为坏轨的部分（一般用不到吧！？）-h ：仅列出 superblock 的数据，不会列出其他的区段内容！ 目录树的操作由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的 inode 号码，此时就能够得到根目录的 inode 内容，并依据该 inode 读取根目录的 block 内的文件名数据，再一层一层的往下读到正确的文件名。 读取步骤 12345[root@study ~]# ll -di / /etc /etc/passwd 128 dr-xr-xr-x. 17 root root 4096 May 4 17:56 /33595521 drwxr-xr-x. 131 root root 8192 Jun 17 00:20 /etc36628004 -rw-r--r--. 1 root root 2092 Jun 17 00:20 /etc/ passwd / 的 inode： 通过挂载点的信息找到 inode 号码为 128 的根目录 inode，且 inode 规范的权限让我们可以读取该 block 的内容（有 r 与 x） ； / 的 block： 经过上个步骤取得 block 的号码，并找到该内容有 etc/ 目录的 inode 号码 （33595521）； etc/ 的 inode： 读取 33595521 号 inode 得知 dmtsai 具有 r 与 x 的权限，因此可以读取 etc/ 的 block 内容； etc/ 的 block： 经过上个步骤取得 block 号码，并找到该内容有 passwd 文件的 inode 号码 （36628004）； passwd 的 inode： 读取 36628004 号 inode 得知 dmtsai 具有 r 的权限，因此可以读取 passwd 的 block 内容; passwd 的 block： 最后将该 block 内容的数据读出来。 写步骤 先确定使用者对于欲新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增； 根据 inode bitmap 找到没有使用的 inode 号码，并将新文件的权限/属性写入； 根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode 的 block 指向数据； 将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap，并更新 superblock 的内容。 日志式文件系统由于各种情况,可能造成数据发生问题,导致写入数据只有inode/block,而缺失bitmap,此时发生metadata与实际数据存放区产生不一致的情况. 在早期的 Ext2 文件系统中，如果发生这个问题， 那么系统在重新开机的时候，就会借由 Superblock 当中记录的 valid bit （是否有挂载） 与 filesystem state （clean 与否） 等状态来判断是否强制进行数据一致性的检查！若有需要检查时则以 e2fsck 这支程序来进行的。因为要针对metadata区域和实际数据存放区域进行比对,所以非常耗时.为了避免上述问题的发生,应运而生了日志文件系统,具体执行步骤: 预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息； 实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据； 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。 在这样的程序当中，万一数据的纪录过程当中发生了问题，那么我们的系统只要去检查日志记录区块， 就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整块 filesystem 去检查， 这样就可以达到快速修复 filesystem 的能力 XFS文件系统EXT文件系统目前对于格式化处理,采用预先规划出inode/block/meta data等数据,未来系统可以直接使用,由于现在硬盘越来越大,所以格式化越来越慢.因此,从centos7.x开始文件系统已默认更换成XFS这个比较适合大容量磁盘与巨型文件,性能较佳的文件系统了. 基本止,xfs就是一个日志文件系统,最早之前它就是被开发来用于大容量磁盘以及高性能文件系统之用.Ext4几乎所有的功能xfs都具备.xfs文件系统在数据分布上,主要规划三个部分:一个数据区(data section),一个文件系统活动登录区(log section),一个实时运行区(realtime section). 数据区(data section)基本上,数据区和Ext文件系统一样,包括inode/data block/superblock等数据,都放在这个区块.这个数据区与Ext家族的block group类似,也是分为多个存储区群组(allocation groups)来分别放置文件系统所要的数据.每个存储区群组都包含了(1)整个文件系统的superblock(2)剩余空间管理机制(3)inode的分配与追踪.此外，inode与 block 都是系统需要用到时， 这才动态配置产生，所以格式化动作超级快！ 另外，与 ext 家族不同的是， xfs 的 block 与 inode 有多种不同的容量可供设置，block 容量可由 512Bytes ~ 64K 调配，不过，Linux 的环境下， 由于内存控制的关系 （分页档 pagesize 的容量之故），因此最高可以使用的 block 大小为 4K 而已！（鸟哥尝试格式化 block 成为 16K 是没问题的，不过，Linux 核心不给挂载！ 所以格式化完成后也无法使用啦！） 至于 inode 容量可由 256Bytes 到 2M 这么大！不过，大概还是保留 256Bytes 的默认值就很够用了！ 文件系统活动登录区(log section)这个区域主要用来被记录文件系统的变化,其实有点像日志区. 实时运行区(realtime section)当有文件被创建时,xfs会在这个区域找一个到数个extent区块,将文件放置在这个区块内,等分配完毕后再写入data section的inode与block中去.这个extent区块大小要在格式化时候指定,最小值4K,最大可到1G.一般非磁盘阵列的磁盘默认64K,而具有磁盘阵列的情况下,则建议extent设置为与stripe一样大较佳. 1234567xfs文件系统的描述数据观察:#找出系统 /boot 这个挂载点下面的文件系统的 superblock 纪录 [root@study ~]# df -T /bootFilesystem Type 1K-blocks Used Available Use% Mounted on/dev/vda2 xfs 1038336 133704 904632 13% /boot[root@study ~]# xfs_info /dev/vda2 df命令列出文件系统的整体磁盘使用量 123456789[root@study ~]# df [-ahikHTm] [目录或文件名]选项与参数：-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：连同该 partition 的 filesystem 名称 （例如 xfs） 也列出；-i ：不用磁盘容量，而以 inode 的数量来显示 du命令评估文件系统的磁盘使用量（常用在推估目录所占容量） 12345678[root@study ~]# du [-ahskm] 文件或目录名称选项与参数：-a ：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已。-h ：以人们较易读的容量格式 （G/M） 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示； df 主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在 Superblock 内的信息， 所以这个指令显示结果的速度非常的快速.du 这个指令其实会直接到文件系统内去搜寻所有的文件数据，这个指令的会执行一小段时间！ Hard Link （实体链接, 硬式链接或实际链接）由于每个文件都占用一个inode,文件内容由inode记录指向,想要读取文件必须经过目录记录的文件名来指向到正确的inode号码才能读取.也就是说,其实文件名只与目录有关,但是文件内容则与inode有关.如果有多个文件名对应一个inode,那就是实体链接的由来.限制: 不能跨FileSystem 不能link目录 如果hard link到链接到目录时,链接的数据需要连同被链接目录下面的所有数据都创建链接，举例来说，如果你要将 /etc 使用实体链接创建一个 /etc_hd 的目录时，那么在 /etc_hd 下面的所有文件名同时都与 /etc 下面的文件名要创建 hard link 的，而不是仅链接到 /etc_hd 与 /etc 而已。 并且，未来如果需要在 /etc_hd 下面创建新文件时，连带的， /etc 下面的数据又得要创建一次 hard link ，因此造成环境相当大的复杂度.所以啰，目前 hard link 对于目录暂时还是不支持的啊！ Symbolic Link(符号链接)Symbolic link 就是在创建一个独立的文件，而这个文件会让数据的读取指向他 link 的那个文件的文件名！由于只是利用文件来做为指向的动作， 所以，当来源文件被删除之后，symbolic link 的文件会“开不了”， 会一直说“无法打开某文件！”。实际上就是找不到原始“文件名”而已啦！ 1234[root@study ~]# ln -s /etc/crontab crontab2[root@study ~]# ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab 上面结果我们可以知道两个文件指向不同的 inode 号码，当然就是两个独立的文件存在！ 而且链接文件的重要内容就是他会写上目标文件的“文件名”， 你可以发现为什么上表中链接文件的大小为 12 Bytes 呢？ 因为箭头（–&gt;）右边的文件名“/etc/crontab”总共有 12 个英文，每个英文占用 1 个 Bytes ，所以文件大小就是 12Bytes了！ ln命令 1234[root@study ~]# ln [-sf] 来源文件 目标文件选项与参数：-s ：如果不加任何参数就进行链接，那就是hard link，至于 -s 就是symbolic link-f ：如果 目标文件 存在时，就主动的将目标文件直接移除后再创建！]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件与目录管理]]></title>
    <url>%2F2017%2F09%2F13%2FLinux%2F%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] 目录相关操作 . 代表此层目录.. 代表上一层目录 代表前一个工作目录~ 代表“目前使用者身份”所在的主文件夹~account 代表 account 这个使用者的主文件夹（account是个帐号名称） pwd命令1234567891011#显示所在目录root@study ~]# pwd [-P]-P ：显示出确实的路径，而非使用链接 （link） 路径。 [root@study mail]# ls -ld /var/maillrwxrwxrwx. 1 root root 10 May 4 17:51 /var/mail -&gt; spool/mail[root@study ~]# cd /var/mail [root@study mail]# pwd/var/mail &lt;==列出目前的工作目录[root@study mail]# pwd -P/var/spool/mail mkdir 创建目录123root@study ~]# mkdir [-p] 目录名-p : 创建层级目录mkdir -p /home/windus/test/linux ls命令12345678910111213141516171819202122232425262728 选项与参数：-a ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）-A ：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）-f ：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）-F ：根据文件、目录等信息，给予附加数据结构，例如： *:代表可可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；-h ：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；-i ：列出 inode 号码，inode 的意义下一章将会介绍；-l ：长数据串行出，包含文件的属性与权限等等数据；（常用）字段说明:1.文件属性：drwxr-xr-x2.文件硬链接数量 33.所有者：user4.所属用户组：group5.文件大小：102 byte6.修改时间：Mar11 22:567.文件名：Filename-n ：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）-r ：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；-S ：以文件大小大小排序，而不是用文件名排序；-t ：依时间排序，而不是用文件名。--color=never ：不要依据文件特性给予颜色显示；--color=always ：显示颜色--color=auto ：让系统自行依据设置来判断是否给予颜色--full-time ：以完整时间模式 （包含年、月、日、时、分） 输出--time=&#123;atime,ctime&#125; ：输出 access 时间或改变权限属性时间 （ctime）而非内容变更时间 （modification time） cp命令12345678910选项与参数:-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；（常用）-d ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；-i ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）-l ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；-p ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；-r ：递回持续复制，用于目录的复制行为；（常用）-s ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。 rmdir命令123root@study ~]# rmdir [-p] 目录名称选项与参数：-p ：连同“上层”“空的”目录也一起删除 rm命令 1.在指令前加上反斜线，可以忽略掉 alias 的指定选项喔！^[详见bash章节]2.删除一个带有 - 开头的文件。（因为“－”是选项,所以系统误判了！ 123456#错误[root@study tmp]# rm -aaa-rm: invalid option -- &apos;a‘#正确 rm --help查找[root@study tmp]# rm ./-aaa-[root@study tmp]# rm -- -aaa- mv命令1234选项与参数：-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新 （update） 特殊用处:1.文件更名(类似命令rename)2.可同时移动多个文件到同一目录 rename命令123456参数:原字符串：将文件名需要替换的字符串； 目标字符串：将文件名中含有的原字符替换成目标字符串； 文件：指定要改变文件名的文件列表#[root@study tmp]# rename .htm .html *.htm basename获取文件/目录名 12345678910选项:-a, --multiple support multiple arguments and treat each as a NAME-s, --suffix=SUFFIX remove a trailing SUFFIX-z, --zero separate output with NUL rather than newline #例子basename /usr/bin/sort -&gt; &quot;sort&quot;basename include/stdio.h .h -&gt; &quot;stdio&quot;basename -s .h include/stdio.h -&gt; &quot;stdio&quot;basename -a any/str1 any/str2 -&gt; &quot;str1&quot; followed by &quot;str2&quot; dirname1234#例子dirname /usr/bin/ -&gt; &quot;/usr&quot;dirname dir1/str dir2/str -&gt; &quot;dir1&quot; followed by &quot;dir2&quot;dirname stdio.h -&gt; &quot;.&quot; 文件内容审阅cat命令由第一行开始显示内容(与tac相反) 1234567选项与参数：-A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E ：将结尾的断行字符 $ 显示出来；-n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；-T ：将 [tab] 按键以 ^I 显示出来；-v ：列出一些看不出来的特殊字符 nl指令添加行号打印,默认不打印空行行号.“其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能呢。 123456789101112nl [选项]... [文件]...-b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种： -n ln ：行号在萤幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ；-w ：行号栏位的占用的位数。(与-n ln 或 -n rz配合使用)-p 在逻辑定界符处不重新开始计算。$ nl -n ln -w 3 test.txt 可翻页检视 more / less两者区别在于前者不能向前翻页(管线操作),后者可以向前翻页并支持更多其它操作 数据撷取- head 撷取前面几行 - tail 取出后几行,默认10行 ***注意:当用-f |grep 选项时,默认会有缓存区不能及时显示可加--line-buffered*** 123例题：假如我想要显示 /etc/man_db.conf 的第 11 到第 20 行呢？head -n 20 /etc/man_db.conf | tail -n 10 非纯文本文件 od12345678选项或参数：-t ：后面可以接各种“类型 （TYPE）”的输出，例如： a ：利用默认的字符来输出； c ：使用 ASCII 字符来输出 d[size] ：利用十进制（decimal）来输出数据，每个整数占用 size Bytes ； f[size] ：利用浮点数值（floating）来输出数据，每个数占用 size Bytes ； o[size] ：利用八进位（octal）来输出数据，每个整数占用 size Bytes ； x[size] ：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes ； 如果对纯文本文件使用这个指令，你甚至可以发现到 ASCII 与字符的对照表！例题：想要立刻找到 password 这几个字的 ASCII 对照，该如何通过 od 来判断？答：echo password | od -t oCc 文件时间 modification time （mtime）：当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！ status time （ctime）：当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。 access time （atime）：当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。 修改文件时间 touch命令123456选项与参数：-a ：仅修订 access time；-c ：仅修改文件的时间，若该文件不存在则不创建新文件；-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;-m ：仅修改 mtime ；-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]. 该命令也可用来新建文件 file命令查看某个文件的基本数据类型,如:ASCII/data文件/binary文件等等信息,也可用来判断tar包文件是用哪种压缩功能打包的. ##文件与文件夹权限在Linux传统的Ext2/Ext3/Ext4文件系统下，我们还可以设置其他的系统隐藏属性， 这部份可使用 chattr 来设置，而以 lsattr 来查看，最重要的属性就是可以设置其不可修改的特性！让连文件的拥有者都不能进行修改！ 这个属性可是相当重要的，尤其是在安全机制上面 （security）！比较可惜的是，在 CentOS 7.x 当中利用 xfs 作为默认文件系统， 但是 xfs 就没有支持所有的 chattr 的参数了！仅有部份参数还有支持而已！ 文件默认权限 umaskumask 的分数指的是“该默认值需要减掉的权限！ 若使用者创建为“文件”则默认“没有可执行（ x ）权限”，亦即只有 rw 这两个项目，也就是最大为 666 分，默认权限如下：-rw-rw-rw- 若使用者创建为“目录”，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为 777 分，默认权限如下：drwxrwxrwx 12345[root@study ~]# umask0022 &lt;==与一般权限有关的是后面三个数字！[root@study ~]# umask -Su=rwx,g=rx,o=rx [root@study ~]# umask 022 &lt;==设置默认权限 文件隐藏属性 chattrchattr指令只能在Ext2/Ext3/Ext4的 Linux 传统文件系统上面完整生效， 其他的文件系统可能就无法完整的支持这个指令了，例如 xfs 仅支持部份参数而已 1234567891011121314151617181920[root@study ~]# chattr [+-=][ASacdistu] 文件或目录名称选项与参数：+ ：增加某一个特殊参数，其他原本存在参数则不动。- ：移除某一个特殊参数，其他原本存在参数则不动。= ：设置一定，且仅有后面接的参数A ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改， 可避免 I/O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）S ：一般文件是非同步写入磁盘的（原理请参考前一章sync的说明），如果加上 S 这个属性时，当你进行任何文件的修改，该更动会“同步”写入磁盘中。a ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性c ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩， 但是在储存的时候，将会先进行压缩后再储存（看来对于大文件似乎蛮有用的！）d ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份i ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！ 对于系统安全性有相当大的助益！只有 root 能设置此属性s ：当文件设置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间， 所以如果误删了，完全无法救回来了喔！u ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中， 可以使用来救援该文件喔！注意1：属性设置常见的是 a 与 i 的设置值，而且很多设置值必须要身为 root 才能设置注意2：xfs 文件系统仅支持 AadiS 而已 显示文件隐藏属性 lsattr12345678root@study ~]# lsattr [-adR] 文件或目录选项与参数：“-a ：将隐藏文件的属性也秀出来；-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；-R ：连同子目录的数据也一并列出来！ [root@study tmp]# chattr +aiS attrtest[root@study tmp]# lsattr attrtest--S-ia---------- attrtest 文件特殊权限Set UID -&gt; SUID权限12[root@study ~]# ls -l /usr/bin/passwd-rwsr-xr-x. 1 root root 27832 Jun 10 2014 /usr/bin/ 注意:上面passwd指令,一般账号没有写入权限,为什么一般账号还能修改密码呢?这就是USID的功能了（注意拥有者的“s”）:1、dmtsai 对于 /usr/bin/passwd 这个程序来说是具有 x 权限的，表示 dmtsai 能执行 passwd；2、passwd 的拥有者是 root 这个帐号；3、dmtsai 执行 passwd 的过程中，会“暂时”获得 root 的权限；4、/etc/shadow 就可以被 dmtsai 所执行的 passwd 所修改。如果一般用户用cat去读取/etc/shadow时,会提示权限不够,因为cat指令没有SUID权限。另外SUID只对二进制程序有用,不能用于shell脚本。 Set GID -&gt; SGID权限与SUID类似，当s标志在文件群组的x位置时，则称为SGID 123[root@study ~]# ll /usr/bin/locate /var/lib/mlocate/mlocate.db-rwx--s--x. 1 root slocate 40496 Jun 10 2014 /usr/bin/locate-rw-r-----. 1 root slocate 2349055 Jun 15 03:44 /var/lib/mlocate/mlocate.db 使用 dmtsai 这个帐号去执行 locate 时，那 dmtsai 将会取得 slocate 群组的支持， 因此就能够去读取 mlocate.db 啦 除了 binary program 之外，事实上 SGID 也能够用在目录上，这也是非常常见的一种用途！ 当一个目录设置了 SGID 的权限后，他将具有如下的功能： 使用者若对于此目录具有 r 与 x 的权限时，该使用者能够进入此目录； 使用者在此目录下的有效群组（effective group）将会变成该目录的群组； 用途：若使用者在此目录下具有 w 的权限（可以新建文件），则使用者所创建的新文件，该新文件的群组与此目录的群组相同。 Sticky Bit -&gt; SBIT权限*目前这个权限仅针对目录有效，对于文件已经没有效果了。在others上的t标识 当使用者对于此目录具有 w, x 权限，亦即具有写入的权限时； 当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件如:/tmp 本身的权限是“drwxrwxrwt”， 在这样的权限内容下，任何人都可以在 /tmp 内新增、修改文件，但仅有该文件/目录创建者与 root 能够删除自己的目录或文件。 SUID/SGID/SBIT 权限设置SUID : 4 SGID : 2 SBIT : 1在数字权限前面加上一个数字就表示几个特殊权限了. 假设要将一个文件权限改为“-rwsr-xr-x”时，由于 s 在使用者权限中，所以是 SUID ，因此， 在原先的 755 之前还要加上 4 ，也就是：“ chmod 4755 filename ”来设置！此外，还有大 S 与大 T 的产生喔！参考下面的范例啦！ 12[root@study tmp]# chmod 7666 test; ls -l test &lt;==具有空的 SUID/SGID 权限-rwSrwSrwT 1 root root 0 Jun 16 02:53 test 注意:上面大写SST,因为特殊权限要求必须有执行权限(上面是666),所以权限不能启作用为空权限 除了数字方法外,也可以通过符号来处理.其中 SUID 为 u+s ，而 SGID 为 g+s ，SBIT 则是 o+t 1234567 #设置权限成为 -rws--x--x 的模样：[root@study tmp]# chmod u=rwxs,go=x test; ls -l test-rws--x--x 1 root root 0 Jun 16 02:53 test #承上，加上 SGID 与 SBIT 在上述的文件权限中！[root@study tmp]# chmod g+s,o+t test; ls -l test-rws--s--t 1 root root 0 Jun 16 02:53 test 指令与文件的搜寻指令文件名搜寻which (寻找”可执行文件”)默认查找PATH内所规范的目录第一个被找到的执行文件 123456选项参数:-a 将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称 root@study ~]# which history/usr/bin/which: no history in （/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin） 因为history是bash内置命令所以不能用which查找，可以通过type命令查看。^[详见bash章节] 文件文件名搜寻whereis (由一些特定的目录中寻找文件文件名)1234567[root@study ~]# whereis [-bmsu] 文件或目录名选项与参数：-l :可以列出 whereis 会去查询的几个主要目录而已-b :只找 binary 格式的文件-m :只找在说明文档 manual 路径下的文件-s :只找 source 来源文件-u :搜寻不在上述三个项目当中的其他特殊文件 locate / updatedblocate寻找的数据是由/var/lib/mlocate里面的数据搜索到的,所以不用搜索硬盘,速度快。但由于数据库默认每天创建一次，所以新建的文件可能搜索不到，或者已删除文件还能搜索到 1234567[root@study ~]# locate [-ir] keyword选项与参数：-i ：忽略大小写的差异；-c ：不输出文件名，仅计算找到的文件数量-l ：仅输出几行的意思，例如输出五行则是 -l 5-S ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等-r ：后面可接正则表达式的显示方式 想要实时搜索就要手动更新数据库：updatedbupdatedb：根据 /etc/updatedb.conf 的设置去搜寻系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件； locate：依据 /var/lib/mlocate 内的数据库记载，找出使用者输入的关键字文件名。*因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！ find12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@study ~]# find [PATH] [option] [action]选项与参数：1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明 -mtime n ：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件； -mtime +n ：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名； -mtime -n ：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。 -newer file ：file 为一个存在的文件，列出比 file 还要新的文件文件名 2. 与使用者或群组名称有关的参数： -uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在/etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。 -gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在/etc/group -user name ：name 为使用者帐号名称喔！例如 dmtsai -group name：name 为群组名称喔，例如 users ； -nouser ：寻找文件的拥有者不存在 /etc/passwd 的人！ -nogroup ：寻找文件的拥有群组不存在于 /etc/group 的文件！ 当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者， 这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。3. 与文件权限及名称有关的参数： -name filename ：搜寻文件名称为 filename 的文件； -size [+-]SIZE ：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有： c: 代表 Byte， k: 代表 1024Bytes。 所以，要找比50KB还要大的文件，就是“ -size +50k” -type TYPE ：搜寻文件的类型为 TYPE 的， 类型主要有： 一般正规文件（f）, 设备文件（b, c）, 目录（d）, 链接文件（l）, socket（s）, 及 FIFO（p） 等属性。 -perm mode ：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！ -perm -mode ：搜寻文件权限“必须要全部囊括 mode 的权“限”的文件。 -perm /mode : 任何权限位 mode 被设置了的文件。举例：[root@study ~]# find / -perm +7000 *所谓的 7000 就是 ---s--s--t ，那么只要含有 s 或 t 的就列出，所以当然要使用 /7000，*使用 -7000 表示要同时含有 ---s--s--t 的所有三个权限。而只需要任意一个，就是 /7000 ～瞭乎？(旧版是：-perm +7000已经被/7000替换)4. 额外可进行的动作：-exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。-print ：将结果打印到屏幕上，这个动作是默认动作！[root@study ~]# find / -name &quot;passwd&quot; -exec ls -l &#123;&#125; \; -exec 后面不支持别名所以上面使用 ls -l{} 代表的是“由find找到的内容”由于find命令是硬盘搜索，所以速度会相对很慢]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件目录权限]]></title>
    <url>%2F2017%2F09%2F12%2FLinux%2F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[[TOC] 文件属性 第一栏代表文件类型与权限 列表第一个字符意义:当为[ d ]则是目录，例如上表文件名为“.config”的那一行；当为[ - ]则是文件，例如上表第三行；若是[ l ]则表示为链接文件（link file）；若是[ b ]则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；若是[ c ]则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。 第二栏表示有多少文件名链接到此节点上 第三栏表示这个文件“拥有者账号” 第四栏表示这个文件所属群组 第五栏表示这个文件大小，默认单位Bytes 第六栏表示文件的创建日期或修改日期 第七栏为文件名 改变文件属性与权限 改变文件群组 chgrp [-R] 群组名 文件或目录 改变文件拥有者 chown [-R] 账号名:群组名 文件或目录 改变权限数字类型改变文件权限 r:4 w:2 o:1chmod [-R] 权限和 文件/文件夹 符号类型改变文件权限 user:u group:g others:o all:a+加入权限 -去除权限 =设置权限写法:chmod [-R] u=rwx,g=rw,o=rw 文件/文件夹 Linux目录配置 HFS要求必须存在的目录 /bin 放置的是单人维护模式下还能够被操作的命令。主要有：cat、chmod、chown、date、mv、mkdir、cp、bash等常用指令。 /boot 此目录主要放置在开机会使用的文件,包括Linux核心文件以及开机菜单与开机所需要的配置文件等等。 /dev Linux上,任何设置与周边设置都以文件形态存在于这个目录。通过读取这个目录下的文件，就等于存取这个设备。比较重要的文件有：/dev/null,/dev/zero,/dev/tty等等。 /etc 系统主要配置文件几乎都放在这个目录内,例如人员账号密码档、各种服务启动档等等。一般来说这个目录文件可以让一般用户查阅，但是只有root用户可以修改。FHS建议不要放置可可执行文件(binary)在这个目录中。 比较重要的文件有：/etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue /etc/opt(必要) 这个目录放置第三方软件/opt的相关配置文件。 /lib 放置的是开机时会用到的函数库,以及在/bin或/sbin下指令会调用的函数库. /lib/modules (必要) 这个目录放置可抽换式的核心模块(驱动程序) /media 放置可移除设置。包括：软盘、光盘、DVD等等设置都暂时挂载于此。常见的文件名有：/media/floppy, /media/cdrom等等。 /mnt 如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。 /opt 第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的distribution提供的），那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ /run 早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！ /sbin 放在/sbin下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。 /srv srv可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。 /tmp 这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！ /usr 第二层FHS设置,见后续… /var 第二层FHS设置,见后续… HFS要求可以存在的目录 /home 这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来 ~：代表目前这个使用者的主文件夹~dmtsai ：则代表 dmtsai 的主文件夹！ /lib\ 用来存放与 /lib 不同的格式的二进制函数库，例如支持 64 位的 /lib64 函数库等 /root 系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中。 事实上FHS针对根目录定义的标准仅有上面这些,不过Linux还有许多目录需要了解一下.下面几个目录也非常重要: /lost+found 这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！ /proc 这个目录本身是一个虚拟目录.它放置 的数据都是在内存中.例如系统核心、行程信息、周边设备状态以及网络状态等等。因为这个目录数据都在内存当中，所以本身不占任何磁盘空间。比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。 /sys 这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！ /usr目录 /usr 目录是Unix Software Resource的缩写， 也就是“Unix操作系统软件资源”所放置的目录，而不是使用者的数据啦！这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。 FHS要求必须存在的目录 /usr/bin 所有一般用户使用的指令都放在这里! 目前CentOS7已经将全部指令放置于此,而使用链接文件的方式将 /bin 链接至此! 也就是说 /bin 与 /usr/bin 是一模一样了! 另外,FHS要求在此目录下不应该有子目录! /usr/lib 基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！ /usr/local 系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)建议安装到此目录,这样会比较方便管理. 举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！ /usr/sbin 非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon）啰！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的。 /usr/share 主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文字文件嘛！ 常见的还有这些次目录：/usr/share/man 线上说明文档/usr/share/doc 软件杂项文件说明/usr/share/zoneinfo 与时区有关的时区文件 FHS建议可以存在的目录 /usr/games 与游戏比较相关的数据放置处 /usr/include c/c++等程序语言的文件开始（header）与包含档（include）放置处，当我们以tarball方式 （*.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！ /usr/libexec 某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。 **/usr/lib\ 与 /lib\/功能相同，因此目前 /lib 就是链接到此目录中 /usr/src 一般源代码建议放在这里, src有source的意思. 至于核心源代码建议放到 /usr/src/linux 目录下./var目录 如果 /usr 是安装时会占用较大硬盘容量的目录，那么 /var 就是在系统运行后才会渐渐占用硬盘容量的目录。 因为 /var 目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如MySQL数据库的文件等等 FHS要求必须存在的目录 /var/cache 应用程序运行中会产生的一些暂存盘 /var/lib 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！ /var/lock 某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 /run/lock 中 /var/log 重要到不行！这是登录文件放置的目录！里面比较重要的文件如 /var/log/messages , /var/log/wtmp（记录登陆者的信息）等。 /var/mail 放置个人电子邮件信箱的目录，不过这个目录也被放置到 /var/spool/mail/ 目录中！ 通常这两个目录是互为链接文件啦！ /var/run 某些程序或者服务启动后, 会将它们的PID放置在这个目录下! 与 /run 相同，这个目录链接到 /run 去了！ /var/spool 这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到/var/spool/cron/目录中！ CentOS观察 uname 1234[dmtsai@study ~]$ uname -r # 查看核心版本3.10.0-229.el7.x86_64[dmtsai@study ~]$ uname -m # 查看操作系统的位版本x86_64 lsb_release指令已经不是默认安装软件了.使用前需要安装 1234567[root@study ~]# dnf install redhat-lsb[root@study ~]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.3.1611 (Core)Release: 7.3.1611Codename: Core /etc/* 1234[root@study ~]# cat /etc/issueCentOS release 5.5 (Final)Kernel r on an m[root@study ~]# cat /etc/redhat-release]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开关机]]></title>
    <url>%2F2017%2F09%2F11%2FLinux%2F%E5%BC%80%E5%85%B3%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[[TOC] 重要热键 Tab 自动补全Ctrl+C 中断目前程序Ctrl+d 键盘输入结束Shift+Page [Up][Down] 上下翻页[Ctrl] + [Alt] + [F1]~[F6]的组合按钮 终端切换 开关机 shutdown [-krhc] [时间] [警告讯息] 关机命令 -k ： 不要真的关机，只是发送警告讯息出去！-r ： 在将系统的服务停掉之后就重新开机（常用）-h ： 将系统的服务停掉后，立即关机。 （常用）-c ： 取消已经在进行的 shutdown 指令内容。时间 ： 指定系统关机的时间！时间的范例下面会说明。若没有这个项目，则默认 1 分钟后自动进行。 reboot 重新开机命令 sync;reboot实际开关机命令默认都会执行sync命令,但为了保险起见还是手动执行一下此命令。 实际使用关机管理工具systemctl [指令] 上面提到的开关机命令实际都是调用此命令执行开关机 halt 进入系统停止的模式，屏幕可能会保留一些讯息，这与你的电源管理模式有关poweroff 进入系统关机模式，直接关机没有提供电力喔！reboot 直接重新开机suspend 进入休眠模式[root@study ~]# systemctl reboot # 系统重新开机[root@study ~]# systemctl poweroff # 系统关机]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Linux学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记——深入React组件(v15.5)]]></title>
    <url>%2F2017%2F05%2F04%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5React%E7%BB%84%E4%BB%B6(v15.5)%2F</url>
    <content type="text"><![CDATA[[TOC] 组件让UI独立，可重复利用，并且单独解决每块问题。React.Component是由React提供的。 React.Component是一个抽象的基类，因此它很少的被直接使用。反而，你会用一个有代表性的子类，并且至少定义一个render()方法。 使用JavaScript定义一个简单的类组件： 12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 如果你没有使用ES6，你需要使用react-create-class模块创建。可以参考React中不使用ES6。 组件生命周期每个组件都有几个生命周期，你可重写它们并在特定时间，它们会被执行。前缀是will的方法会在行为发生前被调用;前缀为did的方法会在行为发生后被调用。 Mounting当一个组件实例被创建并且插入到DOM时，这些方法被调用： constructor()componentWillMount()render()componentDidMount() Updating可能由props或state引发的更新。当组件被重新渲染时，这些方法被调用： componentWillReceiveProps()shouldComponentUpdate()componentWillUpdate()render()componentDidUpdate() Unmounting当组件被移出DOM时，这个方法被调用： componentWillUnmount() 其它API每个组件也提供一些其它API。 setState()forceUpdate() 类属性 defaultPropsdisplayName 实例属性 propsstate 方法使用说明render()这个方法是必须存在的方法。 当被调用时，它会检查props和state，并且返回单一的React元素。这个元素可以是一个本地DOM组件，如\，也可以是一个自定义的合成组件。 你也可以返回null或者false，表示你不想要任何渲染。当返回的是null或者false时，ReactDOM.findDOMNode(this)返回的是null。 这个方法是纯粹的，也就是说它不能更新state，每次调用返回相同的结果，并且它不直接与浏览器交互。 注意：如果shouldComponentUpdate()方法返回false，render()不会被调用。 constructor()构造函数是初始化state的正确位置。如果你不需要初始化state并且也不绑定方法，那就不需要实现构造函数。 123456constructor(props) &#123; super(props); this.state = &#123; color: props.initialColor &#125;;&#125; componentWillUpdate()这个方法在mounting发生前调用，并且在render()方法之前调用。因此，在这个方法设置state同步，不会触发重新渲染。避免了任副作用和订阅。 这仅仅是 服务器渲染时调用的生命周期的钩子。一般推荐使用constructor()代替。 componentDidMount()这个方法mounting发生后调用。在这个方法设置state会触发重新渲染。可以在这里初始化必要的DOM，如果需要加载远程数据，这里是发起请求的好地方。 componentWillReceiveProps()这个方法在一个已加载的组件接收新prop前调用。在这个方法里可以使用setState()比较this.props和nextProps。 注意：即使props没有改变，React也可能调用这个方法。因此，请确保比较当前值和即将改变的值。 在mounting期间初始化props，React不会调用这个方法。它只在组件props被更新时调用。调用setState()通常不会触发此方法。 shouldComponentUpdate()此方法默认行为是，当state改变时组件重新渲染。 当props或state 被接收到时，这个方法将在render()之前调用。当初始化渲染和使用forceUpdate()方法时，此方法不被调用。 此方法返回false时，并不能阻止子组件由于state改变后重新渲染。 目前，此方法返回false时componentWillUpdate()、render() 和 componentDidUpdate()方法不会被调用。注意，这在将来可能只是一个提示，而不是严格的指令，也就是说即使该方法返回false，仍然会重新渲染组件。 componentWillUpdate()此方法被调用在prop和state被接收后组件渲染前，组件初始化渲染不调用此方法。 注意： 1、你不能在这个方法中调用this.setState()，如果你想在props变化后更新state请使用componentWillReceiveProps()代替。 2、如果shouldComponentUpdate()方法返回false，此方法不会被调用。 componentDidUpdate()这个方法在updating发生后立即调用，并且在组件初始化渲染时也不调用。 在组件更新后，在这个方法中操作DOM是个很好的机会。这也是一个做网络请求的好地方。 注意：如果shouldComponentUpdate()方法返回false，此方法不会被调用。 componentWillUnmount()此方法会在组件被卸载和销毁之前立即调用。在这个方法可以执行必要的清理工作。如：无效的定时器、取消网络请求或者清理componentDidMount()创建的DOM元素。 forceUpdate()默认情况下，当组件的state或props改变时就会重新渲染。如果你的render()方法需要依赖一此其它数据，你可以通过调用forceUpdate()方法告诉React组件需要重新渲染。 调用forceUpdate()，会引起render()直接调用，而跳过shouldComponentUpdate()。但是它会正常触发每一个子组件的生命周期方法。 通常应该避免使用此方法。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
        <tag>HTML</tag>
        <tag>React学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记——引用和DOM(v15.5)]]></title>
    <url>%2F2017%2F05%2F03%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%95%E7%94%A8%E5%92%8CDOM(v15.5)%2F</url>
    <content type="text"><![CDATA[[TOC] 在典型的React数据流中，props是父组件与子组件交互的唯一方式。想要修改子组件的，你需要重新渲染父组件的props。然而，有一些种情况是你需要在典型数据流的外面立即修改子组件。要修改的子组件可以是React组件的实例或者是一个DOM元素。对于这两种情况，React 提供了一个解决方案。 何时使用Refs 1、管理焦点、选中或者是媒体重放。2、触发命令动画。3、与第三方DOM库集成。 避免在可声明的事物上使用refs。例如：不在Dialog组件上暴露open()和close()方法，而是传递一个isOpen属性。 在DOM元素上添加一个refReact支持在任何组件上添加一个特殊的属性。ref属性接收一个回调函数，并且这个函数在组件mounted和unmounted时会立即执行。 当ref属性被用在一个HTML元素上时，ref回调函数接收的是基础的DOM元素作为它的参数。 12345678910111213141516171819202122232425262728class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.focus = this.focus.bind(this); &#125; focus() &#123; // 明确文本框使用的原始DOM API focus this.textInput.focus(); &#125; render() &#123; // ref回调函数存储文本框DOM // element in an instance field (for example, this.textInput). return ( &lt;div&gt; &lt;input type="text" ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.focus&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 当组件mounts时，React会调用ref回调函数，并向其传入DOM元素;当组件unmounts时，React调用ref回调函数，并向其传入null。 使用ref回调函数为类设置一个属性，访问DOM元素是一种常见的方式。首先的方法就是向上面一样在ref回调函数中设置一个属性。有一个更简单的写法是：ref={input =&gt; this.textInput = input} 在类的组件上添加一个ref当ref属性被添加到一个以类方式定义的组件上时，它的回调函数接收的是已mount组件的实例作为实例。例如：想要模拟组件在mount后直接被点击： 123456789101112class AutoFocusTextInput extends React.Component &#123; componentDidMount() &#123; this.textInput.focus(); &#125; render() &#123; return ( &lt;CustomTextInput ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; ); &#125;&#125; 注意：只有组件以类的方式定义才有效。 Refs和函数式组件不能在函数式组件上使用ref属性，因为函数式组件没有实例 12345678910111213function MyFunctionalComponent() &#123; return &lt;input /&gt;;&#125;class Parent extends React.Component &#123; render() &#123; // This will *not* work! return ( &lt;MyFunctionalComponent ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; ); &#125;&#125; 如果你需要使用它，你应该将组件转换为类，就像你需要使用生命周期或者状态时候一样。 但是，你可以在函数式组件内部使用ref属性，只要是DOM元素或类组件上就可以。 123456789101112131415161718192021function CustomTextInput(props) &#123; // textInput must be declared here so the ref callback can refer to it let textInput = null; function handleClick() &#123; textInput.focus(); &#125; return ( &lt;div&gt; &lt;input type="text" ref=&#123;(input) =&gt; &#123; textInput = input; &#125;&#125; /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; ); &#125; 暴露DOM Refs到父组件在极少的情况下，你可能想要在一个父组件中接收子组件的DOM节点。这种做法通常是不推荐的，但是对于触发焦点和测试DOM的大小或位置，它偶尔也是有用的。 虽然，可以在子组件上添加一个ref属性，但这不理想的解决方案，你只会得到一个组件的实例，而不是组件的DOM节点。此外，这也不会在函数式组件上工作。 相反，在这种情况下，我们希望暴露一个特殊的prop在子组件上。子组件接收一个任意名字的函数作为prop，并且在一DOM节点上加上一个ref属性。这让父组件通过中间件传递ref回调函数到子组件的DOM节点上。 它在类组件和函数式组件上都可以工作。 1234567891011121314151617function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; render() &#123; return ( &lt;CustomTextInput inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 在上面的例子中，结果this.inputElement在Parent组件中被设置为CustomTextInput组件input元素相应的DOM节点。 这种模式的好处是，它可以纵向深入使用。例如：Parent组件不需要DOM节点，但是另一个组件渲染Parent组件的需要DOM节点（我们叫它GrandParent），我们可以在GrandParent组件中传递inputRef到Parent组件，并且让Parent组件向下传递它到CustomTextInput组件。 1234567891011121314151617181920212223242526function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;function Parent(props) &#123; return ( &lt;div&gt; My input: &lt;CustomTextInput inputRef=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Grandparent extends React.Component &#123; render() &#123; return ( &lt;Parent inputRef=&#123;el =&gt; this.inputElement = el&#125; /&gt; ); &#125;&#125; 注意，如果此种方法需要在子组件中添加代码，如果你对子组件没有绝对的控制权，那么你只能使用findDOMNode()，但是它是不被鼓励使用的。 不要过渡使用Refs你可能倾向使用ref来解决问题应用中的问题，如果是这种情况，请花费一些时间考虑一下，状态应该在组件的层次结构什么位置。通常，拥有该状态的适当位置应该是更高层级的组件上。参考状态提升示例。 旧版API：字符串Refs如果你之前使用过React，你可能会熟悉一个较旧的API,其中ref属性是一个字符串，如像”textInput”,DOM节点被这样访问this.refs.textInput。我们建议不这样使用。因为字符串引用有一些被认为是遗留的问题，并且可能在未来的一个版本中被删除。如果你目前正在使用this.refs.textInput访问refs,我们建议你使用回调模式。 注意 如果ref回调被定义为内联函数，它将在更新期间被调用两次，第一次调用传入null,第二次调用传入DOM 元素。这是因为函数的新实例是通过每次渲染创建的，因此React需要清除旧的引用并设置新的引用。你可以通过将ref回调定义为类上的绑定方法来避免这种情况，但请注意，在大多数情况下它不重要。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
        <tag>HTML</tag>
        <tag>React学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记——使用PropTypes类型检查(v15.5)]]></title>
    <url>%2F2017%2F05%2F03%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8PropTypes%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5(v15.5)%2F</url>
    <content type="text"><![CDATA[[TOC] React v15.5中React.PropTypes已经被废弃了，建议使用prop-types库代替。 随着应用的增长，可能遇到越来越多的类型检查方面的bug，对于一些应用，你可以使用JavaScript的扩展如：flow、typescript来检查你整个应用。但是，对于React来说，即使你不使用这些，其也内置了一些类型检查能力。要使用类型检查作用于组件，你可以指定一个特殊的属性proptypes： 12345678910111213import PropTypes from 'prop-types';class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;Greeting.propTypes = &#123; name: PropTypes.string&#125;; 下面是React对不同类型检查的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // You can declare that a prop is a specific JS primitive. By default, these // are all optional. optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // Anything that can be rendered: numbers, strings, elements or an array // (or fragment) containing these types. optionalNode: PropTypes.node, // A React element. optionalElement: PropTypes.element, // You can also declare that a prop is an instance of a class. This uses // JS's instanceof operator. optionalMessage: PropTypes.instanceOf(Message), // You can ensure that your prop is limited to specific values by treating // it as an enum. optionalEnum: PropTypes.oneOf(['News', 'Photos']), // An object that could be one of many types optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // An array of a certain type optionalArrayOf: PropTypes.arrayOf(PropTypes.number), // An object with property values of a certain type optionalObjectOf: PropTypes.objectOf(PropTypes.number), // An object taking on a particular shape optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // You can chain any of the above with `isRequired` to make sure a warning // is shown if the prop isn't provided. requiredFunc: PropTypes.func.isRequired, // A value of any data type requiredAny: PropTypes.any.isRequired, // You can also specify a custom validator. It should return an Error // object if the validation fails. Don't `console.warn` or throw, as this // won't work inside `oneOfType`. customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // You can also supply a custom validator to `arrayOf` and `objectOf`. // It should return an Error object if the validation fails. The validator // will be called for each key in the array or object. The first two // arguments of the validator are the array or object itself, and the // current item's key. customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;; 需要一个子元素 使用Proptypes.element，你可以指定只有一个子元素可以被传入组件中。 1234567891011121314151617import PropTypes from 'prop-types';class MyComponent extends React.Component &#123; render() &#123; // This must be exactly one element or it will warn. const children = this.props.children; return ( &lt;div&gt; &#123;children&#125; &lt;/div&gt; ); &#125;&#125;MyComponent.propTypes = &#123; children: PropTypes.element.isRequired&#125;; prop默认值你可以通过指定一个特殊的属性defaultProps，来设定prop的默认值。 123456789101112131415161718class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// Specifies the default values for props:Greeting.defaultProps = &#123; name: 'Stranger'&#125;;// Renders "Hello, Stranger":ReactDOM.render( &lt;Greeting /&gt;, document.getElementById('example'));]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
        <tag>HTML</tag>
        <tag>React学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记——深入理解JSX(v15.5)]]></title>
    <url>%2F2017%2F05%2F02%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSX(v15.5)%2F</url>
    <content type="text"><![CDATA[[TOC] 从根本上讲，React语法仅仅是React.createElement(component, props, …children)方法的语法糖。 12345678910111213141516171819202122//JSX代码&lt;MyButton color="blue" shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt;//编译后：React.createElement( MyButton, &#123;color: 'blue', shadowSize: 2&#125;, 'Click Me')如果标签没有子元素，可以使用闭口标签。//JSX代码&lt;div className="sidebar" /&gt;//编译后React.createElement( 'div', &#123;className: 'sidebar'&#125;, null) 指定React元素类型react必须在作用域里由于JSX编译后调用的是React.createElement方法，因此React库必须始终在JSX代码作用域中。 1234567import React from 'react';import CustomButton from './CustomButton';function WarningButton() &#123; // return React.createElement(CustomButton, &#123;color: 'red'&#125;, null); return &lt;CustomButton color="red" /&gt;;&#125; 如果不使用JavaScript打包工具并且已经使用\标签引入React。它就已经在全局作用域中了。 JSX类型使用点表达式你也可以在JSX中使用点表达式引用组件。如果有一个模块导出很多组件的时候，这是很方便的。例如：MyComponents.DatePicker是一个组件，你可以直接在JSX中使用它： 1234567891011import React from 'react';const MyComponents = &#123; DatePicker: function DatePicker(props) &#123; return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;; &#125;&#125;function BlueDatePicker() &#123; return &lt;MyComponents.DatePicker color="blue" /&gt;;&#125; 用户定义组件必须大写当一个元素以小写字母开始，它指的就是一个内建组件，如：\或者\，结果就会将’div’或’span’被传入React.createElement方法。而大写字母开始的组件如会编译成React.createElement(Foo)，并且它符合一个组件的定义。 我们推荐使用大写字母定义一个组件。如果你有一个组件是使用小写字母开始，在JSX中使用它前把它赋值给一个大写变量。 例如，下面代码不会如期运行： 1234567891011121314151617181920212223242526import React from 'react';// 错误！这是一个组件应该产首字母大写function hello(props) &#123; // 正确! 这使用的是&lt;div&gt;标签，因为它是一个有效的HTML标签 return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // 错误! Reac认为 &lt;hello /&gt; 是一个HTML标签，因为它首字母是小写 return &lt;hello toWhat="World" /&gt;;&#125;修复这些问题，重命名hello为Hello，并且在涉及到它的地方使用&lt;Hello/&gt;：import React from 'react';// Correct! This is a component and should be capitalized:function Hello(props) &#123; // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag: return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // Correct! React knows &lt;Hello /&gt; is a component because it's capitalized. return &lt;Hello toWhat="World" /&gt;;&#125; 运行时选择类型你不能使用普通表达式作为React元素的类型。如果你想使用普通表达式表明元素的类型，首先将其赋值给一个大写变量。这种情况经常出现在你想依据prop渲染不同组件的时候。 123456789101112131415161718192021222324252627import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // 错误! JSX 类型不能使用表达式 return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;&#125;修复这个，首先将其赋值给一个大写变量：import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // 正确! JSX 类型可以使用一个大写变量代替. const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125; JSX的PropsJavaScript表达式作为 Props你可以通过{}传递任何表达式作为prop。例如： 1&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt; if表达式和for循环在JavaScript中不是表达式，因此不能直接在JSX中使用。你可以把它们放在周围代码中： 123456789function NumberDescriber(props) &#123; let description; if (props.number % 2 == 0) &#123; description = &lt;strong&gt;even&lt;/strong&gt;; &#125; else &#123; description = &lt;i&gt;odd&lt;/i&gt;; &#125; return &lt;div&gt;&#123;props.number&#125; is an &#123;description&#125; number&lt;/div&gt;;&#125; 字符串你可以传递一个字符串作为prop。这两个JSX表达式是等价的： 123&lt;MyComponent message="hello world" /&gt;&lt;MyComponent message=&#123;'hello world'&#125; /&gt; 当你传递一个字符串时，它的值是未转义的HTML。这两个表达式是等价的： 123&lt;MyComponent message="&amp;lt;3" /&gt;&lt;MyComponent message=&#123;'&lt;3'&#125; /&gt; Props默认值true如果你传递一个没有值的prop，它默认传递的是true。这两个表达式是等价的： 123&lt;MyTextBox autocomplete /&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; 一般来说，不建议使用默认值，因为ES6的语法中对象简写{foo}等价于{foo:foo}而不是{foo:true}，所以这样写容易混淆。只有这个行为和HTML行相同的时候才能这么使用。 扩展属性如果你已经有一个props的对象，并且希望这个props传递给JSX中。可以使用…作为扩展运算符传递整个props对象。下面两个组件是相等的： 12345678function App1() &#123; return &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;&#125;function App2() &#123; const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;; return &lt;Greeting &#123;...props&#125; /&gt;;&#125; 当你创建通用的容器时，扩展属性是很有用的。然而，它也能使你的代码产品混乱，它很容易使组件产生很多无关紧要的props。我们建议很少使用这个语法。 JSX子元素在JSX表达式中包含一个开始标签和一个结束标签，标签中内容通过一个特殊的prop：props.children传递。有几种不同方法传递子元素 字符串你可以在开始和结束标签之间放一字符串，这样props.children的值就是一个字符串。这对于很多内置的HTML元素来说是很有用的： 1&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt; JSX子元素你可以提供更多的JSX元素作为子元素，这对于显示嵌套组件是很有用的： 1234&lt;MyContainer&gt; &lt;MyFirstComponent /&gt; &lt;MySecondComponent /&gt;&lt;/MyContainer&gt; 你可以混合不同类型的子元素，因此你可以使用字符串在JSX子元素中，这是另一种方式的JSX，看起来就像HTML，所以这既是有效的JSX，也是有效的HTML： 1234567&lt;div&gt; Here is a list: &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 一个React组件不能同时返回多个React元素，但是一个JSX表达式可以有多个子元素。因此，如果你想要一个组件呈现多个事情的时候，你可以像上面一样将它包裹在一个div里。 JavaScript表达式作为子元素你可以通过{}传递任何JavaScript表达式作为子元素。例如：这些表达式是相等的： 123&lt;MyComponent&gt;foo&lt;/MyComponent&gt;&lt;MyComponent&gt;&#123;'foo'&#125;&lt;/MyComponent&gt; 这对于渲染任意长度的JSX表达式列表是很有用的。 123456789101112function Item(props) &#123; return &lt;li&gt;&#123;props.message&#125;&lt;/li&gt;;&#125;function TodoList() &#123; const todos = ['finish doc', 'submit pr', 'nag dan to review']; return ( &lt;ul&gt; &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125; &lt;/ul&gt; );&#125; JavaScript表达式可以和其它类型混合成子元素。这在字符串模板里是很有用的。 123function Hello(props) &#123; return &lt;div&gt;Hello &#123;props.addressee&#125;!&lt;/div&gt;;&#125; 函数作为子元素通常，JavaScript表达式插入到JSX中得到一个字符串，一个React元素或者是那些东西的列表。然而，props.children就像其它prop一样可以传递任何类型的数据，不仅仅是React知道如何渲染的类型。例如，如果你有一个自定义组件，你可以让它带一个回调函数作为props.children： 12345678910111213141516// Calls the children callback numTimes to produce a repeated componentfunction Repeat(props) &#123; let items = []; for (let i = 0; i &lt; props.numTimes; i++) &#123; items.push(props.children(i)); &#125; return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;&#125;function ListOfTenThings() &#123; return ( &lt;Repeat numTimes=&#123;10&#125;&gt; &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125; &lt;/Repeat&gt; );&#125; 子元素可以通过自定义组件传递任何类型。 被忽略的Boolean、Null和Undefined fase、null、undefined和true是有效的子元素。它们只是不渲染。下面JSX表达式呈现的效果是一样的： 1234567891011&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&#123;false&#125;&lt;/div&gt;&lt;div&gt;&#123;null&#125;&lt;/div&gt;&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;&lt;div&gt;&#123;true&#125;&lt;/div&gt; 这些在条件渲染React元素的时候是有用的。下面代码，如果showHeader是true则渲染组件： 1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt; 但请注意，一些“falsy” 值，诸如数字0，仍然会被渲染。例如：下面代码不会得到预期的行为，因为props.messages为空值的时候会打印0 12345&lt;div&gt; &#123;props.messages.length &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; 修复上面代码，确保表达式&amp;&amp;前总是布尔值 12345&lt;div&gt; &#123;props.messages.length &gt; 0 &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; 相反地，如果你想要打印出false、true、null或者undefined，你必须先把它转换成一个字符串： 123&lt;div&gt; My JavaScript variable is &#123;String(myVariable)&#125;.&lt;/div&gt;]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
        <tag>HTML</tag>
        <tag>React学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记——组合与继承(v15.5)]]></title>
    <url>%2F2017%2F04%2F25%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF(v15.5)%2F</url>
    <content type="text"><![CDATA[[TOC] React有一个强大的组合模型，并且推荐组合代替继承，在组件间重用代码。 一些组件不能提前知道它们的子组件。它些问题在一些公共组件尤其明显。如：侧边栏或者弹出框等组件。 我们推荐这样的组件使用prop的特殊属性children，直接传递子元素到它们的输出中。 123456789101112131415161718192021function FancyBorder(props) &#123; return ( &lt;div className=&#123;'FancyBorder FancyBorder-' + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125;//传递JSX中嵌套的任意子元素function WelcomeDialog() &#123; return ( &lt;FancyBorder color="blue"&gt; &lt;h1 className="Dialog-title"&gt; Welcome &lt;/h1&gt; &lt;p className="Dialog-message"&gt; Thank you for visiting our spacecraft! &lt;/p&gt; &lt;/FancyBorder&gt; );&#125; JSX标签内任何内容通过prop children参数传递到FancyBorder组件中。由于，FancyBorder组件把{prop.children}渲染在一个\中，所以传入的元素最终被输入在这里。 虽然这种情况是不常见的，很多时候，我们需要的是在一个组件的多个地方，使用这种嵌套。在这种情况下，我们得自己定义规则来代替使用chidren。 123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className="SplitPane"&gt; &lt;div className="SplitPane-left"&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className="SplitPane-right"&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; React元素像\和\只是对象，所以可以像其它任何数据一样作为prop传递它们。 有时候，我们认为组件是其它组件的“特殊实例”。例如，我们可能说组件WelcomeDialog是组件Dialog它的特殊实例。 在React中，这也可以通过组合完成。 1234567891011121314151617181920function Dialog(props) &#123; return ( &lt;FancyBorder color="blue"&gt; &lt;h1 className="Dialog-title"&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className="Dialog-message"&gt; &#123;props.message&#125; &lt;/p&gt; &lt;/FancyBorder&gt; );&#125;function WelcomeDialog() &#123; return ( &lt;Dialog title="Welcome" message="Thank you for visiting our spacecraft!" /&gt; );&#125; 组合对于类定义的组件同样有效。 12345678910111213141516171819202122232425262728293031323334353637383940414243function Dialog(props) &#123; return ( &lt;FancyBorder color="blue"&gt; &lt;h1 className="Dialog-title"&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className="Dialog-message"&gt; &#123;props.message&#125; &lt;/p&gt; &#123;props.children&#125; &lt;/FancyBorder&gt; );&#125;class SignUpDialog extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.handleSignUp = this.handleSignUp.bind(this); this.state = &#123;login: ''&#125;; &#125; render() &#123; return ( &lt;Dialog title="Mars Exploration Program" message="How should we refer to you?"&gt; &lt;input value=&#123;this.state.login&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;button onClick=&#123;this.handleSignUp&#125;&gt; Sign Me Up! &lt;/button&gt; &lt;/Dialog&gt; ); &#125; handleChange(e) &#123; this.setState(&#123;login: e.target.value&#125;); &#125; handleSignUp() &#123; alert(`Welcome aboard, $&#123;this.state.login&#125;!`); &#125;&#125;]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
        <tag>HTML</tag>
        <tag>React学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记——提升state(v15.5)]]></title>
    <url>%2F2017%2F04%2F25%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8F%90%E5%8D%87state(v15.5)%2F</url>
    <content type="text"><![CDATA[[TOC] 通常几个组件需要反映相同数据变化，我们推荐提升共享的state到它们最近的共同祖先元素。实现如下： 创建一个温度计算器来计算，给定温度的水是否会沸腾。 我们将从一个BoilingVerdict组件开始，它接收一个celsius作为prop参数，并且打印水温度。 123456function BoilingVerdict(props) &#123; if (props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil.&lt;/p&gt;; &#125; return &lt;p&gt;The water would not boil.&lt;/p&gt;;&#125; 接下来，创建一个Calculator组件，它渲染一个\用来输入一个摄氏温度，并且保存它的值在this.state.temperature之中。 此外，它根据输入的值来渲染BoilingVerdict组件 12345678910111213141516171819202122232425class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: ''&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(temperature)&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; 添加第二个输入框 我们的新要求是，除了一个摄氏度输入外，再提供一个华氏度输入，并且它们保持同步。 我们可以从Calculator组件提取一个TemperatureInput组件，增加一个scale prop参数，它可的取值可以是“c”或者“f”: 12345678910111213141516171819202122232425262728const scaleNames = &#123; c: 'Celsius', f: 'Fahrenheit'&#125;;class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: ''&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; 现在，修改Calculator组件，渲染两个不同的温度输入： 12345678910class Calculator extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;TemperatureInput scale="c" /&gt; &lt;TemperatureInput scale="f" /&gt; &lt;/div&gt; ); &#125;&#125; 现在已经实现了两个输入框，接下来实现输入其中一个，另一个同时更新功能。 编写转换函数首先，我们写两个函数用于在摄氏度和华氏度之间的单位转换： 1234567function toCelsius(fahrenheit) &#123; return (fahrenheit - 32) * 5 / 9;&#125;function toFahrenheit(celsius) &#123; return (celsius * 9 / 5) + 32;&#125; 这两个是转换数字的函数，我们将另外写一个函数，它接收一个字符串temperature参数和一个converter函数作为参数，并返回一个字符串。我们使用它基于一个输入框的值计算出另一个输入框的值。 当它接收一个无效的temperature参数时返回空字符串，并且它保证输出到小数点后三位。 123456789function tryConvert(temperature, convert) &#123; const input = parseFloat(temperature); if (Number.isNaN(input)) &#123; return ''; &#125; const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString();&#125; 例如，tryConvert(‘abc’, toCelsius)返回一个空字符串; tryConvert(‘10.22’, toFahrenheit) 返回 ‘50.396’。 提升state一般的，TemperatureInput组件的值独立保存到它们的局部state上，然而我们想让两个输入框同步，就需要将共享state移动到需要它的最近共同的祖先组件上。这就叫做“提升state”。 我们将移除TemperatureInput组件局部state到Calculator组件上。 具体步骤： 1.把TemperatureInput组件的 this.state.temperature 换成 this.props.temperature 1234render() &#123; // 修改前: const temperature = this.state.temperature; const temperature = this.props.temperature;｝ 我们知道props是只读的。当temperature在局部state时，可以能setState()修改。然而，现在temperature作为一个prop从父类传过来，TemperatureInput组件无法再控制它。 在React中，通常用组件来解决这种控制问题。就像Dom元素\接收一个value和一个onChange作为prop参数一样，因此可以自定义TemperatureInput组件接收temperature和onTemperatureChange作为prop参数，从它的父组件Calculator中传过来。 现在当TemperatureInput组件想要更新它的temperature时，它可以调用this.props.onTemperatureChange： 1234handleChange(e) &#123; // 修改前: this.setState(&#123;temperature: e.target.value&#125;); this.props.onTemperatureChange(e.target.value);｝ 注意此处的temperature 或者 onTemperatureChange仅仅作为prop参数名，没有什么特殊的涵义。我们可以定义任意自己喜欢的名字，像value和onChange这种通用的惯例。 onTemperatureChange和temperature作为prop参数由父组件Calculator提供。它将通过修改局部state时行改变，因此两个input的值被重新呈现。修改后的完整代码： 12345678910111213141516171819202122class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); &#125; handleChange(e) &#123; this.props.onTemperatureChange(e.target.value); &#125; render() &#123; const temperature = this.props.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; 实现Calculator组件我们会将input里的temperature 和 scale存储到Calulator组件的局部state，这个state是从inputs中提升来的，并且作为它们的数据源。这是我们为了显示两个input值所需要知道的最小条件。 例如，我们摄氏度input中输入37，Calculator组件的state应为 1234&#123;temperature: '37',scale: 'c'&#125; 如果在华氏度的input中输入212，Calculator组件的state应为 1234&#123;temperature: '212',scale: 'f'&#125; 我们可以同时保存两个input的值，但它是不必要的。我们可以根据temperature 和 scale值推断出，其它输入框的值。 两个input保持同步的原因在于，它们的计算来自同一个state： 1234567891011121314151617181920212223242526272829303132333435363738class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: '', scale: 'c'&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: 'c', temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: 'f', temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale="c" temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale="f" temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; 整体流程：1、React在Dom的\上通过onChange事件调用指定方法。在上面示例中是TemperatureInput组件中的handleChange方法。 2、方法handleChange中通过输入的值e.target.value调用this.props.onTemperatureChange()方法，它是父组件Calculator传递过来的一个prop。 3、当它被渲染的时候，父组件Calculator已经为TemperatureInput组件onTemperatureChange属性指定了摄氏度handleCelsiusChange和华氏度handleFahrenheitChange方法。它会依据被编辑的输入框，决定调用哪个方法。 4、在这些方法内部，Calculator组件通过input输入的值和scale来调用setState()方法修改state。 5、React调用Calculator组件的render方法，通过当前state，调用转换方法进行温度转换。 6、React在render方法中通过新的prop参数逐个调用TemperatureInput组件。 7、React更新匹配的input值，被编辑的input值保持不变，其它的input同步更新转换后的值。 每次更新都保持相同的步骤，所以input保持同步。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
        <tag>HTML</tag>
        <tag>React学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记——表单(v15.5)]]></title>
    <url>%2F2017%2F04%2F24%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%A1%A8%E5%8D%95(v15.5)%2F</url>
    <content type="text"><![CDATA[[TOC] React中的HTML表单元素有点不同于其它DOM元素，因为表单元素天生具备一些内部状态。 1234567&lt;form&gt; &lt;label&gt; Name: &lt;input type="text" name="name" /&gt; &lt;/label&gt; &lt;input type="submit" value="Submit" /&gt;&lt;/form&gt; 这个表单具有HTML默认行为，当用户提交表单后跳转到一个新页面。如果你想要在React中实现这种行为，它是有效的。但是，大多数情况是，使用一个JavaScript函数来处理表单提交以及对用户输入表单的数据操作是很方便的。实现这一标准的方法是一种称为“控制组件”的技术。 控制组件在HTML表单元素中，诸如\、 \ 和 \元素，通常保持着它们自己的状态并且根据用户的输入而更新。在React中可变的状态通常保存在组件的state属性中，并且只能使用setState()来更新它们。 我们可以这两个结合起来，使React state成为单一数据源。然后React组件渲染表单并且控制用户后的输入。这种React控制表单元素值的方法被叫做“控制组件”。 例如，前面示例提交表单记录Name时，我们可以把表单写成一个控制组件： 123456789101112131415161718192021222324252627282930class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: ''&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('A name was submitted: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type="text" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type="submit" value="Submit" /&gt; &lt;/form&gt; ); &#125;&#125; 由于表单元素上设置有value属性，显示的值永远this.state.value的值。 textarea标签在HTML中textarea标签的文本内容写在标签里面 123&lt;textarea&gt; Hello there, this is some text in a text area&lt;/textarea&gt; 但是在React中使用value属性代替 1234567891011121314151617181920212223242526272829303132class EssayForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: 'Please write an essay about your favorite DOM element.' &#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert('An essay was submitted: ' + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type="submit" value="Submit" /&gt; &lt;/form&gt; ); &#125;&#125; 处理多个Input如果想处理多个input元素，可以给每个元素加上name属性，并让事件处理函数依据event.targe.name选择处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Reservation extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isGoing: true, numberOfGuests: 2 &#125;; this.handleInputChange = this.handleInputChange.bind(this); &#125; handleInputChange(event) &#123; const target = event.target; const value = target.type === 'checkbox' ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]: value &#125;); &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt; Is going: &lt;input name="isGoing" type="checkbox" checked=&#123;this.state.isGoing&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; Number of guests: &lt;input name="numberOfGuests" type="number" value=&#123;this.state.numberOfGuests&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ); &#125;&#125; 注意，示例18行使用了ES6的计算属性语法，如果用ES5语法实现如下： 123var partialState = &#123;&#125;;partialState[name] = value;this.setState(partialState);]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
        <tag>HTML</tag>
        <tag>React学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记——条件渲染(v15.5)]]></title>
    <url>%2F2017%2F04%2F21%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93(v15.5)%2F</url>
    <content type="text"><![CDATA[[TOC] React条件渲染和JavaScript的条件工作方式是一样的。 使用JavaScript中if或者条件运算符来创建一个代表当前状态的元素，然后让React来更新匹配的UI。 12345678910111213141516171819202122232425//创建登陆用户后组件function UserGreeting(props) &#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;;&#125;//创建访客组件function GuestGreeting(props) &#123; return &lt;h1&gt;Please sign up.&lt;/h1&gt;;&#125;//创建Greeting组件来动态显示登陆用户或访客组件function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125;//渲染Greeting组件ReactDOM.render( // Try changing to isLoggedIn=&#123;true&#125;: &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;, document.getElementById('root')); 元素变量可以使用变量保存元素，这可有条件的渲染组件的一部分，输出的其余部分保持不变。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//创建LoginButton按钮组件function LoginButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Login &lt;/button&gt; );&#125;//创建LogoutButton按钮组件function LogoutButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Logout &lt;/button&gt; );&#125;//创建一个LoginControl组件，它可以根据当前的状态渲染LoginButton或者LogoutButton组件，它也将渲染上面的Gretting组件class LoginControl extends React.Component &#123; constructor(props) &#123; super(props); this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = &#123;isLoggedIn: false&#125;; &#125; handleLoginClick() &#123; this.setState(&#123;isLoggedIn: true&#125;); &#125; handleLogoutClick() &#123; this.setState(&#123;isLoggedIn: false&#125;); &#125; render() &#123; const isLoggedIn = this.state.isLoggedIn; let button = null; if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;; &#125; return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;LoginControl /&gt;, document.getElementById('root')); 内联if使用逻辑‘&amp;&amp;’操作符声明一个变量并且使用if语句有条件的渲染组件是一个很好的方法，然而，有时候你想使用一些简短的语法，就需要用到JSX内联表达式。 JSX可以在‘{}’内嵌套任何表达式，这其中就包括JavaScript逻辑&amp;&amp;操作符，这对于有条件的引入一个元素是很方便的。 12345678910111213141516171819function Mailbox(props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; &#125; &lt;/div&gt; );&#125;const messages = ['React', 'Re: React', 'Re:Re: React'];ReactDOM.render( &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById('root')); 它之所以起作用是因为true &amp;&amp; 表达式 总是得到一个表达式，而false &amp;&amp; 表达式 总是计算为false。因此，如果条件是true,&amp;&amp;后面元素将会被输出，相反如果条件是false，React将会忽略并且跳过它。 内联if-else条件运算符另一种内联方式条件渲染元素是使用JavaScript条件运算符：condition ? true : false 1234567891011121314151617181920212223//使用条件运算符渲染一小块文本render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? 'currently' : 'not'&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125;//它也可以使用在大的表达式中，尽管看起来不明显render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; &#123;isLoggedIn ? ( &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt; ) : ( &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt; )&#125; &lt;/div&gt; );&#125; 就像JavaScript一样，根据你和团队的考虑，可以选择一种适合风格。但要记住，当一个组件的的条件判断过于复杂时，应该考虑拆分组件了。 阻止组件渲染极少的情况下，你可能一个组件隐藏它自己，即使它被其它组件渲染。想隐藏组件可以把它的返回值设为null。 1234567891011121314151617181920212223242526272829303132333435363738394041function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return ( &lt;div className="warning"&gt; Warning! &lt;/div&gt; );&#125;class Page extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;showWarning: true&#125; this.handleToggleClick = this.handleToggleClick.bind(this); &#125; handleToggleClick() &#123; this.setState(prevState =&gt; (&#123; showWarning: !prevState.showWarning &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt; &lt;button onClick=&#123;this.handleToggleClick&#125;&gt; &#123;this.state.showWarning ? 'Hide' : 'Show'&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Page /&gt;, document.getElementById('root')); 组件的render方法返回null，不能影响到组件生命周期方法。例如：componentWillUpdate 和 componentDidUpdate方法仍然后执行。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
        <tag>HTML</tag>
        <tag>React学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React学习笔记——列表和Keys(v15.5)]]></title>
    <url>%2F2017%2F04%2F21%2FReact%2FReact%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8%E5%92%8CKeys(v15.5)%2F</url>
    <content type="text"><![CDATA[[TOC] 渲染多个组件你可以创建一个元素集合，通过‘{}’在JSX中使用 1234567891011//创建元素集合const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;);//使用集合放到ul标签ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById('root')); 基础列表组件 通常希望在一个组件内部渲染列表，修改上面的示例： 1234567891011121314151617function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); Keys注意上面示例第4行的‘key’，它是一个特殊的字符串属性，当创建一个列表元素是必须要包含它，否则会有如下警告： a warning that a key should be provided for list items Keys是帮助React识别哪些项目被修改、添加、删除。主键将给数组中的元素一个稳定的身份。 最好的方式使用一个在列表同级元素中唯一的字符串作为key。例如我们经常使用数据中的IDs作为Keys,但是不建议在没其它办法的情况下使用元素索引作为key,因为如果数据被重新排序，那么对于React来说，识别变动的元素仍然是很慢的。 使用Keys提取组件Keys中有在数组的上下文中才有意义。例如：抽取一个ListItem组件，你应该保持key在数据中的\元素上，而不是在ListItem自己的根元素\上。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function ListItem(props) &#123; const value = props.value; return ( // 错误！此处不需要key &lt;li key=&#123;value.toString()&#125;&gt; &#123;value&#125; &lt;/li&gt; );&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 错误！此处应该指定key &lt;ListItem value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root'));function ListItem(props) &#123; //正确！此处没有key return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key被放在了数组里面 &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById('root')); Keys同级元素间必须是唯一的如同上面提过的key在数组内部的同级元素间必须唯一，但是并不需要全局唯一，可以在两个不同的数组中使用相同的key: 123456789101112131415161718192021222324252627282930313233function Blog(props) &#123; const sidebar = ( &lt;ul&gt; &#123;props.posts.map((post) =&gt; &lt;li key=&#123;post.id&#125;&gt; &#123;post.title&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key=&#123;post.id&#125;&gt; &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;post.content&#125;&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; &#123;sidebar&#125; &lt;hr /&gt; &#123;content&#125; &lt;/div&gt; );&#125;const posts = [ &#123;id: 1, title: 'Hello World', content: 'Welcome to learning React!'&#125;, &#123;id: 2, title: 'Installation', content: 'You can install React from npm.'&#125;];ReactDOM.render( &lt;Blog posts=&#123;posts&#125; /&gt;, document.getElementById('root')); Keys作为React的一个提示服务，不会传递到组件内部。如果需要在组件内部使用，必须明确的使用不同的名字作为pops传入组件： 123456const content = posts.map((post) =&gt; &lt;Post key=&#123;post.id&#125; id=&#123;post.id&#125; title=&#123;post.title&#125; /&gt;); 在JSX中嵌入mapJSX允许在‘{}’中嵌入任意表达式，因此可以内联使用map() 1234567891011function NumberList(props) &#123; const numbers = props.numbers; return ( &lt;ul&gt; &#123;numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; )&#125; &lt;/ul&gt; );&#125;]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
        <tag>NodeJs</tag>
        <tag>HTML</tag>
        <tag>React学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS Sierra触摸板滑动敏感问题解决方案]]></title>
    <url>%2F2016%2F10%2F08%2Ftech_stack%2FMacOS%20Sierra%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%BB%91%E5%8A%A8%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[升级完macOS Sierra系统后，JAVA开发工具滚动条过于敏感问题，原因是由于JDK和Sierra不兼容，由于 Sierra 的触发事件参数比之前系统都复杂一些，而JAVA统一将这些参数处理为默认值，导致滚动速度快了很多，事实上可以发现升级系统后所有Java应用都存在这个问题，还包括Eclipse。。 下载openJDK112版本： http://bintray.com/jetbrains/intellij-jdk/download_file?file_path=jbsdk8u112b403_osx_x64.tar.gz解压后，移动到/Library/Java/JavaVirtualMachines打开idea,双击shift，弹出对话框，输入Switch IDE JDK 选择选项后，将openJDK跟换为刚才下载的版本 重启！ 原文：https://youtrack.jetbrains.com/issue/IDEA-158500]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写Oracle存储过程]]></title>
    <url>%2F2015%2F11%2F19%2Ftech_stack%2F%E7%BC%96%E5%86%99Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[整体结构12345678910create [or replace] procedure 过程名称( 参数 IN|OUT|IN OUT 类型|表.字段%type [default 默认值], ……) AS|IS 变量 类型|表.字段%type [default 默认值]; ……begin ……exception ……end 过程名称; or replace若存在则替换IN输入参数OUT输出参数IN OUT即可做输入参数，也可做输出参数%type与表的字段同类型default赋默认值（out参数不能赋默认值）过程中参数类型不用指定大小，而声明的变量类型要指定大小。如：字符类型varchar2(30)声明时需要指定30AS|IS没有区别，任选一个即可exception异常处理[可选] 逻辑判断123456789IF判断if 条件 then ……elsif 条件 then ……else ……end if; FOR循环：1、自定义循环次数： 123for i in 1..1000 loop ……end loop; 2、利用游标循环： 1234CURSOR cur IS SELECT * FROM xxx;for cur_result in cur LOOP ……END LOOP; WHILE循环：123while 条件 loop ……end loop; 异常处理 系统异常 异常原因 access_into_null 未定义对象 case_not_found case 中若未包含相应的when，并且没有设置 collection_is_null 集合元素未初始化 curser_already_open 游标已经打开 dup_val_on_index 唯一索引对应的列上有重复的值 invalid_cursor 在不合法的游标上进行操作 invalid_number 内嵌的 sql 语句不能将字符转换为数字 no_data_found 使用 select into 未返回行，或应用索引表未初始化的 too_many_rows 执行 select into 时，结果集超过一行 zero_divide 除数为 0 subscript_beyond_count 元素下标超过嵌套表或varray的最大值 subscript_outside_limit 使用嵌套表或 varray 时，将下标指定为负数 value_error 赋值时，变量长度不足以容纳实际数据 login_denied pl/sql 应用程序连接到 oracle 数据库时，提供了不正确的用户名或密码确的用户名或密码 not_logged_on pl/sql应用程序在没有连接 oralce 数据库的情况下访问数据问数据 program_error pl/sql 内部问题，可能需要重装数据字典＆ pl./sql系统包统包 rowtype_mismatch 主游标变量与 pl/sql 游标变量的返回类型不兼容 self_is_null 使用对象类型时，在 null 对象上调用对象方法 storage_error 运行 pl/sql 时，超出内存空间 sys_invalid_id 无效的 rowid 字符串 timeout_on_resource oracle 在等待资源时超时 自定义异常12345678910111213141516171819create [or replace] procedure 过程名称( 参数 IN|OUT|IN OUT 类型|表.字段%type [default 默认值], ……) AS|IS 变量 类型|表.字段%type [default 默认值]; …… userException exception;begin if 条件 then raise userException; end if; ……exception when no_data_found then --系统异常 when userException then --自定义异常 when others then --其他异常end 过程名称; goto语句：Oracle中没有continue关键字，在loop中可以用goto语句实现同样的效果。goto会增加程序复杂度，可读性变差使程序不易控制和维护。&lt;&lt; &gt;&gt;后面不能直接跟EXCEPTION这种关键字类的语句，要用NULL把标签跟关键字隔开。类似的关键字还有END LOOP之类的，等等。 123456789101112131415declare i int := 1;begin loop dbms_output.put_line(&apos;输出i=&apos; || i); if i = 10 then goto end_loop; end if; i := i + 1; end loop; &lt;&lt;end_loop&gt;&gt; null;exception ……end; 注释– 单行注释/ / 多行注释 注释必须在create [or replace] procedure之内，否则不能保存。 其他问题DBMS_OUTPUT.put_line()打印方法可用于跟踪调试PL/SQL DEVELOPER自带调试功能]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>存储过程</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雪]]></title>
    <url>%2F2015%2F11%2F07%2Fblog%2F%E9%9B%AA%2F</url>
    <content type="text"><![CDATA[北风卷地白草折，胡天八月即飞雪。忽如一夜春风来，千树万树梨花开。 是的，这就是昨天早晨首先映入我眼帘的景象，虽然远远没有达到这个程度，但对于J城来说，也可以这样来说了。雪，对于我这样一个很久没看到过的东北人来说是一种常人很难体会到的感觉。当我走出房屋融入到其中的那一刻，心里徘徊的一个念头告诉我“我想家了”。 是啊，离家多年却从来没有真正意义的回过家乡了，很久没有感受过腊九寒冬，没有看到过银装素裹的北国风光了，甚至可能已经渐渐的忘记那种冷的感觉，有很多朋友问我是怎么忍耐那种严寒呢，我的回答是你怎么知道我们不是在享受呢。没错没有经历过的你，也许觉得难以置信。让我无耐的是有一些人，仅仅去过几次却妄加评判，我也只能呵呵了。 记得小学的时候，语文课的一篇作文，题目就是《雪》，当时外面大雪纷飞，老师为了让我们能写好决定那节课可以自由外出去感受，结果所有同学都跑到操场去写作文，当时写作文都是套用的各种模版像什么“银装素裹”，“雪你是可爱的美容师”等等，还有什么“鹅毛大雪，漫天飘舞”，结果交作业的时候，大多数人的写法都差不多==! 在我印象中那时候的雪总是特别的大的，过膝盖也是很平常的，鹅毛大雪说的真不是特别夸张，下雪后的全校上午可以少上一到两节课去操场扫雪，虽然挺累但是大家的兴致还是特别高，其中的乐趣无穷无尽。课间的时候打雪仗、堆雪人、摔跤，每当这个时候每个人包括老师都会忘记自己的身份，而变成对手。 往事总是让人感觉很美好，更多的是因为当时没有好好体会，一直是认为是理所当然，等到失去后才知道难能可贵，到头来也只能触景生情罢了。 多么希望的画面能定格在此时，一个孤寂的黑色身影走在茫茫的白色世界中……]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[折腾]]></title>
    <url>%2F2015%2F10%2F26%2Fblog%2F%E6%8A%98%E8%85%BE%2F</url>
    <content type="text"><![CDATA[又是疲劳的一个月，又是一个又爱又恨的月分。 十一小长假又去一趟北戴河，不过这次却少了些上一次的感觉，却多了几分回味和体会，本来是想去青岛的，还好没抢到青岛的票，38元一只的虾想想都后怕……俗话说“乐极生悲，物极必反”，疯狂的假期后迎接我的就是一轮疯狂的加班，累的我是前仰后合。 一直以来都对自己的这个网站都不是特别满意，不论是功能、布局、还是内容等等，所以一直都在不断的改啊改调啊调的，这次做了比较大的调整，虽然也不算特别满意，但也可以让自己的心里抗一段时间了。 前些天用了一年的.info域名到期了，我犹豫了好久决定换回.com域名，总感觉其它域名有些不正规，应该是先入为主的影响吧。之前一直用的是.com的，去年也不知怎么的头脑发热，用了一年的.info其实主要还是因为当时比较便宜。这次换回来以后也不会再变了，除非这个站不开了。为了以后可以拓展更多功能，这次加上了二级域名blog，以后博客这块都会在这个二级域名下了，这样才能完全利用域名。 说来真是惭愧，网站建了好几年了，天天折腾外皮，内容却没怎么更新太多，正如某些博客前辈所批评的那样，目前域名Google PR 是1，这也还是我第一年刚申请时攒下来的，后来就没涨过。 本来也没想把这件事发展成怎样，其实也就算是一种娱乐吧，也不想天天弄什么长篇大论，也不想通篇BUG攻略什么，所以每当这个时候，写的都是一些流水文吧，不过那又怎么样呢，感觉也挺好的！你好，10月！]]></content>
      <categories>
        <category>芬芳年华</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS Content]]></title>
    <url>%2F2015%2F04%2F11%2Ftech_stack%2FCSS%20Content%2F</url>
    <content type="text"><![CDATA[定义与用法content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容。该属性用于定义元素之前或之后放置的生成内容。默认地，这往往是行内内容，不过该内容创建的框类型可以用属性 display 控制。 值 描述 none normal content specifications inherit 规定应该从父元素继承 content 属性的值。 1234567&lt;style&gt;div:before&#123; content:"书记说："; color:red;&#125;&lt;/style&gt;&lt;div&gt;同志们好！&lt;/div&gt; 浏览器支持所有浏览器都支持 content 属性。 特殊字符content属性同样支持ASCII 特殊字符，具体字符请参考(X)HTML的特殊字符，如果想要查询某个符号的数值可以使用the Entity Conversion Calculator进行转换或者反向转换。 1234567&lt;style&gt;div:before&#123; content:"\2660"; color:red;&#125;&lt;/style&gt;&lt;div&gt;A（红桃A）&lt;/div&gt; 属性的使用content属性还可以通过attr(属性名)方式与标签属性相结合使用。 1234567&lt;style&gt;div:before&#123; content:attr(title); color:red;&#125;&lt;/style&gt;&lt;div title="副"&gt;总经理说：全体涨工资！&lt;/div&gt; 功能进阶与CSS3相配合实现类似title属性的功能，但是比title体验效果好。 1234567891011121314151617181920212223242526272829303132333435&lt;style&gt;a &#123; color: #900; text-decoration: none;&#125;a:hover &#123; color: red; position: relative;&#125;a[tip]:hover:after &#123; content: attr(tip); padding: 4px 8px; color: #333; position: absolute; left: 0; top: 100%; white-space: nowrap; z-index: 20px; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px; -moz-box-shadow: 0px 0px 4px #222; -webkit-box-shadow: 0px 0px 4px #222; box-shadow: 0px 0px 4px #222; background-image: -moz-linear-gradient(top, #eeeeee, #cccccc); background-image: -webkit-gradient(linear,left top,left bottom,color-stop(0, #eeeeee),color-stop(1, #cccccc)); background-image: -webkit-linear-gradient(top, #eeeeee, #cccccc); background-image: -moz-linear-gradient(top, #eeeeee, #cccccc); background-image: -ms-linear-gradient(top, #eeeeee, #cccccc); background-image: -o-linear-gradient(top, #eeeeee, #cccccc); &#125;&lt;/style&gt;&lt;a href="#" tip="鼠标已悬浮！"&gt;请把鼠标悬浮在此！&lt;/a&gt;]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
        <tag>WEB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[等我]]></title>
    <url>%2F2015%2F04%2F07%2Fblog%2F%E7%AD%89%E6%88%91%2F</url>
    <content type="text"><![CDATA[等我有时间了……等我有钱了……等我……等我…… 曾经或者现在不知道被这句话忽悠了多少次，一次又一次拿着这句连鬼不都信的话在敷衍着，欺骗着自己那纯洁的心灵。 体育运动是我一直以来的爱好，尤其篮球是我最喜欢的运动，从小学开始我就接触到了篮球，当时我是我们班里第一个学会三步篮的人，同学们那羡慕的眼神让我至今记忆犹新。都说好的开始是成功的一半，在我看来却未必，这只是一些人为了让自己坚持下去而找的一个鼓励自己的方式。到了中学时期，我几乎每次都是篮球比赛中的首发阵容，随着一年年的长大，除了年龄没被落下外，身高和体重到后来却慢慢的被甩开了一大截，以至于从原来的锋位掉到了后来的后位。虽然一些客观原因让我无法控制，但还是凭借着我那无人能及的速度和投篮精准的优势没让我彻底掉下神坛。后来我和我的室友们发展了第二纵队（由第二阵容人员组成）王朝，当时整个学校没有几个能打过我们那个阵容，现在想想依旧心潮澎湃。后来学习压力越来越大，渐渐地玩球的时间越来越少，当时我对自己说的一句话就是“等我以后有时间了，要好好的玩”，现在时间是有了，可是人却再也凑不齐了。 都说现在过年过节越来越没有味道了，方式方法没什么变化，为什么会变得没意思了呢。对我来说原因有几条，以前家庭经济条件不太好，平时省吃俭用的过日子，只有过年时才能吃得到平时吃不到的东西，玩到平时玩不到的，年少无愁。记得当时过完除夕盼十五，因为只有那天才有我最喜欢的元宵，家里有时为了省钱，不会去外面买，自己用糖和花生什么的自己包，有时候包的不好咬的特别硬，即使那样我还吃的满嘴留香，而且总是吃不够，当时我就想“等我挣钱了，我要买好多好多圆宵吃”。后来，我真的挣钱了，正月十八买的勉强吃了两次，现在还剩半袋在冰箱放着！ 最近我的朋友圈里有一个每天坚持学英语的，每天为了鼓励自己都写一句话，今天写的是“困难就怕坚持二字”，我想了想这句话改成“困难就怕行动二字”更适合我。很多时候真的不太需要等我，只是我们更想等我而已，莫怠明日…… 明 ·钱鹤滩《明日歌》 明日复明日， 明日何其多？我生待明日， 万事成蹉跎。世人若被明日累，春去秋来老将至。朝看水东流， 暮看日西坠。百年明日能几何？ 请君听我明日歌！]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[寻找失去的记忆]]></title>
    <url>%2F2015%2F04%2F02%2Fblog%2F%E5%AF%BB%E6%89%BE%E5%A4%B1%E5%8E%BB%E7%9A%84%E8%AE%B0%E5%BF%86%2F</url>
    <content type="text"><![CDATA[我可能是个喜欢回忆的人，往往越久远的事，我越喜欢去想，然后是一阵感慨，然后再怀念，然后再伤感，然后再… 不知怎么着，已经几年都没联系过的高中同学最近异常活跃，还建立了微信讨论组。每天都说个不停，我也“有幸”被拽了进去，偶尔也参与一下讨论，大多数情况都没人理我，让我找不到存在感，于是我慢慢的发展成了潜水一族，现在想想那几年混的挺失败的，没有什么人缘，唯一的几个死党也随着时间的流逝逐渐疏远了。这就是当初我死活都不敢相信的现实，我不知道时间改变了什么，我只知道我还是那个我。 现在我身边讨论最多的话题就是结婚了，同事结婚，同学结婚，朋友结婚，身边的人都在结婚。是啊，到了这该死的年纪除了结婚还能有什么呢。前两天有个同学在qq上问我现在在哪怎么样之类的，我当时很诧异因为我已经和他几年没联系过了，上学的时候关系不能说有多深交情至少面上还是不错的。我开玩笑回复他我在外地谋生啊，然后他说：”是吗，我要结婚了，还想请你来喝喜酒呢，你也回不来了啊！“。我又回复他，是啊，最近有好多同学都结婚了，我也回不去，只能祝福你们了。当我还在等着他的回复时，却再也没有声音了。后来我得知有一个同学也没参加，但是礼钱到了。 没错我确实人缘不行，如果美好的东西非要带上铜臭的气味，我宁愿抛弃。如果要加上一个期限的话，那就永远吧！今夜我再一次迷失了自己，回到了无穷无尽的记忆中。”同学你叫什么名字，朋友我们在哪见过，兄弟你还记得我吗“，当我得知我曾经暗恋过的女生，已经为人妻为人母的那一刻，我才知道我当时的愚蠢。疯狂一次也许一切都会不一样，可是谁又能说那就是错呢，也许错的是我依旧还在原地踏步。 打开相册，寻找记忆中的点滴，虽然我可能忘记了你，但我却依然努力的想起…标记…]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Z的自白]]></title>
    <url>%2F2015%2F03%2F21%2Fblog%2FZ%E7%9A%84%E8%87%AA%E7%99%BD%2F</url>
    <content type="text"><![CDATA[“Z，22岁生日快。”“谢谢！希望新的一岁我会抬头……”我来自H市X县的一个小地方，以前的我一直都认为是自命不凡的，这个想法不知道是何时萌生的，也许是从我来到这个世界的那一刻吧，因为龙抬头那天，我注定的不平凡人生就这样开始了。 这还得从我和我现在已经不认识了的表弟第一天上学说起，那个时候学校离家比较远，交通条件也不好，只能步行两三里地去上学，当时我不知道我为什么要去一个那么多人地方，妈妈告诉我上课不许说话，铃声响后就下课了。于是，我一直没有说话，别人跟我说话我都不理会。而在妈妈走后不知过了多久，我终于听到了铃声，而我却把课间休息当成了放学，我跑到学校门口找了妈妈很久都没找到，于是我做了一次不寻常的事，自己走回了家，回到家里大人们都震惊了，当时应该是5岁左右，具体记不清了。 辗转间来到了一个新的地方开始了我的小学，那也是我记忆中最美好无忧的时光。班长，委员，同桌，最好的组长，最好的朋友，最美的同学……当时忘记了是什么原因，我和一个同学打架把他推倒在地上，脸都划破了。那也是我人生中第一次打架，回到家后我很害怕，也没敢告诉父母，那个同学的家长找到了家里，我都没敢出门，后来因为大人们都认识也就不了了之了。漫长的小学时光终于在我的长大成材梦中结束了，毕业晚会上也随着当时非常火的同一首歌落下的帷幕，炉火徐徐……我们毕业了。“鲜花曾告诉我你怎样走过，大地知道你心中的第一个角落，甜蜜的梦啊谁都不会错过……” 就这样一点点，一步步，我醒了，醒得那么干脆。 我叫Z，我来自H市X县的一个小地方，以前的我一直都自命不凡！(未完待续……)]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[站长也要懂项目]]></title>
    <url>%2F2015%2F03%2F18%2Fblog%2F%E7%AB%99%E9%95%BF%E4%B9%9F%E8%A6%81%E6%87%82%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[在当今社会中，一切都是项目，一切都将成为项目。 ——美国项目管理专业资质认证委员会主席Paul Grace 博客建立也有一年多啦，一直在断断续续的维护着，三天打渔，几个月晒网，找个好听点的借口“忙”。 俗话说“麻雀虽小，五脏俱全”，我这小站点也算是经历过风风雨雨啦，建立之初的想法是怎么也算是个ＩＴ人啦，给人做过的网站也有很多啦，为什么还没有自己的小站呢。于是网上找了好久买了一个云服务器，整个网站的全部架构全是我自己设计的，做了半个多月试运行上线了，虽然功能不是很全，但是一直在不断的完善，当时成就感天天爆棚。半年后通过一点点的了解，发现大多数的个人网站用的都是虚拟主机，于是将目光移到了这边，经两三考虑对于没有收入的网站来说，云服务器确实像它的名字一样，有点高不可及，可是虚拟主机一般支持的都是ＰＨＰ网站而我那个网站是ＪＡＶＡ做的自然就不能用了，还是有一些失望，再三衡量下我还站在了成本这一面。那么问题来啦，“空间技术哪家强”，“怎么建站”……，对于ＰＨＰ我也是一窍不通，于是网上搜罗各种攻略，手册等等直到现在，虽不敢说是什么大牛，但建站各种问题，我也应该能说说一二啦，看来抽时间我也可以写一篇建站攻略啦^_^。 对于网站来说，其实最重要的就是Search Engine Optimization，也就是我们常说的搜索引擎优化简称ＳＥＯ，网上对这方面的攻略比比绋皆是，除非你向我一样不是特别追求页面的访问量，否则我相信你应该看过很多类似的文章。虽然我并没有对这方面的技术有过太多的研究，但是我却对这方面有一些特别的看法。 我认为站长优先关注的，恰恰不是ＳＥＯ（也不是瓜子），而是网站本身质量。首先内容是否有吸引力、新颖，如果你的网站能在这方面搏到访客的满意，那么你就不太需要做别的来浪费时间啦。然而往往大多数人都是废在这儿了，这是硬实力的体现，只能自己努力啦。其次，是页面的流畅度和交互感觉方面。我相信如果一个受访页面在３秒之内加载不出来，这个网站在访客心中印象的地位就大打折扣了，如果５秒中之内还打不开，我会选择直接关掉，除非你有让我不得不看的理由。不过你真的有这本事，你还优化什么流量啊！你不就垄断了吗……质量是一个项目最基本的要求，如果一产品边最基本的质量都保证不了，那么这个产品可能不会成功。之所以用“可能”两字，原因在于不同环境下有不同的需求，不同的需求下又造成了不同的标准，所以不同的产品质量的好坏也就无法做到统一评判。归结一句话就是干系人是否满意，从马桶盖上就可以看出些问题了……. 影响到用户体验的因素往往有很多，比如常说的主机类型，带宽大小，以及智能交互的体验等方面，而说到这些往往也都会牵扯一个问题“成本”，尤其对没有收益的小网站来说，当然要想办法越低越好啦。但是这里需要注意到一个前提“不影响体验效果”，也就是一直说的保证质量。有些人可能不太想花钱，但是也想搭建一个网站，于是就到处搜寻免费空间，费了好大的劲终于弄好了，也写了好多内容，功能和体验上也花费了好多心思，结果没过几个月或者几天，主机数据全部丢失或停止运营，最后连灰都没见着！你可能会想，没事反正也没花钱没啥损失。但是，真的没什么损失吗，你所付出的精力，你辛辛苦苦写出来文章，即使你的内容全都是些流水仗，那也是付出了机会成本的。当然一个产品的好与坏不能仅仅用成本的高低来区分，最根本的因素还是质量达标－干系人满意。然而质量有时又不仅仅说的是产品的本身，雾霾就是很好的例证…… 虽然我并不是什么技术大牛，但凭借这么多年的实践，我相信做到每天几更应该是不成问题的，但事实上我并没有这么做，因为从最开始的定位上我就不想让我的地盘变成一个纯技术类型，我只想在这里记录的是日常的点点滴滴，可以是任何类型。这个问题也就涉及到你的网站想要发展的范围，它是整个网站的骨架，直接影响着你网站的流量。你的网站到底是什么类型，一定要做到心中有数。 前面谈到硬实力，须要长时间的积累，但是就像我一样眼下并不达不到，难道就被判死刑了吗。也不一定，硬的不行咱来软的呗，交流是可以很好解决这一问题的办法，只有互动多了才能发掘出更多的想法和不被所知的见解，流量也自然而然就上去了。 有了这些，你还用ＳＥＯ吗？用，当然用，锦上添花嘛^_^……]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[吃汤圆]]></title>
    <url>%2F2015%2F03%2F09%2Fblog%2F%E5%90%83%E6%B1%A4%E5%9C%86%2F</url>
    <content type="text"><![CDATA[独在异乡为异客，每逢佳节倍思亲。遥知兄弟登高处， 遍插茱萸少一人。 —王维 十五的元宵十八吃，说到元宵让我想起前天下班高峰期的８号线瘫痪，好多人都去鸟巢看灯，导致截流限行排了半个小时才上去。 记得以前在家的时候每到十五那天，家家户户都会走出家门，我们那里叫做“走百步”，意思是除百病，让一年有个好身体。大街上人来人往，有的跑着，有的蹦着，有的手里提着灯笼，有的嘴里嚼着冰糖葫芦；有集体放烟花的，也有组织扭大秧歌的，雪花飞舞，冰灯闪耀，街边到处都是点的透亮的火堆…… 另一个习俗应该就是往河里仍硬币了，一块的，五角的，一毛的，还有几分的。好多人到了第二天就下去捡，据说可以让你小发一笔的。路上遇到卖小灯笼的，我们叫喊着让母亲给买一个，软磨硬泡下母亲终于给我和小哥一人买了一个，小灯笼是玻璃做的，在里面放上蜡烛，专门喜欢往黑暗的地方跑，那叫一个开心，整个晚上都高兴的无法入睡。 散步回来，最大的期待就是煮元宵啦，那个时候一年到头来就只有这一天才能吃得到元宵，满满吃了两大碗小肚子撑的圆鼓鼓的，却还是眼巴巴的看着锅里剩下的，真嫌自己的肚子太小。 后来，大一些了才知道了，有北方“滚”元宵，南方“包”汤圆的说法，那个时候记得大人总是喜欢给小孩讲一个故事，大意就是说俄罗斯人来中国看到元宵，怎么也弄不明白为什么中国人能把元宵包的那么圆，然后大人总是自豪的说滚圆的呗。 再大一些后，总是在十五的时候吃元宵，可是我发现每次回来时候包装上写的都是汤圆，从没看过有写着元宵的，不知为何，我开始怀疑我是否吃过真的元宵，难免总有一些失落感！ …… 哐嘁哐嘁，终于做上地铁啦，吃了点快餐，到家了……]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[回归平常]]></title>
    <url>%2F2015%2F03%2F02%2Fblog%2F%E5%9B%9E%E5%BD%92%E5%B9%B3%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[龙应台写给儿子安德烈的一段话，“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。 转眼间，年已过，节已跑，与预想中一样，除了又老了一岁，就真的再也没有别的了。送走了亲朋暂别了好友，生活又回归到了原有，一个春节过后钱包在不知不觉中少了几千块大洋，还引起不小风波。算了算小时候一共收到的红包都没这一次发出去的多，Ｄuang！！！ 节前信誓旦旦的不惰落，又荡成了一波波水纹，放松了一个小长假后，又要转换回奔波学习的节奏，确实有很大的挑战，有些不知所措。 刚看了一下最近讨论最热的《穹顶之下》，这部百万巨作，终于解答了我一直以来的疑问。“是什么？从哪来？到哪去？” 发展可以与环境同在，但铜臭才是万恶之根！ 好了，不唠叨啦，戴上口罩谋生去了……]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无心]]></title>
    <url>%2F2015%2F02%2F03%2Fblog%2F%E6%97%A0%E5%BF%83%2F</url>
    <content type="text"><![CDATA[无心工作，无心看书，两周，一周，5天，3天……，人人都在倒数着，期盼着！ 冬去春来，新年的脚步已然渐渐走近，不知不觉中，时光悄然逝去，到头来浑浑噩噩的不是唱着时间都去哪了就是什么时光时光慢些吧，了然无趣。 今年春节应该是近几年比较热闹的一年，好多亲戚都要聚到一起来过年，记得小时候每逢春节都有好多人，欢聚一堂，只有经历过才能体会到什么叫年味；长大后，为生活，为“幸福”，或者不知道为了什么，各自四散，得到了很多，却失去了更多。 Ｊ城今冬下三场雪，一场十分钟（没有亲眼看见），一场五分钟，一场在梦里。 总是想做一些事情，可实现起来才知道想和做的结合有多么困难，明日复明日，于是，一连串的恶性循环就开始了。 明年是期待收获的一年，想要花开，就不能停止灌溉！]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[等一分钟MV]]></title>
    <url>%2F2015%2F01%2F09%2Fblog%2F%E7%AD%89%E4%B8%80%E5%88%86%E9%92%9FMV%2F</url>
    <content type="text"><![CDATA[最近迷上mv于是拿出以前录的歌用了十几个小时的视频制作，完成了这个mv，也算是处女作啦，瑕疵很多，但毕竟也算是一点成果,相信后续会起来越来越精致。 歌曲录制于2011年]]></content>
      <categories>
        <category>自娱自乐</category>
      </categories>
      <tags>
        <tag>MV</tag>
        <tag>翻唱</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又到一年十一时(一)]]></title>
    <url>%2F2014%2F10%2F01%2Fblog%2F%E5%8F%88%E5%88%B0%E4%B8%80%E5%B9%B4%E5%8D%81%E4%B8%80%E6%97%B6%2F</url>
    <content type="text"><![CDATA[雨依旧淅沥沥的飘个不停仿佛从未停息,转眼间冬去秋来又是一年，徘徊与迷茫仍是这一年的主题，不同的是收获了更多新鲜而有意义的人或事，回想起去年那雨中穿梭，奋勇前行的情景,仍在继续，必将终身难忘，而如此更多的激情我想才刚刚开始。 今年的北京比每年冷的有些早，刚进十月就已经有些冬天的感觉了，整个黄金周只能猫在窝里了，外面的世界虽然很精彩，但是一票难求的咱们却是桑不起啊。 听说又有砖家同志发言了建议取消黄金周，此人正是当年提出取消五一的那位，我的小心脏又开始担心了，这不会是最后的黄金“粥”了吧，可惜我还没有抓住机会去享受；听说高考要取消英语了，我不禁泪流满面啊；听说乌克兰要闹独立，我不禁又要泪流满面；听说……听说……。好吧这一年发生的事还真不少，可怜我这小小的记忆内存啊！ 话说我今年又搬了两次家，这让我越来越觉得漂着的感觉是多么的让人无奈了。不禁让我想起了一句诗词“有的房空着，可你却住不起；有些人住的起，可他们却不惜住。”于是乎，我渐渐的靠近了七环，疏远了组织。 明年也许依旧是平凡的一年，但更是我期待的一年，也会是我努力收获的一年，也许在别人眼中不值一提。努力，共勉-2014]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网页head内容跑到了body中]]></title>
    <url>%2F2014%2F09%2F29%2Ftech_stack%2F%E7%BD%91%E9%A1%B5head%E5%86%85%E5%AE%B9%E8%B7%91%E5%88%B0%E4%BA%86body%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[最近发现博客的favicon图标在chrome浏览器中不显示，但在IE中却可以，于是我打开调试工具查看，结果发现HTML head标签的内容全部跑到body中去了，由于favicon必须在head标签中所以现在不能显示了。于是排查可能出现的问题： 1.存在标签未闭合等问题2.存在移动head内容的js代码等问题3.存在编码或乱码等问题 经过检查后排除了1.2项的问题于是把注意力集中在第三个问题上，经过一阵咕弄终于发现了由于文件保存的时候编码存在BOM标记。 BOM是Windows下记事本软件保存一个UTF-8编码的文件时开头正文的一部分来表明编码方式的隐藏字符，对于一般文件貌似没有什么太大麻烦，但对于PHP来说却不是个福星，它会被PHP完全读取出来，使整个网页向下填充无法紧贴浏览器顶部，并且可能出现标签混乱。 既然找到了问题就着手解决问题吧。 一种方法是手动将文本在编辑器中打开，将编码转换为UTF-8无BOM编码方式，当然如果你的文件太多这个方法就不太适用了。 第二种方法如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?php $basedir = str_replace('/clearBOM.php','',str_replace('\\','/',dirname(__FILE__)));$auto = 1;checkdir($basedir);function checkdir($basedir)&#123; if ($dh = opendir($basedir)) &#123; while (($file = readdir($dh)) !== false) &#123; if ($file != '.' &amp;&amp; $file != '..')&#123; if (!is_dir($basedir.'/'.$file)) &#123; $filename = $basedir.'/'.$file; echo 'filename:'.$basedir.'/'.$file.checkBOM($filename).'&lt;br&gt;'; &#125; else &#123; $dirname = $basedir.'/'.$file; checkdir($dirname); &#125; &#125; &#125; closedir($dh); &#125;&#125;function checkBOM ($filename) &#123; global $auto; $contents = file_get_contents($filename); $charset[1] = substr($contents, 0, 1); $charset[2] = substr($contents, 1, 1); $charset[3] = substr($contents, 2, 1); if (ord($charset[1]) == 239 &amp;&amp; ord($charset[2]) == 187 &amp;&amp; ord($charset[3]) == 191) &#123; if ($auto == 1) &#123; $rest = substr($contents, 3); rewrite ($filename, $rest); return '&lt;font color=red&gt;BOM found,automatically removed.&lt;/font&gt;'; &#125; else &#123; return '&lt;font color=red&gt;BOM found.&lt;/font&gt;'; &#125; &#125; else &#123; return 'BOM Not Found.'; &#125;&#125;function rewrite ($filename, $data) &#123; $filenum = fopen($filename, 'w'); flock($filenum, LOCK_EX); fwrite($filenum, $data); fclose($filenum);&#125;?&gt; 将上面代码保存为PHP文件（注意编码格式哦），然后上传后在浏览器中执行一下就OK了，看一下效果，搞定收工……^^!]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>BOM</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Properties文件]]></title>
    <url>%2F2014%2F09%2F28%2Ftech_stack%2FJava%20Properties%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[Java开发者对Properties一定再熟悉不过了,它是JAVA项目里特有的一种配置文件，Properties 继承于 Hashtable，所以可对 Properties 对象应用 put 和 putAll 方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是 String 的项，应该使用 setProperty 方法。如果在“不安全”的 Properties 对象（即包含非 String 的键或值）上调用 store 或 save 方法，则该调用将失败。 最近做项目想在项目中实现动态配置文件的功能，本来以为水到渠成的事，结果遇到了一点小麻烦，现将问题记录下来。 通常用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.test;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Properties;/** * * @author Windus * @version v1.0 * */public class PropertiesUtil &#123; private Properties properties; // properties文件路径 private String proPath; public PropertiesUtil(String proPath) &#123; this.proPath = proPath; loadProperties(); &#125; /** * 加载Properties文件 * * @param proPath */ public void loadProperties() &#123; try &#123; properties = new Properties(); InputStream is = this.getClass().getResourceAsStream(proPath); properties.load(is); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 读取配置文件键值 * * @param key * @return */ public String getProperties(String key) &#123; if (properties != null) &#123; return properties.getProperty(key); &#125; else &#123; return null; &#125; &#125; /** * 设置键值 * * @param key * @param value */ public void setProperties(String key, String value) &#123; try &#123; if (properties != null) &#123; // 设置键值 properties.setProperty(key, value); OutputStream fos = new FileOutputStream(proPath); properties.store(fos, new SimpleDateFormat("yyyy-MM-dd").format(new Date())); fos.flush(); fos.close(); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; PropertiesUtil propertiesUtil = new PropertiesUtil("/test.properties"); //打印当前键值 System.out.println(propertiesUtil.getProperties("name")); //设置键值 propertiesUtil.setProperties("name", "windus"); //打印修改后的值 System.out.println(propertiesUtil.getProperties("name")); //重新加载properties文件读取 PropertiesUtil propertiesUtil = new PropertiesUtil("/test.properties"); System.out.println(propertiesUtil.getProperties("name")); &#125; &#125; 当我在启动Tomcat后，重新在前台传入key值后调用设置方法后重新读取，如main方法中一样调用，发现每次修改后的properties文件本身确实改变了，但读取出来的值确不是实时更新的，原因在于getProperties每次读取都是从内存中读取，而对于文件的更新后没有实时加载到内存中。 经过轮番的修改……测试……不行；修改……测试……不行；…… ……后：得出解决方法，问题出现在加载properties文件的方法上：如上37行 123InputStream is = this.getClass().getResourceAsStream(proPath);//修改为InputStream is = new BufferedInputStream(new FileInputStream(getClass().getResource(proPath).getPath())); getResourceAsStream每次读取来自内存中，所以可以通过getResource(proPath).getPath()来获取properties文件路径，然后读取到输入流中实时加载properties文件，此时即可得到每次改变后的值。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux上分不清的查询指令]]></title>
    <url>%2F2014%2F05%2F05%2Ftech_stack%2FLinux%E4%B8%8A%E5%88%86%E4%B8%8D%E6%B8%85%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[whatis [指令或数据]: 列出相关指令的说明文件（相当于man -f） apropos [指令或数据]: 列出系统的说明文件中，相关指令或关键词（相当于man -k） whatis/apropos两个指令想要使用必须用makewhatis(root权限)建立whatis数据库。 whois: 查找并显示指定帐号(或域名)的用户相关信息，因为它是到Network Solutions的WHOIS数据库去查找，所以该帐号名称必须在上面注册方能寻获，不区分大小写。 whereis [-bmsu] 档案或目录名: 从指定目录中搜寻特定档案。 1234-b : 查找binary格式档案-m : 查找在说明文件manual路径下的文件-s : 查找source来源档案-u : 查找不在上述档案中的其它特殊档案 locate [-ir] 搜寻字符串: 和whereis类似locate是从数据库中搜寻档案，由于数据库默认每天更新一次，所以会有数据不实时的限制问题。（如：最新文档搜寻不到、已删除档案仍然存在等问题） updatedb指令可以读取/etc/updatedb.conf,然后在硬盘中搜寻文件动作，最后更新/var/lib/mlocate数据库。locate：依据 /var/lib/mlocate 内癿数据库记载，找出用户输入癿关键词文件名。 which: 从PATH路径中搜寻执行档（默认显示第一个，加-a显示全部） type [-typa] name: 查找指令类型（如：内建指令builtin）,如果后面名称不能以执行档的状态找到，那该名称不会被找到。也可以作为which用来找指令。 file: 查看档案基本数据的类型（如：ASCII、data 档案、binary等），并且其中没有使用到动态函式库。 find [选项] : 功能强大的搜寻指令，由于是硬盘操作，速度稍慢。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乔迁之喜,开門大吉]]></title>
    <url>%2F2014%2F03%2F09%2Fblog%2F%E4%B9%94%E8%BF%81%E4%B9%8B%E5%96%9C%2C%E5%BC%80%E9%96%80%E5%A4%A7%E5%90%89%2F</url>
    <content type="text"><![CDATA[新博客终于搭建完毕了,由于先前从一个国外免费空间先试了一下手,所以一切还很顺利,没有遇到什么难题,只是主题真是让我煞费苦心,想要一种自由,大气,舒适的,确始终没找到.最后发现了这一款还算满意吧. 对自已的文彩很有自知之明的我建立这个博客只是为了自我生活中比较有意义的人或事以一篇或一段文字的形式记录下来,如果恰巧其中的某些只言片语能够让你感受到乐趣或是对你有所帮助,那便是我又一收获实乃三生有幸. 最近翻我以前的物品时,从中发现了我一本10多年以前的一篇日记,我从头到尾翻了一遍往事一幕幕浮现在我脑海,回想起那时青涩的我,还有我那年青的母亲.多年以后我越长越大,离家也越来越远.回家就越来越少.时过境迁,物是人非唯有那本快要泛黄的日记本记录着那一幕幕永恒的瞬间.那一笔笔的画面比影像还要清晰的在我的脑海放映.那一夜我兴愤的失眠了. 所以我决定重新捡起笔头来记录这生活的点点滴滴.等到下一十年、下下一个十年再来回忆.由于我对个人网站的喜爱我会公开我部分记录到到我的个人博客来,其中可能包括但不限于生活感悟、个人游记、技术文摘等等. Dolly’ll never go away ^_^]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决浏览器模式兼容问题]]></title>
    <url>%2F2014%2F01%2F06%2Ftech_stack%2F%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[网站前端开发在我看来是开发中最让人郁闷的工作，并不是其技术有多难，而是因为它的各种不稳定因素。今天浏览器厂商一个标准，明天浏览器厂商一个标准，这家厂商一个标准，那家一个厂商一个标准。前端开发大多数时候并不是因为一个布局实现方式而苦恼，而是为了各种浏览器的兼容。然而，最让人头疼的就属IE6啦。虽然这个浏览器，曾经立下过汗马功劳，但真的到了功成身退的时候了。 IE7在我看来只是微软公司临时抱佛脚的替代品，过渡产品自然用的就比较少，就像曾经的vista系统。从IE8浏览器开始，微软向 Web 标准进行靠拢。改变重大，但是IE6的市场占有率仍然居高不下，且其代码标准与W3C的标准有许多出入，故按照 IE6/7 的规范来编写代码在IE8中也未必兼容，为了解决这个问题IE8浏览器增加了一种叫做“兼容性视图”的功能。从此处牵出两个功能“浏览器模式”和“文档模式”。“浏览器模式”用于切换IE针对该网页的默认文档模式、对不同版本浏览器的条件备注解析、发送给网站服务器的用户代理（User-Agent）字符串的值。网站可以根据浏览器返回的不同用户代理字符串判断浏览器的版本和安装的功能，这样就可以向不同的浏览器返回不同的页面内容。“文档模式”用于指定IE的页面排版引擎（Trident）以哪个版本的方式来解析并渲染网页代码。切换文档模式会导致网页被刷新，但不会更改用户代理字符串中的版本号，也不会从服务器重新下载网页。切换浏览器模式的同时，浏览器也会自动切换到相应的文档模式。问题出现了，既然这么多模式那么怎么选择使用哪种模式，X-UA-Compatible出现了这是一匹神马。有了它开发者无需考虑网页是否兼容IE8浏览器，只要确保网页在IE6、IE7下的表现就可以了。 页面中用法: 1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; 在\&lt;head>标签下面加入上面代码：IE=edge告诉IE使用最新的引擎渲染网页(其它可选值：IE5、IE6、IE7、IE8 )，chrome=1则可以激活Chrome Frame(可以让旧版IE浏览器使用Chrome的WebKit渲染引擎处理网页，因此旧版IE用户可以体验到包括HTML5在内的众多现代网页技术。)参考：http://blogs.msdn.com/b/ie/archive/2010/06/16/ie-s-compatibility-features-for-site-developers.aspx Apache设置方法:[信息参考自]可以在Apache主机做一些设置让服务器告诉IE采用何种引擎来渲染。在网站作用目录找到或新建.htaccess文件，添加下面的内容保存即可。 12345678&lt;IfModule mod_setenvif.c&gt; &lt;IfModule mod_headers.c&gt; BrowserMatch MSIE ie Header set X-UA-Compatible "IE=Edge" env=ie BrowserMatch chromeframe gcf Header append X-UA-Compatible "chrome=1" env=gcf &lt;/IfModule&gt;&lt;/IfModule&gt; Ngnix设置方法:找到\nginx\conf\nginx.conf并编辑，在server { }区域里（最好是闭合符前面起一行）添加下列代码即可。 1add_header "X-UA-Compatible" "IE=Edge,chrome=1"; 360浏览器内核控制:由于WebKit内核的浏览器逐渐盛行，越来越多的人加入它的行列，然而国内windows系统的大环境下IE几乎是每台电脑必有的浏览器，所以目前很多网站只支持IE浏览器。如：银行系统从而越来越多的双核浏览器诞生了。其中360浏览器就是个典型的Chrome+IE=360,相信很多人都发现过有的页面用360浏览器打开是IE内核，有的是WebKit内核。然而当我的只想用WebKit内核或是IE内核时，360提借供了一个内核选择功能： html代码: 1234567&lt;html&gt; &lt;head&gt; &lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。详细参考：http://se.360.cn/v6/help/meta.html]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>WEB</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五笔学习小记]]></title>
    <url>%2F2013%2F11%2F26%2Fblog%2F%E4%BA%94%E7%AC%94%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[键盘分区和区号汉字有五种基本笔划， 横、竖、撇、捺、折，所有的字根都是由这五种笔划组成的，分别划为5个区。每个区有五个位，按一定顺序编号，就叫区位号。比如1区顺序是从G到A，G为1区第1位，它的区位号就是11，F为1区第2位，区位号就是12 键名字根王土大木工 目日口田山禾白月人金 言立水火之已子女又纟 字根一般分布规律(1)总体规律：一区：横 二区：竖 三区：撇 四区：捺 五区：折 注意:在五笔中，笔划“提”归在“横”里，“点”归在“捺”里，“竖钩”归在“竖”里 (2)非定性规律 如：规律1：在1区1位，里面有一横这个字根，在1区2位有二横这个字根，在1区3位，里面有三横这个字根。第2区1位，有一竖这个字根，2区2位，有二竖这个字根，2区3 位，有三竖这个字根，2 区4位，有四竖这个字根。第3区1位里一撇，3区2位里二撇，3区3位里三撇。第4区，41区位里有点，42区位里有二点水，43区位里有三点水，44区位里有四点底。第5区，51区位中的“乙”是一折，52区位中的“&lt;”“ ”是二折，53区位中的“巛”是三折 规律2：1区1位，“王”的第一笔是横，第二笔还是横；1区2位，“土”的第一笔是横，第二笔是竖；1区3位，“大”的第一笔是横，第二笔是撇；再看1区5位，“七”的第一笔是横，第二笔是折。（字根的第二笔与位号一致。不是所有的字根都符合这个规律，还是有很多特殊的。） 规律3：相似性如：W键，里面的“人、八、 、 ”这四个字根形态都差不多。还有B键，里面的“阝、卩”很容易联想到字母B。L键，里面的这四个字根：，彼此长得很像，和四竖也很像。 字根顺口溜横区:王旁青头(兼)五一(G), 土士二干十寸雨(F)大犬三(羊)古石厂(D), 木丁西(S)工戈草头右框七(A) 竖区:目具上止卜虎皮(H), 日早两竖与虫依(J)口与川 字根稀(K), 田甲方框四车力(L)山由贝 下框几(M) 撇区:禾竹一撇双人立 反文条头共三一(T), 白手看头三二斤(R)月彡(衫)乃用家衣底(E), 人和八 三四里(W)金勺缺点无尾鱼 犬旁留乂一点夕 氏无七(妻)(Q) 捺区:言文方广在四一 高头一捺谁人去(Y), 立辛两点六门病(U)水旁兴头小倒立(I), 火业头 四点米(O)之字军盖建到底 摘礻(示)衤(衣)(P) 折区:已半巳满不出己 左框折尸心和羽(N), 子耳了也框向上(B)女刀九臼山朝西(V), 又巴马 丢矢矣(C)慈母无心弓和匕 幼无力 汉字拆分字根间的结构关系可以概括为四种类型，单、散、连、交。单，就是指这个字根本身就是一个汉字。包括五种基本笔划“一、丨、丿、丶、乙”，25个键名字根和字根中的汉字。比如“言、虫、寸、夕”等。散，就是指构成汉字的字根不止一个，且汉字之间有一定的距离。比如“苗”字，由“艹”和“田”两个字根组成，字根间还有点距离。连，就是指一个字根与一个单笔划相连。比如“勺”，就是“勹”和点组成的，我们认为它们是相连的。这样的例子还有“术、太、主、义、斗、头”等。 注意:有些字，字根虽然连着，但在五笔中不认为它们是相连的，如“足、充、首、左、页”等，还有，单笔划与字根间有明显距离的也不认为是相连，比如“个、少、么、旦、全”等。交就是指两个或多个字根交叉重叠构成的汉字。比如“本”，就是由字根“木”和“一”相交构成的。(1)多字跟拆分由四个或四个以上的字根的合体字，它的输入方法是按照书写顺序，取第一、二、三、末四个字根的编码。如：“毅”字是由“立、 、几、又”四个字根组成的，这四个字根的编码依次是UEMC，那么在五笔输入法中，键入UEMC，就输入了“毅”字。 注意: 1.在拆分汉字时，先要注意按书写顺序来拆分汉字，然后对里面的一些复杂字根，按照它的自然界限进行拆分，对界线不明显了，就要按拆分原则进行拆分。 2.先左后右，先上后下，先横后竖，先撇后捺，先内后外，先中间后两边，先进门后关门。 3.取大优先，兼顾直观，能散不连，能连不交。 (2)拆分原则取大优先原则。在各种可能的拆法中，保证按书写顺序拆分出尽可能大的字根，以保证拆分出的字根数最少。兼顾直观原则。就是说在拆字时，尽量照顾字的直观性，一个笔划不能分割在两个字根中。【“兼顾直观”和“取大优先”原则是相通的，都是取大字根，笔划不能重复或是截断。】能散不连原则。如果字可以拆成几个字根散的结构，就不要拆成连的结构。能连不交原则。如果字可以能按连的结构拆分, 就不要按交的结构拆分。 (3)汉字字型1、左右型—代号12、上下型—代号23、杂合型—代号3 注意:1.包围和半包围关系的汉字，一律视为杂合型，如“团、同、医、凶、句”等。2.含有“辶”的字也是杂合型，如“过、进、延”等。3.“厂、尸、眉(上半部)”等字根组成的一些字也是杂合型。4.一个基本字根和一个单笔划相连，也视为杂合型，如自己的“自”。5.一个基本字根之前或之后有孤立点的也当作杂合型，比如“勺、术、太、主、斗”等。6.几个基本字根交叉重叠之后构成的汉字，也视为杂合型。比如“申、里、半、串、东、电”等。 (4)少字根拆分由少于4个字根构成的字需要加入末笔字型交叉识别码。末笔字型交叉识别码=末笔代码+字型代码 末笔字型交叉识别码列表 &nbsp; 左右型 上下型 杂合型 横 G(11) F(12) D(13) 竖 H(21) J(22) K(23) 撇 T(31) R(32) E(33) 捺 Y(41) U(42) I(43) 折 N(51) B(52) V(53) 末笔特殊约定: 1.为了有足够多的区分能力，对“辶”、“廴”的字和全包围字，它们的“末笔”规定为被包围部分的末笔。2.如果“囗”包围的一个字根组成的双码字根再位于另一个字根之后，所得到的三根字的末笔仍然是被包围的那个字根的末笔。3.如果用“辶”包围一个字根组成的双码字再位于另一个字根后面，所得到的三根字末笔为“辶”的末笔“丶”，如“链”，编码为OLPY。4.对“九、刀、七、力、匕”等字根，当它们参加“识别”时一律用“折笔”作为末笔。5.我们接着讲末笔约定。“我”、“贱”、“成”等字的“末笔”，遵循“从上到下”的原则，末笔应该是“丿”。6.带单独点的字，比如“义”，“太”，“勺”等，我们把点当作末笔，并且认为“丶”与附近的字根是“连”的关系。 (5)成子字根输入在字根总表中，除了键名字根外，本身就是汉字的字根。输入方法是：先打一下该字根所在的键，再打该字根的第一、第二及最末一个单笔画。 (6) 一级简码 一地在要工，上是中国同。gfdsa hjklm和的有人我，主产不为这。trewq yuiop民了发以经。nbvcx (7) 二级简码输入方法：一笔代码+二笔代码+空格键 如：睡：全码（htgf）简码（ht）二级简码是由25个键位代码排列组合而成的。25×25=625，去掉一些没有的空字，二级简码将近六百个。 (8) 三级简码输入方法：一笔代码+二笔代码+三笔代码+空格键字的前三个字根编码在五笔中是唯一的，这个字都可以作为三级简码来输入。在汉字中，三级简码一共有4000多个。 (9) 二字词汇输入方法：取每个字的前两个字根的代码如：热爱 － rvyo epdc = rvep 注意:当“键名”及“成字字根”参加组词时，应该从这个字的全码中取头两位编码如：土地 — ffff fbn = fffb (10) 多字词汇三字词汇：取前两个字的第一个字根+最后一个字前两个字根如：计算机－yfh thaj smn＝ytsm四字词汇：取每个字的第一个字根 如：操作系统－rwtx 偏旁部首打法一 ggll丨 hhll丿 ttll丶 yyll nnll 注意: 补位码 ll]]></content>
      <categories>
        <category>芬芳年华</category>
      </categories>
      <tags>
        <tag>输入法</tag>
        <tag>五笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的一次骑行经历-北戴河(三)]]></title>
    <url>%2F2013%2F11%2F21%2Fblog%2F%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86-%E5%8C%97%E6%88%B4%E6%B2%B3(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[时间：4:10分……………….地点：离海边约500米…….目的：南戴河海边日出……人员：我自己……………….环境：漆黑一片，海风搜身感觉：冷、黑、冷、黑…… 又是一阵清澈的水流声，把我从甜美的梦乡中拉了回来。经过两天的劳累现在的我已经是严重缺觉，虽然很疲惫但日出的诱惑，还是将我沉重的身体拉了起来。起来洗脸、刷牙，刚喝了一口水，咸咸的滋味又让我吐了出来，这水怎么这么咸啊，不会是直接把海水引过来的吧！由于不知道日出的准确时间，快速的洗漱完毕，穿上比平常厚的衣服，出门向海边走去(事实证明我穿的太少了)。 走出旅馆，外面一片漆黑，大门还是蹩着的，打开大门向外走，越走越黑，连路都有点看不见了（南戴河人民晚上都不开路灯的吗？），凭着昨天晚上对方位的判断，以为大海应该在旅馆前方，走了有5分钟竟然连海的影子都没看见，我意识到时走错了，正常应该只有500米，回想起刚才看见的一个很高的建筑物，和网上所说的天马浴场很像，于是变换方向朝建筑物走去。果然没出5分钟，伴随着大海的声音越来越大，风也越来越大，很快就来到了天马浴场。此时：4:点40分 来到海边后，我走到沙滩上，大海深处一片漆黑但却没有黑暗的寂静，相反的是一阵阵海浪拍打岸边的声音，我看见一排排白色的不知道什么东西，在海中从北向南的滑着（最初我以为是小船，后来天亮了我才知道原来是浪花）。岸边的海风太大，让我寒冷难耐，于是我走回上边的广场找物体避风，但是却没有效果，于是我就绕着旁边的花坛绕圈跑了起来，好在稍微缓解了一下冻透的身体。 早晨5:00，陆陆续续出现了一波人，跟着他们来到了沙滩旁边的健身器，此时身体依旧很冷，于是乎拼命玩着各种健身器材来提升身上的温度。 5:30分，人越来越多，我沿着沙滩一路向东看到有一条探进海中十几米的小长廊，走上长廊走进海中感觉到海风之大，我这单薄的衣服，让我再一次后悔没有带更厚的衣物。 5:40分，天边出现红晕，感觉海风越来越大，海水都被吹到了桥上，有人说，太阳已经出来了，只是今天有浮尘所以还要等会才能看见。 5:50分，越来越多的人回到沙滩上，只剩下寥寥无几的几个人和我还站在这里！ 5:58分，天边红霞越来越亮了，太阳要升起来了，此时我已经冻的哆哆嗦嗦了。升起来啦…… 日出升起来那一过程非常漂亮，手机照的不是特别的好。等到太阳完全升上来以后，沙滩上到处都是海鸥，他就会落在你身边感觉更是美，后来沿着沙滩走了一圈，本来想捡两个海螺的，可是一个都没发现（后来才知道，我没去对地方，沙滩南边有很多）。之后去了吃了点早点，回去补个回笼觉了！]]></content>
      <categories>
        <category>芬芳年华</category>
      </categories>
      <tags>
        <tag>骑行</tag>
        <tag>旅游</tag>
        <tag>北戴河</tag>
        <tag>大海</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的一次骑行经历—北戴河(二)]]></title>
    <url>%2F2013%2F10%2F28%2Fblog%2F%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[朦胧中一阵阵清澈的溪水声，将我从梦中带回到现实。关闭手机，起床洗漱，酸痛感遍布全身，但体力恢复的差不多了。收拾了半个小时后，下楼准备退房出发，旅馆老板还没起床，叫醒老板后，老板把旅店们打开，一股清凉感，拂面而来，让我神清气爽。太阳刚刚升起，车子整理好，沿着大道向前走，找早餐的地方，走了很远 1，看到一家早餐点，坐下来吃了了点早餐。以前没注意过，这次近距离接触，发现唐山话很好说啊，只要每个字都发二声音再加点儿音 2，听起来就就很像了\^_\^。 吃完早点，全身充满能量，感觉一天能骑200公里 3。感觉总是会骗人的，出了玉田县，又与久违的102国道交汇了，灰依然很大，车依然很多，之前的豪言壮语烟消云散，怎么一个“累”字了得。 当前坐标(117,40)当前位置(玉田县)当前目标(唐山丰润区)里程(40KM)。 由于昨天的120公里行程，今天的任务尤显艰巨160。丰润这段路，甚是奇怪，都是缓坡,最好的路况也就算是平道了(几乎没有感觉到)。经过两个小时左右接近丰润的时候，道路坑坑洼洼尤其的难走，路上漫天“灰”舞，简直无法形容，我的两层魔术头巾，已经起不到多大的作用了。幸好这样的路只有一段，后来换入曹雪芹西道，进入丰润区。这一段路总体感觉，没什么好感，一路缓坡平路，我现在的感觉只能用一首歌来形容“走过了一村又一寨……（当然我不是小和尚）”，其它的就没什么印象了。 8点20分,曹雪芹西道，简单休息了一下，看了一下地图，确定路线后继续前行，话说曹雪芹道可真是够长的，单曹雪芹西道就走了半个小时(当然速度不是很快，毕竟城区里人多，车多，红灯多。中间路过曹雪芹像，让我终于相信原来他真是个男的。)。 到曹雪芹东道的尽头向南走，继续踏上熟悉的102国道。快要离开丰润前，下车休息了一下，补充点食物和水，还遇到了三个骑友，他们是直接去北戴河的。他们没耽误多久又出发了，他们走后我们又休息了十几分钟，也继续前进了。 下一站，滦县60公里，进入102国道继续前行，从此时起，每每看到一个指示牌，我的心里都会相当兴奋，因为我知道距离目标黄金海岸南戴河越来越近了。骑行了大约20分钟左右，我们追上了刚刚先走的几个骑友，他们中有一个人体力下滑严重，骑得特别慢，导致他们整体速度很慢。我们一起骑行了一段距离，他们速度实在太慢了，我们就走到了他们前边，于是102国道上就上演了这样我们停下来休息，他们追上来，他们停下休息，我们追上去……无休止的卡位战，又过了2-3个小时，已经12点多了，距离滦县还有20公里，看来我们先前估算的路程少了，实际上不只60公里。我们也有点很累了，早上5点多出发到现在也很长时间，再不补充的点食物，下午可就有问题了。于是我们到了滦县方向与102国道的交叉点“野鸡坨镇” 4，解决午饭问题，点了几个菜，吃点米饭(这块吃饭还行，不怎么贵，味道一般吧)。午饭一个小时，继续向前走，这一段的102国道不是怎么好走，到处积水，因为我们要在野鸡坨镇向南走252省道，但是前方道路积水，我没敢尝试过去，几经打听在一位阿姨的帮助下，绕了半天终于在一个小道上了省道。 省道果然比国道强的多，马路宽阔无比，并行四辆大车，都绰绰有余。一路平道，骑起来不怎么费劲，一直到了滦县，几十公里的路，一点没感到累。不过话说回来这条道还真是长啊，骑了半个多小时，到了一个大牌楼收费站，上面俩个大字“滦北”，此时看一下地图，晕，这条道才走了一半。又过了半个小时，看到一个立交桥，上面写着“千年古县”什么的，此时终于接近此段路的目的地滦县！ 这段路从里程上看确实比到丰润的距离远了20公里 5，不过这段路骑得要比前一段路爽的多啊，虽然道路依旧一般,而且有几段距离满地是泥，灰依旧不小，最主要是这段路有起伏，有上坡，有下坡，有平道，就像生活，风平浪静，虽然舒服但总感觉缺少点什么，跌宕起伏，虽然艰难，却乐在其中。 上了205，路却是好走的多了，路上的风景也好的多了，这可能就是人们口中传颂的苦尽甘来吧，呵呵。一个下坡，开启了我几公里的30+。走了几十公里后，倒处是在修路，路上又遇到一个骑友，从山东来的，要去大连！走了一段路，就不见踪影了，看来我们一路，一直超越啊，不知过了多久，看见一座大山，终于接近昌黎县了！休息了一下，吃了一些食物，喝了一罐红牛 6。 进入昌黎，有两条路：一条继续205，另一条是横穿昌黎继续向前。经过导航定位后我们选择了前者 7，我们几乎绕了一圈后，发现走的有点不对，于是换入365省道，走入了一条不归路！！！于是越走越远，越走越黑，差不多六点左右，天色已经快看不见了，我们停下来，把车子上安上手电、尾灯等，此时已经意识到走错了路. 于是决定继续换入一个向北的路，这条路没有路灯到处漆黑一片，很窄，车还很多 8。这条路还真不是一般的长，走了好久，此时地点是黄金海岸不知道哪个门，换入364省道，恩路是真好，就是没有灯,这条路我骑得依然很兴奋 9，因为这条道的尽头，就是我们的目的地。终于在8点左右，我们到达了南戴河，去了事先订好好的旅店！我们的骑行旅程到此结束了，骑行里数190公里…… 一路上来虽然有很多艰辛，但同时也有很多了欢乐和享受,这也正是我骑行的乐趣所在。由于，我们是第一次去，走了很多弯路，也带了些无用的东西，是我们骑行负担更重，所以我把需要的东西，大致总结了一下： 骑行装备（头盔、眼镜、口罩&lt;魔术头巾&gt;、手套、裤带、备胎、修车组合工具、气筒、货架、行李包&lt;其实去北戴河，我感觉没必要带行李包，真不需要带太多，我们这 次就带的多了，完全可以，用一个大一点的背包搞定&gt;）等. 衣服(至少2套衣服&lt;十月份早晚天气很冷，带些厚的&gt;、拖鞋&lt;去海边，相当有用，我这次没带，后悔死了&gt;、鞋&lt;我带了2双，雨中骑行湿了一双&gt;)等. 手机软件(导航软件&lt;这点可真要选好，我这次可是深受其害啊，一定要多下载几款，总结一下我用的导航软件：高德，查询路线还行，定位可真是不准啊。凯立德： 定位准确，但是小地方查不到&gt;)其它，可根据自己实际条件和爱好了，如：帐篷啊，充气船啊等等。 &sup1;玉田这地，吃饭的真的好少啊！&sup2;包子(báo zī)儿.&sup3;万万没想到最后真的成了现实.4这个地名很有意思，这一片的地名貌似都喜欢以“坨”结尾.5对这种长距离骑行，远几公里的感觉都是不一样的.6这真不是一个广告，我估计这就是导致我后来越骑越有力气的原因\^\^!7事实上我们真的错了，205其实是绕了昌黎一圈==!.8虽然如此，但此时丝毫没有疲惫感，非常兴奋，因为我已经闻到大海的腥味了，我知道这次是真的快到了，当然也许是红牛的作用\^\^.9当然，我也归功于红牛上了！我的队友在滦县的时候就喝了准备的红牛，我告诉他会后悔的,果然他现在的状态，惨不忍睹.]]></content>
      <categories>
        <category>芬芳年华</category>
      </categories>
      <tags>
        <tag>骑行</tag>
        <tag>旅游</tag>
        <tag>北戴河</tag>
        <tag>大海</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2 xhEditor富文本编辑器-ajax图片上传]]></title>
    <url>%2F2013%2F10%2F26%2Ftech_stack%2Fstruts2%20xhEditor%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-ajax%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[JAVA上传类代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class UploadAction extends ActionSupport &#123; private File filedata;//xheditor提供的上传文件名不可更改 private String filedataFileName; // 上传文件名 注意filedata private String filedataContentType;// 上传文件类型 /** * 上传文件 */ public void upload() &#123; logger.info("上传文件:" + filedataFileName); String filePath = Struts2Util.getRequest().getSession() .getServletContext().getRealPath("/") + filedataFileName; File file = new File(filePath); if (file.exists()) &#123; file.delete(); file = new File(filePath); &#125; try &#123; FileUtils.copyFile(filedata, file); // copy(uploadFile, file); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public File getFiledata() &#123; return filedata; &#125; public void setFiledata(File filedata) &#123; this.filedata = filedata; &#125; public String getFiledataFileName() &#123; return filedataFileName; &#125; public void setFiledataFileName(String filedataFileName) &#123; this.filedataFileName = filedataFileName; &#125; public String getFiledataContentType() &#123; return filedataContentType; &#125; public void setFiledataContentType(String filedataContentType) &#123; this.filedataContentType = filedataContentType; &#125;&#125; 下载临时文件夹 1&lt;constant name="struts.multipart.saveDir" value="/tmp"/&gt; 下载文件大小 1&lt;constant name="struts.multipart.maxSize" value="10000000"/&gt; js代码:1$('#xh').xheditor(&#123;upImgUrl: projectName + "/manage/upload!upload",upImgExt:"jpg,jpeg,gif,png"&#125;); 搞定测试，始终获取不到文件，相信很多人都遇到了遇到过这一步，经过百般尝试后发现js加上 html5Upload:false 继续测试，上传可以了，但是总提示返回错误，而且我想加自定义回调函数 onUpload:unloadComplete 发现回调函数不执行。查找了很多资料，才发现我的返回值不正确，上传方法返回必须是json格式的数据，格式如下：{“err”:””,”msg”:”上传成功！”}搞定收工!]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>xhEditor</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的一次骑行经历—北戴河(一)]]></title>
    <url>%2F2013%2F10%2F08%2Fblog%2F%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[似乎每一个骑行者都要至少一次雨中骑行的经历才能体会到骑行的乐趣，似乎每一次旅行都要经历种种磨砺才算是完美！ 向往已久的骑行终于在这次十一小长假实现了，前一个月就想去北戴河了，由于种种问题终于没能成行。恰巧同事买了个新车子，俩人一商量走你…… 原计划骑行路线：D1:北京-廊坊三河(55KM G102)-天津蓟县(90KM G102)-唐山玉田县(118KM G102)-唐山丰润区(152KM G102)D2:丰润—滦县(60KM)——昌黎(100KM G205)—(黄金海岸118KM G205) D1）5点钟起床：天气晴，哦不对，是起来晴，洗漱完后，天气开始下雨了，哇塞！！！好大一声雷。难道Game就要Over了，管它呢先吃早餐的说。吃完饭后，天气雨点貌似有点小了，准备出发，Go Go Go！自行车刚搬下楼，大雨再一次与我们拥抱,计划貌似再一次与我们惜别。 肿么办，我真想冒着大雨出发，可是这次出行并不是我自己一个人，所以要争求同伴的意见，经商议等雨停了再出发 1。然后同伴上楼等待，我依然站在楼下默默祈祷，又过了十几分钟雨丝毫没有停下的迹象，我第一次有了放弃的想法。 又过了十几分钟，已经7点多了，与原计划5点足足晚了2个小时。再不走计划行程可能就要泡汤了！此时，我的心里一直有个声音呼喊着我：“出发……出发……”！最后的决定是无论如何也要去。我跑上楼去问一下同伴还要不要去，最后同伴也下定决心，冒雨出发！于是我们穿上雨披上车出发了，这时雨变的小些了； 老天总喜欢和我们开些小玩笑，骑车来到附近ATM，只见屏幕上一排大字:“暂停服务！”= =！。好吧，只有上四环绕到大望路去取了 2,开拔! 目的地：大望路 soho取款机。 到了大望路取完钱后，整理了一下随身物品，现在真正要出发了，此时脑海里浮现出那句歌词“你问我要去向何方，我指着大海的方向！……”。 第一站&gt;京通快速—燕郊（约30KM），上了京通快速，雨越来越大，雨披渐渐失去了作用，骑行也倍感吃力。雨中骑行怎么一个“爽”字了得，可是停下来后的感觉，可就真心难受了！ 原本潮白河大桥想留影的，无耐雨太大，没有停歇继续前进，又走了几公里，在燕郊一处小市场内，休息一会，补充点水和食物 3。休息了十几分钟，下身湿透伴随着小风[哆嗦]，赶紧上车继续前行！ 第二站&gt;燕郊—三河(约25KM)，此时码表莫名其妙的罢工了，在11点左右，我们看到了一个高大无比，相当气派的门楼，上面写着几个大字“三河欢迎您”！哇塞，这就是传说的三河，果然不一般 →_→ 。 雨依旧很大，没有机会照相，继续向三河城区方向前进。到了城区，找了半天，只发现一个还可以的清真兰州拉面(PS：河北人应该酷爱面食，一路上到处是拉面、火烧之类的。)，对于我来说面食很不抗饿，一碗牛肉拉面入肚后感觉没饱，于是我们拿出自己带来的牛肉，刚想吃被老板阻止了。外带非本店清真食品不能在这吃。好吧，那就不吃了，虽然没吃饱 4。 下午1点，三河出发—目标丰润(约100KM)，天气逐渐变晴，温暖的阳光，精神焕发，可是浪费掉的体力，却是找不回了，体力感到明显下滑。 过了蓟县，走了大约20多公里，我的队友体力严重不支，骑行速度只能维持在15KM/H。此时，距离最近地点玉田还有40多公里，此时距离北京已经80多公里，为了不让我们行程落后，也是为了激励队友，我尽量把速度控制在20KM/H以上。又走走停停过了十几公里，我也明显感到体力不行了 5。 此时已经四点了，看来到丰润已是不太可能了，于是选择了玉田落脚。接下来的20公里，成了自我骑行以来最艰难的20公里。到达玉田后，夜色将近，于是现在最重要的一个任务就是找旅馆。就在我们要选定一个名为“XXX宾馆”的时候，一个哥们走进我们视线，上来询问我们从哪里来，到哪里去。经了解他是玉田本地人，也是骑行爱好者，于是我们向他询问这家宾馆怎么样，他告诉我们不要在这家很贵，然后告诉我们哪块的便宜。 正在此时，恰巧一个女的开车经过，听到我们谈话后开始对那个哥们发飙了：“我们家也不贵啊，你谁啊，你哪家的，你别走……”此处省略500字。于是我们赶紧掉头走，没想到那哥们又跟了上来，告诉我们详细的地址(多么热心，真诚的人)，在此我要对那位哥们说声谢谢！按照那位哥们说的路线，我们很容易找到了一个不错的旅馆，俩人才50块钱。车子和行李搬到旅馆后我们出去满足了肚子一个愿望\^_\^。之后又去超市采购了一些明天行程的用品，然后回到旅馆，洗了一下被泥水灌溉过的车子。感觉明天的东西准备差不多了，于是上床昏昏沉沉的睡着了…… 总结： 今天总体感觉还好主要是上午雨中骑行浪费大部分体力，下午导致体力不支，不过下雨其实也真不是什么坏事102国道的灰，真不是吹的，多亏下雨让我们少吃了一些！ &sup1;我真没抱有雨停的希望,事实也确实如此.&sup2;因为我们只知道这块有ATM.&sup3;主要是食物，“水”真是不缺.4据我事后分析，这也是导致后来我们体力不支，惜叹止步玉田的原因之一\^\^.5最主要是车座部位难受\^\^.]]></content>
      <categories>
        <category>芬芳年华</category>
      </categories>
      <tags>
        <tag>骑行</tag>
        <tag>旅游</tag>
        <tag>北戴河</tag>
        <tag>大海</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA设置模式学习笔记]]></title>
    <url>%2F2013%2F09%2F01%2Ftech_stack%2FJAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[[TOC] 遵循原则单一职责原则：1、一个类或接口只有一个职责；2、应该仅有一个原因引起类的变更； 在日常使用中很难完全做到。提高了可读性和可维护性，降低变更引起的风险。 里氏替换原则：所有引用基类的地方必须能透明地使用其子类对象。父类出现的地方子类就可以出现，反之未必。避免子类的个性。 依赖倒置原则：高层模块不应该依赖底层模块，两者都应该依赖其抽象类；抽象不应该依赖细节；细节应该依赖抽象。 Java中的常见规则： 接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。 各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。接口隔离原则 接口尽可能小，一个接口只服务于一个子模块或业务逻辑 已经被污染的接口，若变更的风险较大，则采用适配器模式进行处理。 迪米特法则核心观念是类间解耦，弱耦合；一个类应该对自己需要耦合或者调用者的类知道的最少。 开闭原则一个软件实体(类、模块、函数)应该对外扩展开放，对修改关闭。运维尽量减少对原代码的修改，保持历史代码的纯洁性，提高系统的稳定性； 设计模式单例模式（Singleton Pattern）定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。 使用场景：1、要求生成唯一序列号的环境；2、整个项目需要一个共享访问点或共享数据。3、创建对象需要消耗的资源过多，如访问IO和数据库等资源。 懒汉模式：12345678910111213publicclass SingletonClass1 &#123; private SingletonClass1 instance = new SingletonClass1(); private SingletonClass1()&#123;&#125; public SingletonClass1 getInstance()&#123; returninstance; &#125;&#125; 饿汉模式：123456789101112131415161718192021publicclass SingletonClass2 &#123; /**静态内部类*/ privatestaticclass SingletonInstance &#123; //因为instance是静态的，不会构造多次 privatestaticfinal SingletonClass2 instance = new SingletonClass2(); &#125; private SingletonClass2()&#123;&#125; public SingletonClass2getInstance()&#123; return SingletonInstance.instance; &#125;&#125; 问题：一个单例对象在内存中长久不使用，JVM就认为这个对象是垃圾，在CPU资源空闲的的情况下该对象会被清理掉； 通常使用Spring可以让对象长久驻留内存。 工厂方法模式（Factory Pattern）定义：用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使用一个类的实例化延迟到其子类。示例: 12345678910111213141516171819202122232425publicclass ConcreteCreator extends Creator&#123; /**创建一个产品对象，创建类型可自行设定*/ @Override public &lt;T extends Procuct&gt; T createProduct(Class c) &#123; Procuct product = null; try &#123; product = (Procuct) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T)product; &#125;&#125; 补充说明：工厂方法，有很多扩展，比如简单的静态工厂模式，升级的多级工厂类，抽象工厂模式。 模板方法模式（Template Method Pattern）定义：定义一个操作中的算法框架放在抽象类中，而将一些步骤延迟到子类中。使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。（父类提供公共的模板方法，子类实现基本方法） 注意：为防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。 使用场景：1、多个子类有公有的方法，并且逻辑基本相同。2、重要、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能有各子类实现。3、重构时，模板方法经常使用。 示例： 123456789101112131415161718192021222324252627publicabstractclass AbstractClass &#123; //基本方法 protectedabstractvoid doSomething(); //基本方法 protectedabstractvoid doAnything(); //模板方法 publicfinalvoid templeteMethod()&#123; //公共的算法 // ................. //调用基本方法完成相关的逻辑 doSomething(); doAnything(); &#125;&#125; 代理模式（Proxy Pattern）定义：为其他对象提供一种代理以控制对这个对象的访问。普通代理：通过代理来访问角色，不能直接访问真实角色；真实角色的初始化放在代理类中。强制代理：真实角色初始化后，不能直接使用，必须获取代理类，用代理类调用对应的方法。动态代理：在实现阶段不用关心代理谁，在运行阶段才指定代理那个对象。 态代理部分示例： 12345678910111213141516171819202122232425262728293031323334353637/** * 动态代理类处理器 * InvocationHandler是JDK提供的动态代理接口 */publicclass GamePlayerProxyHandler implements InvocationHandler&#123; //被代理者 private Object o = null; public GamePlayerProxyHandler(Object o)&#123; this.o = o; &#125; @Override public Object invoke(Object proxy, Method method, Object[]args) throws Throwable &#123; return method.invoke(this.o, args); &#125;&#125;publicclass Client &#123; publicstaticvoid main(String[] args) &#123; IGamePlayer player = new GamePlayer(); //动态产生一个代理者 IGamePlayer playerProxy = (IGamePlayer) Proxy.newProxyInstance(player.getClass().getClassLoader(), newClass[]&#123;IGamePlayer.class&#125;, new GamePlayerProxyHandler(player)); //用代理者调用 playerProxy.login(&quot;李四&quot;, &quot;aaa&quot;); &#125;&#125; 原型模式（Prototype Pattern）定义：通过拷贝原型创建新的对象，而不是new。（在内存中以二进制流进行拷贝）拷贝有深拷贝和浅拷贝之分。 使用场景：1、资源优化场景：类初始化需要消耗非常多的资源。2、性能和安全要求的场景：通过new产生对象需要繁琐的数据准备或访问权限。3、一个对象多个修改者场景。 命令模式（Command Pattern）定义：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能；高内聚模式。 通常包含三个角色：Receive角色（执行具体命令），Command命令角色（声明所有命令），Invoker调用者角色 说明：命令模式结合责任链模式，实现命令族解析任务；结合模板方法模式，可以减少Command子类的膨胀问题。 使用场景：只要认为有命令的地方都可用。 观察者模式（Observer Pattern）定义：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象会得到通知并被自动更新。 使用场景：1、关联行为场景；2、事件多级触发场景；3、跨系统的消息交换场景，如消息队列的处理机制。 门面模式（Façade pattern）定义：要求一个子系统的外部与其内部的通信必须通过一个统一的对象接口。门面模式提供一个高层次的接口，使得子系统更易于使用。 使用场景：1、为一个复杂的模块或子系统提供一个供外界访问的接口。2、子系统相对独立，外界对子系统的访问只要黑箱操作即可。 注意事项：1、一个子系统可以有多个门面。2、门面不参与子系统内的业务逻辑。 适配器模式（Adapter Pattern）定义：将一个类的接口变成客户端所期待的另一种接口，从而使原本不匹配而无法在一起工作的两个类一起工作。通常包含三个角色：Target角色、Adapter源角色、Adapter适配器角色 使用场景：已经投产的项目修改时，经常使用。]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>JAVA</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
