<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vim编辑器进阶学习(二)</title>
      <link href="2022/03/23/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
      <url>2022/03/23/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h2><p><code>VIM</code>有十种寄存器，通过<code>:reg</code> 命令可以显示寄存器内容，通过<code>&quot; + 寄存器名称 + 命令</code>可以将内容放入寄存器或取出。</p><ul><li><p><strong>未命名寄存器（<code>&quot;</code>）</strong></p><p><code>VIM</code>会将删除指令（<code>d</code>、<code>c</code>、<code>s</code>、<code>x</code>）和复制指令（<code>y</code>） 的文本放入该寄存器中,每次指令执行内容会覆盖上次放入内容。</p></li><li><p><strong>编号寄存器（<code>0-9</code>）</strong></p><p><code>VIM</code> 将剪切和删除指令（除了<code>x</code>指令）的文本放入该寄存器中。<code>0</code> 号寄存器存储最近复制指令的文本，<code>1</code>号寄存器存储最近删除指令的文本（手动指定寄存器情况除外）,每成功执行一次指令<code>VIM</code>将前一个内容从<code>1</code> 号寄存器转移到<code>2</code> 号寄存器，<code>2</code> 号到<code>3</code>号，依此类推，<code>9</code> 号寄存器上一次内容将丢弃。</p></li><li><p><strong>小文本删除寄存器（<code>-</code>）</strong></p><p><code>VIM</code> 将删除小于一行的文本放入该寄存器中（如<code>x</code> 指令，手动指定寄存器情况除外）。</p></li><li><p><strong>命名寄存器（<code>a~z</code> 或 <code>A~Z</code>）</strong></p><p>完全由用户指定内容的寄存器，使用小写字母可以替换对应命名寄存器的内容（如：<code>&quot;ayy</code>指令），使用大写字母可以追加对应命名寄存器的内容（如：<code>&quot;Ayy</code>指令）,当<code>cpoptions</code> 标志位指定<code>&gt;</code></p></li><li><p><strong>只读寄存器（<code>.</code>、<code>%</code>、<code>:</code>）</strong></p><p><code>.</code>存储最近插入的文本寄存器，可以通过<code>c</code> 指令重复上一次操作。<code>%</code>存储当前文件名。<code>:</code>存储最近执行的命令。</p></li><li><p><strong>交换文件寄存器（<code>#</code>）</strong></p><p>存储了当前窗口交换文件的名字。这个寄存器也是只读的，主要是为了一个插件改变它之后再恢复它。</p></li><li><p><strong>表达式寄存器（<code>=</code>）</strong></p><p>存储<code>VIM</code> 表达式的寄存器，普通模式可以通过指令<code>&quot;=</code>进行存储，插入模式可以通过<code>&lt;C-r&gt; =</code>指令存储。更多参考文档<code>:h expression</code>。</p></li><li><p><strong>选择寄存器（<code>*</code>、<code>+</code>）</strong></p><p><code>GUI</code>系统剪切板寄存器，当剪切板无效或无法工作时将使用<strong>未命名寄存器</strong>代替。<code>X11</code> 提供了<code>PRIMARY</code>, <code>SECONDARY</code>, 和 <code>CLIPBOARD</code> 三种寄存器，其中<code>vim</code> 仅实现了<code>PRIMARY</code> 和 <code>CLIPBOARD</code>分别使用<code>*</code>和<code>+</code>表示。</p></li><li><p><strong>黑洞寄存器（<code>_</code>）</strong></p><p>该寄存器功能和<code>/dev/null</code>设备类似，写入这个寄存器的内容将消失，可以用来删除文本。如使用指令<code>&quot;_dd</code> 删除当前行。</p></li><li><p><strong>上次搜索寄存器</strong></p><p>存储最近一次搜索的内容，这个被使用于<code>n</code> 指令和<code>hlsearch</code> 指令。</p></li></ul><h2 id="宏macro"><a class="markdownIt-Anchor" href="#宏macro"></a> 宏（Macro)</h2><p>可以通过宏录制一组命令，然后重复执行。宏命令也存储在<code>vim</code> 寄存器中，并且必须在<code>normal</code> 模式下使用。</p><ul><li><p><strong>录制宏</strong></p><p>通过命令<code>q + 寄存器名称（0-9a-zA-Z&quot;）</code>开始录制。如：<code>qa</code>命令开始录制一个宏并存储在命名寄存器<code>a</code> 中，此时<code>vim</code> 左下方将显示<code>recording @a</code>。</p><pre class="highlight"><code class="vim"># 将下列每行文本中间隔字母转为大写my name <span class="hljs-keyword">is</span> lili!how old are you!what <span class="hljs-keyword">do</span> you do!-------------------------------------------<span class="hljs-number">1</span>、录制宏到 q 寄存器 `qq` recording @q ...<span class="hljs-number">2</span>、执行替换命令：gU 转大写字母命令 <span class="hljs-keyword">l</span> 向右移动光标 <span class="hljs-keyword">ws</span> 表示跳转到下一个单词(<span class="hljs-keyword">vim</span>-easymotion 插件) <span class="hljs-keyword">j</span> 向下移动光标 <span class="hljs-number">0</span> 回到行首<span class="hljs-number">0</span>gUlwsgUlwsgUlwsgUlj0-------------------------------------------# 新文本内容My Name Is Lili!how old are you!what <span class="hljs-keyword">do</span> you do!</code></pre></li><li><p><strong>停止宏录制</strong></p><p>开始一个宏命令录制后，可以按<code>q</code> 键停止宏录制。</p></li><li><p><strong>宏的使用</strong></p><p>录制好的宏可以通过<code>[数字] + @ + 寄存器名称（0-9a-zA-Z&quot;）</code>执行。<code>@</code>符号前可以加数字表示执行次数，如执行两次上面录制的宏<code>2@q</code>。</p><pre class="highlight"><code class="vim"># 执行两次录制的宏后文本内容My Name Is Lili!How Old Are You!What Do You Do!</code></pre><p>上面命令也可替换成<code>[数字] + @@</code> 命令表示重复执行前一个宏。如：<code>2@@</code>命令可以达到上面一样效果。</p><p>宏命令也可以通过<code>:normal</code>命令执行，如<code>:normal @q</code> 表示执行宏<code>q</code>。</p><blockquote><p>由于宏命令同样存储在<code>vim</code> 寄存器中，因此也可以利用寄存器特性对宏命令进行修改和追加，如<code>qQ</code> 命令就可以对宏<code>q</code> 进行命令追加。也可以直接修改寄存器内容对宏命令进行修改。</p></blockquote></li></ul><h2 id="文本对象text-objects"><a class="markdownIt-Anchor" href="#文本对象text-objects"></a> 文本对象（Text Objects）</h2><ul><li><p><strong>文本对象类型</strong></p><p>单词（<code>w</code>)、句子（<code>s</code>）、段落（<code>p</code>）</p><p><strong>区间对象：</strong></p><p><code>[</code>、<code>]</code>、<code>&#123;</code>、<code>&#125;</code>、<code>(</code>、<code>)</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&quot;</code>、<code>'</code>、<font color="red">`</font>、<code>t（tag 标签块)</code>、<code>b|B（block 块）</code></p></li><li><p><strong>文本对象范围</strong></p><p>inner(<code>i</code>)：不包含空格</p><p>around(<code>a</code>)：包含空格</p></li><li><p><strong>文本对象命令</strong></p><p><code>[number]&lt;command&gt;[Text Object]</code></p><p><strong>number</strong> 命令执行次数</p><p><strong>command 选项：</strong></p><ul><li><p>删除 <strong>delete(<code>d</code>)</strong></p></li><li><p>改变 <strong>change(<code>c</code>)</strong></p></li><li><p>复制 <strong>yank(<code>y</code>)</strong></p></li></ul></li><li><p><strong>示例</strong></p><p>i. 选择单词</p><p>文本：<code>Good morning everyone !</code></p><p><code>viw</code> 结果 <em style="background:red">Good</em> morning everyone !</p><p><code>vaw</code> 结果 <em style="background:red">Good </em>morning everyone !</p><p>ii. 删除单词</p><p><code>diw</code> 结果 <s>Good</s> morning everyone !<br><code>2daw</code> 结果 <s>Good morning</s>everyone !　（试试<code>2diw</code> 执行结果）</p><p>iii. 区块操作</p><p>文本：<code>[Good morning everyone !]</code></p><p><code>vi[</code> 结果 [<em style="background:red">Good morning everyone !</em>]</p><p>iv. 标签操作</p><p>文本：<code>&lt;div&gt;Good morning everyone !&lt;/div&gt;</code></p><p><code>vit</code> 结果 &lt;div&gt;<em style="background:red">Good morning everyone !</em>&lt;/div&gt;</p><blockquote><p>更多操作参考文档 <code>:h text-objects</code></p></blockquote></li></ul><h2 id="标记-marks"><a class="markdownIt-Anchor" href="#标记-marks"></a> 标记 marks</h2><h2 id="折叠"><a class="markdownIt-Anchor" href="#折叠"></a> 折叠</h2><h2 id="搜索与替换"><a class="markdownIt-Anchor" href="#搜索与替换"></a> 搜索与替换</h2>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议—TCP 传输控制协议</title>
      <link href="2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>尽管<code>TCP</code>和<code>UDP</code>使用相同的网络层，<code>TCP</code>却向应用层提供了与<code>UDP</code>完全不同的服务。</p><p><strong><code>TCP</code>提供了一种面向连接、可靠的字节流服务</strong> 。</p><p><strong>面向连接</strong> 意味着两个使用<code>TCP</code>的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个<code>TCP</code>连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。</p><p><strong>可靠性</strong> ：</p><ul><li>应用数据被分割成<code>TCP</code>认为最适合发送的数据块。这和<code>UDP</code>完全不同，应用程序产生的数据报长度将保持不变。由<code>TCP</code>传递给<code>IP</code>的信息单位称为报文段或段（<code>segment</code>）。</li><li>当<code>TCP</code>发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li>当<code>TCP</code>收到发自<code>TCP</code>连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</li><li><code>TCP</code>将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错， <code>TCP</code>将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。</li><li><code>TCP</code>报文段作为<code>IP</code>数据报来传输，而<code>IP</code>数据报的到达可能会失序，因此<code>TCP</code>报文段的到达也可能会失序。如果必要，<code>TCP</code>将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</li><li><code>IP</code>数据报会发生重复，<code>TCP</code>的接收端必须丢弃重复的数据。</li><li><code>TCP</code>还能提供流量控制。<code>TCP</code>连接的每一方都有固定大小的缓冲空间。<code>TCP</code>的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li></ul><blockquote><p><code>TCP</code>对字节流的内容不作任何解释。 <code>TCP</code>不知道传输的数据字节流是二进制数据，还是<code>ASCII</code>字符、<code>EBCDIC</code>字符或者其他类型数据。对字节流的解释由<code>TCP</code>连接双方的应用层解释。</p><p>这种对字节流的处理方式与<code>Unix</code>操作系统对文件的处理方式很相似。<code>Unix</code>的内核对一个应用读或写的内容不作任何解释，而是交给应用程序处理。对<code>Unix</code>的内核来说，它无法区分一个二进制文件与一个文本文件。</p></blockquote><h3 id="tcp-首部"><a class="markdownIt-Anchor" href="#tcp-首部"></a> TCP 首部</h3><p><code>TCP</code>数据被封装在一个<code>IP</code>数据报中，如下图：</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/TCP数据在IP数据报中封装.gif" alt="TCP数据在IP数据报中封装" style="max-width:60%;"><span class="image-caption">TCP数据在IP数据报中封装</span><p><code>TCP</code>首部数据格式如下图：</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/TCP首部.gif" alt="TCP首部" style="max-width:60%;"><span class="image-caption">TCP首部</span><p>每个<code>TCP</code>段都包含 <strong>源端口</strong> 和 <strong>目的端口号</strong> 字段，用于寻找发端和收端应用进程。这两个值加<br>上<code>IP</code>首部中的源端<code>IP</code>地址和目的端<code>IP</code>地址唯一确定一个<code>TCP</code>连接。</p><blockquote><p>一个<code>IP</code>地址和一个端口号也称为一个套接字（<code>socket</code>）。这个术语出现在最早的<code>TCP</code>规范（<code>RFC793</code>）中，后来它也作为表示伯克利版的编程接口。</p><p>第个<code>TCP</code>连接由一对套接字（<code>socket pair</code>）(包含客户<code>IP</code>地址、客户端口号、服务器<code>IP</code>地址和服务器端口号的四元组 )组成，可唯一确定互联网络中每个<code>TCP</code>连接的双方。</p></blockquote><p><strong>序号</strong> 字段，<code>TCP</code>是面向字节流的，在一个<code>TCP</code>连接中，传送的字节流中的每个字节都被顺序编号。序号是<code>32bit</code>无符号数，序号到达<code>2^32-1</code>后从<code>0</code>开始。该字段标识从<code>TCP</code>发端向收端发送的数据字节流中的第一个字节的序号。</p><blockquote><p>当建立一个新的连接时， <code>SYN</code>标志被打开值为<code>1</code>。序列号字段包含此主机为此连接选择的 <strong>初始序号（Initial Sequence Number，ISN）</strong> 。该主机要发送数据的第一个字节序号为这个<code>ISN</code>加<code>1</code>，因为<code>SYN</code>标志消耗了一个序号。</p><p><code>RFC 793</code>中指出<code>ISN</code>被绑定在一个（可能是虚假的）<code>32</code>位时钟上，其低位大约每<code>4</code>微秒递增一次。直到超过<code>2^32</code>后又从<code>0</code>开始，这个周期大概是<code>4.55</code>小时。所以，如果<code>TCP Segment</code>  <strong>段最大寿命（Maximum Segment Lifetime，MSL）</strong> 即在网络上的存活时间不超过  <code>4.55</code>小时，那么就不会用到重复的<code>ISN</code>。</p></blockquote><p><strong>确认序号</strong> 字段，包含发送确认的一端所期望收到的下一个序号，即应当是上次已成功收到数据字节序号加<code>1</code>。只有<code>ACK</code>标志为<code>1</code>时该字段才有效。</p><blockquote><p>发送<code>ACK</code>无需任何代价，因为<code>32bit</code>的确认序号字段和<code>ACK</code>标志一样，总是<code>TCP</code>首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， <code>ACK</code>标志也总是被设置为<code>1</code>。</p></blockquote><p><code>TCP</code>为应用层提供 <strong>全双工服务</strong> 。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p><blockquote><p><strong>全双工</strong> ： 指可以同时（瞬时）进行信号的双向传输（<code>A→B</code>且<code>B→A</code>）。指<code>A→B</code>的同时<code>B→A</code>，是瞬时同步的。</p><p><strong>半双工</strong> ：指一个时间内只有一个方向的信号传输（<code>A→B</code>或<code>B→A</code>）。</p></blockquote><p><strong>长度</strong> 字段，首部中<code>32 bit</code>的数目。占<code>4bit</code>，因此最大值为<code>1111</code>，十进制表示为<code>15</code>，所以以<code>TCP</code>首部最大字节为<code>15*(32/8)=60</code>字节。</p><p><code>6</code>个 <strong>标志</strong> 比特字段，它们可同时被设置为<code>1</code>，具体如下：</p><p><code>URG</code> 紧急指针（<code>urgent pointer</code>）有效</p><p><code>ACK</code> 确认序号有效。</p><p><code>PSH</code> 接收方应该尽快将这个报文段交给应用层。</p><p><code>RST</code> 重建连接。</p><p><code>SYN</code> 同步序号用来发起一个连接。</p><p><code>FIN</code> 发端完成发送任务。</p><p><strong>窗口大小</strong> 字段，<code>TCP</code>的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端真正期望接收的字节。窗口大小占<code>16bit</code>，因此窗口大小最大字节为<code>2^16-1=65535</code>字节。</p><p><strong>检验和</strong> 字段，覆盖了整个<code>TCP</code>报文段（<code>TCP</code>首部+数据）。这是一个强制性字段，由发端计算和存储，并由收端进行验证。计算方法与<code>UDP</code>类似，使用一个伪首部。</p><p><strong>紧急指针</strong> 字段，只有当<code>URG</code>被设置（即值为<code>1</code>时），该字段才生效。它是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</p><p><strong>选项</strong> 字段，长度可变，最长可达<code>4</code>字节。</p><blockquote><p><code>TCP</code>最初只规定了一种选项，即 <strong>最大报文段长度（Maximum Segment Szie，MSS）</strong> 。<code>MSS</code>是每一个<code>TCP</code>报文段中的数据字段的最大长度。数据字段加上<code>TCP</code>首部才等于整个的<code>TCP</code>报文段。所以<code>MSS</code>并不是整个<code>TCP</code>报文段的最大长度，而是<code>TCP</code>报文段长度减去<code>TCP</code>首部长度”。</p></blockquote><h3 id="tcp-连接的建立与终止"><a class="markdownIt-Anchor" href="#tcp-连接的建立与终止"></a> TCP 连接的建立与终止</h3><p>使用<code>telnet</code>命令建立一个<code>TCP</code>连接：</p><pre class="highlight"><code class="bash">$ telnet 192.168.1.134 13101 discard <span class="hljs-comment"># discard 是一个服务类似于 Linux 中 /dev/null 作用，用于 tcp/ip 测试</span>Trying 192.168.1.134..Connected to 192.168.1.134.Escape character is <span class="hljs-string">'^]'</span>.^]            <span class="hljs-comment"># 进入 telnet 命令行</span>telnet&gt; quit  <span class="hljs-comment"># 退出 telnet</span>Connection closed.-----------------------------------------------<span class="hljs-comment"># tcpdump 命令监控</span>$ tcpdump78: 192.168.31.62.54258 &gt; 39.106.86.134.13101: S , seq 3984939603, win 65535, length 074: 39.106.86.134.13101 &gt; 192.168.31.62.54258: S , seq 2131422913, ack 3984939604, win 28960, length 066: 192.168.31.62.54258 &gt; 39.106.86.134.13101: . , ack 1, win 2058, length 0144: 39.106.86.134.13101 &gt; 192.168.31.62.54258: P , seq 1:79, ack 1, length 7866: 192.168.31.62.54258 &gt; 39.106.86.134.13101: . , ack 79, win 2057, length 0</code></pre><p>对于<code>TCP</code>段，每行输出格式如下：</p><p><strong>源 &gt; 目的 : 标志</strong></p><p>其中标志代表<code>TCP</code>首部<code>6</code>个标志中的<code>4</code>个，字符含义如下：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">标志</th></tr></thead><tbody><tr><td style="text-align:center">S</td><td style="text-align:center">SYN</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">FIN</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">RST</td></tr><tr><td style="text-align:center">P</td><td style="text-align:center">PSH</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">表示以上四个标志比特均置 0</td></tr></tbody></table><blockquote><p>上表中四个标志比特中的多个可能同时出现在一个报文段中，但通常一次只见到一个。</p><p><code>TCP</code>首部中的其他两个标志比特—<code>ACK</code> 和<code>URG</code>—<code>tcpdump</code>将作特殊显示。</p></blockquote><p>第一行中，<code>seq</code>表示序号，<code>ack</code>表示确认序号，<code>win</code>表示窗口大小，<code>length</code>表示发送数据长度（上例中没有发送任何数据所以为<code>0</code>）。</p><p><em><strong>为什么，第三行，<code>ack</code>值为<code>1</code>，而不是前一个<code>seq+1</code>？</strong></em></p><p>是因为<code>tcpdump</code>命令默认显示相对序号值，如果想强制显示绝对序列值可以加上<code>-S</code>选项。</p><p>第四行，序号为<code>1:79</code>，表示 <strong>开始序号:结尾序号(不包含)</strong> 。这种格式只在相对序号模式下显示，结尾序号值为 <strong>开始序号+length</strong> 的和，这样显示方便看出数据的长度。因为是不包含关系，所以它就的第五行确认序号<code>ack</code>。</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/TCP链接断开.gif" alt="状态机与连接、传输数据、断开连接" style="max-width:80%;"><span class="image-caption">状态机与连接、传输数据、断开连接</span><p>如上图，建立一个链接需要 <strong>三次握手</strong> ，因为通信双方要相互通知对方自己的初始化序号，作为以后数据通信序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p><p>断开一个链接需要 <strong>四次挥手</strong> ，这是由<code>TCP</code>的半关闭（<code>half-close</code>）造成的。一个<code>TCP</code>连接是全双工，因此每个方向必须单独地进行关闭。只不过，有一方是被动的。</p><blockquote><p>当一端收到一个<code>FIN</code>只意味着在这一方向上没有数据流动。一个<code>TCP</code>连接在收到一个<code>FIN</code>后仍能发送数据。而这对利用半关闭的应用来说是可能的，尽管在实际应用中只有很少的<code>TCP</code>应用程序这样做。</p></blockquote><p>为了使用这个特性，编程接口必须为应用程序提供一种方式来说明 “ <em><strong>我已经完成了数据传送，因此发送一个文件结束（<code>FIN</code>）给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束（<code>FIN</code>）</strong></em> ”。</p><p>如果应用程序不调用<code>close</code>而调用<code>shutdown</code>，且第二个参数值为<code>1</code>，则<code>socket</code>接口支持半关闭。</p><p>典型的例子是<code>Unix</code>中的<code>rsh</code>命令，它将完成在另一个系统上执行一个命令。它的操作很简单，就是将输入的指令复制给<code>TCP</code>连接，并将结果从<code>TCP</code>链接中复制给标准输出。当输入指令后，<code>rsh</code>客户端执行半关闭，并继续接收来自<code>TCP</code>另一端的数据直到结束。</p><h3 id="状态机转换解释"><a class="markdownIt-Anchor" href="#状态机转换解释"></a> 状态机转换解释</h3><p><strong>建立链接三次握手：</strong></p><hr><ul><li><p><code>CLOSED</code></p><p>起点，当超时或连接关闭时进入该状态。它并不是一个真正状态，而是这个状态图的假想起点和终点。</p></li><li><p><code>LISTEN</code></p><p>服务器等待连接的状态，服务器进入该状态后开始监听客户发送的连接请求。这被称为“被动打开”。</p></li><li><p><code>SYN_SENT</code></p><p>当第一次握手时，客户启动一个连接。客户调用<code>connect()</code>，并向服务器发送一个<code>SYN</code>消息，然后进入该状态，等待服务器的确认。如果服务器不能被连接，它将进入<code>CLOSED</code>状态。</p></li><li><p><code>SYN_RCVD</code></p><p>第二握手时发生，服务器从客户接收<code>SYN</code>，服务器从<code>LISTEN</code>进入该状态。然后向客户发送一个<code>SYN + ACK</code>。</p><blockquote><p>状态图还描述一种情况，当客户发送一个<code>SYN</code>，并且从服务器接收了一个<code>SYN</code>请求。也就是，同时发起两个连接请求（ <strong>同时打开</strong> ），这时客户状态将从<code>SYN_SENT</code>状态转换到<code>SYN_RCVD</code>状态。</p></blockquote></li><li><p><code>ESTABLISHED</code></p><p>在第三次握手阶段，客户从服务器接收<code>SYN + ACK</code>后，它将发送一个<code>ACK</code>确认给服务器，客户进入<code>ESTABLISHED</code>状态，指示客户已经准备好。但是<code>TCP</code>需要两端都做好传输数据准备，因此在服务器接收到客户的<code>ACK</code>后从<code>SYN_RCVD</code>状态进入<code>ESTABLISHED</code>状态。此时就可以后续的数据传输了。</p></li></ul><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/TCP建立链接状态转换图.gif" alt="TCP建立链接状态转换图" style="max-width:60%;"><span class="image-caption">TCP建立链接状态转换图</span><p>如上图，建立连接一系列状态变化：</p><ul><li><p><strong>客户</strong> 和 <strong>服务器</strong> 初始状态是<mark>CLOSED</mark>。</p></li><li><p>程序调用<code>UNIX “listen()”</code>将触发 “被动打开动作”，这个状态转换不触发任何响应。<strong>服务器</strong> 进入<mark>LISTEN</mark>状态。</p></li><li><p>当要建立一个<code>TCP</code>链接时，客户程序调用<code>UNIX “connect()”</code>，这个事件被称为“主动打开”。这个转换将向 <strong>服务器</strong> 传送一个<code>SYN</code>信息。<strong>客户</strong> 进入<mark>SYN_SENT</mark>状态。</p></li><li><p>当 <code>SYN</code>信息被 <strong>服务器</strong> 接收后，它会向 <strong>客户</strong> 发送<code>SYN + ACK</code>信息。<strong>服务器</strong> 进入<mark>SYN_RCVD</mark>状态。</p></li><li><p>当<code>SYN + ACK</code>被 <strong>客户</strong> 接收，它会向 <strong>服务器</strong> 发送一个<code>ACK</code>信息。<strong>客户</strong> 进入<mark>ESTABLISHED</mark>状态。</p><blockquote><p>客户完成，客户可以发送和接收数据消息。</p></blockquote></li><li><p>最后，当<code>ACK</code>被 <strong>服务器</strong> 接收后，<strong>服务器</strong> 进入<mark>ESTABLISHED</mark>状态。</p><blockquote><p>服务器完成，服务器也可以发送和接收消息。</p></blockquote></li></ul><br><p><strong>断开链接四次挥手</strong>：</p><hr><ul><li><p><code>FIN_WAIT_1</code></p><p>第一次挥手，客户执行主动关闭，就会从<code>ESTABLISHED</code>进入该状态。然后发送一个<code>FIN</code>信息。</p></li><li><p><code>CLOSE_WAIT</code></p><p>接收客户发送来的<code>FIN</code>，同时发送出<code>ACK</code>，此时服务器进入该状态。</p></li><li><p><code>FIN_WAIT_2</code></p><p>接收到服务器的<code>ACK</code>消息，客户进入该状态。</p></li><li><p><code>CLOSING</code></p><p>当客户与服务器同时发起一个关闭请求（ <strong>同时关闭</strong> ）， 两边都在等待接收到对方发给自己的<code>ACK</code>之前收到对方的<code>FIN</code>，此时两边都进入<code>CLOSING</code>状态。</p></li><li><p><code>LAST_ACK</code></p><p>服务器发起一个关闭请求，并从<code>CLOSE_WAIT</code>状态进入该状态。</p></li><li><p><code>TIME_WAIT</code></p><p>通过状态图，可以看出总共有三种状态可以进入该状态：</p><ol><li><p><code>CLOSING</code>进入</p><p>同时关闭时，当客户和服务器都收到<code>ACK</code>时，会进入该状态。</p></li><li><p><code>FIN_WAIT_1</code>进入</p><p>客户执行主动关闭，已经发送了<code>FIN</code>并且等待<code>ACK</code>；此时服务端也发起了一个主动关闭，并且发送了<code>FIN</code>。客户端收到了前一个<code>ACK</code>，也收到了服务器<code>FIN</code>，并且发送了<code>ACK</code>。此时进入该状态。</p><blockquote><p>该状态转换与进入<code>CLOSING</code>接收<code>FIN</code>与<code>ACK</code>顺序不一样。</p></blockquote></li><li><p><code>FIN_WAIT_2</code>进入</p><p>客户端完成它自己发起的关闭请求后，接收了服务器发送的<code>FIN</code>，然后响应了<code>ACK</code>后进入该状态。</p></li></ol></li><li><p><code>2MSL</code></p><p><code>TIME_WAIT</code>状态也称为<code>2MSL</code>，每个实现必须选择一个值作为 <strong>报文段最大生存时间（Maximum Segment Lifetime，MSL）</strong>  ，它是任何报文段被丢弃前在网络内的最长时间。</p><blockquote><p><code>RFC 793[Postel 1981c]</code>指出<code>MSL</code>为<code>2</code>分钟。然而，实现中的常用值是<code>30</code>秒，<code>1</code>分钟或<code>2</code>分钟。</p></blockquote><p>对于一个具体实现给定的<code>MSL</code>值，处理原则是：当一个<code>TCP</code>执行主动关闭时，并发回最后一个<code>ACK</code>，该连接必须保持<code>TIME_WAIT</code>状态为两倍的<code>MSL</code>。这样可以让<code>TCP</code>再次发送最后的<code>ACK</code>以防这个<code>ACK</code>丢失（另一端超时并重发最后的<code>FIN</code>）。</p><blockquote><p>这种<code>2MSL</code>等待的另一种影响是，<code>socket</code>定义的双向连接（客户<code>IP</code>、客户端口、服务器<code>IP</code>、服务器端口）在<code>2MSL</code>等待结束前不能被重新使用。大多数<code>TCP</code>实现强加了更严格的限制，在<code>2MSL</code>等待期间，<code>Socket</code>中使用的本地端口默认情况下不能再被使用。</p><p>某些实现和<code>API</code>提供了一种避开该限制的方法，使用<code>Socket API</code>时可以指定<code>SO_REUSEADDR</code>选项。它允许调用者对处于<code>2MSL</code>等待的本地端口进行赋值。但<code>TCP</code>原则上仍将避免使用仍处于<code>2MSL</code>连接中的端口。</p></blockquote><p>客户执行主动关闭并进入<code>TIME_WAIT</code>是正常的。服务器通常执行被动关闭，不会进入<code>TIME_WAIT</code>状态。如果终止一个客户程序，并立即重新启动这个客户程序，则这个新客户程序将不能重用相同的本地端口。这不会带来什么问题，因为客户使用临时本地端口，而并不关心这个临时端口号是什么。</p><p>然而，对于服务器，情况就有所不同，因为服务器使用熟知端口。如果我们终止一个已经建立连接的服务器程序，并试图立即重新启动这个服务器程序，服务器程序将不能把它的这个熟知端口赋值给它的端点，因为那个端口是处于<code>2MSL</code>连接的一部分。在重新启动服务器程序前，它需要在<code>1 ~ 4</code>分钟。</p><p><em><strong>如果我们试图从其他主机来建立这个连接会如何？</strong></em></p><p>首先我们必须在<code>sun</code>服务器上以<code>-A</code>标记来重新启动服务器程序，因为它需要的端口还处于<code>2MSL</code>等待连接的一部分。</p><pre class="highlight"><code class="bash">[root@study ~]<span class="hljs-comment"># sock -A -s 6666</span></code></pre><p>接着，在<code>2MSL</code>等待结束前，我们在另一台主机上启动客户程序：</p><pre class="highlight"><code class="bash">[root@study ~]<span class="hljs-comment"># sock -b1098 sun 6666</span>connected on 38.106.86.134.1098 to 38.106.86.133.6666</code></pre><p>结果连接成功了！这违反了<code>TCP</code>规范，但被大多数的伯克利版实现所支持。这些实现允许一个新的连接请求到达仍处于<code>TIME_WAIT</code>状态的连接，只要新的序号大于该连接前一个替身的最后序号。</p></li></ul><h3 id="数据传输"><a class="markdownIt-Anchor" href="#数据传输"></a> 数据传输</h3><p><code>TCP</code>通常需要处理两类数据，一类是成块数据（如：<code>FTP</code>、<code>电子邮件</code>），一类是交互数据（如<code>Telnet</code>、<code>Rlogin</code>）。按分组数量计算，两类数据各占一半；按照字节计算比例约为<code>9:1</code>。这是因为成块数据的报文段基本上都是满长度（通常为<code>512</code>字节数据），而交互数据则小的多（通常小于<code>10</code>个字节）。<code>TCP</code>需要同时处理这两类数据，但使用的处理算法则有所不同。</p><h4 id="交互式输入"><a class="markdownIt-Anchor" href="#交互式输入"></a> 交互式输入</h4><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/交互式按键回显.gif" alt="TCP数据交互式按键回显" style="max-width:60%;"><span class="image-caption">TCP数据交互式按键回显</span><p>上图是一个<code>Rlogin</code>连接上键入一个交互命令时所产生的数据流。注意到通常每一个交互按键都会产生一个数据分组，也就是说，每次从客户传到服务器的是一个字节的按键（而不是每次一行）。并且，<code>Rlogin</code> 需要远程服务器回显客户键入的字符，这样就会产生<code>4</code> 个报文段：</p><ol><li>来自客户的交互按键。</li><li>来自服务器的按键确认。</li><li>来自服务器的按键回显。</li><li>来自客户的按键回显确认。</li></ol><blockquote><p><code>Rlogin</code> 每次总是从客户发送一个字节到服务器，<code>Telnet</code> 则有一个选项允许客户发送一行到服务器，通过这个选项可以减少网络负载。<code>BDS/386</code> 通过设置一个<code>Rlogin</code>连接的<code>TOS</code>来获得最小时延。</p></blockquote><h5 id="时延的确认"><a class="markdownIt-Anchor" href="#时延的确认"></a> 时延的确认</h5><p>通常可以将<code>Rlogin</code>报文段<code>2</code>和<code>3</code>进行合并，将按键确认和按键回显一起发送，这种合并的技术称为<strong>时延的确认</strong>。<code>TCP</code> 在接收到数据时并不立即发送<code>ACK</code>，它会推迟发送以便将<code>ACK</code>与需要沿该方向发送的数据一起发送（这种现象有时也称为数据稍带<code>ACK</code>）。</p><blockquote><p>绝大多数实现采用的时延为<code>200ms</code>，也就是说，<code>TCP</code>将以最大<code>200ms</code> 的时延等待是否有数据一起发送。</p></blockquote><p>观察下图客户接到数据和发送<code>ACK</code>之间的时间差，就会发现它们似乎是随机的：123.5、65.6、109.0、132.2。而发送<code>ACK</code>的实际时间（从 0 开始）：139.9、539.3、940.1（用星号标出），这些时间差则是<code>200ms</code>整数倍。出现这两种现象的原因是<code>TCP</code>使用了一个<code>200ms</code>定时器，该定时器以相对内核引导的<code>200ms</code>固定时间溢出；由于要确认的数据是随机到达的（16.4、474.3、831.1 等），所以<code>TCP</code>在内核的<code>200ms</code> 定时器的下一次溢出时得到通知可能是将来的<code>1~200ms</code>中的任何时刻。</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/时延的确认.gif" alt="时延的确认" style="max-width:60%;"><span class="image-caption">时延的确认</span><blockquote><p><code>Host Requirements RFC</code>声明<code>TCP</code>需要实现一个经受时延的<code>ACK</code>，但时延必须小于<code>500ms</code>。</p></blockquote><h5 id="nagle-算法"><a class="markdownIt-Anchor" href="#nagle-算法"></a> Nagle 算法</h5><p>在一个<code>Rlogin</code>连接上客户一般每次发送一个字节到服务器，这就产生了一些<code>41</code>字节长的分组（<code>20</code>字节的<code>IP</code>首部、<code>20</code>字节的<code>TCP</code>首部和<code>1</code>个字节的数据）。在局域网上，这些小分组（被称为微小分组(<code>tinygram</code>)）通常不会引起麻烦，因为局域网一般不会出现拥塞。但在广域网上，则会增加拥塞出现的可能。</p><p>一种简单和友好的方法就是采用<code>RFC 896 [Nagle 1984]</code>中所建议的<code>Nagle</code>算法。 <strong>该算法要求一个<code>TCP</code>连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。<code>TCP</code>收集这些少量的分组，并在确认到来时以一个分组的方式发出去。</strong> 该算法的优越之处在于它是自适应的（即确认到达得越快，数据也就发送的越快），在希望减少微小分组数目的低速广域网上，则会发送更少的分组。</p><blockquote><p>从上图中可以看出，在以太网上一个字节被发送、确认和回显的平均往返时间约为<code>16ms</code>（16.5、16.3、16.5），因此每秒大约传送<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><mn>62.5</mn></mrow><annotation encoding="application/x-tex">1000/16=62.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span>个字符。为了产生比这个速度更快的数据，我们每秒键入的字符必须多于<code>60</code>个，这表明在局域网环境下两个主机之间发送数据时很少使用这个算法。</p></blockquote><p>当往返时间（<code>RTT</code>）增加时，如在下图，通过一个广域网传输，情况就会发生变化。首先注意到从<code>slip</code>到<code>远程服务器</code>不存在经受时延的<code>ACK</code>，这是因为在时延定时器溢出之前总是有数据等待发送。其次，从左到右待发数据长度是不同的，分别为<code>1</code>、<code>1</code>、<code>2</code>、<code>1</code>、<code>2</code>，<code>2</code>、<code>3</code>、<code>1</code>和<code>3</code>个字节，这是因为客户只有收到前一个数据的确认后才发送已经收集的数据。通过使用<code>Nagle</code>算法，发送<code>16</code>个字节的数据客户端只需要使用<code>9</code>个报文段，而不再使用<code>16</code>个。</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/广域网rlogin数据传输.gif" alt="广域网 rlogin 数据传输" style="max-width:60%;"><span class="image-caption">广域网 rlogin 数据传输</span><blockquote><p>报文段<code>14</code>和<code>15</code>看起来似乎与<code>Nagle</code>算法相违背，但是通过观察其序号发现，确认序号是<code>54</code>，因此报文段<code>14</code>是报文段<code>12</code>中确认的应答。客户在发送该报文段之前，接收到了来自服务器的报文段<code>13</code>，报文段<code>15</code>中包含了对序号为<code>56</code>的报文段<code>13</code>的确认。因此即使从客户到服务器有两个连续返回的报文段，客户也是遵守<code>Nagle</code>算法的。</p></blockquote><p>上图中，报文段<code>12</code>不包含任何数据，因此可以假定这是一个时延的<code>ACK</code>。服务器当时一定非常忙，因此无法在服务器定时溢出前及时处理所收到的字符。</p><h5 id="关闭-nagle-算法"><a class="markdownIt-Anchor" href="#关闭-nagle-算法"></a> 关闭 Nagle 算法</h5><p>在一些实时性要求比较高的场景下，采用了<code>Nagle</code>算法会让用户感觉到时延，所以我们可以选择关闭<code>Nagle</code>算法。</p><p>在一个交互注册过程中键入终端一个特殊功能键<code>F1</code>，这个功能键通常会产生三个字节的字符序列：一个转义字符、一个左括号<code>[</code>和一个<code>M</code>。如果<code>TCP</code>每次只得到一个字符它可能会发送序列中的第一个字符，然后缓存其他字符并等待。但当服务器接收到该字符后，它并不发送确认，而是继续等待接收序列中的其他字符。因此会经常触发服务器的时延确认算法，对于交互用户而言，这将产生明显的时延。</p><blockquote><p><code>Socket API</code>可以使用<code>TCP_NODELAY</code>选项来关闭<code>Nagle</code>算法。<br><code>Host Requirements RFC</code>声明<code>TCP</code>必须实现<code>Nagle</code>算法，但必须为应用提供一种方法来关闭该算法在某个连接上执行。</p></blockquote><h4 id="成块数据"><a class="markdownIt-Anchor" href="#成块数据"></a> 成块数据</h4><p>与<code>TFTP</code>使用了停止等待协议不同，<code>TCP</code>使用的被称为 <strong>滑动窗口协议</strong> 的另一种形式的流量控制方法。该协议允许发送方在停止并待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议 — TFTP 与 BOOTP 协议</title>
      <link href="2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="tftp-协议"><a class="markdownIt-Anchor" href="#tftp-协议"></a> TFTP 协议</h3><p><strong>简单文件传送协议（Trivial File Transfer Protocol，TFTP）</strong>，最初用于无盘系统（通常是无盘系统或者X终端）。与<code>FTP</code>协议不同，为了更简单、小巧，<code>TFTP</code>被设计使用<code>UDP</code>。<code>TFTP</code>(及其所需的<code>UDP</code>、<code>IP</code>和设备驱动程序)可以装入只读存储器。</p><h4 id="协议"><a class="markdownIt-Anchor" href="#协议"></a> 协议</h4><p>客户和服务器之间的每次交换开始时，客户请求服务器读取或写入一个文件。请求报文格式如下：</p><img src="/2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/TFTP报文格式.gif" alt="5种TFTP报文格式" style="max-width:60%;"><span class="image-caption">5种TFTP报文格式</span><p><strong>操作码</strong> 字段，读请求<code>RRQ</code>，操作码为<code>1</code>；写请求<code>WRQ</code>，操作码为<code>2</code>。</p><p><strong>文件名</strong> 字段，表示客户要读取或写入的位于服务器上的文件。文件字段以<code>0</code>字节作为结束。</p><p><strong>模式</strong> 字段，一个<code>ASCII</code>码串，同样以<code>0</code>字节结束。<code>netascii</code>表示数据以成行的<code>ASCII</code>码字符组成，以两个字节—回车符跟换行符（<code>CR/LF</code>）作为结束符，默认使用该模式；<code>octet</code>表示将数据看作<code>8bit</code>一组的字节流而不作任何解释。</p><p><strong>块编号</strong> 字段，每个数据分组包含一个块编号字段，它以后要在确认分组中使用。</p><blockquote><p>当<code>TFTP</code>客户需要发送一个读请求说明要读的文件名和文件模式 (<code>mode</code>)。如果这个文件能被这个客户读取，<code>TFTP</code>服务器就返回一个块编号为<code>1</code>的数据分组。<code>TFTP</code>客户又发送一个块编号为<code>1</code>的<code>ACK</code>。<code>TFTP</code>服务器随后发送块编号为<code>2</code>的数据。<code>TFTP</code>客户发回块编号为<code>2</code>的<code>ACK</code>。重复这个过程直到这个文件传送完。除了最后一个数据分组可含有不足<code>512</code>字节的数据，其他每个数据分组均含有<code>512</code>字节的数据。当<code>TFTP</code>客户收到一个不足<code>512</code>字节的数据分组，就知道它收到最后一个数据分组。</p><p>在写请求的情况下， <code>TFTP</code> 客户发送<code>WRQ</code>指明文件名和模式。如果该文件能被 该客户写，<code>TFTP</code>服务器就返回块编号为<code>0</code>的<code>ACK</code>包。该客户就将文件的头<code>512</code>字节以块编号为<code>1</code>发出。服务器则返回块编号为<code>1</code>的<code>ACK</code>。</p></blockquote><p>这种类型的数据传输称为<strong>停止等待协议</strong>。它只用在一些简单的协议，（如<code>TFTP</code>，在任一时刻外部网络中只有一个数据包处于传输中，并且任一方每接收到一个包，就要又发送一个新的包来作为回复，一直到文件传输完毕）。<code>TCP</code>提供了不同形式的确认，能提供更高的系统吞吐量。<code>TFTP</code>的优点在于实现的简单而不是高的系统吞吐量。</p><p>最后一种<code>TFTP</code>报文类型是差错报文，它的操作码为<code>5</code>。它用于服务器不能处理读请求或写请求的情况。在文件传输过程中的读和写差错也会导致传送这种报文，接着停止传输。<strong>差错编号</strong> 字段给出一个数字的差错码，跟着是一个<code>ASCII</code>表示的 <strong>差错报文</strong> 字段，可能包含额外的操作系统说明的信息。</p><blockquote><p>既然<code>TFTP</code>使用不可靠的<code>UDP</code>，<code>TFTP</code>就必须处理分组丢失和分组重复。分组丢失可通过发送方的超时与重传机制解决，在原先的<a href="https://zh.wikipedia.org/wiki/TFTP">TFTP</a>（<a href="https://tools.ietf.org/html/rfc783">RFC 783</a>）版本里这会引起一个叫 <strong><a href="https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%96%B0%E6%89%8B%E7%97%87%E5%80%99%E7%BE%A4">魔术新手综合症（Sorcerer’s Apprentice Syndrome，SAS）</a></strong> 问题，在第二版的TFTP（<a href="https://tools.ietf.org/html/rfc1350">RFC 1350</a>）被修正，说明里指出只有第一个ACK会被承认并引发下一个资料区块的传送，同一份资料的ACK将被直接忽略。</p></blockquote><h4 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h4><p><code>TFTP</code>分组中并不提供用户名和口令，这是它的一个特征（即，“安全漏洞”）。由于<code>TFTP</code>是设计用于系统引导过程进程，它不可能提供用户名和口令。</p><p>这一特性被许多解密高手用于获取<code>Unix</code>口令文件的复制，然后来猜测用户口令。为防止这种类型的访问，目前大多数<code>TFTP</code>服务器提供了一个选项来限制只能访问特定目录下的文件（<code>Unix</code>系统中通常是 <code>/tftpboot</code> ）。这个目录中只包含无盘系统进行系统引导时所需的文件。</p><p>对其他的安全性， <code>Unix</code>系统下的<code>TFTP</code>服务器通常将它的用户<code>ID</code>和组<code>ID</code>设置为不会赋给任何真正用户的值。这只允许访问具有读或写属性的文件。</p><h3 id="bootp-协议"><a class="markdownIt-Anchor" href="#bootp-协议"></a> BOOTP 协议</h3><p><strong>引导程序协议（Bootstrap Protocol，BOOTP）</strong> ，基于<code>IP/UDP</code>协议，也称自举协议，是<code>DHCP</code>协议的前身。用于无盘工作站的局域网中，可以让无盘工作站从一个中心服务器上获得<code>IP</code>地址。</p><p>在进行系统引导时，能够通过<code>RARP</code>来获取它的<code>IP</code>地址，但是会有两个问题：</p><ul><li><code>IP</code>地址是返回的唯一结果。</li><li><code>RARP</code>使用链路层广播，所以它的请求不会被路由器转发，迫使每个网络都要设置一个<code>RARP</code>服务器。</li></ul><p><code>BOOTP</code>使用<code>UDP</code>，且通常需与<code>TFTP</code>协同工作，用于无盘系统进行系统引导的替代方法。</p><h4 id="分组格式"><a class="markdownIt-Anchor" href="#分组格式"></a> 分组格式</h4><p><code>BOOTP</code>请求和应答均被封装在<code>UDP</code>数据报中，如下：</p><img src="/2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/BOOTP分组格式.gif" alt="BOOTP 分组格式" style="max-width:60%;"><span class="image-caption">BOOTP 分组格式</span><p>下图是一个长度为<code>300</code>字节的<code>BOOTP</code>请求和应答格式：</p><img src="/2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/BOOTP请求和应答的格式.gif" alt="BOOTP 请求和应答的格式" style="max-width:60%;"><span class="image-caption">BOOTP 请求和应答的格式</span><p><strong>操作码</strong> 字段，请求为<code>1</code>；应答为<code>2</code>。</p><p><strong>硬件类型</strong> 字段，<code>1</code>表示<code>10Mb/s</code>的以太网，与<code>ARP</code>请求或应答含义相同。</p><p><strong>硬件地址长度</strong> 字段，同样地与<code>ARP</code>一样为<code>6</code>字节。</p><p><strong>跳数</strong> 字段，由客户设置为<code>0</code>，也可以被一个代理服务器设置。</p><p><strong>事务标识</strong> 字段，由客户设置，并由服务器返回的<code>32bit</code>整数。客户用对请求和应答进行匹配。对每个请求客户应该将该字段设置为一个随机数。 <code>0</code>表示该客户忽略这个字段。</p><p><strong>秒数</strong> 字段，客户开始进行引导时，将该字段设置一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户请求，这意味着主服务器没有启动。</p><p><strong>客户 IP 地址</strong> 字段，如果客户已经知道了自身的<code>IP</code>地址，它将写入该字段。否则，将该字段置为<code>0</code>。</p><p><strong>你的 IP 地址</strong> 字段，如果客户不知道自身的<code>IP</code>地址时，服务器将该客户的<code>IP</code>地址写入该字段。</p><p><strong>服务器 IP 地址</strong> 字段，由服务器填写。</p><p><strong>网关 IP 地址</strong> 字段，如果使用了某个代理服务器，则该代理服务器填写该字段。</p><p><strong>客户主机硬件地址</strong> 字段，客户必须在该设置它的硬件地址，尽管这个值与以太网数据帧头的值相同。<code>UDP</code>数据报中也设置了这个字段，使任何接收这个数据报的用户进程（如：<code>BOOTP</code>服务器）很容易使用它。</p><p><strong>服务器主机名</strong> 字段，是一个以空值终止的字符串，由服务器选则性地填写。</p><p><strong>引导文件名</strong> 字段，由服务器填写的，用于系统引导的文件名及其所在位置的路径全名。</p><p><strong>特定厂商信息</strong> 字段，用于对<code>BOOTP</code>进行不同的扩展。</p><p><code>RFC 1533 [Alexander and Droms 1993]</code> 定义了这个区域的格式，这个区域含有服务器返回客户的可选信息。如果有信息要提供，这个区域的前<code>4</code>个字节被设置为<code>IP</code>地址<code>99.130.83.99</code>。这可称作 <strong>魔术甜饼</strong> (<code>magic cookie</code>)，表示该区域内包含信息。其余部分是一个条目表，格式如下：</p><img src="/2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/特定厂商格式.gif" alt="特定厂商格式" style="max-width:60%;"><span class="image-caption">特定厂商格式</span><p>每个条目开始是一个<code>1</code>字节的标志字段，其中的两个条目仅有标志字段：标志为<code>0</code>的条目作为填充字节（为使后面的条目有更好的字节边界），标志为<code>255</code>的条目表示结尾条目。第一个结尾条目后剩余的字节都应设置为这个数值（<code>255</code>）。除了这两个<code>1</code>字节的条目，其他的条目还包含一个单字节的长度字段，后面是相应的信息。</p><p><strong>子网掩码</strong> 条目和 <strong>时间值</strong> 条目都是定长条目，因为它们的值总是占<code>4</code>个字节。时间偏移值是从<code>1900年1月1日0时</code>以来的秒数（<code>UTC</code>）。</p><p><strong>网关</strong> 条目是变长条目。长度通常是<code>4</code>的倍数，这个值是一个或多个供客户使用的网关（路由器）的<code>IP</code>地址。返回的第一个必须是首选的网关。</p><blockquote><p><code>RFC 1533</code> 还定义了其他<code>14</code>个条目。其中最重要的可能是<code>DNS</code>名字服务器的<code>IP</code>地址条目，条目的值为 <code>6</code>。其他的条目包括打印服务器、时间服务器等的<code>IP</code>地址。详细情况可参考<code>RFC</code>文档。</p><p>厂商说明区域的大小被限制为<code>64</code>字节。这对某些应用是个约束。一个新的称为 **动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）**已经出现，但它不是替代<code>BOOTP</code>的。<code>DHCP</code>将这个区域的长度扩展到<code>312</code>字节，它在<code>RFC 1541 [Droms 1993]</code> 中定义。</p></blockquote><h4 id="端口号"><a class="markdownIt-Anchor" href="#端口号"></a> 端口号</h4><p><code>BOOTP</code>有两个熟知的端口，服务器<code>67</code>，客户<code>68</code>。这意味着<code>BOOTP</code> 客户不会选择未用的临时端口，而只用端口<code>68</code>。选择两个端口而不是仅选择一个端口因为<code>BOOTP</code>务器的应答可以进行广播（但通常是不用广播的）。</p><p>如果服务器的应答是通过广播传送的，同时客户又选择未用的临时端口，那么这些广播也能被其他的主机中碰巧使用相同临时端口的应用进程接收到。因此，采用随机端口（即临时端口）对广播来说是一个不好的选择。</p><p>如果客户也使用服务器的知名端口（<code>67</code>）作为它的端口，那么网络内的所有服务器会被唤醒来查看每个广播应答（如果所有的服务器都被唤醒，它们将检查操作码，如果是一个应答而不是请求，就不作处理）。因此可以让所有的客户使用与服务器知名端口不同的同一知名端口。</p><p>如果多个客户同时进行系统引导，并且服务器广播所有应答，这样每个客户都会收到其他客户的应答。客户可以通过<code>BOOTP</code>首部中的事务标识字段来确认应答是否与请求匹配，或者可以通过检查返回的客户硬件地址加以区分。</p><h4 id="bootp-服务器设计"><a class="markdownIt-Anchor" href="#bootp-服务器设计"></a> BOOTP 服务器设计</h4><p><code>BOOTP</code>客户通常固化在无盘系统只读存储器中，因此了解<code>BOOTP</code>服务器的实现将更有意义。</p><p><code>BOOTP</code>服务器将从它的熟知端口号<code>67</code>读取<code>UDP</code>数据报，没有特别的需要。这与必须要读取以太网帧类型字段<code>RARP</code>请求的<code>RARP</code>服务器不同。<code>BOOTP</code>协议通过将客户的硬件地址放入<code>BOOTP</code>分组中，使得服务器很容易获取客户硬件地址。</p><blockquote><p>这里出现了一个有趣的问题： <code>TFTP</code>服务器如何能将一个响应直接送回<code>BOOTP</code> 客户？这个响应是一个<code>UDP</code>数据报，而服务器知道该客户的<code>IP</code>地址（可能通过读取服务器上的配置文件）。由于客户端不知道自己的<code>IP</code>地址，因此无法应答<code>ARP</code>请求，因此服务器上的<code>ARP</code>无法找到客户的硬件地址。（这就是<code>RFC951</code>中被称作 &quot;<code>chicken and egg</code>&quot;的问题）</p></blockquote><p>对于上面问题，有两种解决方案：</p><p>第一种是服务器发送一个<code>IOCTL(2)</code>请求给内核，为该客户在<code>ARP</code>高速缓存中设置一个条目（这就是命令<code>arp -s</code>的工作），所以当服务器发送<code>UDP</code>数据报时，服务器<code>ARP</code>模块将会在<code>ARP</code>高速缓存中发现客户<code>IP</code>地址。服务器一直这么做直到它知道客户的硬件地址和<code>IP</code>地址。</p><p>第二种是服务器广播这个<code>BOOTP</code>应答而不是直接将应答发回该客户，通常期望网络广播越少越好，因此这种解决方案应该只在服务器无法在它的<code>ARP</code>高速缓存设置一个条目的情况下使用。通常只有拥有超级用户权限才能在<code>ARP</code>高速缓存设置一个条目，如果没有这种权限就只能广播<code>BOOTP</code>应答。</p><blockquote><p>当一个客户使用<code>BOOTP</code>（操作码为<code>1</code>）进行系统引导时，引导请求通常是采用链路层广播， <code>IP</code>首部中的目的<code>IP</code>地址为<code>255.255.255.255</code>（受限的广播）。源<code>IP</code>地址通常是<code>0.0.0.0</code>，因为此时客户还不知道它本身的<code>IP</code>地址。</p></blockquote><h4 id="bootp-穿越路由"><a class="markdownIt-Anchor" href="#bootp-穿越路由"></a> BOOTP 穿越路由</h4><p>绝大多数路由器厂商的产品都支持<code>BOOTP</code>协议，所以能够被路由器转发。这个功能主要用于无盘路由器，因为如果一个带磁盘的多用户系统被用作路由器，它就能够自己运行<code>BOOTP</code>服务器。</p><blockquote><p>常用的<code>Unix BOOTP</code>服务器支持这种中继模式（<code>relay mode</code>）。</p><p>如果在这个物理网络内运行一个<code>BOOTP</code>服务器，通常没有必要将<code>BOOTP</code>请求转发到在另外网络中的另一个服务器。</p></blockquote><p>当路由器（也称作“<code>BOOTP</code> 中继代理”）在服务器的熟知端口（<code>67</code>）接收到<code>BOOTP</code>请求时，中继代理将<code>IP</code>地址填入收到<code>BOOTP</code>请求中的“ <strong>网关IP地址</strong> 字段”，然后将该请求发送到真正的<code>BOOTP</code>服务器（由中继代<br>理填入网关字段的地址是收到的<code>BOOTP</code>请求接口的<code>IP</code>地址）。中继代理还将跳数字段值加<code>1</code>（这是为防止请求被无限地在网络内转发。 <code>RFC951</code>认为如果跳数值到达<code>3</code>就可以丢弃该请求）。</p><p>发出的请求是一个单播的数据报（与发起的客户的请求是广播的相反），它能按照一定的路由通过其他的路由器到达真正的<code>BOOTP</code>服务器。真正的<code>BOOTP</code>服务器收到这个请求后，产生<code>BOOTP</code>应答，并将它发回中继代理，而不是请求的客户。既然请求网关字段不为零，真正的<code>BOOTP</code>服务器知道这个请求是经过转发的。中继代理收到应答后将它发给请求的客户。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
            <tag> TFTP </tag>
            
            <tag> BOOTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议 — DNS 域名系统</title>
      <link href="2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>域名系统也叫 <strong>域名解析（Domain name resolution，DNS）</strong> 是一种用于<code>TCP/IP</code>应用程序的分布式数据库，它提供主机名字和<code>IP</code>地址间的转换及有关电子邮件的选路信息。</p><blockquote><p>分布式的意思是，在<code>Internet</code>上的单个站点不能拥有所有信息，。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供<code>Internet</code>上的其他系统（客户程序）查询。 <code>DNS</code>提供了允许服务器和客户程序相互通信的协议。</p></blockquote><p>对<code>DNS</code>的访问是通过一个地址解析器（<code>resolver</code>）来完成的，在<code>Unix</code>主机中该解析器主要通过两个函数<code>gethostbyname(3)</code>和<code>gethostbyaddr(3)</code>来访问的。前者接收主机名字返回<code>IP</code>地址，后者接收<code>IP</code>地址寻找主机名字。</p><blockquote><p>解析器并不像<code>TCP/IP</code>协议那样是操作系统的内核，而是应用程序的一部分。在一个应用程序打开一个<code>TCP</code>连接或使用<code>UDP</code>发送一个数据报之前，必须将一个主机名转换成为一个<code>IP</code>地址，操作系统内核中的<code>TCP/IP</code>协议簇对<code>DNS</code>一点都不知道。</p></blockquote><h3 id="dns-基础"><a class="markdownIt-Anchor" href="#dns-基础"></a> DNS 基础</h3><p><code>DNS</code>的名字空间和<code>Unix</code>文件系统具有相似的层次结构，每个节点（圆圈）有一个最多<code>63</code>个字符长的标签。这棵树的根是一个空标签的特殊节点，标签不区分大小写。树上的任何节点的域名是从该节点开始到根节点的标签列表，使用<code>.</code>符号分割。域名树上的不同节点可以使用相同标签，但是每个节点在域名树上必须有一个唯一的域名。</p><p><strong>完全限定域名（Full Qualified Domain Name，FQDN）</strong> ,也叫 <strong>绝对域名</strong> 。它指定在域名系统树层次结构中的确切位置，它指定了所有域的级别（包括顶级域和根区域）。一个完全限定域名是没有歧义的，只有一种方式去解释它。通常它由一个主机名和最少一个更高级域标签并通过<code>.</code>分割符组成，并且以顶级域结束。</p><blockquote><p>域名系统的根域名（顶级域）未命名的，它是通过在域名系统层次结构中有一个空标签来表示。而完全限定名以顶级域结尾，因此如果不完全限定域名以两个以上标签组成，则可以认为它是完全限定域名；或者某些情况要求完全限定域名以<code>.</code>符号结尾。如<code>.tuc.noao.edu.</code>。</p></blockquote><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS层次组织.gif" alt="DNS 层次组织" style="max-width:60%;"><span class="image-caption">DNS 层次组织</span><p><strong>顶级域名被分为三个部分</strong>：</p><ul><li><code>arpa</code>是一个特殊域，用于地址到名字的映射。</li><li>普通域，<code>7</code>个三字符。通常只有<code>.gov</code>、<code>.mil</code>仅限于美国使用。</li><li>国家域，依据<code>ISO 3166</code>国家代码的两字符。</li></ul><blockquote><p><code>DNS</code>通过 <strong>网络信息中心</strong> <code>NIC</code>分配顶级域和委派其他指定地区域的授权机构。</p><p>一个独立管理的<code>DNS</code>子树称为一个区域 (<code>zone</code> )。一个常见的区域是一个二级域，如<code>noao.edu</code>。许多二级域将它们的区域划分成更小的区域。例如，大学可能根据不同的系来划分区域，公司可能根据不同的部门来划分区域。</p><p>一旦一个区域的授权机构被委派后，由它负责向该区域提供多个名字服务器。当一个新系统加入到一个区域中时，该区域的<code>DNS</code>管理者为该新系统申请一个域名和一个<code>IP</code>地址，并将它们加到名字服务器的数据库中。这就是授权机构存在的必要性。</p></blockquote><p>一个名字服务器负责一个或多个区域。一个区域的管理者必须为该区域提供一个主名字服务器和至少一个辅助名字服务器。主、辅名字服务器必须是独立和冗余的，以便当某个名字服务器发生故障时不会影响该区域的名字服务。</p><p>主、辅名字服务器的主要区别在于主名字服务器从磁盘文件中调入该区域的所有信息，而辅名字服务器则从主服务器调入所有信息。我们将辅名字服务器从主服务器调入信息称为区域传送。</p><blockquote><p>当一个新主机加入一个区域时，区域管理者将适当的信息（最少包括名字和<code>IP</code>地址）加入到运行在主名字服务器上的一个磁盘文件中，然后通知主名字服务器重新调入它的配置文件。辅名字服务器定时（通常是每隔<code>3</code>小时）向主名字服务器询问是否有新数据。如果有新数据，则通过区域传送方式获得新数据。</p></blockquote><p>当名字服务器没有请求信息时，它必须联系另一个名字服务器。然而并不是每个名字服务器如何联系其他名字服务器，但是每个名字服务器必须知道怎么联系根名字服务器。</p><blockquote><p><code>1993</code>年<code>4</code>月时有<code>8</code>个根名字服务器，所有的主名字服务器都必须知道根服务器的<code>IP</code>地址（这些<code>IP</code>地址在主名字服务器的配置文件中，主服务器必须知道根服务器的<code>IP</code>地址，而不是它们的域名）。</p><p>根服务器则知道所有二级域中的每个授权名字服务器的名字和位置（<code>IP</code>地址）。<em><strong>正在处理请求的名字服务器与根服务器联系，根服务器告诉它与另一个名字服务器联系。</strong></em></p></blockquote><p><code>DNS</code>的一个基本特性是使用超高速缓存。即当一个名字服务器收到有关映射的信息（主机名字到<code>IP</code>地址）时，它会将该信息存放在高速缓存中。这样若以后遇到相同的映射请求，就能直接使用缓存中的结果而无需通过其他服务器查询。</p><h3 id="dns-报文"><a class="markdownIt-Anchor" href="#dns-报文"></a> DNS 报文</h3><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS报文格式.gif" alt="DNS 报文格式" style="max-width:60%;"><span class="image-caption">DNS 报文格式</span><p><code>DNS</code>定义了一个用于查询和响应的报文格式（如上图）。报文由<code>12</code>字节首部和<code>4</code>个可变字段组成。</p><p><strong>标识</strong> 字段，由客户程序设置，并由服务器返回结果，客户程序通过它来确定响应与查询是否匹配。</p><p><strong>标志</strong> 字段，占<code>16bit</code>被分为多个子字段，如下：</p><ul><li><code>QR</code>字段，<code>0</code>表示查询，<code>1</code>表示响应。占<code>1bit</code>。</li><li><code>opcode</code>字段，<code>0</code>表示标准查询，<code>1</code>表示反向查询，<code>2</code>表示服务器状态请求。点<code>4bit</code>。</li><li><code>AA</code>字段，权威回答。如果查询结果由管理域名的域名服务器而不是缓存服务器提供的，则称为权威回答。</li><li><code>TC</code>字段，表示“可截断的”。使用<code>UDP</code>时，当其值为<code>1</code>时，总长度超过512字节，只返回前512个字节，这时 DNS就需要使用TCP重发原来的查询请求。</li><li><code>RD</code>字段，表示“期望递归”。该比特在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个<strong>递归查询</strong>。如果该位为<code>0</code>，且被请求的名字服务器没有一个权威回答，它就返回一个能解答该查询的其他名字服务器列表，这称为<strong>迭代查询</strong>。</li><li><code>RA</code>字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为<code>1</code>。</li><li><code>zero</code>字段，必须为<code>0</code>。</li><li><code>rcode</code>字段，返回码。<code>0</code>表示没有差错，<code>3</code>表示名字差错。名字差错只能从一个权威的名字服务器上返回，它表示指定的域名在查询中不存在。</li></ul><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS报文标志字段.gif" alt="DNS 报文标志字段" style="max-width:60%;"><span class="image-caption">DNS 报文标志字段</span><p>随后的四个<code>16bit</code>字段说明最后四个变长字段中包含的条目数。对于查询报文，问题数通常是<code>1</code>，而其他三项则均为<code>0</code>。类似地，对于应答报文，回答数至少是<code>1</code>，剩下的两项可以是<code>0</code>或非<code>0</code>。</p><h4 id="查询问题"><a class="markdownIt-Anchor" href="#查询问题"></a> 查询问题</h4><p>问题部分中，通常只有一个问题，每个问题的格式如下：</p><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS查询报文中问题格式.gif" alt="DNS 查询报文中问题格式" style="max-width:60%;"><span class="image-caption">DNS 查询报文中问题格式</span><p><strong>查询名</strong>字段，要查找的名字，它是一个或多个标签的序列。每个标签以首字节的计数值来说明随后标签的字节长度，名字最后以字节为<code>0</code>结束，长度为<code>0</code>的标签是根标签。因为标签最大长度为<code>63</code>，所以计数字节的值必须是<code>0 ~ 63</code>的数。该字段无需以整<code>32bit</code>边界结束，即无需填充字节。</p><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/域名存储.gif" alt="blog.fcwalkers.com 域名存储格式" style="max-width:60%;"><span class="image-caption">blog.fcwalkers.com 域名存储格式</span><p><strong>查询类型</strong>字段，每个问题有一个查询类型，并且每个响应（也叫一个 <strong>资源记录</strong> ）也有一个类型。</p><p>常见的查询类型如下：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">数值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">1</td><td style="text-align:center">传回一个<code>32bit</code>的<code>IPv4</code>地址，最常用于映射主机名称到<code>IP</code>地址。正向查询</td></tr><tr><td style="text-align:center">AAAA</td><td style="text-align:center">28</td><td style="text-align:center">传回一个<code>128bit</code>的<code>IPv6</code>地址，最常用于映射主机名称到<code>IP</code>地址。正向查询</td></tr><tr><td style="text-align:center">CNAME</td><td style="text-align:center">5</td><td style="text-align:center">一个主机名字的别名，域名系统将会继续尝试查找新的名字（将域名指向另外一个域名<code>canonical name</code>）。</td></tr><tr><td style="text-align:center">NS</td><td style="text-align:center">2</td><td style="text-align:center">委托<code>DNS</code>区域使用已提供的权威名字服务器（<code>Name server</code>）。</td></tr><tr><td style="text-align:center">MX</td><td style="text-align:center">15</td><td style="text-align:center">将一个域名映射到该域名的邮件传输代理（<strong>Message Transfer Agents，MTA</strong>）列表。</td></tr><tr><td style="text-align:center">SRV</td><td style="text-align:center">33</td><td style="text-align:center"><mark>服务定位记录，被新式协议使用而避免产生特定协议的记录</mark>。</td></tr><tr><td style="text-align:center">PTR</td><td style="text-align:center">12</td><td style="text-align:center">由<code>IP</code>到域名的查询，反向查询。</td></tr><tr><td style="text-align:center">TXT</td><td style="text-align:center">16</td><td style="text-align:center">最初用于DNS记录中的任意人类可读文本。然而，自20世纪90年代初以来，这种记录更多地携带机器可读的数据，如随机加密等。一般做一些验证记录时会使用此项如：做SPF（反垃圾邮件）记录。</td></tr><tr><td style="text-align:center">SOA</td><td style="text-align:center">6</td><td style="text-align:center">指定<code>DNS</code>域的权威信息，包括主要名称服务器、域名管理员邮箱地址、域名序列号和与刷新区域几个相关的计时器。</td></tr><tr><td style="text-align:center">AXFR</td><td style="text-align:center">252</td><td style="text-align:center">将整个区域文件从主要名称服务器传输到次要名称服务器</td></tr><tr><td style="text-align:center">*（或 ANY）</td><td style="text-align:center">255</td><td style="text-align:center">返回名称服务器已知的所有类型的所有记录</td></tr></tbody></table><p><strong>查询类</strong> 字段，值通常是<code>1</code>表示互联网地址（某些站点也支持其他非 I P地址）。</p><h4 id="响应资源记录"><a class="markdownIt-Anchor" href="#响应资源记录"></a> 响应资源记录</h4><p><code>DNS</code>最后三个字段 <strong>回答</strong> 、 <strong>授权</strong>、 <strong>附加信息</strong> 字段均采用一种称为资源记录（ <strong>Resource Record，RR</strong> ）的相同格式。如下图：</p><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS资源记录格式.gif" alt="DNS 资源记录格式" style="max-width:60%;"><span class="image-caption">DNS 资源记录格式</span><p><strong>域名</strong> 字段是下面资源数据的名字，它的格式与前面 <strong>查询名</strong> 字段格式相同。</p><p><strong>类型</strong> 字段，指定一个<code>RR</code>类型码，它与前面查询类型值相同。</p><p><strong>类</strong> 字段，值通常是<code>1</code>表示互联网地址（某些站点也支持其他非 I P地址）。</p><p><strong>生存时间</strong> 字段，<code>RR</code>被客户端缓存的秒数，通常是<code>2</code>天。</p><p><strong>资源数据长度</strong> 字段，说明了资源数据的数量。</p><p><strong>资源数据</strong> 字段，该数据的格式依赖于类型字段的值。对于类型<code>1</code>（A记录）资源数据是<code>4</code>字节的<code>IP</code>数据。</p><h3 id="dns-反向查询"><a class="markdownIt-Anchor" href="#dns-反向查询"></a> DNS 反向查询</h3><p><code>DNS</code>反向查询是查询域名系统来确定<code>IP</code>地址关联的域名的技术，即给定一个<code>IP</code>地址返回该地址对应的域名。反向<code>DNS</code>查询的过程使用<code>PRT</code>记录，互联网的反向<code>DNS</code>数据库根植于<code>.arpa</code>顶级域名。</p><blockquote><p>协议<code>[rfc:1912 RFC1912年]</code>建议，每一个互联网可访问的主机都应该有一个名字”和“每一个IP地址都应该有一个匹配 PTR 记录”，但这并不是一个<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86">互联网标准</a> 强制要求，所以并不是每一个IP地址都有一个反向记录。</p></blockquote><p>反向查找<code>IPv4</code>地址时使用一个特殊的域名<code>in-addr.arpa</code>。在上面树形图中<code>IP</code>地址为<code>140.252.13.33</code>，在<code>DNS</code>树中结点<code>in-addr.arpa</code>的下一级必须是该<code>IP</code>地址的第一字节<code>140</code>，再下一级是<code>252</code>，依此类推。</p><blockquote><p>需要注意的是<code>DNS</code>名字是由<code>DNS</code>树底部向上书写的，所以<code>IP</code>地址<code>140.252.13.33</code>，它的<code>DNS</code>名字是<code>33.13.252.140.in-addr.arpa</code>。</p><p>必须写出<code>4</code>字节的<code>IP</code>地址，因为授权的代表是基于网络号： <code>A</code>类地址是第一字节， <code>B</code>类地址是第一、二字节，<code>C</code>类地址则是第一、二、三字节。</p></blockquote><p>反向查找<code>IPv6</code>地址时，使用一个特殊域名<code>ip6.arpa</code>（以前是<code>ip6.int</code>）。<code>IPv6</code>地址，以十六进制数字表示为子域。</p><h3 id="高速缓存"><a class="markdownIt-Anchor" href="#高速缓存"></a> 高速缓存</h3><p>为了减少<code>Internet</code>上<code>DNS</code>的通信量，所有的名字服务器均使用高速缓存。在标准的<code>Unix</code>实现中，高速缓存是由名字服务器而不是由名字解析器维护的。由于解析器是每个应用程序的一部分，并且应用程序又不可能总处于工作状态，因此将缓存放入整个系统运行期间都存在的程序(名称服务器)中是有意义的。这使缓存对于使用这个服务器的任何应用都是有效的。站点上任何使用该名字服务器的主机也可以共享服务器缓存。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议—UDP 用户数据报协议</title>
      <link href="2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p><code>UDP</code>（<strong>User Datagram Protocol</strong>）是一个简单的面向数据报的运输层协议，进程的每个输出操作都正好产生一个<code>UDP</code>数据报并组装成一个待发送的<code>IP</code>数据报。这与面向流字符的协议不同，如<code>TCP</code>，应用程序产生的全部数据与真正发送的单个<code>IP</code>数据报可能没有什么联系。</p><p><code>UDP</code>不提供可靠性，它把应用程序传给<code>IP</code>层的数据发送出去，但是并不保证它们能到达目的地。</p><h3 id="udp-首部"><a class="markdownIt-Anchor" href="#udp-首部"></a> UDP 首部</h3><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/UDP首部.gif" style="max-width:60%;"><p><code>UDP</code>首部字段：</p><p><strong>端口号</strong> 表示发送进程和接收进程。</p><p><strong>UDP 长度</strong> 表示<code>UDP</code>首部和<code>UDP</code>数据的字节长度。最小值为<code>8</code>字节（可以发送<code>0</code>字节数据报），<code>IP</code>数据报指的是数据报全长，因此<code>UDP</code>数据报长度是全长减去<code>IP</code>数据报首部长度。</p><p><strong>检验和</strong> 检验和覆盖<code>UDP</code>首部和<code>UDP</code>数据。它与<code>IP</code>首部检验和只覆盖<code>IP</code>首部不同。并且它的检验和是可选的。如果发送端没有计算检验和而接收端检测到检验和有差错，那么<code>UDP</code>数据报就要被悄悄地丢弃。不产生任何差错报文（当<code>IP</code>层检测到<code>IP</code>首部检验和有差错时也这样做）。</p><p>计算方法与<code>IP</code>首部检验和类似，不同之处有：</p><ul><li><p><code>UDP</code> 数据报长度可以为奇数字节，但是检验和算法是把若干个<code>16bit</code>字相加。解决方法是必要时在最后增加填充字节<code>0</code>，这只是为了检验和的计算（也就是说，可能增加的填充字节不被传送）。</p></li><li><p><code>UDP</code>数据报<code>TCP</code>段都包含一个<code>12</code>字节长度的伪首部，它是为了计算检验和设置的。伪首部包含<code>IP</code>首部一些字段。其目的是让<code>UDP</code>两次检查数据是否已经正确到达目的地。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/UDP伪首部.gif" alt="UDP 伪首部" style="max-width:60%;"><span class="image-caption">UDP 伪首部</span></li></ul><p>上图是一个奇数字节长度的<code>UDP</code>数据报，因而在计算检验和时需要在尾部加上 “ <strong>填充字节（0）</strong> ”；</p><p><strong>UDP 长度</strong> 字段在检验和计算中出现两次。</p><p>如果检验和计算结果为<code>0</code>，则存入的值全为<code>1</code>（65535），这在二进制反码计算中是等效的。如果传送的检验和为<code>0</code>，说明发送端没有计算检验和。</p><blockquote><p>尽管<code>UDP</code>检验和是可选的，但是它们应该总是在用。在单个局域网中关闭检验和可能是可以被接受的，但是在数据报通过路由器时，通过对链路层数据帧进行循环冗余检验（如以太网或令牌环数据帧）可以检测到大多数的差错，导致传输失败。路由器中也存在软件和硬件差错，以致于修改数据报中的数据。如果关闭端到端的<code>UDP</code>检验和功能，那么这些差错在<code>UDP</code>数据报中就不能被检测出来。一些数据链路层协议（如<code>SLIP</code>）没有任何形式的数据链路检验和。</p><p><code>Host Requirements RFC</code>声明，<code>UDP</code>检验和选项在默认条件下是打开的。它还声明，如果发送端已经计算了检验和，那么接收端必须检验接收到的检验和（如接收到检验和不为<code>0</code>）。但是，许多系统没有遵守这一点，只是在出口检验和选项被打开时才验证接收到的检验和。</p></blockquote><h3 id="ip-分片"><a class="markdownIt-Anchor" href="#ip-分片"></a> IP 分片</h3><p>物理网络层一般要限制每次发送数据帧的最大长度，任何时候<code>IP</code>层接收到一份要发送的数据报时，它先要判断向本地哪个接口发送数据（选路），并查询该接口获得其<code>MTU</code>；<code>IP</code>把<code>MTU</code>与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</p><p>把一份<code>IP</code>数据报分片以后，只有到达目的地才进行重新组装（<mark>这里的重新组装与其他网络协议要求在“下一跳”就进行重新组装不同</mark>）。重新组装由目的<code>IP</code>层来完成，其目的是使分片和重新组装过程对运输层（<code>TCP</code>和<code>UDP</code>）是透明的。</p><blockquote><p>已经分片过的数据报有可能会再次进行分片（可能不止一次）。<code>IP</code>首部中包含的数据为分片和重新组装提供了足够的信息。</p></blockquote><img src="https://blog.fcwalkers.com/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E9%A6%96%E9%83%A8.png" alt="IP首部" style="max-height:300px"><span class="image-caption">IP首部</span><p><code>IP</code>首部分片字段如上图：</p><p><strong>标识</strong> 字段，每份<code>IP</code>数据报标识字段包含一个唯一值，该值在数据报分片时被复制到每个片中。</p><p><strong>标志</strong> 字段，目前只有两位有意义：</p><ul><li><p>第一位 没有被使用</p></li><li><p>第二位 <code>DF</code>（dont’t fragment），当<code>DF=1</code>时<code>IP</code>将不对数据报进行分片。</p></li><li><p>第三位 <code>MF</code>（more fragment），当<code>MF=1</code>时表示还有更多分片，只有最后一个分片该位置<code>0</code>。</p></li></ul><p><strong>片偏移</strong> 字段，指该片偏移原始数据报开始处的位置。</p><p><em>当数据报被分片后，每个片的总长度字段值要改为该片的长度值。</em></p><blockquote><p><code>UDP</code>即使只丢失一片数据也要重传整个数据报。为什么会发生这种情况呢？</p><p>因为<code>IP</code>层本身没有超时重传的机制——由更高层来负责超时和重传，<code>TCP</code>有超时和重传机制，但<code>UDP</code>没有，一些<code>UDP</code>应用程序本身也执行超时和重传。</p><p>当来自<code>TCP</code>报文段的某一片丢失后，<code>TCP</code>在超时后会重发整个<code>TCP</code>报文段，该报文段对应于一份<code>IP</code>数据报。没有办法只重传数据报中的一个数据报片。事实上，如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常要避免分片。</p></blockquote><h3 id="icmp-不可达差错"><a class="markdownIt-Anchor" href="#icmp-不可达差错"></a> ICMP 不可达差错</h3><p>发生<code>ICMP</code>不可达差错的另一种情况，是当路由器收到一份需要分片的数据报，而在<code>IP</code>首部又设置了不分片（<code>DF</code>）的标志比特。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/ICMP分片不可达.gif" alt="需要分片但又设置不分片标志比特时的ICMP不可达差错报文格式" style="max-width:60%;"><span class="image-caption">需要分片但又设置不分片标志比特时的ICMP不可达差错报文格式</span><p>注意报文中的 <strong>下一跳网络的MTU</strong> 字段，如果路由器没有提供这种新的<code>ICMP</code>差错报文格式，那么该字段设置为<code>0</code>。</p><blockquote><p>新版的路由器需求<code>RFC [Almquist 1993]</code>声明，在发生这种<code>ICMP</code>不可达差错时，路由器必须生成这种新格式的报文。</p></blockquote><h3 id="路径-mtu-发现"><a class="markdownIt-Anchor" href="#路径-mtu-发现"></a> 路径 MTU 发现</h3><h4 id="traceroute-确定路径-mtu"><a class="markdownIt-Anchor" href="#traceroute-确定路径-mtu"></a> traceroute 确定路径 MTU</h4><h4 id="采用-udp-的路径-mtu-发现"><a class="markdownIt-Anchor" href="#采用-udp-的路径-mtu-发现"></a> 采用 UDP 的路径 MTU 发现</h4><h3 id="udp-数据报最大长度"><a class="markdownIt-Anchor" href="#udp-数据报最大长度"></a> UDP 数据报最大长度</h3><p><code>IP</code>数据报最大长度是<code>65535</code>字节，这是由<code>IP</code>首部<code>16bit</code>总长度字段决定的。除去<code>20</code>字节的<code>IP</code>首部和<code>8</code>字节的<code>UDP</code>首部，<code>UDP</code>数据报中用户数据的最大长度为<code>65507</code>字节。但是大多数实现所提供的长度比这个值小。</p><p><strong>限制因素</strong>：</p><ul><li><p>应用程序可能受到其程序接口的限制。如，<code>socket API</code>提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度，这个长度与应用程序可以读写的最大<code>UDP</code>数据报的长度直接相关。现在大部分系统默认都提供了可读写大于<code>8192</code>字节的<code>UDP</code>数据报（使用这个默认值是因为<code>8192</code>是<code>NFS</code>读写用户数据数的默认值）。</p></li><li><p><code>TCP/IP</code>内核实现的限制。可能存在一些实现特性（或差错），使<code>IP</code>数据报长度小于<code>65535</code>字节。</p><blockquote><p>由于<code>IP</code>能够发送或接收特定长度的数据报并不意味着接收应用程序可以读取该长度的数据。因此，<code>UDP</code>编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？</p><p>不幸的是，该问题的答案取决于编程接口和实现。</p></blockquote></li></ul><h3 id="icmp-源站抑制差错"><a class="markdownIt-Anchor" href="#icmp-源站抑制差错"></a> ICMP 源站抑制差错</h3><p>当一个系统（主机或路由器）接收数据报的速度比其处理速度快，<mark>可能</mark>产生这个差错。之所以是可能这个词是因为即使一个系统已经没有缓存并丢弃数据报，也不要求它一定要发送源站抑制报文。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/ICMP源站抑制差错报文.gif" alt="ICMP 源站抑制差错报文" style="max-width:60%;"><span class="image-caption">ICMP 源站抑制差错报文</span><p><code>RFC 1009 [Braden and Postel 1987]</code>要求路由器在没有缓存时产生源站抑制差错报文，但是新的<code>Router Requirements RFC [Almquist 1993]</code>对此作了修改，提出路由器不应该产生源站抑制差错报文。由于源站抑制要消耗网络带宽，且对于拥塞来说是一种无效而不公平的调整，因此现在人们对于源站抑制差错的态度是不支持的。</p><h3 id="广播和多播"><a class="markdownIt-Anchor" href="#广播和多播"></a> 广播和多播</h3><p><code>IP</code>地址总共有三种：单播地址、多播地址和广播地址。其中广播地址和多播地址仅应用于<code>UDP</code>，它们对需将报文同时传往多个接收者的应用来说十分重要。</p><p><code>TCP</code>是一个面向连接的协议，它意味着分别运行于两主机（由<code>IP</code>地址确定）内的两进程（由端口号确定）间存在一条连接。</p><p>通常每个以太网帧仅发往单个目的主机，目的地址指明单个接收接口，因而称为单播(<code>unicast</code>)。在这种方式下，任意两个主机的通信不会干扰网内其他主机（可能引起争夺共享信道的情况除外）。</p><p>有时一个主机要向网上的所有其他主机发送帧，这就是广播(<code>broadcast</code>)。通过<code>ARP</code>和<code>RARP</code>可以看到这一过程。</p><p>多播(<code>multicast</code>) 处于单播和广播之间，帧仅传送给属于多播组的多个主机。</p><blockquote><p>大多数的网卡经过配置都能接收目的地址为多播地址或某些子网多播地址的帧。对于以太网，当地址中最高字节的最低位设置为<code>1</code>时表示该地址是一个多播地址，用十六进制可表示为<code>01:00:00:00:00:00</code>（以太网广播地址<code>ff:ff:ff:ff:ff:ff</code>可看作是以太网多播地址的特例）。</p></blockquote><p>使用广播的问题在于它增加了对广播数据不感兴趣主机的处理负荷。多播的出现减少了对应用不感兴趣主机的处理负荷。使用多播，主机可加入一个或多个多播组。这样，网卡将获悉该主机属于哪个多播组，然后仅接收主机所在多播组的那些多播帧。</p><h4 id="广播"><a class="markdownIt-Anchor" href="#广播"></a> 广播</h4><p>下表为广播地址划分，其中<code>-1</code>表示所有比特位全为<code>1</code>；<code>0</code>表示所有比特位全为<code>0</code>；<code>netid</code>、<code>subnetid</code>表示不全为<code>0</code>或<code>1</code>的对应字段。</p><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">子网号</th><th style="text-align:center">主机号</th><th style="text-align:center">源端</th><th style="text-align:center">目的端</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-1</td><td style="text-align:center"></td><td style="text-align:center">-1</td><td style="text-align:center">不可能</td><td style="text-align:center">OK</td><td style="text-align:center">受限制广播（永远不被转发）</td></tr><tr><td style="text-align:center">netid</td><td style="text-align:center"></td><td style="text-align:center">-1</td><td style="text-align:center">不可能</td><td style="text-align:center">OK</td><td style="text-align:center">以网络为目的向<code>netid</code>广播</td></tr><tr><td style="text-align:center">netid</td><td style="text-align:center">subnetid</td><td style="text-align:center">-1</td><td style="text-align:center">不可能</td><td style="text-align:center">OK</td><td style="text-align:center">以子网为目的向<code>netid</code>、<code>subnetid</code>广播</td></tr><tr><td style="text-align:center">netid</td><td style="text-align:center">-1</td><td style="text-align:center">-1</td><td style="text-align:center">不可能</td><td style="text-align:center">OK</td><td style="text-align:center">以所有子网为目的向<code>netid</code>广播</td></tr></tbody></table><p><strong>受限制广播</strong> 地址是<code>255.255.255.255</code>，该地址用于主机配置过程中<code>IP</code>数据报的目的地址，此时主机可能不知道它所在的网络掩码，甚至连它的<code>IP</code>地址也不知道（如主机启动过程中）。</p><blockquote><p>在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出现在本地网络中。</p></blockquote><p><strong>指向网络的广播</strong> 地址是主机号全为<code>1</code>的地址。<code>A</code>类网络广播地址为<code>netid.255.255.255</code>，其中<code>netid</code>为<code>A</code>类网络的网络号。</p><blockquote><p>一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</p></blockquote><p><strong>指向子网的广播</strong> 地址为主机号全为<code>1</code>且具有特定子网号(<code>subnetid</code>)的地址。作为子网直接广播地址的<code>IP</code>地址需要了解子网的掩码。</p><p>如路由器收到发往<code>128.1.2.255</code>的数据报，当<code>B</code>类网络<code>128.1</code>的子网掩码为<code>255.255.255.0</code>时，该地址就是指向子网的广播地址；但如果该子网的掩码为<code>255.255.254.0</code>，该地址就不是指向子网的广播地址。</p><pre class="highlight"><code class>  子网掩码：255.255.255.0                        子网掩码：255.255.254.0  |  V  10000000 00000001 00000010 11111111          10000000 00000001 00000010 11111111&amp; 11111111 11111111 11111111 00000000        &amp; 11111111 11111111 11111110 00000000—————————————————————————————————————        —————————————————————————————————————  10000000 00000001 00000010 00000000          10000000 00000001 00000011 00000000  128      1        2        0                 128      1        3        0</code></pre><p>计算结果如上，当子网的掩码为<code>255.255.254.0</code>时，<code>IP</code>地址为<code>128.1.3.0</code>其中子网地址为<code>3</code>，所以地址<code>128.1.2.255</code>就不是指向子网<code>2</code>的广播地址了。</p><p><strong>指向所有子网的广播</strong> 地址为子网号全为<code>1</code>，主机号也全为<code>1</code>的地址。指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。</p><p>如子网掩码为<code>255.255.255.0</code>，那么<code>IP</code>地址<code>128.1.255.255</code>是一个指向所有子网的广播地址。</p><blockquote><p>通过子网掩码<code>255.255.255.0</code>可以获得主机与子网号的分界线，即<code>0</code>表示的最后<code>8bit</code>是主机号；而通过<code>128</code>可以知道是<code>B</code>类地址，所以前<code>16bit</code>是由<code>2bit</code>前缀<code>10</code>和<code>14bit</code>网络号组成，所以接下来<code>8bit</code>则表示子网号。根据指向所有子网的广播地址划分规则就可以写出该<code>IP</code>地址，即最后<code>16bit</code>的子网号和主机号均为<code>1</code>即<code>255</code>，即最终<code>IP</code>地址为<code>128.1.255.255</code>。</p></blockquote><p>如果网络没有划分子网，这就是一个指向网络的广播。</p><p><code>RFC 922</code>要求将一个指向所有子网的广播传送给所有子网，但当前的路由器没有这么做。因为一个因错误配置而没有子网掩码的主机会把它的本地广播传送到所有子网。</p><p>如<code>IP</code>地址为<code>128.1.2.3</code>的主机没有设置子网掩码，它的广播地址在正常情况下的默认值是<code>128.1.255.255</code>。但如果子网掩码被设置为<code>255.255.255.0</code>，那么由错误配置的主机发出的广播将指向所有的子网。</p><blockquote><p><code>B</code>类地址<code>128</code>的默认子网掩码是<code>255.255.0.0</code>，此时<code>128.1.255.255</code>广播地址就是一个<strong>指向网络的广播</strong>；当子网掩码被错误设置为<code>255.255.255.0</code>时，该广播地址就变成了<strong>指向所有子网的广播</strong>。</p></blockquote><h4 id="多播"><a class="markdownIt-Anchor" href="#多播"></a> 多播</h4><p><code>IP</code>多播提供两类服务：</p><ul><li>向多个目的地址传送数据。如交互式会议系统和向多个接收者分发邮件或新闻。如果不采用多播，目前这些应用大多采用<code>TCP</code>来完成（向每个目的地址传送一个单独的数据复制）。然而，即使使用多播，某些应用可能继续采用<code>TCP</code>来保证它的可靠性。</li><li>客户对服务器的请求。如，无盘工作站需要确定启动引导服务器。目前，这项服务是通过广播来提供的，但是使用多播可降低不提供这项服务主机的负担。</li></ul><p>能够接收发往一个特定多播组地址数据的主机集合称为主机组 (<code>host group</code>)。一个主机组可跨越多个网络。主机组中成员可随时加入或离开主机组。主机组中对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送信息。</p><blockquote><p>一些多播组地址被 <strong>互联网数字分配机构（The Internet Assigned Numbers Authority，IANA）</strong> 确定为知名地址。它们也被当作永久主机组，这和<code>TCP</code>及<code>UDP</code>中的熟知端口相似。同样，这些知名多播地址在<code>RFC</code>最新分配数字中列出。注意这些多播地址所代表的组是永久组，而它们的组成员却不是永久的。</p><p>如<code>224.0.0.1</code>代表该子网内的所有系统组；<code>224.0.0.2</code>代表该子网内的所有路由器组；<code>224.0.1.1</code>用作网络时间协议<code>NTP</code>；<code>224.0.0.9</code>用作<code>RIP-2</code>；<code>224.0.1.2</code>用作<code>SGI</code>公司的<code>dogfight</code>应用。</p></blockquote><p><strong>多播组地址到以太网地址的转换</strong>：</p><p><code>IANA</code>拥有一个以太网地址块，即高位<code>24bit</code>为<code>00:00:5e</code>（十六进制表示），该地址块所拥有的地址范围从<code>00:00:5e:00:00:00</code>到<code>00:00:5e:ff:ff:ff</code>，<code>IANA</code>将其中一半分配为多播地址。为了指明一个多播地址，任何一个以太网地址的首字节必须是<code>01</code>。所以<code>IP</code>多播相对应的以太网地址范围从<code>01:00:5e:00:00:00</code>到<code>01:00:5e:7f:ff:ff</code>。</p><p>这种地址分配将使以太网多播地址中的<code>23bit</code>与<code>IP</code>多播组号对应起来，通过将多播组号中的低位<code>23bit</code>映射到以太网地址中的低位<code>23bit</code>实现。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/以太网多播地址映射.gif" alt="D类IP地址对到以太网多播地址的映射" style="max-width:60%;"><span class="image-caption">D类IP地址对到以太网多播地址的映射</span><blockquote><p>由于多播组号中的最高<code>5bit</code>在映射过程中被忽略，因此每个以太网多播地址对应的多播组是不唯一的。<code>32</code> 个不同的多播组号被映射为一个以太网地址。见下面示例。</p></blockquote><pre class="highlight"><code class>多播地址`224.128.64.32`，十六进制表示为`e0.80.40.20`，后23位二进制表示为` 0000000 01000000 00100000；多播地址`224.0.64.32`,十六进制表示为`e0:00:40:20`，后23位二进制表示为` 0000000 00101000 00100000根据上图映射规则将其转换成以太网地址均为`01:00:5e:00:40:20`。</code></pre><p>既然地址映射是不唯一的，那么设备驱动程序或<code>IP</code>层（见下图展示了主机对由信道传送过来帧的过滤过程）就必须对数据报进行过滤。因为网卡可能接收到主机不想接收的多播数据帧。另外，如果网卡不提供足够的多播数据帧过滤功能，设备驱动程序就必须接收所有多播数据帧，然后对它们进行过滤。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/协议栈各层对收到帧的过滤过程.gif" alt="协议栈各层对收到帧的过滤过程" style="height:300px;"><span class="image-caption">协议栈各层对收到帧的过滤过程</span><p><strong>局域网网卡趋向两种处理类型</strong>：</p><ul><li>网卡根据对多播地址的散列值实行多播过滤，这意味仍会接收到不想接收的多播数据；</li><li>网卡只接收一些固定数目的多播地址，这意味着当主机想接收超过网卡预先支持多播地址以外的多播地址时，必须将网卡设置为 <strong>多播混杂(multicast promiscuous)</strong> 模式。</li></ul><p>这两种类型的网卡仍需要设备驱动程序检查收到的帧是否真是主机所需要的。</p><p>即使网卡实现了完美的多播过滤（基于<code>48bit</code>的硬件地址），由于从<code>D</code>类<code>IP</code>地址到<code>48bit</code>的硬件地址的映射不是一对一的，过滤过程仍是必要的。</p><blockquote><p>尽管存在地址映射不完美和需要硬件过滤的不足，多播仍然比广播好。</p></blockquote><p><strong>单个物理网络的多播过程</strong>：</p><p>多播进程将目的<code>IP</code>地址指明为多播地址，设备驱动程序将它转换为相应的以太网地址，然后把数据发送出去。这些接收进程必须通知它们的<code>IP</code>层，它们想接收的发往给定多播地址的数据报，并且设备驱动程序必须能够接收这些多播帧，这个过程就是 <strong>加入一个多播组</strong> 。当一个主机收到多播数据报时，它必须向属于那个多播组的每个进程均传送一个复制，因为一个主机上可能存在多个属于同一多播组的进程。</p><p><strong>单个物理网络以外的多播</strong> 需要通过路由器转发多播数据时，复杂性就增加了。需要有一个协议让多播路由器了解确定网络中属于确定多播组的任何一个主机，这个协议就是<code>Internet</code>组管理协议（<code>IGMP</code>）。</p><h3 id="igmp"><a class="markdownIt-Anchor" href="#igmp"></a> IGMP</h3><p><strong>因特网组管理协议（Internet Group Management Protocol，ICMP）</strong> ，它让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/IGMP.gif" alt="IGMP报文封装在IP数据报中" style="max-width:60%;"><span class="image-caption">IGMP报文封装在IP数据报中</span><p>与<code>ICMP</code>一样，<code>IGMP</code>也被当作<code>IP</code>层的一部分，通过<code>IP</code>数据报进行传输。区别在于<code>IGMP</code>有固定长度<code>8</code>字节，没有可选数据。</p><h4 id="报文格式"><a class="markdownIt-Anchor" href="#报文格式"></a> 报文格式</h4><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/IGMP报文.gif" alt="IGMP报文格式" style="max-width:60%;"><span class="image-caption">IGMP报文格式</span><p><strong>IGMP 版本</strong> 字段，值为<code>1</code>。</p><p><strong>IGMP 类型</strong> 字段，值为<code>1</code>表明是由多播路由器发出的查询报文；值为<code>2</code>表明是主机发出的报告报文。</p><p><strong>检验和</strong> 字段，与<code>ICMG</code>协议相同。</p><p><strong>组地址</strong> 字段，为<code>D</code>类<code>IP</code>地址。在查询报文中设置为<code>0</code>；在报告报文中为要参加的组地址。</p><h4 id="加入多播组"><a class="markdownIt-Anchor" href="#加入多播组"></a> 加入多播组</h4><p>多播的基础就是一个进程的概念（操作系统执行的一个程序），该进程在一个主机的给定接口上加入了一个多播组。在一个给定接口上的多播组中的成员是动态的，它随时因进程加入和离开多播组而变化。</p><p>这里所指的进程必须以某种方式在给定的接口上加入某个多播组。进程也能离开先前加入的多播组。这些是一个支持多播主机中任何<code>API</code>所必需的部分。</p><blockquote><p>多播组中的成员是与接口相关联的，一个进程可以在多个接口上加入同一多播组。</p><p>主机必须保留一个表，此表中包含所有至少含有一个进程的多播组以及多播组中的进程数量。</p></blockquote><h4 id="igmp-报告和查询"><a class="markdownIt-Anchor" href="#igmp-报告和查询"></a> IGMP 报告和查询</h4><p>多播路由器使用<code>IGMP</code>报文来记录与该路由器相连网络中组成员的变化情况。规则如下：</p><ul><li>当第一个进程加入一个组时，主机就发送一个<code>ICMP</code>报告。如果一个主机的多个进程加入同一组，只发送一个<code>IGMP</code>报告。这个报告被发送到进程加入组所在的同一接口上。</li><li>进程离开一个组时，主机不发送 <code>IGMP</code>报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的<code>IGMP</code>查询中就不再发送报告报文。</li><li>多播路由器定时发送<code>IGMP</code>查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个<code>IGMP</code>查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此<code>IGMP</code>查询报文中的组地址被设置为<code>0</code>。</li><li>主机通过发送<code>IGMP</code>报告来响应一个<code>IGMP</code>查询，对每个至少还包含一个进程的组均要发回<code>IGMP</code>报告。</li></ul><blockquote><p>使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。</p></blockquote><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/IGMP查询与报告.gif" alt="IGMP查询与报告" style="max-width:60%;"><span class="image-caption">IGMP查询与报告</span><p><strong>实现细节</strong>：</p><ul><li>当一个主机首次发送<code>IGMP</code>报告时，并不保证该报告被可靠接收（因为使用的<code>IP</code>交付服务）。下一报告将在间隔一段时间后发送，时间间隔由主机在<code>0</code>～<code>10</code>秒的范围内随机选择。</li><li>当一个主机收到路由器发出的查询后，并不立即响应，而是经过一定的时间间隔后才发出响应（主机必须对它参加的每个组均发送一个响应）。 <strong>既然参加同一多播组的所有主机均发送一个报告，所以可将它们的发送间隔设置为随机时延。</strong></li></ul><blockquote><p>在一个物理网络中的所有主机将收到同组其他主机发送的所有报告，因为如上图所示的报告中的目的地址是组地址。这意味着如果一个主机在等待发送报告的过程中，却收到了发自其他主机的相同报告，则该主机的响应就可以不必发送了。因为多播路由器并不关心有多少主机属于该组（甚至不关心哪些主机属于一个多播组），而只关心该组是否还至少拥有一个主机。</p></blockquote><p><strong>生存时间</strong>：</p><p>在默认情况下，待传多播数据报的<code>TTL</code>被设置为<code>1</code>，这将使多播数据报仅局限在同一子网内传送。更大的<code>TTL</code>值能被多播路由器转发。</p><blockquote><p>对发往一个多播地址的数据报从不会产生<code>ICMP</code>差错。当<code>TTL</code>值为0时，多播路由器也不产生<code>ICMP</code>“超时”差错。</p></blockquote><p>通过增加<code>TTL</code>值的方法，一个应用程序可实现对一个特定服务器的扩展环搜索 (<code>expanding ring search</code>)。第一个多播数据报以<code>TTL</code>等于<code>1</code>发送。如果没有响应，就尝试将<code>TTL</code>设置为<code>2</code>然后<code>3</code>，等等。在这种方式下，该应用能找到以跳数来度量的最近的服务器。</p><blockquote><p>从<code>224.0.0.1</code>到<code>224.0.0.255</code>的特殊地址空间用于多播范围不超过<code>1</code>的应用。不管<code>TTL</code>值是多少，多播路由器均不转发目的地址为这些地址中的任何一个地址的数据报。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议－IP 选路</title>
      <link href="2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/"/>
      <url>2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="ip-选路"><a class="markdownIt-Anchor" href="#ip-选路"></a> IP 选路</h3><p><code>IP</code>层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。这区别于选路策略，它只是一组决定把哪些路由放入路由表的规则。<code>IP</code>执行选路机制，而路由守护程序则一般提供选路策略。</p><h4 id="路由表"><a class="markdownIt-Anchor" href="#路由表"></a> 路由表</h4><p>执行<code>netstat -rn</code> 命令列出路由表如下：</p><pre class="highlight"><code class="bash">$ netstat -rnrouting tablesDestination     Gateway         Flags   Ifacedefault         192.168.1.1     UG      en0127.0.0.1       127.0.0.1       UH      lo0 192.168.1.30    192.168.1.35    UGH     en0</code></pre><p>如果目的地是<code>Destination</code>字段中的值，那么网关（路由器）将把分组转发到<code>Gateway</code>所对应的地址。</p><p><code>Flags</code>标志字段：</p><ul><li>U　该路由可以使用。</li><li>G　该路由是一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的。</li><li>H　该路由是到一个主机，即目的地是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目地地址是一个网络地址（一个网络号，或网络号与子网号的组合）。</li><li>D　该路由是重定向报文创建的。</li><li>M　该路由已被重定向报文修改。</li></ul><blockquote><p><code>deafult</code>表示默认路由，<code>Host Requirements RFC</code>文档中特别说明，<code>IP</code>层必须支持多个默认路由。但是，许多实现系统并不支持这一点。</p></blockquote><p>主机路由表的复杂性取决于主机所在网络的拓扑结构：</p><ul><li>最简单的情况是主机未与任何网络相连。<code>TCP/IP</code>协议仍然能用于这样的主机，但是只能与自己本身通信，路由表只包含环回接口一项。</li><li>第二种情况是主机连接在一个局域网上，只能访问局域网上的主机。这时路由表包含两项分别是环回接口和局域网（以太网）。</li><li>如果主机能够通过单个路由器访问其他网络（如<code>Internet</code>）时，那么就进行下一步。一般情况下增加一个默认表指向该路由器。</li><li>如果要新增其他的特定的主机或网络路由，那么就进行最后一步。</li></ul><blockquote><p>如果路由表中没有默认项，而又没找到匹配项时，会有两种情况：</p><p>1）如果数据报是由本机产生的，那么就给发送该数据报的应用程序返回一个差错（主机不可达或网络不可达差错）。</p><p>2）如果是被转发的数据报，那么就给原始发送端发送一份<code>ICMP</code>主机不可达差错报文。</p></blockquote><h4 id="icmp-重定向差错"><a class="markdownIt-Anchor" href="#icmp-重定向差错"></a> ICMP 重定向差错</h4><p>当<code>IP</code>数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送<code>ICMP</code>重定向差错报文给<code>IP</code>数据报的发送端。只有当主机可以选择路由器发送分组的情况下，我们才可能看到<code>ICMP</code>重定向报文，如下图：</p><ul><li>主机发送一份数据报给<code>R2</code>，主机的默认路由表是<code>R1</code>，所以数据报先到达<code>R1</code>。</li><li><code>R1</code>收到数据报并检查它的路由表，发现<code>R2</code>是该数据报的下一站。当它把数据报发送给<code>R2</code>时，<code>R1</code>检测到它正在发送的接口与数据报到达的接口相同（即主机与两台路由所连接的<code>LAN</code>）。这样就给路由器发送重定向报文给原始发送端提供了线索。</li><li><code>R1</code>发送一份<code>ICMP</code>重定向报文给主机，告诉它以后把数据报发送给<code>R2</code>而不是<code>R1</code>。</li></ul><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/ICMP重定向示例.gif" alt="ICMP 重定向示例" style="max-width:50%;"><span class="image-caption">ICMP 重定向示例</span><blockquote><p><code>ICMP</code>重定向允许<code>TCP/IP</code>主机在进行选路时不需要具备智能特性，而把所有的智能特性放在路由器端。</p><p>主机启动时路由表中可以只有一个默认表项，通过接收重定向报文来逐步学习。</p></blockquote><h4 id="icmp-重定向报文"><a class="markdownIt-Anchor" href="#icmp-重定向报文"></a> ICMP 重定向报文</h4><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/ICMP重定向报文.gif" alt="ICMP 重定向报文" style="max-width:60%;"><span class="image-caption">ICMP 重定向报文</span><p><strong>代码</strong> 字段：</p><ul><li><code>0</code> 网络重定向</li><li><code>1</code> 主机重定向</li><li><code>2</code> 服务类型和网络重定向</li><li><code>3</code> 服务类型和主机重定向</li></ul><blockquote><p><code>ICMP</code>重定向报文的接收者必须查看三个<code>IP</code>地址：</p><p>1）导致重定向的<code>IP</code>地址（即<code>ICMP</code>重定向报文的数据，位于<code>IP</code>数据报首部）；</p><p>2）发送重定向报文的路由器的<code>IP</code>地址（包含重定向信息的<code>IP</code>数据报中的源地址）；</p><p>3）应该采用的路由器<code>IP</code>地址（在<code>ICMP</code>报文中的<code>4</code>~<code>7</code>字节）。</p><p><code>ICMP</code>只能由路由器生成，而不能由主机生成，重定向报文是为主机而不是为路由器使用的。</p></blockquote><p><u>假定多个路由共同参与一个共同参与一种选路协议，则该协议应该消除重定向需求（这就意味着路由表应该被路由守护进程或重定向修改，但不能同时修改。</u> <mark>没读懂???</mark></p><p>当一个<code>BSD</code>主机作为路由器生成<code>ICMP</code>重定向报文前必须通过下面检查：</p><ul><li><p>出接口必须等于入接口</p></li><li><p>用于传出的数据报的路由不能是已经被<code>ICMP</code>重定向创建或修改的，并且不能是路由器的默认路由。</p></li><li><p>数据报不能是源路由</p></li><li><p>内核必须被配置成可以发送重定向</p><blockquote><p>内核变量通常被命名为<code>ip_sendredirects</code>或类似名字来配置，大多数现代系统（<code>BSD</code>、<code>SunOS4.1</code>、<code>Solaris 2.x</code>、和<code>AIX 3.2.2</code>）默认都启用了这个变量，其他系统如<code>SVR4</code>默认禁用该变量。</p></blockquote></li></ul><p>当一个<code>BSD</code>主机接收一个<code>ICMP</code>重定向更新路由表之前必须通过下面检查：</p><ul><li>新的路由器必须直接与网络相连接</li><li>重定向的目的地必须是当前路由器（即当前主机）</li><li>重定向不能让主机本身作为路由器</li><li>被修改的路由必须是一个间接路由</li></ul><blockquote><p>这是为了防止路由器或主机的误操作，以及恶意用户的破坏，导致错误地修改系统路由表。</p><p>路由器应该发送的只是对主机的重定向（代码<code>1</code>或<code>3</code>），而不是对网络的重定向。</p></blockquote><h4 id="icmp-路由器发现报文"><a class="markdownIt-Anchor" href="#icmp-路由器发现报文"></a> ICMP 路由器发现报文</h4><p>到达主机或网络的路由如果不直接相连，那么必须加入路由表。常用的方法是在系统被引导启动时使用<code>route</code>命令。但是几乎没有系统愿意在初始化文件中包含<code>route</code>命令。</p><p>一些系统允许在某个文件中指定默认的路由器，如<code>/etc/defaultrouter</code>。于是在每次重新启动系统时都要在路由表中加入该默认项。</p><p>另一种新的方法是使用<code>ICMP</code>路由器通告和请求报文，允许每个正在监听的主机相应地更新它们的路由表。</p><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/ICMP通告请求报文.gif" style="max-width:60%;"><p><strong>地址数</strong> 字段，报文中所含地址的数量（路由器在一份报文中可以通告多个地址）。</p><p><strong>地址项大小</strong> 字段，每个路由器地址<code>32bit</code>字的数目，始终为<code>2</code>（<code>MAC</code>地址<code>64bit</code>除以<code>32bit</code>等于<code>2</code>）。</p><p><strong>生存时间</strong> 字段，通告地址的有效时间（秒）。</p><p><strong>路由器地址</strong> 字段，发送路由器的某个<code>IP</code>地址。</p><p><strong>优先级</strong> 字段，是一个<code>32bit</code>有符号整数，指出该<code>IP</code>地址作为默认路由器地址的优先级，这是相对于子网上的其他路由器地址而言。值越大优先级越高，值为<code>0x80000000</code>表示该地址不能作为默认路由器地址使用，默认值一般为<code>0</code>。</p><blockquote><p>当路由器启动时，它不定期随机在所有广播或多播传送接口上发送通告报文。随机传送的目的是为了减小与子网上其他路由器发生冲突的概率。一般每两次通告间隔<code>450</code>秒和<code>600</code>秒。一份给定的通告报文默认生命周期是<code>30</code>分钟。</p><p>是当路由器上的某个接口被关闭时，路由器可以在该接口上发送最后一份通告报文，并把生命周期值设为<code>0</code>。</p><p>除了定期发送主动提供的通告报文以外，路由器还要监听来自主机的请求报文，并发送路由器通告报文以响应这些请求报文。</p></blockquote><p>主机在引导期间一般发送三份路由器请求报文，每三秒钟发送一次。一旦接收到一个有效的通告报文，就停止发送请求报文。主机也监听来自相邻路由器的请求报文。这些通告报文可以改变主机的默认路由器。另外，如果没有接收到来自当前默认路由器的通告报文，那么默认路由器会超时。</p><p>只要有一般的默认路由器，该路由器就会每隔<code>10</code>分钟发送通告报文，报文的生命周期是<code>30</code>分钟。这说明主机的默认表项是不会超时的，即使错过一份或两份通告报文。</p><h3 id="动态选路协议"><a class="markdownIt-Anchor" href="#动态选路协议"></a> 动态选路协议</h3><p>上面的静态选路在配置接口时以默认方式生成路由表项（对于直接连接的接口），并通过<code>route</code>命令增加表项（通常从系统自引导程序文件），或是通过<code>ICMP</code>重定向方式生成表项（通常是在默认方式出错的情况下）。</p><p>在网络很小且与其他网络只有单个连接点且没有多余路由时（若主路由失败，可以使用备用路由），采用这种方法是可行的。如果上述三种方法均无法满足，通常使用 <strong>动态选路</strong>。</p><h4 id="动态选路"><a class="markdownIt-Anchor" href="#动态选路"></a> 动态选路</h4><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/IP层工作流程.gif" alt="IP 层工作流程" style="max-width:60%;"><span class="image-caption">IP 层工作流程</span><p>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。路由器上有一个 <strong>路由守护进程（routing daemon）</strong> 它运行选路协议，并与其相邻的一些路由器进行通信。路由守护程序根据它从相邻路由器接收的信息，更新内核中的路由表。</p><p>动态路由并不改变内核在<code>IP</code>层选路方式（内核搜索路由表，查找主机路由、风格路由以及默认路由的方式并没有改变），仅仅是放置路由表中的信息改变了，路由是由动态路由守护程序动态的增加或删除，而不再来自于引导程序中的route命令。</p><blockquote><p>路由守护程序将 <strong>选路策略（routing policy）</strong> 加入到系统中，选择路由并加入内核路由表中。如果守护程序发现前往同一信宿存在多条路由，那么它（以某种方法）将选择最佳路由并加入内核路由表中。如果路由守护程序发现一条链路已经断开（可能是路由器崩溃或电话线路不好），它可以删除受影响的路由或增加另一条路由以绕过该问题。</p></blockquote><p><code>Internet</code>系统中采用了许多不同的选路协议，以一组 <strong>自治系统（Autonomous System，AS）</strong> 方式组织，每个自治系统由单个实体管理。如一个公司或大学校园都可以定义为自治系统。</p><p>每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为 <strong>内部网关协议（Interior Gateway Protocol，IGP）</strong> 或 <strong>域内选路协议（intradomain routing protocol）</strong> 。</p><p>常见的<code>IGP</code>协议：</p><ul><li><code>RIP（Routing Information Protoco）</code>　路由信息协议，最常用的选路协议。</li><li><code>OSPF（Open Shortest Path First）</code>　一种新的选路协议，开放最短路径优先协议，意图取代 RIP。</li><li><code>HELLO</code>　NSFNET 骨干网上使用的较早的协议，现在已经不用了。</li></ul><p><em><strong><code>RFC [Almquist 1993]</code>规定，实现任何动态选路协议的路由器必须同时支持<code>RIP</code>和<code>OSPE</code>，还可以支持其他 <code>IGP</code> 协议</strong></em></p><p><strong>外部网关协议（Exterier Gateway Protocol，EGP）</strong> 或 <strong>域内选路协议</strong> 是用于不同自治系统之间路由器的独立路由协议。</p><p>常见的<code>EGP</code>协议：</p><ul><li><code>EGP</code>　与它同名的协议。</li><li><code>BGP（Border Gateway Protocol，BGP）</code>　新的外部网关协议是当前在 NSFNET 骨干网和一些连接到骨干网的区域性网络上使用的是 <strong>边界网关协议</strong>。意在取代 EGP 协议。</li></ul><h4 id="rip"><a class="markdownIt-Anchor" href="#rip"></a> RIP</h4><p><strong>路由信息协议（Routing Information Protoco，RIP）</strong> ,它是最广为使用（也是最受攻击）的选路协议。对于 <code>RIP</code>的正式描述文件是<code>RFC 1058 [Hedrick 1988a]</code>，是该<code>RFC</code>是在该协议实现数年后才出现的。</p><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/RIP.gif" style="max-width:60%;"><p><code>RIP</code>报文包含在<code>UDP</code>数据报中，如上图：</p><p><strong>命令</strong> 字段，<code>1</code>表示请求；<code>2</code>表示应答；<code>3</code>和<code>4</code>是两个舍弃不用的命令；最后两个是非正式命令，<code>5</code>表示轮询<code>6</code>表示轮询表项。</p><blockquote><p>请求命令表示要求其他系统发送全部或部分路由表。应答命令表示包含发送者的全部或部分路由表。</p></blockquote><p><strong>版本</strong> 字段，通常为<code>1</code>。<em>第二版本 RIP 将此字段设置为 2</em></p><p>接下来是<code>20</code>字节的路由表项，其中 <strong>地址系列</strong> 字段值为<code>2</code>表示<code>IP</code>协议； <strong>32位 IP 地址</strong> 字段值是该路由的目的<code>IP</code>地址（可以是子网地址和主机地址）； <strong>度量</strong> 字段是以跳计数的路由开销值。</p><blockquote><p>一个<code>RIP</code>报文中最多可以有<code>25</code>个路由表项，上限<code>25</code>是为了保证<code>RIP</code>总报文长度为<code>20*25+4=504</code>，小于<code>512</code>字节。由于此限制，所以为了发送整个路由表，经常需要发送多个报文。</p></blockquote><p><code>RIP</code>正常运行流程如下：</p><ul><li><p><strong>初始化</strong> ，在启动一个路由守护程序时，先判断启动哪些接口，并在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。在点对点链路中，该请求是发送给其他终点。如果网络支持广播，请求则以广播方式发送。目的端口号是<code>520</code>（其他路由器守护程序的端口号）。</p><blockquote><p>请求报文命令字段值为<code>1</code>，地址系列字段值为<code>0</code>，度量字段值为<code>16</code>。这是一种要求另一端完整路由表的特殊请求报文。</p></blockquote></li><li><p><strong>接收到请求</strong> ，如果请求是上面的特殊请求，那么路由器将完整路由表发送给请求者。否则，处理请求表中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量值设置为<code>16</code>（度量为<code>16</code>是一种称为“无穷大”的特殊值，它意味着没有到达目的路由），然后发回响应。</p></li><li><p><strong>接收到响应</strong> ，使响应生效，可能会更新路由表。可能会增加新表项，对已有表项进行修改，或是将已有表项删除。</p></li><li><p><strong>定期选路更新</strong> ，每过<code>30</code>秒所有或部分路由器会将完整路由表发送给相邻路由器。发送路由表可以是广播形式，或是发送点对点链路的其他终点。</p></li><li><p><strong>触发更新</strong> ，每当一条路由度量发生变化时，就对它进行更新。不需要发送完整路由表，只需要发送变化的路由表项。</p><blockquote><p>每条路由都有与之相关的定时器。如果运行<code>RIP</code>的系统发现一条路由在<code>3</code>分钟内未更新，就将该路由的度量设置成无穷大（<code>16</code>），并标注为删除。这意味着已经在<code>6</code>个<code>30</code>秒更新时间里没收到通告该路由的路由器的更新了。再过<code>60</code>秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。</p></blockquote></li></ul><h4 id="度量"><a class="markdownIt-Anchor" href="#度量"></a> 度量</h4><p><code>RIP</code> 的度量是以跳(<code>hop</code>)计算的，直接相连的接口跳数为<code>1</code>。如下图，路由器<code>R1</code>通过发送广播到<code>N1</code>通告它与<code>N2</code>之间的跳数是<code>1</code>（发送给<code>N1</code>的广播中通告它与<code>N1</code>之间的路由是无用的）。同时也发送广播给<code>N2</code>通告它与<code>N1</code>之间的跳数为<code>1</code>。同样<code>R2</code>通告它与<code>N2</code>的度量为<code>1</code>，与<code>N3</code>的度量为<code>1</code>。</p><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/RIP度量.gif" alt="路由器和网络示例" style="max-width:60%;"><span class="image-caption">路由器和网络示例</span><p>如果相邻的路由器通告它与其他网络的跳数为<code>1</code>，那么我们就与那个网络的度量就是<code>2</code>，原因在于发送报文到达该网络必须经过那个路由器。如上图，<code>R1</code>到<code>N3</code>和<code>R2</code>到<code>N1</code>的度量均为<code>2</code>。</p><blockquote><p>由于每个路由器都发送其路由表给邻站，因此，可以判断在同一个自治系统<code>AS</code>内到每个网络的路由。如果在该<code>AS</code>内从一个路由器到一个网络有多条路由，那么路由器将选择跳数最小的路由，而忽略其他路由。</p><p>跳数的最大值是<code>15</code>，这意味着<code>RIP</code>只能用在主机间最大跳数值为<code>15</code>的<code>AS</code>内。度量为<code>16</code>表示到无路由到达该<code>IP</code>地址。</p></blockquote><h4 id="rip-缺陷"><a class="markdownIt-Anchor" href="#rip-缺陷"></a> RIP 缺陷</h4><p><code>RIP</code>没有子网地址概念。如果标准<code>B</code>类主机地址主机号不为<code>0</code>，那么<code>RIP</code>无法区分非零部分是一个子网号，还是一个主机号。有一些实现通过接收到的<code>RIP</code>信息，来使用接口的网络掩码，但这有可能出错。</p><p>其次，在路由器或链路发生故障后，通常需要几分钟甚至更长一的时间稳定下来。在这段时间里可能发生路由环路，在实现<code>RIP</code>时必须很多微妙的措施来防止路由环路的出现，使其尽快建立。</p><blockquote><p>路由环路，就是数据包不断在这个网络传输，始终到达不了目的地，导致掉线或者网络瘫痪。</p><p>在维护路由表信息的时候，如果在拓扑发生改变后，网络收敛缓慢产生了不协调或者矛盾的路由选择条目，就会发生路由环路的问题，这种条件下，路由器对无法到达的网络路由不予理睬，导致用户的数据包不停在网络上循环发送，最终造成网络资源的严重浪费。</p></blockquote><p>采用跳数作为路由度量忽略了一些其他考虑的因素。并且度量最大值是<code>15</code>，则限制了可以使用<code>RIP</code>网络的大小。</p><h4 id="rip-2"><a class="markdownIt-Anchor" href="#rip-2"></a> RIP-2</h4><p><code>RIP</code>的第二版只是对第一版进行扩充，并不改变协议本身，而是利用一些“必须为0”字段来传递一些额外信息。如果<code>RIP</code>忽略了这些“必须为0”字段，那么<code>RIP</code>和<code>RIP-2</code>可以交互操作。</p><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/RIP-2.gif" alt="RIP-2报文格式" style="max-width:60%;"><span class="image-caption">RIP-2报文格式</span><p><strong>路由域</strong> 字段，是这个数据报所属的路由守护程序的标识符。在<code>Unix</code>实现中，它可以是一个路由守护程序的进程号。这个字段允许管理者在一个路由器上运行多个<code>RIP</code>实例，每个实例在一个路由域内运行。</p><p><strong>路由标记</strong> 字段，是为了支持外部的网关协议而存在的，它携带一个<code>EGP</code>和<code>BGP</code>的自治系统号。</p><p><strong>子网掩码</strong> 字段，每个表项的子网掩码应该用于相应的<code>IP</code>地址上。</p><p><strong>下一站IP地址</strong> 字段，指明发往目的<code>IP</code>地址的报文该发往哪里。该字段为<code>0</code>表示发往目的地址的报文应该发给发送<code>RIP</code>报文的系统。</p><blockquote><p><code>RIP-2</code>提供了一种简单的鉴别机制，指定<code>RIP</code>报文前<code>20</code>字节表项地址系列为<code>0xffff</code>，路由标记为<code>2</code>，表项中其余<code>16</code>字节包含一个明文口令。</p><p><code>RIP-2</code>除了广播外，还支持多播，可以减少不收听<code>RIP-2</code>报文的主机负载。</p></blockquote><h4 id="ospf"><a class="markdownIt-Anchor" href="#ospf"></a> OSPF</h4><p>开放最短路径优先协议是除了<code>RIP</code>外另一个内部网关协议，它克服了<code>RIP</code>的所有限制，随着大部分厂商支持<code>OSPF</code>，在很多网络中<code>OSPF</code>将逐步取代<code>RIP</code>。</p><p>与采用距离向量（跳数）的<code>RIP</code>不同，<code>OSPF</code>是一个链路状态协议。每个路由器都根据它所收到邻站的这些距离向量来更新自己的路由表。</p><p>在一个链路协议中，路由器并不与邻站交换路由信息。它采用的是每个路由器主动的测试与其邻站相连链路的状态，将这些信息发送给它的其他邻站，而邻站将这些信息在自治系统中传播出去。每个路由器接收这些链路状态信息，并建立起完整的路由表。</p><blockquote><p>链路状态协议总是比距离向量协议收敛（路由发生变化后，稳定下来）更快。</p></blockquote><p><code>OSPF</code>不使用<code>UDP</code>而是直接使用<code>IP</code>,在<code>IP</code>首部协议字段有自己的值。</p><p><strong>特点</strong>：</p><p>1）可以对每个<code>IP</code>服务类型（<code>TOS</code>）计算各自路由集。这意味着对于任何目的，可以有多个路由表项，每个表项对应着一个<code>IP</code>服务类型。</p><p>2）每个接口被分配一个 <a href="https://baike.baidu.com/item/%E6%97%A0%E9%87%8F%E7%BA%B2/10675963"><em>无量纲</em> </a> 成本，可以通过吞吐率、往返时间、可靠性或其他性能来进行分配。可以给每个<code>IP</code>服务类型单独分配成本。</p><p>3）当对同一个目的地址存在多个相同成本的路由时，在这些路由上平均分配流量，称之为流量平衡。</p><p>4）支持子网，子网掩码与每个通告路由相连。这样就允许将一个任何类型的<code>IP</code>地址分割成多个不同大小的子网。到一个主机的路由是通过全<code>1</code>子网掩码进行通告的。默认路由是以<code>IP</code>地址为<code>0.0.0.0</code>网络掩码为全<code>0</code>进行通告的。</p><p>5）路由器之间点对点链路不需要每端都有一个<code>IP</code>地址，称之为无记号网络。这样可以节省<code>IP</code>地址。</p><p>6）采用一种简单鉴别机制。可以采用类似于<code>RIP-2</code>机制的方法指定一个明文口令。</p><p>7）采用多播，而不是广播形式，以减少不参与<code>OSPF</code>系统的负载。</p><h4 id="bgp"><a class="markdownIt-Anchor" href="#bgp"></a> BGP</h4><p>边界网关协议，是一种不同自治系统的路由器之间进行通信的外部网关协议。<code>BGP</code>是<code>ARPANET</code>所使用的老<code>EGP</code>的取代品。</p><p><code>BGP</code>系统与其他<code>BGP</code>系统之间交换网络可到达信息包括数据到达这些网络所必须经过的自治系统<code>AS</code>中的所有路径。这些信息足以构造一幅自治系统连接图。然后，可以根据连接图删除选路环，制订选路策略。</p><p>将一个自治系统中的<code>IP</code>数据报分为本地流量和通过流量。其中，本地流量是起始或终止于该自治系统的流量（即信源<code>IP</code>地址或宿信<code>IP</code>地址所指定的主机位于该自治系统中），其他流量则称为通过流量。在<code>Internet</code>中使用<code>BGP</code>的一个目的就是减少通过流量。</p><p><strong>自治系统分类</strong>：</p><ul><li><code>残桩自治系统（stub AS）</code>，与其他自治系统只有单个连接，因此只有本地流量。</li><li><code>多接口自治系统（multihomed AS）</code>，与其他自治系统有多个连接，但拒绝传送通过流量。</li><li><code>传送自治系统（transit AS）</code>，与其他自治系统有多个连接，在一些策略准则下，可以传送本地流量和通过流量。</li></ul><blockquote><p>可以将<code>Internet</code>的总拓扑结构看成是由一些残桩自治系统、多接口自治系统以及传送自治系统的任意互连。</p><p>残桩自治系统和多接口自治系统不需要使用<code>BGP</code>，它们通过运行<code>EGP</code>在自治系统之间交换可到达信息。</p></blockquote><p><code>BGP</code>允许使用基于策略的选路。由自治系统管理员制订策略，并通过配置文件将策略指定给<code>BGP</code>。制订策略并不是协议的一部分，但指定策略允许<code>BGP</code>实现在存在多个可选路径时选择路径，并控制信息的重发送。选路策略与政治、安全或经济因素有关。</p><p><code>BGP</code>使用<code>TCP</code>作为其传输层协议，两个运行<code>BGP</code>的系统之间建立一条<code>TCP</code>连接，然后交换整个<code>BGP</code>路由表。从这个时候开始，在路由表发生变化时，再发送更新信号。</p><p><code>BGP</code>是一个距离向量协议，但是与（通告到目的地址跳数的）<code>RIP</code>不同的是，<code>BGP</code>列举了到每个目的地址的路由（自治系统到达目的地址的序列号）。这样就排除了一些距离向量协议的问题。采用<code>16 bit</code>数字表示自治系统标识。</p><blockquote><p><code>BGP</code>通过定期发送<code>keepalive</code>报文给其邻站来检测<code>TCP</code>连接对端的链路或主机失败。两个报文之间的时间间隔建议值为<code>30</code>秒。应用层的<code>keepalive</code>报文与<code>TCP</code>的<code>keepalive</code>选项是独立的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
            <tag> IP选路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议－Ping 与 Traceroute 程序</title>
      <link href="2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/"/>
      <url>2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="ping-程序"><a class="markdownIt-Anchor" href="#ping-程序"></a> Ping 程序</h3><p>名字源于声纳定位，用于测试目的主机是否可达。该程序发送一份<code>ICMP</code>回显请求报文给主机，并等待返回<code>ICMP</code>回显应答。</p><p>一般来说，如果不能<code>Ping</code>到某台主机，也就不能<code>Telnet</code>或<code>FTP</code>到那台主机。</p><blockquote><p>随着<code>Internet</code>安全意识的增强，出现了提供访问控制清单的路由器和防火墙，像这样的无限定的断言就不再成立了。</p><p>一台主机的可达性可能不只取决于<code>IP</code>层是否可达，还取决于使用何种协议以及端口号。</p></blockquote><p><code>Ping</code>程序还能测出到这台主机的往返时间，表明该主机离我们有“多远”。</p><p><mark>发送回显请求的 Ping 程序为客户，被 Ping 主机称为服务器。</mark></p><p>大多数<code>TCP/IP</code>实现都在内核中直接支持<code>Ping</code>服务器，这种服务器不是一个用户进程。</p><img src="/2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/ICMP回显报文.gif" alt="ICMP 回显请求和应答报文" style="max-width:60%;"><span class="image-caption">ICMP 回显请求和应答报文</span><p>对于其他类型的<code>ICMP</code>查询报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显。</p><blockquote><p><code>Unix</code>系统在实现<code>Ping</code>程序时是把<code>ICMP</code>报文中的标识符字段置成发送进程的<code>ID</code>号。这样即使在同一台主机上同时运行了多个<code>Ping</code>程序实例，<code>Ping</code>程序也可以识别出返回的信息。</p></blockquote><p><strong>序列号</strong> 从<code>0</code>开始，每发送一次新的回显请求就加<code>1</code>。<code>Ping</code>程序打印出返回的每个分组的序列号，允许我们查看是否有分组丢失、失序或重复。</p><h4 id="lan-输出"><a class="markdownIt-Anchor" href="#lan-输出"></a> LAN 输出</h4><p>在局域网上<code>Ping</code>程序输出结果如下：</p><pre class="highlight"><code class="bash">$ ping <span class="hljs-built_in">test</span>PING <span class="hljs-built_in">test</span> (192.168.2.80): 56 data bytes64 bytes from 192.168.2.80: icmp_seq=0 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=1 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=2 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=3 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=4 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=5 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=6 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=7 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=8 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=9 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=10 ttl=54 time=0 ms...--- www.a.shifen.com ping statistics ---10 packets transmitted, 10 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 5.709/12.672/25.952/8.467 ms</code></pre><p>当<code>ICMP</code>回显应答时，打印结果：</p><ul><li><p>目的主机<code>IP</code> 域名被解析器转换成了<code>IP</code>地址。</p></li><li><p><code>icmp_seq</code>（序列号）每次都从<code>0</code>开始逐条加<code>1</code>。</p></li><li><p><code>ttl</code>（<code>IP</code>首部中生存时间）</p></li><li><p><code>time</code>（往返时间）往返时间是当应答返回时，用当前时间减去在<code>ICMP</code>存放的请求时间计算得出。</p></li><li><p><code>packets transmitted</code> 发包数量</p></li><li><p><code>packets received</code> 接包数量</p></li><li><p><code>packet loss</code> 丢包率</p></li><li><p><code>round-trip time（RTT）</code> 往返时间的<code>min/avg/max</code>计算结果。</p></li></ul><blockquote><p>上面结果中<code>time</code>均为<code>0ms</code>，这是因为程序使用的计时器分辨率低的原因。</p><p><code>BSD/386</code>版本<code>0.9.4</code>系统只能提供<code>10ms</code>级的计时器。</p><p>通常，第<code>1</code>个往返时间值要比其他的大。这是由于目的端的硬件地址不在<code>ARP</code>高速缓存中的缘故。</p></blockquote><h4 id="wan-输出"><a class="markdownIt-Anchor" href="#wan-输出"></a> WAN 输出</h4><p>广域网上<code>Ping</code>程序输出结果会有一些不同，如下：</p><pre class="highlight"><code class="bash">$ ping www.baidu.comPING www.wshifen.com (103.235.46.39): 56 data bytes64 bytes from 103.235.46.39: icmp_seq=0 ttl=48 time=467.455 ms64 bytes from 103.235.46.39: icmp_seq=1 ttl=48 time=473.325 ms64 bytes from 103.235.46.39: icmp_seq=2 ttl=48 time=494.168 msRequest timeout <span class="hljs-keyword">for</span> icmp_seq 364 bytes from 103.235.46.39: icmp_seq=4 ttl=48 time=473.140 ms64 bytes from 103.235.46.39: icmp_seq=5 ttl=48 time=469.418 ms64 bytes from 103.235.46.39: icmp_seq=6 ttl=48 time=481.582 ms64 bytes from 103.235.46.39: icmp_seq=7 ttl=48 time=486.009 ms64 bytes from 103.235.46.39: icmp_seq=8 ttl=48 time=478.788 ms64 bytes from 103.235.46.39: icmp_seq=9 ttl=48 time=484.603 ms64 bytes from 103.235.46.39: icmp_seq=10 ttl=48 time=470.790 ms...--- www.wshifen.com ping statistics ---15 packets transmitted, 13 packets received, 13.3% packet lossround-trip min/avg/max/stddev = 467.455/481.129/494.168/9.280 ms</code></pre><p>如上，序号<code>3</code>回显请求或应答丢失。广域网中还可能出现，重复的分组（相同序号的分组被打印多次）、失序的分组（序号<code>N+1</code>在序号<code>N</code>前面打印）</p><h4 id="ip-记录路由选项"><a class="markdownIt-Anchor" href="#ip-记录路由选项"></a> IP 记录路由选项</h4><p>学习<code>IP</code>首部的时候，提到过可变部分有<code>32bit</code>的选项，<code>Ping</code>程序就提供了查看<code>IP</code>记录路由的选项<code>RR</code>。大多数<code>ping</code>命令通过<code>-R</code>选项指定该功能，它使得<code>Ping</code>程序发出的<code>IP</code>数据报中设置<code>IP</code>的<code>RR</code>选项。这样，每个处理该数据报的路由器都把它的<code>IP</code>放入选项字段中。</p><p>当数据报到达目的端时， <code>IP</code>地址清单应该复制到<code>ICMP</code>回显应答中，这样返回途中所经过的路由器地址也被加入清单中。当<code>Ping</code>程序收到回显应答时，它就打印出这份<code>IP</code>地址清单。</p><blockquote><p>这个过程看似简单，但是存在一些缺陷。因为<code>RR</code>是选项功能，中间路由器对<code>RR</code>的处理未必支持。</p><p>幸运的是，现在的大多数系统都支持这些选项功能，只是有一些系统不把<code>ICMP</code>请求中的<code>IP</code>清单复制到<code>ICMP</code>应答中。</p></blockquote><p><code>IP</code>首部长度字段只有<code>4bit</code>，因此<code>IP</code>首部只能包含<code>15</code>个<code>32bit</code>（即<code>60</code>字节）。其中固定部分长度为<code>20</code>字节，<code>RR</code>选项占<code>3</code>个字节（格式见下图），所以最多只剩下<code>37</code>个字节用来存在<code>IP</code>地址清单，也就是最多只能放<code>9</code>个<code>IP</code>地址。</p><p>除了上面提到的两个缺点外，记录路由选项工作得很好，为详细查看如何处理<code>IP</code>选项提供了一个机会。</p><img src="/2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/RR选项一般格式.gif" alt="IP 首部中 RR 选项一般格式" style="max-width:70%;"><span class="image-caption">IP 首部中 RR 选项一般格式</span><p><strong>code</strong>  字段，值为<code>7</code>指明<code>IP</code>选项类型。</p><p><strong>len</strong> 字段，<code>RR</code>选项总字节长度，一般为<code>39</code>（尽管可以为<code>RR</code>选项设置比最大长度小的长度，但是<code>Ping</code>程序总是提供<code>39</code>字节的选项字段，最多可以记录<code>9</code>个<code>IP</code>地址。由于<code>IP</code>首部中留给选项的空间有限，所以一般情况都设置成最大长度）。</p><p><strong>ptr</strong> 字段，称作指针字段。它是一个基于<code>1</code>的指针，指向存放下一个<code>IP</code>地址的位置。它的最小值为<code>4</code>，指向存放第一个<code>IP</code>地址的位置。随着每个<code>IP</code>地址存入清单， <code>ptr</code>的值分别为<code>8</code>，<code>12</code>，<code>16</code>，最大到<code>36</code>。当记录下<code>9</code>个<code>IP</code>地址后，<code>ptr</code>的值为<code>40</code>，表示清单已满。</p><blockquote><p>当路由器在清单中记录<code>IP</code>地址时，它应该记录入口地址还是出口地址？</p><p><code>RFC 791 [Postel 1981a]</code>指定路由器记录出口<code>IP</code>地址。</p><p>当原始主机（运行<code>ping</code>程序的主机）收到带有<code>RR</code>选项的<code>ICMP</code>回显应答时，它也要把它的入口<code>IP</code>地址放入清单中。</p></blockquote><p><strong><code>RR</code>选项示例：</strong></p><hr><p>在主机<code>svr4</code>上运行<code>Ping</code>程序到主机<code>slip</code>，其中有个中间路由<code>bdsi</code>将处理这个数据报。</p><pre class="highlight"><code class="bash">$ ping -R slipPING slip (140.252.13.65): 56 data bytes64 bytes from 140.252.13.65: icmp_seq=0 ttl=254 <span class="hljs-built_in">times</span>=280msRR:    bsdi (140.252.13.65)       slip (140.252.13.65)       bsdi (140.252.13.35)       svr4 (140.252.13.34)64 bytes from 140.252.13.65: icmp_seq=1 ttl=254 <span class="hljs-built_in">times</span>=280ms 64 bytes from 140.252.13.65: icmp_seq=2 ttl=254 <span class="hljs-built_in">times</span>=270ms ... 省略--- 140.252.13.65 ping statistics ---3 packets transmitted, 3 packets recieved, 0% packets lossround-trip min/avg/max = 270/276/280 ms</code></pre><p>分组经过<code>4</code>跳，每一跳把自己的出口<code>ip</code>加入<code>RR</code>清单，最后一跳<code>svr4</code>收到<code>ICMP</code>回显应答，所以把自己的入口<code>IP</code>也加入清单中。如下图：</p><img src="/2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/Ping程序记录路由选项.gif" alt="Ping 程序记录路由选项" style="max-width:70%;"><span class="image-caption">Ping 程序记录路由选项</span><hr><h3 id="traceroute-程序"><a class="markdownIt-Anchor" href="#traceroute-程序"></a> Traceroute 程序</h3><p><code>Ping</code>程序可以通过<code>RR</code>选项记录<code>IP</code>路由有三个问题：</p><ul><li>并不是所有的路由器都支持<code>RR</code>选项。</li><li>记录路由是单项的选项。发送端设置了该选项，那么接收端不得不从收到的<code>IP</code>首部中提取出所有的信息，然后全部返回给发送端。</li><li><code>IP</code>首部中留给选项的空间有限，不能存放当前大多数的路径。在<code>IP</code>首部选项字段中最多只能存放<code>9</code>个<code>IP</code>地址。</li></ul><p><code>Traceroute</code>程序可以解决上面的问题。它不需要中间路由器具备任何特殊的或可选的功能；它只需要目的端运行一个<code>UDP</code>模块，其他不需要任何特殊的服务器应用程序；</p><p><code>Traceroute</code>程序使用<code>ICMP</code>报文和<code>IP</code>首部中的<code>TTL</code>字段。<code>TTL</code>字段由发送端初始设置的一个<code>8bit</code>字段，推荐初始值为<code>64</code>。较老系统一经常初始化为<code>15</code>或<code>32</code>。一些<code>Ping</code>程序发送<code>ICMP</code>回显应答时经常把<code>TTL</code>设为最大值<code>255</code>。</p><blockquote><p>每个处理数据报的路由器都需要把<code>TTL</code>的值减<code>1</code>或减去数据报在路由器中停留的秒数。</p><p>由于大多数的路由器转发数据报的时延都小于<code>1</code>秒钟，因此<code>TTL</code>最终成为一个跳站的计数器，所</p><p>经过的每个路由器都将其值减<code>1</code>。</p><p><code>RFC 1009 [Braden and Postel 1987]</code>指出，如果路由器转发数据报的时延超过<code>1</code>秒，那么它将把<code>TTL</code>值减去所消耗的时间（秒数）。但很少有路由器这么实现。新的路由器需求文档<code>RFC [Almquist 1993]</code>为此指定它为可选择功能，允许把<code>TTL</code>看成一个跳站计数器。</p></blockquote><p><code>TTL</code>字段的目的是防止数据报在选中时无休止的在网络中流动。当路由器收到一份<code>IP</code>数据报时，如果其<code>TTL</code>值是<code>0</code>，路由器会将该数据报丢弃并给源主机发送一个<code>ICMP</code>超时信息。<code>Traceroute</code><mark>程序的关键在于包含这份 ICMP 信息的 IP 报文信源地址是该路由器的 IP 地址</mark></p><hr><p>综上所述，<code>Traceroute</code>程序的操作过程是，它发送一个<code>TTL</code>为<code>1</code>的<code>IP</code>数据报给目的主机，第一个路由器将<code>TTL</code>值减<code>1</code>后丢弃该数据报并发回一份<code>ICMP</code>超时报文，这样就得到了第一个路由器地址；然后，<code>Traceroute</code>再发送一份<code>TTL</code>为<code>2</code>的<code>IP</code>数据报，获取第二个路由器地址，依此类推，直到最终目的主机为止。</p><hr><blockquote><p>上面操作过程问题是，当目的主机接收到<code>TTL</code>为<code>1</code>的<code>IP</code>数据报时，因为已经到达目的地，所以它不会丢弃该数据报而产生一个超时<code>ICMP</code>报文。所以该方法无法判断是否已经到达目的地。</p><p>为了解决这个问题，<code>Traceroute</code>程序发送一个<code>UDP</code>数据报给目的主机，但使用一个不可能值作为端口（大于30 000），使目的主机任何一个程序都不可能使用该端口。所以，当数据报到达时，目的主机<code>UDP</code>模块将产生一个“端口不可达”错误的<code>ICMP</code>报文，通过判断这个状态就可以知道是否已经到达目的地。</p></blockquote><p><code>Traceroute</code>程序可以为发送数据报设置<code>TTL</code>字段，并非所有<code>TCP/IP</code>接口程序都支持这项功能（目前大多数系统都支持这项功能）。</p><h4 id="lan-输出-2"><a class="markdownIt-Anchor" href="#lan-输出-2"></a> LAN 输出</h4><pre class="highlight"><code class="bash">$ traceroute laniptraceroute to lanip (192.168.1.59), 64 hops max, 52 byte packets 1  lanip (192.168.1.59)  6.332 ms  5.757 ms  5.427 ms</code></pre><p>第一行，打印出域名和<code>IP</code>地址、最大<code>TTL</code>值为<code>64</code>和<code>52</code>字节数据包包括<code>IP</code>首部<code>20</code>字节、<code>UDP</code>首部<code>8</code>字节和<code>24</code>字节的用户数据（包含每发一个数据报就加 1的序列号、<code>TTL</code>和发送数据报的时间）。</p><p>从第二行起，以<code>TTL</code>开始，接下来是主机或路由器名及<code>IP</code>地址。</p><blockquote><p>对于每个<code>TTL</code>值，发送3份数据报，每收到一份<code>ICMP</code>数据报就打印其往返时间。如果在<code>5</code>秒内仍未收到任意一个数据报的响应，则打印一个<code>*</code>号，并发送下一个数据报。</p><p>往返时间是由发送主机的<code>Traceroute</code>程序计算的，它是指从<code>Traceroute</code>程序到该路由器的总往返时间。如果对每段路径的时间感兴趣，可以用<code>TTL</code>字段为<code>N + 1</code>所打印出来的时间减去<code>TTL</code>字段为<code>N</code>的时间。</p></blockquote><p>上面数据<code>TTL</code>为<code>1</code>的前<code>3</code>份<code>ICMP</code>数据报分别在<code>6.332ms</code>、<code>5.757ms</code>和<code>5.427ms</code>收到。并且由于<code>TTL</code>为字段为<code>1</code>就到达最终目的主机，因此程序就此停止。</p><h4 id="wan-输出-2"><a class="markdownIt-Anchor" href="#wan-输出-2"></a> WAN 输出</h4><pre class="highlight"><code class="bash">$ traceroute www.baidu.comtraceroute: Warning: www.baidu.com has multiple addresses; using 182.61.200.7traceroute to www.a.shifen.com (182.61.200.7), 64 hops max, 52 byte packets 1  192.168.1.1 (192.168.1.1)  19.327 ms  19.036 ms  19.118 ms 2  43.228.38.145 (43.228.38.145)  6.653 ms  6.279 ms  6.568 ms 3  10.1.14.33 (10.1.14.33)  4.085 ms  3.979 ms * 4  10.1.16.165 (10.1.16.165)  25.585 ms  25.723 ms  25.560 ms 5  103.216.40.30 (103.216.40.30)  5.586 ms  27.102 ms  25.276 ms 6  182.61.255.32 (182.61.255.32)  24.570 ms    182.61.255.40 (182.61.255.40)  6.256 ms    182.61.255.34 (182.61.255.34)  24.247 ms 7  182.61.255.47 (182.61.255.47)  6.141 ms    182.61.254.183 (182.61.254.183)  6.415 ms    182.61.254.171 (182.61.254.171)  5.069 ms 8  * * * 9  * * *10  * * *... 省略64  * * *</code></pre><h4 id="ip-源站选路选项"><a class="markdownIt-Anchor" href="#ip-源站选路选项"></a> IP 源站选路选项</h4><p>通常<code>IP</code>路由是动态的，即每个路由器都要判断数据报下面该转发到哪个路由器。应用程序对此不进行控制，通常也不关心路由。</p><p><strong>源站选路（source route）</strong> 的思想是由发送者指定路由，可以采用以下两种形式：</p><ul><li>严格源站选路，发送端指明<code>IP</code>数据报所必须采用的确切路由。如果一个路由器发现源站路由所指定的下一个路由器不在其直接连接的网络上，那么它就返回一个“源站路由失败”的<code>ICMP</code>差错报文（即<code>type</code>字段值为<code>3</code>，<code>code</code>字段值为<code>5</code>，同时<code>RTT</code>后面会跟随<code>!S</code>符号）。</li><li>宽松源站选路，发送端指明一个数据报经过的<code>IP</code>地址清单，但是数据报在清单上指明任意两个地址之间可以通过其他路由器。</li></ul><p><code>Traceroute</code>程序提供了一个查看源站选路的方法，可以在选项中指明源站路由，然后检查其运行情况。</p><blockquote><p>一些公开的<code>Traceroute</code>程序源代码包中包含指明宽松的源站选路的补丁。但是在标准版中通常并不包含此项。这些补丁的解释是 “<code>Van Jacobson</code>的原始<code>Traceroute</code>程序（1 9 8 8年春）支持该特性，但后来因为有人提出会使网关崩溃而将此功能去除。”</p></blockquote><p>源站路由选项的格式与记录路由选项格式基本一致。不同之处是，对于源站选路，我们必须在发送<code>IP</code>数据报前填充<code>IP</code>地址清单，即对于源站选路，要为所需要的<code>IP</code>地址数分配空间并进行初始化，通常其数量小于<code>9</code>。</p><p><strong>code</strong> 字段，值分别为<code>0x83</code>（表示宽松源站选路）和<code>0x89</code>（表示严格的源站选路）。</p><p><strong>len</strong> 和 <strong>ptr</strong> 字段与记录路由选项一样。</p><p>源站路由选项的实际称呼为“源站及记录路由”（对于宽松的源站选路和严格的源站选路，分别用<code>LSRR</code>和<code>SSRR</code>表示），这是因为在数据报沿路由发送过程中，对<code>IP</code>地址清单进行了更新。其运行过程如下：</p><ul><li><p>发送主机从应用程序接收源站路由清单，将第<code>1</code>个表项去掉（它是数据报的最终目的地址），将剩余的项移到<code>1</code>个项中，并将原来的目的地址作为清单的最后一项。指针仍然指向清单的第<code>1</code>项（即，指针的值为<code>4</code>）。</p></li><li><p>每个处理数据报的路由器检查其是否为数据报的最终地址。如果不是，则正常转发数据报（在这种情况下，必须指明宽松源站选路，否则就不能接收到该数据报）。</p></li><li><p>如果该路由器是最终目的，且指针不大于路径的长度：</p><ul><li>由<code>ptr</code>所指定的清单中的下一个地址就是数据报的最终目的地址；</li><li>由外出接口（<code>outgoing interface</code>）相对应的<code>IP</code>地址取代刚才使用的源地址；</li><li>指针加4。</li></ul><p>如下图示例，主机<code>S</code>发送数据报到<code>D</code>，指定源路由为<code>R1</code>、<code>R2</code>和<code>R3</code>。<code>#</code>表示指针，其值分别为<code>4</code>、<code>8</code>、<code>12</code>和<code>16</code>。长度字段为<code>15</code>（三个<code>IP</code>地址<code>12</code>字节加上首部<code>3</code>字节）。</p></li></ul><img src="/2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/源站路由选项示例.gif" alt="IP 源站路由选项示例" style="max-width:70%;"><span class="image-caption">IP 源站路由选项示例</span><h4 id="traceroute-命令示例"><a class="markdownIt-Anchor" href="#traceroute-命令示例"></a> traceroute 命令示例</h4><p>使用<code>traceroute</code>命令<code>-g</code>选项，可以为宽松的源站选路指明一些中间路由器。最多可指定<code>8</code>个中间路由器（不是<code>9</code>个的原因是所有编程接口要求最后的表目是目的主机）。</p><blockquote><p>在命令行指定的路由器必须是十进制<code>IP</code>地址而不是域名，因为反向域名解析（通过<code>IP</code>地址返回域名）将域名与<code>IP</code>地址相关联，但是前向解析（即给出域名返回<code>IP</code>地址）则无法做到。在<code>DNS</code>中，前向映射和反向映射是两个独立的文件，而并非所有的管理者都同时拥有这两个文件。因此，在一个方向是工作正常而另一个方向却失败的情况并不少见。</p></blockquote><p>使用<code>traceroute</code>命令<code>-G</code>选项，可以执行严格源站选路。</p><blockquote><p>宽松选路的往返路由可能不完全相同，即从<code>A</code>到<code>B</code>的路径并不一定与从<code>B</code>到<code>A</code>的路径完全一样。</p><p>指定一个宽松的源站路由，该路由的目的端和宽松路径一样，但发送端为目的主机。如果发出路径的结果与返回路径不同，这很好地说明了在<code>Internet</code>上，选路可能是不对称的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
            <tag> Ping </tag>
            
            <tag> Traceroute </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议－地址解析协议</title>
      <link href="2021/09/27/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/09/27/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="arp"><a class="markdownIt-Anchor" href="#arp"></a> ARP</h2><p>当一台主机把以太网的数据帧发送到位于同一局域网上的另一台主机时，是根据<code>48bit</code>的以太网地址来确定目的接口的，设备驱动程序从不检查<code>IP</code>数据报中的目的地<code>IP</code>地址。</p><p>地址解析为这两种不同的地址形式提供映射。 <strong>地址解析协议（Adress Resolution Protocol，ARP）</strong> 为<code>IP</code>地址到对应的硬件地址之间提供动态映射。</p><blockquote><p>ARP 高效运行的关键是由于每个主机都有一个<code>ARP</code>高速缓存，存放最近<code>Internet</code>地址到硬件地址之间的映射记录。高速缓存从被创建起，每一项的生存时间一般为<code>20</code>分钟。</p></blockquote><p><code>示例</code>：</p><pre class="highlight"><code class="bash">$ ftp bsdi <span class="hljs-comment"># 执行 ftp 命令</span>-----------后台执行步骤如下---------------------------------------1.应用程序 FTP 客户端调用函数`gethostbyname(3)`把主机名转换成 IP 地址。  这个转换过程使用`DNS`或在较小的网络使用一个静态的主机文件`/etc/hosts`。2.FTP 用得到的 IP 地址请求 TCP 建立连接。3.TCP 用 IP 地址发送一份数据报。5.如果目的主机在本网络上，IP 数据报可直达目的主机；如果在远程网络上，  通过 IP 选路函数确定下一跳路由器地址，并让它转发数据报。6.如果是以太网，则需要将 IP 地址变换成以太网地址。这就是 ARP 的功能。7.ARP 发送一份 ARP请求的以太网数据帧（包括 IP 地址和主机名）给以太网上的每个主机，这个过程叫做广播。8.目的地址主机 ARP 收到广播后，识别出发送端在寻问它的地址后，发送一个 ARP 应答（包含 IP 地址和硬件地址）。9.发送 IP 数据报到目的主机。</code></pre><blockquote><p>接口都有一个<code>48bit</code>硬件地址，通常称呼其为<code>MAC</code>地址。地址每个字节用十六进制数表示，每字节中间以<code>:</code>隔开，共有<code>2^48</code>个可能的<code>MAC</code>地址。通过<code>IEEE</code>统一分配使用，分配方式是固定一个<code>MAC</code>地址的前<code>24bit</code>，让公司自己为每个适配器生成后<code>24bit</code>。</p></blockquote><h3 id="arp-分组格式"><a class="markdownIt-Anchor" href="#arp-分组格式"></a> ARP 分组格式</h3><img src="/2021/09/27/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/ARP分组格式.gif" alt="以太网ARP请求/应答分组格式" style="max-width:80%;"><span class="image-caption">以太网ARP请求/应答分组格式</span><p><strong>源地址</strong> 和 <strong>目的地址</strong>  ，均占<code>6</code>字节，其中目的地址值是全为<code>1</code>的特殊地址表示广播地址。<mark>电缆上所有的以太网接口都要接收广播的数据帧。</mark></p><p><strong>帧类型</strong> 表示后面的数据类型。对于<code>ARP</code>请求和应答来说，该字段值均为<code>0x0806</code>。</p><p><strong>硬件类型</strong> 表示硬件地址的类型，值为<code>1</code>表示以太网地址。</p><p><strong>协议类型</strong> 表示要映射的协议地址类型，值为<code>0x0800</code>表示<code>IP</code>地址。它的值与以太网数据帧中类型字段<code>IP</code>数据报类型的值相同，这是有意设计的。</p><p><strong>硬件地址长度</strong> 和 <strong>协议地址长度</strong> ，单位为<code>字节</code>，所以对于以太网上<code>IP</code>地址的<code>ARP</code>请求和应答来说，它们的值分别为 <code>6</code>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>48</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">48/8=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">8</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>）和<code>4</code>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">32/8=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>）。</p><p><strong>操作字段（op）</strong> 总共有四种操作类型：</p><ul><li>值为<code>1</code>，表示<code>ARP</code>请求。</li><li>值为<code>2</code>，表示<code>ARP</code>应答。</li><li>值为<code>3</code>，表示<code>RARP</code>请求。</li><li>值为<code>4</code>，表示<code>RARP</code>应答。</li></ul><p>这个字段是必须的，因为<code>ARP/RARP</code>的帧类型字段值是相同的。</p><p>最后四个字段有一些重复信息，如在以太网帧首部和<code>ARP</code>请求数据帧中都有 <strong>发送端硬件地址</strong> 信息。</p><blockquote><p>对于一个<code>ARP</code>请求来说，除 <strong>目的端硬件地址</strong> 外的所有其他的字段都有填充值。当系统收到一份目的端为本机的<code>ARP</code>请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为<code>2</code>，最后把它发送回去。</p></blockquote><h3 id="arp-请求应答"><a class="markdownIt-Anchor" href="#arp-请求应答"></a> ARP 请求/应答</h3><p>当一台主机<code>bsdi</code>通过<code>telnet</code>工具发送一个简单的请求时，<code>ARP</code>的执行情况如下：</p><pre class="highlight"><code class="bash">$ arp -a <span class="hljs-comment"># 检查 ARP 高速缓存为空</span>$ telnet svr4 discard <span class="hljs-comment"># 连接 svr4</span>Trying 140.252.13.34..Connected to svr4.Escape character is <span class="hljs-string">'^]'</span>.^]            <span class="hljs-comment"># 进入 telnet 命令行</span>telnet&gt; quit  <span class="hljs-comment"># 退出 telnet</span>Connection closed.-----------------------------------------------<span class="hljs-comment"># 在 telnet 目标系统执行　tcpdump 命令监控 ARP </span>$ tcpdump -e1    0.0                  0:0:c0:6f:2d:40    ff:ff:ff:ff:ff:ff    arp    60                          arp who-has svr4 tell bsdi2.   0.002174 (0.0022)    0:0:c0:c2:9b:26    0:0:c0:6f:2d:40      arp    60                          arp reply svr4 is-at 0:0:c0:c2:9b:263.   ...省略</code></pre><p>第<code>1</code>行，源端主机<code>bsdi</code>硬件地址<code>0:0:c0:6f:2d:40</code>，目的地址表示为广播地址，电缆上所有的以太网接口都要接收这个数据帧并对它进行处理。</p><p><code>arp</code>说明此数据帧是一个<code>ARP</code>请求或应答，所以帧类型字段值是<code>0x0806</code>。</p><p><code>60</code>表示以太网数据帧长度，由于<code>ARP</code>数据帧长度都是<code>42</code>字节（帧头<code>14</code>字节包括<strong>目的地址、源地址、类型字段</strong>，<code>28</code>字节<code>ARP</code>数据），因此，第一帧都必须加入填充字符以达到以太网<code>60</code>字节的最小长度要求。</p><blockquote><p>最小长度指<code>14</code>字节的以太网帧头（包括目的地址、源地址、长度），数据字段<code>46</code>字节，不包括<code>4</code>字节以太网帧尾。</p></blockquote><p><code>arp who-has</code>表示<code>ARP</code>请求的数据帧中，目的<code>IP</code>地址是<code>svr4</code>的地址，发送端<code>IP</code>地址是<code>bsdi</code>的地址。</p><p>第<code>2</code>行，目的主机进行<code>ARP</code>应答，其目的主机<code>IP</code>是<code>bsdi(0:0:c0:6f:2d:40)</code>，<code>ARP</code>应答是直接发送到请求主机，而不是广播。</p><p><code>arp reply</code>表示应答<code>svr4</code>的地址在<code>0:0:c0:c2:9b:26</code>。</p><blockquote><p>从第<code>2</code>行开始，每行在括号中都包含与上一行的时间差（单位：秒）。</p></blockquote><hr><p>如果查询的主机已关机或不存在时，情况如下：</p><pre class="highlight"><code class="bash">$ telnet 140.252.13.36 <span class="hljs-comment"># 连接无效 IP 地址</span>Trying 140.252.13.36...telnet: Unable to connect remote host: Connection timed out.$ arp -a <span class="hljs-comment"># 检查 ARP 高速缓存</span>? (140.252.13.36) at (incomplete)----------------------------------------------------------------<span class="hljs-comment"># 在另一系统执行 tcpdump 命令</span>$ tcpdump1    0.0                   arp who-has 140.252.13.36 tell bsdi2    5.509069  (5.5091)    arp who-has 140.252.13.36 tell bsdi3    29.509745 (24.0007)   arp who-has 140.252.13.36 tell bsdi</code></pre><p><code>ARP</code>请求按照指定规则一直重发，直到时间超过<code>TCP</code>请求设置的超时时间结束，通常为<code>75</code>秒。</p><hr><h3 id="arp-高速缓存超时设置"><a class="markdownIt-Anchor" href="#arp-高速缓存超时设置"></a> ARP 高速缓存超时设置</h3><p>在<code>ARP</code>高速缓存中的表项一般都要设置超时时间，通常对完整表项的超时时间设置为<code>20</code>分钟，不完整的表项超时时间为<code>3</code>分钟。上面<code>telnet 140.252.13.36</code>示例中的表项就是不完整表项(<code>incomplete</code>)，即以太网上不存在的主机发出的的<code>ARP</code>请求。</p><blockquote><p>管理员可以通过<code>arp</code>命令把地址放入高速缓存中，而不设置超时时间。</p><p><code>Host Requirements RFC</code>表明，即使表项正在使用时超时值也应该启动，但是大多数从伯克利系统演变而来的系统没有这样做，它们在每次使用表项时重设超时时间。</p></blockquote><h3 id="arp-代理"><a class="markdownIt-Anchor" href="#arp-代理"></a> ARP 代理</h3><p>如果<code>ARP</code>请求是从一个网络主机发往另一个网络主机，那么连接这两个网络的路由器就可以回答这个请求，这个过程称作 <strong>委托 ARP 或 ARP代理</strong> 。</p><blockquote><p><strong>ARP 代理</strong> 会让<code>ARP</code>请求发送端误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。</p><p>路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。</p></blockquote><p>如下图，当子网<code>140.252.1</code>上的主机<code>gemini</code>将一份<code>IP</code>数据报要传递给<code>140.252.1.29</code>的<code>sun</code>时，会发送<code>ARP</code>请求给<code>140.252.1.29</code>。路由器<code>netb</code>识别出该<code>IP</code>地址属于它的一个拨号主机，于是把它的以太网接口地址<code>140.252.1</code>作为硬件地址来回答。</p><p>主机<code>gemini</code>通过以太网发送<code>IP</code>数据报到<code>netb</code>，<code>netb</code>通过拨号<code>SLIP</code>将数据报转发到<code>sun</code>。这个过程对所有<code>140.252.1</code>子网上的主机都是透明的，主机<code>sun</code>实际上是路由器<code>netb</code>后面配置的。</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 在主机`gemini`上执行`arp -a`命令，经过与主机`sun`通信后，</span><span class="hljs-comment"># 发现同一个子网`140.252.1`上的`netb`和`sun`的 IP 地址映射的硬件地址是相同的。</span><span class="hljs-comment"># 这通常是使用 ARP 委托的线索。</span>$ arp -anetb (140.252.1.183) at 0:80:ad:3:6a:80sun (140.252.1.29) at 0:80:ad:3:6a:80</code></pre><img src="/2021/09/27/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/ARP代理.gif" alt="ARP 代理" style="max-height:350px"><span class="image-caption">ARP 代理</span><blockquote><p>通过上图发现，<code>bsdi</code>和<code>slip</code>之间分别有一个<code>IP</code>，所以路由器<code>netb</code>下方<code>SLIP</code>链路显然缺少一个<code>IP</code>地址，这是因为路由器不需要知道拨号<code>SLIP</code>链路每一端的<code>IP</code>地址（减少了<code>IP</code>的使用）。</p><p>通过分组到达的串行线路接口来确定发送分组的拨号主机，因此对于连接到路由器的每个拨号主机不需要用唯一的<code>IP</code>地址，所有拨号主机使用同一个<code>IP</code>地址作为<code>SLIP</code>链路的目的地址。</p><p>通过<code>ifconfig</code>命令可以显示该拨号<code>SLIP</code>链路的目的地址是<code>140.252.1.183</code>。</p></blockquote><h3 id="免费-arp"><a class="markdownIt-Anchor" href="#免费-arp"></a> 免费 ARP</h3><p><strong>免费ARP（Gratuitous ARP）</strong> 包是一种特殊的<code>ARP</code>请求，它并非期待得到<code>IP</code>对应的<code>MAC</code>地址，而是当主机启动的时候，发送一个<code>Gratuitous ARP</code>请求，即请求自己的<code>IP</code>地址的<code>MAC</code>地址。</p><p>它与普通<code>ARP</code>请求报文的区别在于报文中的目标<code>IP</code>地址。普通<code>ARP</code>报文中的目标<code>IP</code>地址是其他主机的<code>IP</code>地址，而免费<code>ARP</code>的请求报文中，目标<code>IP</code>地址是自己的<code>IP</code>地址。</p><p><code>作用</code>：</p><ul><li>用于检测<code>IP</code>地址冲突。当一台主机发送了免费<code>ARP</code>请求报文后，如果收到了<code>ARP</code>响应报文，则说明网络内已经存在使用该<code>IP</code>地址的主机。</li><li>用于更新其他主机的 ARP 缓存表。当主机更换了网卡（接口卡）,而其他主机的<code>ARP</code>缓存表仍然保留着原来的<code>MAC</code>地址。这时，可以发送免费的<code>ARP</code>数据包。其他主机收到该数据包后，将更新<code>ARP</code>缓存表，将原来的<code>MAC</code>地址替换为新的<code>MAC</code>地址。</li></ul><h2 id="rarp"><a class="markdownIt-Anchor" href="#rarp"></a> RARP</h2><p><strong>逆地址解析协议（Reverse Address Resolution Protocol，RARP）</strong>,与<code>ARP</code>作用相反，用于将<code>MAC</code>地址通过读取<code>ARP</code>缓存表获取其<code>IP</code>地址。</p><p>具有本地磁盘的主机，一般通过磁盘上配置文件读取<code>IP</code>地址，但是无盘主机（如X终端或无盘工作站）则需要通过其他方法来获取<code>IP</code>地址。</p><p>网络上每个系统都具有唯一的硬件地址，它由网络接口生产厂商配置，无盘系统就可以从接口网卡读取硬件地址，再通过<code>RARP</code>协议获取<code>IP</code>地址。</p><h3 id="rarp-分组格式"><a class="markdownIt-Anchor" href="#rarp-分组格式"></a> RARP 分组格式</h3><p>与<code>ARP</code>分组格式基本一致，主要区别是<code>RARP</code>请求/应答帧类型是<code>0x8035</code>，请求操作代码是<code>3</code>,应答操作代码是<code>4</code>。</p><blockquote><p><code>RARP</code>请求以广播方式传送，而<code>RARP</code>的应答一般是单播传送。</p></blockquote><h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3><ul><li>发送主机发送一个本地<code>RARP</code>广播，声明自己的<code>MAC</code>地址并请求任何收到该请求的<code>RARP</code>服务器分配一个<code>IP</code>地址；</li><li>本地网段上的<code>RARP</code>服务器收到此请求后，检查其<code>RARP</code>列表中<code>MAC</code>地址对应的<code>IP</code>地址；</li><li>如果存在，<code>RARP</code>服务器给源主机发送一个响应数据包并将该<code>IP</code>地址提供给对方主机使用；</li><li>如果不存在，<code>RARP</code>服务器对此不做任何响应；</li><li>源主机收到<code>RARP</code>服务器响应信息，就可利用得到<code>IP</code>地址进行通信；如果一直没收到<code>RARP</code>服务器响应，则表示初始化失败。</li></ul><h3 id="rarp-服务器设计"><a class="markdownIt-Anchor" href="#rarp-服务器设计"></a> RARP 服务器设计</h3><p><code>RARP</code>在原理上很简单但是实现比较复杂，由于<code>RARP</code>的请求是在硬件层上的广播，因此不能通过路由器进行转发。为了让无盘系统在<code>RARP</code>关机的状态下也能引导，通常在每个网络上都要实现多个<code>RARP</code>服务器，服务器数量增加，网络流量也随之增加。</p><p>发送<code>RARP</code>请求的无盘系统一般采用最先收到的<code>RARP</code>应答（<code>ARP</code>没有这种情况，因为只有一台主机发送<code>ARP</code>应答），另外在同一网络中不同主机可能会同时进行<code>RARP</code>应答，这样增加了以太网发生冲突的概率。</p><blockquote><p><code>RARP</code>服务器一般要为多个主机提供硬件地址到<code>IP</code>地址的映射，该映射包含在一个磁盘文件中（<code>Uinx</code>系统一般位于<code>/etc/ethers</code>目录中）。由于内核一般不读取和分析磁盘文件，因此<code>RARP</code>服务器的功能就由用户进程来提供，而不是作为内核的<code>TCP/IP</code>实现的一部分。</p><p>更为复杂的是，<code>RARP</code>请求是作为一个特殊类型的以太网帧类型（<code>0x8035</code>）来传送，这说明<code>RARP</code>服务器必须能够发送和接收这种类型的以太网数据帧。由于发送和接收这些数据帧与系统有关，因此<code>RARP</code>服务器的实现是与系统捆绑在一起的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
            <tag> ARP </tag>
            
            <tag> RARP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议－链路层</title>
      <link href="2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p><strong>节点</strong> 链路层协议的任何设备都叫做节点。</p><p><strong>链路</strong> 沿着通信路径连接相邻节点的通信信道。</p><p>在通过特定的链路时，传输节点将数据报封装在 <strong>链路层帧</strong> 中，并将该帧传送的到链路中。</p><p><strong>链路层提供的服务</strong>：</p><ul><li><code>成帧</code> 网络层数据报经过链路传送之前，链路层协议会将其用链路层帧封装起来。一个帧由一个数据字段（存储网络层数据报）和若干字段组成，不同协议帧的结构不同。</li><li><code>链路接入</code> <strong>媒体访问控制(Medium Access Control，MAC)</strong> 协议规定了帧在链路上的传输规则。对于链路仅有一个发送方和一个接收方的点对点链路，<code>MAC</code>协议规定无论何时链路空闲，发送方都能发送帧。当多个节点共享单个广播链路时，即所谓多路访问问题，<code>MAC</code>协议用于协调多个节点帧传输。</li><li><code>可靠交付</code> 与运输层可靠交付类似，链路层的可靠交付通常是通过确认和重传取得的。通常用于容易产生高差错率的链路（如无线链路），其目的是在差错发生的链路上纠正，而不是通过运输层或应用层协议迫使进行端到端的数据重传。对于低比特差错的链路（如光纤、双绞铜线、同轴电缆），可靠交付会被认为是一种不必要的的开销，因此许多线路层协议不提供可靠交付服务。</li><li><code>差错检测和纠正</code> 当帧中的一个比特作为<code>1</code>传输时，接收方节点的链路层硬件可能不正确的将其判断成为<code>0</code>，反之亦然。这是由于信号衰减和电磁噪声导致的，因为没必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。运输层和网络层也提供相应的检验，即检验和。链路层的检验机制通常更为复杂，并且用硬件实现。<code>纠正</code>与差错检测类似，区别在于其不但可以检测差错，而且能确定差错出现的位置，并纠正这些差错。</li></ul><blockquote><p>链路层主体是在 <strong>网络适配器（network adapter）</strong> 中实现的，网络适配器也叫 <strong>网络接口卡（Network Interface Card，NIC）</strong> 。位于网络适配器核心的是链路层控制器，该控制器通常是实现了成帧、链路接入、差错检测等服务的芯片。</p><p>部分链路层服务（如封装链路层寻址信息、激活控制器硬件、向网络层传递数据报等）运行在主机<code>CPU</code>上的软件中实现。</p><p>因此，链路层是硬件与软件的结合体，即此处是协议栈中硬件与软件交接的部分。</p></blockquote><h3 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h3><p>差错检测的准确措词是 “是否检测到差错，而非是否出了差错”，所以即使用不用差错检测比特，也还是可能有 <strong>未检出比特差错</strong> 。因此，要选择一个差错检测方案，使得这种事件发生的概率很小。然而差错检测和纠正技术越复杂（即未检出比特差错概率较小的技术），开销就越大，也就意味着需要更多的计算量。</p><h4 id="奇偶校验"><a class="markdownIt-Anchor" href="#奇偶校验"></a> 奇偶校验</h4><p>差错检测最简单的方式就是 <strong>单个奇偶校验位（parity bit）</strong> 。如下图，要发送的信息<code>D</code>有<code>d</code>比特，在偶校验方案中只需要包一个校验比特，选择它的值使得<code>d+1</code>比特中<code>1</code>的总数是偶数个，如下图中的<code>d</code>的比特<code>1</code>的个数是<code>9</code>个，因此校验比特填入<code>1</code>使得发送数据比特<code>1</code>的个数为<code>10</code>个满足比特偶校验。反之，则为奇数校验。</p><img src="/2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/偶校验.gif" alt="比特偶校验" style="max-width:60%;"><span class="image-caption">比特偶校验</span><blockquote><p>采用偶校验方案中，接收方如果发现了奇数个<code>1</code>比特，说明至少出现了一个比特差错，或者说出现了奇数个比特差错；如果出现了偶数个比特差错，这将导致一个 <em><strong>未检出比特差错</strong></em>。</p><p>如果比特差错的概率小，且比特间的差错可以被看作是独立发生的，在一个分组中多个比特同时出错的概率极小的情况下，<em><strong>单个奇偶校验位</strong></em> 可能就足够了。然而，测量表明差错经常以“突发”方式聚集在一起，而不是独立发生的。</p></blockquote><h4 id="检验和"><a class="markdownIt-Anchor" href="#检验和"></a> 检验和</h4><p>检验和方法需要相对较小的开销，如<code>TCP</code>和<code>UDP</code>中的检验和只用了<code>16bit</code>。与常用于链路层的<code>CRC</code>相比，它们提供相对软弱的差错保护。</p><p>因为运输层差错检测用软件实现，采用简单快速的检验和方法进行差错检测的方案是很重要的。而链路层的差错检测在适配器中用硬件实现，它能够更快速的执行更复杂的<code>CRC</code>操作。</p><p>更多检验和原理请参考<a href="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/#%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE-ip">[IP首部检验和计算步骤]</a></p><h4 id="循环冗余检测"><a class="markdownIt-Anchor" href="#循环冗余检测"></a> 循环冗余检测</h4><p><strong>循环冗余检测（Cyclic Redundancy Check，CRC）</strong></p><h3 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h3><p>它是<code>数字设备公司</code>、<code>因特尔公司</code>和<code>Xerox公司</code>于<code>1982</code>年联合发布的一个标准，命名为 <strong>以太网（Ethernet Version 2）</strong> ，它是当今<code>TCP/IP</code>采用的主要的局域网技术。它采用一种 <strong>带冲突检测的载波侦听多路接入（Carrier Sense, Multiple Access with Collision Detection，CSMA/CD）</strong> 速率为<code>10Mb/s</code>，地址为<code>48bit</code>。</p><p>几年后， <strong>电气与电子工程师协会（Institute of Electrical and Electronics Engineers，IEEE）</strong> <code>802</code>委员会公布了一个稍有不同的标准集：</p><ul><li><p><code>802.3 标准</code> 针对整个<code>CSMA/CD</code>网络</p></li><li><p><code>802.4标准</code> 针对令牌总线网络</p></li><li><p><code>802.5标准</code> 针对令牌环网络</p></li><li><p><code>802.2标准</code> 定义上面三个标准共同特性，如<code>逻辑链路控制（LLC）</code></p></li></ul><p>其中<code>802.2标准</code>和<code>802.3标准</code>定义了一个与<code>以太网</code>不同的帧格式。详见下图：</p><h4 id="帧结构"><a class="markdownIt-Anchor" href="#帧结构"></a> 帧结构</h4><img src="/2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/以太网帧结构.gif" alt="以太网帧结构" style="max-width:80%;"><span class="image-caption">以太网帧结构</span><ul><li><p><code>802</code>标准帧格式</p><ul><li><strong>目的地址</strong> 和 <strong>源地址</strong> 字段，即硬件地址（<code>MAC</code>地址），大小为 <code>48bit（6字节）</code>（<code>802.3</code>允许使用<code>16bit</code>的地址）。</li><li><strong>长度</strong> 字段，指它后续的数据的字节长度，不包括<code>CRC</code>。</li><li><strong>目的服务访问点（ Destination Service Access Point，DSAP）</strong> 和 <strong>源服务访问点（Source Service Access Point，SSAP）</strong> 的值都设为<code>0xaa</code>。</li><li><strong>Ctrl</strong> 字段，值为<code>3</code>。</li><li><strong>org code</strong> 字段，值为<code>0</code>。</li><li><strong>类型</strong> 字段，由后续 <strong>子网接入协议（Sub-network Access Protocol，SNAP）</strong> 的首部给出。</li><li><strong>数据字段</strong> 字段，标准定义了该字段的最小长度为<code>38</code>字节，长度不够时需要在不足空间插入<code>PAD</code>填充字节。</li><li><strong>CRC</strong> 字段，帧内差错的循环冗余检测码。</li></ul></li><li><p>以太网帧格式</p><ul><li><strong>目的地址</strong> 和 <strong>源地址</strong> 字段，即硬件地址（<code>MAC</code>地址），大小为 <code>48bit（6字节）</code></li><li><strong>类型</strong> 字段，与<code>802</code>标准格式相同，但是有效长度值与<code>802</code>标准不一样，因此可以根据此来区分两种帧，即大于<code>1500</code>就是以太网，否则为<code>802.3</code>。</li><li><strong>数据字段</strong> 字段，标准定义了该字段的最小长度为<code>46</code>字节，长度不够时需要在不足空间插入<code>PAD</code>填充字节。</li><li><strong>CRC</strong> 字段，帧内差错的循环冗余检测码。</li></ul><blockquote><p><strong>前同步码</strong> ，以太网帧以一个<code>8</code>字节的前同步码（Preamble）字段开始。前<code>7</code>字节值都是<code>10101010</code>，用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。</p><p><em>为什么要同步时钟呢？因为发送适配器不会以精确的速率传输帧，总会有一些漂移，但是局域网上的其他适配器不会预先知道这种漂移，因此，接收适配器只需要通过锁定前同步码前<code>7</code>字节比特，就能够锁定发送适配器时钟</em>；</p><p>最后一个字节值为<code>10101011</code>，最后两比特<code>11</code>是警告适配器“重要的内容”就要到来了。</p></blockquote></li></ul><h3 id="slip"><a class="markdownIt-Anchor" href="#slip"></a> SLIP</h3><p><strong>串行线路 IP（Serial Line IP，SLIP）</strong>，是一种在串行线路上对<code>IP</code>数据报进行简单封装的方法，适用于家庭中每台计算机几乎都有的<code>RS-232</code>串行端口和高速调制解调器接入<code>Internet</code>。它是一种广泛使用的协议。</p><h4 id="帧结构-2"><a class="markdownIt-Anchor" href="#帧结构-2"></a> 帧结构</h4><img src="/2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/SLIP帧结构.gif" alt="SLIP帧结构" style="max-width:80%;"><span class="image-caption">SLIP帧结构</span><ul><li><code>IP</code>数据报以一个称作<code>END（0xc0）</code>的特殊字符结束。同时，为了防止数据报到来前的线路噪声被当成数据报内容，大多数实现的开始处也传入一个<code>END</code>字符（<em>这样前一个错误报文交给上层后，发现内容毫无意义而被丢弃</em>）。</li><li>如果<code>IP</code>报文中的某个字符为<code>END</code>，那么就要连续传输两个字节<code>0xdb</code>和<code>0xdc</code>来取代它。<code>0xdb</code>字符被称作是<code>SLIP</code>的<code>ESC</code>字符，它的值与<code>ASCII</code>中的<code>ESC（0x1b）</code>字符不同。</li><li>如果<code>IP</code>报文中某个字符为<code>SLIP</code>的<code>ESC</code>字符，那么就要连续传输两个字节<code>0xdb</code>和<code>0xdd</code>来取代它。</li></ul><h4 id="缺陷"><a class="markdownIt-Anchor" href="#缺陷"></a> 缺陷</h4><ul><li>每一端必须知道对方的<code>IP</code>地址，没办法把本端的地址通知给另一端。</li><li>数据帧中没有类型字段，如果一条串行线路用于<code>SLIP</code>，那么它不能同时使用其他协议。</li><li>没有在数据帧上加检验和，如果发生错误只能通过上层协议来发现（新型调制解调器可以发现和纠正错误报文）。</li></ul><h4 id="压缩"><a class="markdownIt-Anchor" href="#压缩"></a> 压缩</h4><p>由于串行线路的速率通常较低（<code>19200b/s</code>或更低)，而且通信经常是交互式的（如Telnet），因此<code>SLIP</code>线路上有许多小的<code>TCP</code>分组进行交换。通常为了传输<code>1</code>个字节的数据需要<code>20</code>个字节<code>IP</code>首部和<code>20</code>个字节的<code>TCP</code>首部，总数超过<code>40</code>个字节。</p><p>基于上面性能上的缺陷，提出了一个压缩的<code>SLIP</code>协议，即<code>CSLIP</code>。它一般能把上面<code>40</code>个字节压缩到<code>3</code>到<code>5</code>个字节，大大缩短了交互响应时间。</p><p>大多数<code>SLIP</code>产品都支持<code>CSLIP</code>。</p><p><strong>SLIP接口标志</strong>：</p><ul><li><code>LINK0</code>表示一个允许压缩的<code>SLIP</code>数据</li><li><code>LINK1</code>表示如果从另一端收到一份压缩报文就允许使用<code>CSLIP</code>。</li><li><code>LINK2</code>所有外出的<code>ICMP</code>报文都被丢弃。</li></ul><h3 id="ppp"><a class="markdownIt-Anchor" href="#ppp"></a> PPP</h3><p><strong>点对点协议（Point to Point Protocol，PPP）</strong> ，修改了<code>SLIP</code>协议中所有的缺陷。<code>PPP</code>包括以下三个部分：</p><ul><li>在串行链路上封装<code>IP</code>数据报的方法。</li><li>建立、配置及测试数据链路的 <strong>链路控制协议（Link Control Protocol，LCP）</strong> 它允许双方进行协商，以确定不同选项。</li><li>针对不同网络层协议的 <strong>网络控制协议（Network Control Protocol，NCP）</strong> 体系。如<code>IP NCP</code>允许双方协商是否对报文首部进行压缩，类似于<code>CSLIP</code>。</li></ul><h4 id="帧结构-3"><a class="markdownIt-Anchor" href="#帧结构-3"></a> 帧结构</h4><img src="/2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/PPP帧结构.gif" alt="PPP帧结构" style="max-width:80%;"><span class="image-caption">PPP帧结构</span><ul><li>每一帧都以<code>0x7e</code>开始和结束。</li><li><strong>地址</strong> 字段，值始终为<code>0xff</code>。</li><li><strong>控制</strong> 字段，值始终为<code>0x03</code>。</li><li><strong>协议</strong> 字段，类似以太网中类型字符功能。</li><li><strong>CRC</strong> 字段，循环冗余检验码。</li></ul><blockquote><p>当标志字符<code>0x7e</code>出现在 <strong>信息</strong> 字段时，需要对它进行转义。在同步链路中通过一种称作 <strong>比特填充（bit stuffing）</strong> 的硬件技术实现；</p><p>在异步链路中，特殊字符<code>0x7d</code>用作转义字符，后面紧接着的字符的第<code>6</code>比特要取其补码（<code>注意：此处的补码为 “求补” [&quot;补码&quot;跟&quot;求补&quot;不总是一回事，求补，求余，全集的补是空集，空集的补是全集，1的补是0，0的补是1]---解释来源网络</code>）：</p><ul><li><p>当遇到<code>0x7e</code>时，需要连续传递两个字符<code>0x7d</code>和<code>0x7e</code>，然后将<code>0x7e</code>的第<code>6</code>比特转换成其补码，即<code>1111110</code>转为<code>1011110</code>，所以最终传递的两个字符为<code>0x7d</code>和<code>0x5e</code>。</p></li><li><p>当遇到<code>0x7d</code>时，也需要进行转义，原理同上，即最终传递两个字符为<code>0x7d</code>和<code>0x5d</code>。</p></li><li><p>默认情况下，需要对<code>ASCII</code>的<code>32</code>个控制字符（排除空格控制字符）进行转义。如<code>0x01</code>，这时将其第<code>6</code>个比特取补码后变为<code>1</code>，即<code>000001</code>转换为<code>100001</code>，所以最终传递两个字符为<code>0x7d</code>和<code>0x21</code>。</p><p>这样做的原因是防止它们出现在双方主机的串行接口驱动程序或调制解调器中，因为有时它们会把这些控制字符解释成特殊的含义。</p></li></ul></blockquote><p>与<code>SLIP</code>类似，<code>PPP</code>也常用于低速的串行链路，因此可以利用链路控制协议，大多数产品通过协商可以省略标志符和地址字段，并且把协议字段由<code>2</code>个字节减少到<code>1</code>个字节。</p><p>使用<code>IP</code>网络控制协议，大多数可以通过协商采用<code>Van Jacobson</code>报文首部压缩方法（对应<code>CSLIP</code>）减小<code>IP</code>的<code>TCP</code>首部长度。</p><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h4><ul><li>支持在单根串行线路上运行多种协议，不只是<code>IP</code>协议。</li><li>每一帧都有循环冗余检测。</li><li>使用<code>IP</code>网络控制协议，通信双方可以进行<code>IP</code>地址的动态协商。</li><li>与<code>CSLIP</code>类似，对<code>TCP</code>和<code>IP</code>报文首部进行压缩。</li><li>链路控制协议可以对多个数据链路选项进行设置。</li></ul><p>实现这些优点的代价是在每一帧的首部增加 3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</p><h3 id="环回接口"><a class="markdownIt-Anchor" href="#环回接口"></a> 环回接口</h3><p><strong>环回接口（Loopback Interface，lo）</strong> ，是路由器上的一个逻辑虚拟接口。大多数产品都支持环回接口，以允许运行在同一台主机的客户和服务程序进行<code>TCP/IP</code>通信。</p><p><code>A</code>类网络号<code>127</code>就是为其预留的，通常把<code>IP</code>地址<code>127.0.0.1</code>分配给这个接口，子网掩码一般建议设为<code>255.255.255.255</code>，并命名为<code>localhost</code>。一个传给环回接口的<code>IP</code>数据报不能在任何网络上出现。</p><p>当传输层检测到目的地端的地址是环回地址，可以省略传输层和网络层的所有逻辑操作。但大多数产品还是照样完成传输层和网络层的所有过程，只是当<code>IP</code>数据报离开网络层时把它返回自己；</p><p>当目的地址是广播地址或多播地址时，<code>IP</code>数据报会复制一份传给环回地址，然后发送到以太网上。</p><h4 id="创建原因"><a class="markdownIt-Anchor" href="#创建原因"></a> 创建原因</h4><ul><li>环回接口有一个特性，除非设备瘫痪，否则其状态一直是<code>up</code>。基于这个特性，用来建立比物理接口更稳定的路由邻居来保证邻居关系不会中断。</li><li>用来作为<code>Router-ID</code>，相当于一台路由器的身份证号，在一个指定的范围内只能标识一台设备，不能有重复。稳定可靠，可以节省地址。</li><li>用于网络连通性测试创建并配置好环回接口之后，它的地址是能被<code>ping</code>或<code>telnet</code>的，这就可以被用来测试网络的连通性。</li><li>用于虚拟隧道连接在建立<code>IPSec</code>或<code>GRE</code>之类的虚拟隧道时，使用<code>loopback</code>接口可以保证整个隧道的稳定性。</li></ul><blockquote><p>BSD系统定义了变量<code>useloopback</code>，并初始化为<code>1</code>。如果值为<code>0</code>，以太网驱动程序就会把本地分组送到网络，而不是送到环回接口上。它能否工作取决于所使用的以太网口卡和设备驱动程序。</p></blockquote><h3 id="mtu"><a class="markdownIt-Anchor" href="#mtu"></a> MTU</h3><p>以太网和<code>802.3</code>对数据帧的长度最大限制为<code>1500</code>和<code>1492</code>字节，链路层的这个特性称作， <strong>最大传输单元（MTU)</strong> 。</p><p>如果<code>IP</code>层传输的数据报长度超过<code>MTU</code>，那么<code>IP</code>层就需要进行切片分组成若干片，并且每片都小于<code>MTU</code>。</p><p>当两台主机通信需要经过多个网络时，那么每个网络的链路层可能有不同的<code>MTU</code>。此时重要的不是两台主机的<code>MTU</code>，而是路径中的最小<code>MTU</code>，它被称作 <strong>路径MTU</strong> 。</p><blockquote><p>两台主机之间的路径<code>MTU</code>不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从<code>A</code>到<code>B</code>的路由可能与从<code>B</code>到<code>A</code>的路由不同），因此路径<code>MTU</code>在两个方向上不一定是一致的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
            <tag> 以太网 </tag>
            
            <tag> SLIP </tag>
            
            <tag> PPP </tag>
            
            <tag> 环回接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议－网络层</title>
      <link href="2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="路由器"><a class="markdownIt-Anchor" href="#路由器"></a> 路由器</h3><ul><li><strong>转发</strong> 当一个分组到达某路由器输入链路接口时，该路由器须将该分组移动到适当的输出链路接口的路由器本地动作。转发发生的尺度很短，因此通常用硬件来实现。它是 <strong>数据平面</strong> 唯一实现的功能。</li><li><strong>路由选择</strong>  当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由和路径。计算这些路径的算法被称为<strong>路由选择算法</strong>。路由选择发生的时间尺度长，因此通常用软件来实现，它是 <strong>控制平面</strong> 实现的功能。</li><li><strong>路由表</strong>  每台网络路由器内存中都有一个路由表，当收到一份数据报时，路由器检查分组首部一个或多个字段值，用于在其路由表中索引，然后进行转发分组。路由表中包含以下信息：<ul><li><strong>目的 IP 地址</strong> 它可以是一个完整的主机地址，也可以是一个网络地址。由该表中的标志字段指定。</li><li><strong>下一跳（下一站）路由器的 IP 地址</strong> 指在一个可以直接相连网络上的路由器，可以转发的数据报。下一跳路由器不是最终目的，但它可以把传送它的数据报转发到最终目的地。</li><li><strong>标志</strong> 其中一个标志指明目的<code>IP</code>地址是网络地址还是主机地址；另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口。</li><li><strong>为数据报的传输指定一个网络接口</strong></li></ul></li></ul><h4 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h4><p>当收到一份数据报进行转发时，它先要搜索路由表。当数据报来自某个网络接口时，<code>IP</code>首部先检查目的<code>IP</code>是否为本机<code>IP</code>地址之一或者广播<code>IP</code>地址。如果是，数据报被发送到由<code>IP</code>首部协议字段所指定的协议模块进行处理。反之，如果<code>IP</code>层被设置为路由器功能，那么就对数据报进行转发，否则数据报被丢弃。</p><p><code>IP</code>路由选择是逐跳进行的，<code>IP</code>并不知道到达目的地的完整路径。所有<code>IP</code>路由选择只为数据报传输提供下一站路由器的<code>IP</code>地址。它假定下一站路由器比发送数据报的主机更接近目的地，且下一站路由器与该主机是直接相连的。</p><p><code>IP</code>路由选择步骤：</p><ol><li>搜索路由表，寻找与目的<code>IP</code>完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接网络接口（取决于标志字段的值）。</li><li>搜索路由表，寻找与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接网络接口（取决于标志字段的值）。网络上的所有主机可以通过这个表目进行寻径，这种搜索网络的匹配方法必须考虑可能的子网掩码。</li><li>搜索路由表，寻找标记为“默认（default）”的表目，如果找到，则把报文发送给该表目指定的下一站路由器。</li><li>如果上面步骤都没有成功，该数据报不能被发送。如果该数据报来自本机，则会向应用程序返回一个“主机或网络不可达”错误。</li></ol><blockquote><p>为网络指定一个路由器，而不必为每个主机指定一个，这是<code>IP</code>路由选择的一个基本特性。这样可以极大缩小路由表的规模，比如 <code>Internet</code> 上路由器只有几千个表目，而不会超过100万个。</p></blockquote><h3 id="网际协议-ip"><a class="markdownIt-Anchor" href="#网际协议-ip"></a> 网际协议－IP</h3><p><code>IP</code>是<code>TCP/IP</code>协议族中最为核心的协议。所有<code>TCP</code>、<code>UDP</code>、<code>ICMP</code>和<code>IGMP</code>数据都以<code>IP</code>数据报格式传输。</p><p>它不能保证<code>IP</code>数据报能成功地到达目的地。 <code>IP</code>仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， <code>IP</code>有一个简单的错误处理算法：丢弃该数据报，然后发送 <code>ICMP</code>消息报给信源端。</p><p>它是无连接的，不维护任何数据报文的后续状态信息。每个数据报相互独立，因此<code>IP</code>数据报可以不按顺序接收。当一个端向另一端发送两个数据报（<code>A</code>和<code>B</code>），每个数据报都是独立进行路由选择，可能选择不同线路，所以<code>B</code>可能在<code>A</code>之前到达。</p><h4 id="ip首部"><a class="markdownIt-Anchor" href="#ip首部"></a> IP首部</h4><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/IP首部.png" alt="IP首部" style="max-height:300px"><span class="image-caption">IP首部</span><p>最高位在左边，记为<code>0bit</code>; 最低位在右边，记为<code>31bit</code>。</p><p><code>4</code>个字节的<code>32bit</code>的值以下面次序输出：</p><p>​首先，<code>0~7bit</code>;  其次<code>8~15bit</code>; 然后<code>16~23bit</code>; 最后<code>24~31bit</code>。</p><blockquote><p><code>TCP/IP</code>首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作<strong>网络字节序（big endian）</strong>。</p><p>以其他形式存储的二进制整数的机器（如<code>little endian</code>），必须在传输数据之前把首部转换成网络字节序。</p></blockquote><p>目前协议 <strong>版本(Ver)</strong> 号是<code>4</code>，因此有时<code>IP</code>也被称为<code>IPv4</code>。</p><p><strong>首部长度(IHL)</strong> 指的是首部占用<code>32bit</code>的数目，普通<code>IP</code>该字段的值为<code>5</code>行（固定部分），每行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">32/8=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 字节 ，因此首部长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo>∗</mo><mn>4</mn><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">5*4=20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> 个字节。如果有选项部分，由于首部长度为<code>4bit</code>，所以最大值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">2^4-1=15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 行（即取值范围 0-15），所以首部最大长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn><mo>∗</mo><mn>4</mn><mo>=</mo><mn>60</mn></mrow><annotation encoding="application/x-tex">15*4=60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span></span></span></span> 字节。</p><p><strong>服务类型（TOS,Type Of Service）</strong>，字段包括</p><ul><li><p>一个<code>3bit</code>的优先权子字段（现在已被废弃），默认值<code>000</code>。</p></li><li><p><code>4bit</code>的<code>TOS</code>子字段，分别代表（最小时延、最大吞吐量、最高可靠性、最小费用），只能置其中<code>1bit</code>为<code>1</code>，如果均为<code>0</code>，那么就意味着一般服务。</p></li></ul><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">最小延时</th><th style="text-align:center">最大吞吐量</th><th style="text-align:center">最高可靠性</th><th style="text-align:center">最小费用</th><th style="text-align:center">16进制值</th></tr></thead><tbody><tr><td style="text-align:center">Telnet/Rlogin</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">FTP</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">控制</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">数据</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x08</td></tr><tr><td style="text-align:center">任意块数据</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x08</td></tr><tr><td style="text-align:center">TFTP</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">SMTP</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">命令阶段</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">数据阶段</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x08</td></tr><tr><td style="text-align:center">DNS</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UDP查询</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">TCP查询</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x00</td></tr><tr><td style="text-align:center">区域查询</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x08</td></tr><tr><td style="text-align:center">IMCP</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">差错</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x00</td></tr><tr><td style="text-align:center">查询</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x00</td></tr><tr><td style="text-align:center">任何IGP</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0x04</td></tr><tr><td style="text-align:center">SNMP</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0x04</td></tr><tr><td style="text-align:center">BOOTP</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x00</td></tr><tr><td style="text-align:center">NNTP</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0x02</td></tr></tbody></table><ul><li><code>1bit</code>的未用位（必须置0）</li></ul><blockquote><p>以<code>Telnet/Rlogin</code>应用为例，因为这两个应用主要用于传输少量交互数据，所以要求最小传输时延。其<code>TOS</code>最终值为<code>000,1000,0</code>，换算成十六进制为<code>0x10</code>。</p><p>现在大多数<code>TCP/IP</code>实现都不支持<code>TOS</code>特性，但自<code>4.3BSD Reno</code>以后新版本系统都对它进行了设置。另外，新路由协议<code>OSPE</code>和<code>IS-IS</code>都能根据这些字段进行路由决策。</p><p>由于大多数实现都不使用<code>TOS</code>字段，因此像<code>SLIP</code>这种排队机制自己来判断和处理，驱动程序先查看协议段（确定是否是一个<code>TCP</code>段），然后检查<code>TCP</code>信源和信宿的端口号，以判断是否是一个交互服务。</p></blockquote><p><strong>总长度(Total Length)</strong> 字段指整个<code>IP</code>数据报长度，以字节为单位。利用<strong>首部长度</strong>和<strong>总长度</strong>字段，就可以知道<code>IP</code>数据报中数据内容的起始位置和长度。由于该字段长度为<code>16bit</code>，所以<code>IP</code>数据报最大长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>65</mn><mo separator="true">,</mo><mn>535</mn></mrow><annotation encoding="application/x-tex">2^{16}-1=65,535</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">3</span><span class="mord">5</span></span></span></span> 即，65,535字节。也就是<strong>最大传输单元（Maximum Transmission Unit，MTU）</strong> 为65,535字节。</p><blockquote><p>尽管可以传输最大<code>65,535</code>字节的数据报，但大多数链路层都会对它进行分片。而且主机也要求不能接收超过<code>576</code>字节的数据报。类似<code>UDP</code>的应用，它们限制用户数据报长度为<code>512</code>字节，小于<code>576</code>字节。</p><p>事实上现在大多数的实现（特别是那些支持网络的文件系统<code>NFS</code>的实现）允许超过<code>8192</code>字节的<code>IP</code>数据报。</p></blockquote><p><strong>标识(Identification)</strong> 字段，唯一的标识主机发送的每一分数据报。通常每发送一份报文它的值就会加<code>1</code>。</p><blockquote><p><code>RFC 791 [Postel 1981a]</code>认为标识字段应该由让<code>IP</code>发送数据报的上层来选择。假设有两个连续的<code>IP</code>数据报，其中一个是由<code>TCP</code>生成的，而另一个是由<code>UDP</code>生成的，那么它们可能具有相同的标识字段。尽管这也可以照常工作（由重组算法来处理），但是在大多数从伯克利派生出来的系统中，每发送一个<code>IP</code>数据报，<code>IP</code>层都要把一个内核变量的值加<code>1</code>，不管交给<code>IP</code>的数据来自哪一层。内核变量的初始值根据系统引导时的时间来设置。</p></blockquote><p><strong>TTL(time-to-live)</strong> 生存时间字段，设置了数据报可以经过的最多路由器数，指定了数据报的生存时间。初始值由源主机设置（通常为<code>32</code>或<code>64</code>）,经过一个处理它的路由器该值减<code>1</code>，当该值为<code>0</code>时，数据报被丢弃,并发送<code>ICMP</code>报文通知源主机。</p><p><strong>首部检验和(Header Checksum)</strong> 字段，根据<code>IP</code>首部计算的检验和码，它不对首部后面的数据进行计算。</p><p><code>ICMP</code>、<code>IGMP</code>、<code>UDP</code>和<code>TCP</code>在它们各自的首部中均含有首部检验和码。</p><blockquote><p>为了计算一份数据报的<code>IP</code>检验和，首先将检验和字段置为<code>0</code>。然后，将首部中的数据按每<code>16bit</code>一块分成若干块（每块包含16位的原因是检验和正好是16位，这样便于将计算结果填充到对应的16位字段），对首部中每个<code>16bit</code>求和（注意当高位溢出时，需要低位回卷）后取反（即<code>0</code>变成<code>1</code>,<code>1</code>变成<code>0</code>）结果并存储到检验和字段中。</p><p>第二种计算方法是，先将各字段二进制数据先取反，再求和。</p></blockquote><p><code>抓包数据</code>：</p><pre class="highlight"><code class>Internet protocol Version 4, src: 192.168.0.109(192.168.0.109), Dst: 224.0.0.252(224.0.0.252)Version: 4Header length: 20bytesDifferentiated Service field: 0x00 Total length: 71Identification: 0x1fd6 (8150)Flags: 0x00Fragment offset: 0Time to live: 1Protocol: UDP (17)Header checksum: 0xf7be [correct][Good: True][Bad: False]Souce: 192.168.0.109Destination: 224.0.0.252</code></pre><p>结合上面抓包数据，发送方检验和计算步骤见下图：</p><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/IP首部检验和计算步骤.gif" alt="IP首部检验和计算步骤" style="max-width:70%"><span class="image-caption">IP首部检验和计算步骤</span><blockquote><p>检验和求和前，首先将各字段各进制数值转换成二进制数值。如<code>首部长度(Header length)</code>数据报值为<code>20bytes</code>，先将其转换成十进制值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>4</mn><mo separator="true">,</mo><mn>20</mn><mi mathvariant="normal">/</mi><mn>4</mn><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">32/8=4,20/4=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>(行)，然后再将<code>5</code>转成二进制<code>101</code>，由于首部长度占<code>4bit</code>，所以不足位补<code>0</code>，即<code>0101</code>。</p><p>求和时，当最高位需要进位时，进位被回卷到最低位。如上图虚线框结果，最高位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1+1=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，只保留数值<code>0</code>，数值<code>1</code>回卷到最低位，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>+</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0+0+1=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，其中<code>1</code>就是高位回卷的数值。</p></blockquote><p>接收方校验数据步骤和发送方类似，区别在于接收方不再将检验和字段置为<code>0</code>，而是发送方计算好的值<code>0xf7be</code>即<code>1111011110111110</code>，所以接收方最终计算结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0000100001000001</mn><mo>+</mo><mn>1111011110111110</mn><mo>=</mo><mn>1111111111111111</mn></mrow><annotation encoding="application/x-tex">0000100001000001+1111011110111110=1111111111111111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>。如果结果每个比特位不全是<code>1</code>，那么<code>IP</code>将丢弃收到的数据报，但是不生成差错报文，由上层去发现丢失的数据报并进行重传。</p><p>最后一个字段是<strong>可选字段</strong>，目前这些选项定义如下：</p><ul><li>安全和处理限制（用于军事领域，参见<a href="https://datatracker.ietf.org/doc/html/rfc1108">RFC 1108[Kent 1991]</a>)</li><li>记录路径（让每个路由器都记录下它的<code>IP</code>地址）</li><li>时间戳（让每个路由器都记录下它的<code>IP</code>地址和时间）</li><li>宽松源站选路（为数据指定一系列必须经过的<code>IP</code>地址）</li><li>严格源站选路（与宽松源站选路类似，但是要求只能经过指定的<code>IP</code>地址，不能经过其他地址）</li></ul><h4 id="ipv4编址"><a class="markdownIt-Anchor" href="#ipv4编址"></a> IPv4编址</h4><p>一台主机通常只有一条链路连接的网络，当主机中<code>IP</code>想发送一个数据报时，它就在该链路上发送。而路由器的任务是从链路上接收数据报，并从其它链路上转发出去，所以路由器必须拥有两条以上的链路。</p><p>主机、路由器与物理链路之间的边界叫作<strong>接口</strong>。<code>IP</code>要求每台主机和路由器都拥有自己的<code>IP</code>地址。</p><blockquote><p>一个<code>IP</code>地址与一个接口关联，而不是与包括该接口的主机或路由器相关联。</p></blockquote><p><strong>子网</strong> 具有相同的前半部分地址的一组<code>IP</code>地址，可以利用地址的前半部分划分组。在一个<code>IP</code>网络中划分子网使我们能将一个单一的大型网络，分成若干个较小的网络。</p><p>这样做原因是<code>A</code>类、<code>B</code>类地址为主机分配了太多的空间，在一个网络内一般不会存在如此多主机，同时子网的存在，使得外部路由器只需要知道通往子网的<code>IP</code>地址路径即可，再由子网去寻找具体子网<code>IP</code>地址即可；从而不需要知道所有子网下的<code>IP</code>地址路径，可以缩减路由表的规模。基于以上原因<code>IP</code>允许划分更小的网络，称为<strong>子网</strong>。</p><blockquote><p>大多数子网都是<code>B</code>类地址，也可以用于<code>C</code>类地址，很少出现在<code>A</code>类地址因为<code>A</code>类地址本身就很少。但是，大多数<code>A</code>类地址都是进行子网划分的。</p></blockquote><p>现在所有主机都要求支持子网编址，子网编址不再把<code>IP</code>地址看成单纯的的 <strong>网络号</strong> 和 <strong>主机号</strong> 组成，而是把主机号再分成一个 <strong>子网号</strong> 和 <strong>主机号</strong> 。</p><p>主机除了<code>IP</code>地址外，还需要知道有多少比特留给了子网号和主机号，这个问题通过<strong>子网掩码</strong> 来解决。子网掩码也是一个<code>32bit</code>的值，其中<code>网络号</code>和<code>子网号</code>（<em>如果存在，不设置子网掩码情况下，即采用默认子网掩码时，子网号不存在</em>）的值均为<code>1</code>，<code>主机号</code>值为<code>0</code>。</p><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/子网B.gif" alt="两种B类地址子网掩码" style="max-width:60%;"><span class="image-caption">两种B类地址子网掩码</span><blockquote><p>如果知道本机<code>IP</code>地址，就可以知道地址分类(A、B或C类)，也就知道网络号和子网号之间的分界线。而根据子网掩码可知道子网号和主机号之间的分界线。</p></blockquote><pre class="highlight"><code class>假设主机地址：140.252.1.1（B类地址），子网掩码：255.255.255.0（8bit子网号，8bit主机号）- 当目的地址是：140.252.4.5，可知B类网络号相同（均为140.252），子网号不同(分别为1和4)- 当目的地址是：140.252.1.22，可知B类网络号相同（均为140.252），子网号相同（均为1），主机号不同（分别为1和22）- 当目的地址是：192.43.235.6（C类地址），可知网络号不同，因此不需要进一步比较了给定两个 IP 地址和子网掩码后，IP 路由选择功能一直进行这样的比较。</code></pre><p><code>子网掩码</code>通过<strong>无类别域间路由选择（Classless Inter-Domain Routing，CIDR）</strong> 分配策略分配地址，它是一个按位，基于前缀的用于解释<code>IP</code>地址的标准。当使用子网寻址时，<code>32bit</code>的<code>IP</code>被划分为两部分，并且也具点分有十进制数形式<code>a.b.c.d/x</code>，其中<code>x</code>表示地址的第一部分即最左侧开始的比特数，叫做<strong>前缀</strong>，该部分定义了子网地址。</p><pre class="highlight"><code class>如上例，IP地址为：140.252.1.1，子网掩码：255.255.255.0使用 CIDR 子网掩码表示为 140.252.1.1/24|| 转换为二进制V                    24bit11111111 11111111 11111111 000000000255      255      255      0所以子网掩码为：255.255.255.0|| 与 IP 按位与计算V　 11111111 11111111 11111111 000000000 子网掩码&amp;　10001100 11111100 00000001 000000001 IP——————————————————————————————————————————　 10001100 11111100 00000001 000000000   140      252      1        0   结果为：140.252.1.0　其表达的含义为该 IP 地址 140.252.1.1 属于 140.252.1.0 这个网络，其主机号为 1，即这个网络中编号为 1 的主机。</code></pre><p>子网掩码一定是配合<code>IP</code>地址来使用的。对于常用网络<code>A</code>、<code>B</code>、<code>C</code> 类<code>IP</code>地址其默认子网掩码（<mark>缺省子网掩码即未划分子网，对应的网络号的位都置1，主机号都置0</mark>）的二进制与十进制对应关系见下表：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">子网掩码（二进制）</th><th style="text-align:center">子网掩码十进制:</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">11111111 00000000 00000000 00000000</td><td style="text-align:center">255.0.0.0</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">11111111 11111111 00000000 00000000</td><td style="text-align:center">255.255.0.0</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">11111111 11111111 11111111 00000000</td><td style="text-align:center">255.255.255.0</td></tr></tbody></table><p><strong>特殊的 IP 地址</strong> ：</p><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">子网号</th><th style="text-align:center">主机号</th><th style="text-align:center">源端</th><th style="text-align:center">目的端</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">OK</td><td style="text-align:center">不可能</td><td style="text-align:center">网络上的主机</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">主机号</td><td style="text-align:center">OK</td><td style="text-align:center">不可能</td><td style="text-align:center">网络上的特定主机</td></tr></tbody></table><p><a href="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/#%E5%B9%BF%E6%92%AD">注：更多特殊IP地址参考广播地址</a></p><h3 id="icmp"><a class="markdownIt-Anchor" href="#icmp"></a> ICMP</h3><p><strong>因特网控制报文协议（Internet Control Message Protocol，ICMP）</strong> ，它用于网际协议<code>IP</code>中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。</p><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/IP数据报ICMP.gif" alt="ICMP 封装在 IP 数据报内部" style="max-height:90px"><span class="image-caption">ICMP 封装在 IP 数据报内部</span><p><code>ICMP</code>依靠<code>IP</code>来完成它的任务，它是<code>IP</code>的主要部分。它一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了<code>ping</code> 和<code>traceroute</code> 这两个特别的程序。</p><h4 id="报文格式"><a class="markdownIt-Anchor" href="#报文格式"></a> 报文格式</h4><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP报文.gif" alt="ICMP 报文" style="max-width:60%;"><span class="image-caption">ICMP 报文</span><p><code>ICMP</code>报头从<code>IP</code>报头的第<code>160bit</code>开始（<code>IP</code>首部按20字节，未使用可选部分计算）。</p><ul><li><p><strong>类型</strong> 、<strong>代码</strong></p><p>不同类型的报文由由这两个字段共同决定，当发送一份<code>ICMP</code>差错报文时，报文始终包含<code>IP</code>的首部和<code>ICMP</code>差错报文的前<code>8</code>个字节。这样，接收<code>ICMP</code>差错报文的模块就会把它与某个特定协议和用户进程联系起来。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">代码</th><th style="text-align:center">描述</th><th style="text-align:center">查询</th><th style="text-align:center">差错</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">回显应答（Ping应答）</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1 和 2</td><td style="text-align:center">-</td><td style="text-align:center">保留</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">未分配</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">-</td><td style="text-align:center">目的不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">0</td><td style="text-align:center">网络不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">1</td><td style="text-align:center">主机不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">2</td><td style="text-align:center">协议不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">3</td><td style="text-align:center">端口不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">4</td><td style="text-align:center">需要进行分片但设置了不分片比特</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">5</td><td style="text-align:center">源站选路失败</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">6</td><td style="text-align:center">目的网络不认识</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">7</td><td style="text-align:center">目的主机不认识</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">8</td><td style="text-align:center">源主机被隔离</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">9</td><td style="text-align:center">目的网络被强制禁止</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">10</td><td style="text-align:center">目的主机被强制禁止</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">11</td><td style="text-align:center">对特定的TOS 网络不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">12</td><td style="text-align:center">对特定的TOS 主机不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">13</td><td style="text-align:center">由于过滤，通信被强制禁止</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">14</td><td style="text-align:center">主机越权</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">15</td><td style="text-align:center">优先权终止生效</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">源端关闭（拥塞控制）</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0</td><td style="text-align:center">对网络重定向</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">1</td><td style="text-align:center">对主机重定向</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">2</td><td style="text-align:center">基于TOS 的网络重定向</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">3</td><td style="text-align:center">基于TOS 的主机重定向</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">-</td><td style="text-align:center">备用主机地址</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">-</td><td style="text-align:center">保留</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">未分配</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">0</td><td style="text-align:center">请求回显（Ping请求）</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">0</td><td style="text-align:center">路由通告</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">0</td><td style="text-align:center">路由器的发现/选择/请求</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">0</td><td style="text-align:center">TTL 超时</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">1</td><td style="text-align:center">分片重组超时</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">0</td><td style="text-align:center">IP 报首部参数错误（坏的I P首部）</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">1</td><td style="text-align:center">丢失必要选项</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">2</td><td style="text-align:center">不支持的长度</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">0</td><td style="text-align:center">时间戳请求</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">0</td><td style="text-align:center">时间戳应答</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">0</td><td style="text-align:center">信息请求</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">0</td><td style="text-align:center">信息应答</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">0</td><td style="text-align:center">地址掩码请求</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">0</td><td style="text-align:center">地址掩码应答</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">弃用</td></tr></tbody></table></li><li><p><strong>检验和</strong></p><p>检验和字段是必须存在的字段，覆盖整<code>ICMP</code>个报文，算法与<code>IP</code>首部检验和相同。</p></li></ul><blockquote><p>不会产生<code>ICMP</code>差错报文的情况：</p><ul><li><code>ICMP</code>差错报文（但是，查询<code>ICMP</code>报文可能产生<code>ICMP</code>差错报文）</li><li>目的地址是广播地址或多播地址的<code>IP</code>数据报</li><li>链路层广播的数据报</li><li>不是<code>IP</code>分片的第一片</li><li>源地址不是单个主机的数据报（也就是说，源地址不能为零地址、环回地址、广播地址和多播地址）</li></ul><p>这些规则防止过去允许<code>ICMP</code>差错报文对广播分组响应所带来的广播风暴。</p></blockquote><h4 id="icmp-地址掩码请求与应答"><a class="markdownIt-Anchor" href="#icmp-地址掩码请求与应答"></a> ICMP 地址掩码请求与应答</h4><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP地址掩码报文.gif" alt="ICMP 地址掩码请求和应答报文" style="max-width:60%;"><span class="image-caption">ICMP 地址掩码请求和应答报文</span><p><code>ICMP</code>地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码（这一过程与<code>RARP</code>类似）。</p><p>报文中 <strong>标识符</strong> 和 <strong>序列</strong> 字段，由发送端任意指定，这些值在应答中将被返回。这样发送端就可以把应答与请求进行匹配。</p><h4 id="icmp-时间戳请求与应答"><a class="markdownIt-Anchor" href="#icmp-时间戳请求与应答"></a> ICMP 时间戳请求与应答</h4><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP时间戳报文.gif" alt="ICMP 时间戳请求和应答报文" style="max-width:60%;"><span class="image-caption">ICMP 时间戳请求和应答报文</span><p>报文主要用于互联网机器之间同步时钟。返回的建议值是自午夜开始计算的毫秒数，协调的统一时间<code>UTC</code>。这种<code>ICMP</code>报文的好处是它提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间（如某些<code>UNIX</code>系统提供的<code>rdate</code>命令）只能提供秒级分辨率。</p><blockquote><p>由于返回的时间是从午夜开始计算的，因此调用者必须通过其他方法获知当时的日期，这是它的一个缺陷。</p></blockquote><p>请求端填写发起时间戳，然后发送报文。应答系统收到请求报文时填写接收时间戳，在发送应答时填写发送时间戳。但是，实际上，大多数的实现把后面两个字段都设成相同的值（提供三个字段的原因是可以让发送方分别计算发送请求的时间和发送应答的时间）。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
            <tag> IP </tag>
            
            <tag> ICMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP协议（一）</title>
      <link href="2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="分层"><a class="markdownIt-Anchor" href="#分层"></a> 分层</h3><img src="/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/分层.png" alt="TCP/IP 分层" style="max-height:300px"><span class="image-caption">TCP/IP 分层</span><ul><li><p><strong>应用层</strong> 负责处理特定的应用程序细节。</p></li><li><p><strong>运输层</strong> 为两台主机提供端到端的通信。主要协议有<code>TCP</code> 和<code>UDP</code>。二者都使用<code>IP</code>作为网络层协议。</p><ul><li><p>TCP，为两台主机提供高可靠性的数据通信。它的工作是将应用程序交给它的数据分成合适的小块交给下面的网络层，并确认收到的分组。</p></li><li><p>UDP，为应用层提供一种简单的服务，为数据报分组从一台主机发送到另一台主机，但不能保证数据报能够到达，因此它是不可靠的。</p><blockquote><p>数据报是指从发送方传输到接收方的一个信息单元。</p></blockquote></li></ul></li><li><p><strong>网络层</strong> 处理分组在网络中的活动。主要协议有<code>IP</code>、<code>ICMP</code>以及<code>IGMP</code>。</p><ul><li><p>IP，网络层上主要协议，同时被<code>TCP</code>和<code>UDP</code>使用。一般情况下直接访问<code>IP</code>的应用程序很少见，但也是有可能存在的。</p></li><li><p>ICMP，<code>Internet</code>控制报文协议，<code>IP</code>层用它与其他主机或路由器交换错误报文和其它重要信息。</p></li><li><p>IGMP，<code>Internet</code>组管理协议，用来把一个<code>UDP</code>数据报多播到多个主机。</p><blockquote><p>从表面上看，网络层和运输层之间的区别不那么明显。为什么要把它们划分成两个不同的层次呢？</p><p>在<code>TCP/IP</code>协议族中，网络层 <code>IP</code>提供的是一种不可靠的服务。它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。<code>TCP</code>在不可靠的<code>IP</code>层，采用超时重传、发送/接收端到端的确认分组等机制，提供一种可靠的运输层。</p></blockquote></li></ul></li><li><p><strong>链路层</strong> 也叫做数据链路层或网络接口层，包括系统设备驱动程序和计算机中对应的网络接口卡，用于处理电缆（或其他传输媒介）的物理接口细节。主要协议有<code>ARP（地址解析协议）</code>和<code>RARP（逆地址解析协议）</code>，是某些网络接口使用的特殊协议，用来转换<code>IP</code>层和网络接口层使用的地址。</p></li></ul><h3 id="ip地址"><a class="markdownIt-Anchor" href="#ip地址"></a> IP地址</h3><p>互联网上每个接口必须有一个唯一的<code>IP地址</code>，长度为<code>32bit</code>。总共分为五类：</p><img src="/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/ip地址分类.png" alt="IP地址分类" style="max-height:300px"><span class="image-caption">IP地址分类</span><blockquote><p>多接口主机具有多个 <code>IP</code>地址，其中每个接口都对应一个 <code>IP</code>地址。每类<code>IP</code>地址第一个和最后一个地址无效。</p></blockquote><p><strong>A类地址</strong>，网络号占<code>7bit</code>，全世界只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>126</mn></mrow><annotation encoding="application/x-tex">2^7-2=126</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">6</span></span></span></span> 个<code>A</code>类网络；主机号占<code>24bit</code>，因此每个<code>A</code>类网络可以连接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>16</mn><mo separator="true">,</mo><mn>777</mn><mo separator="true">,</mo><mn>214</mn></mrow><annotation encoding="application/x-tex">2^{24}-2=16,777,214</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">7</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span></span></span></span> 台主机。适用于大型网络中。</p><p><strong>B类地址</strong>，网络号占<code>14bit</code>，网络数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>16</mn><mo separator="true">,</mo><mn>382</mn></mrow><annotation encoding="application/x-tex">2^{14}-2=16,382</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mord">2</span></span></span></span> 个 ，但是<code>127</code>为保留诊断专用网络号（如<code>127.0.0.1</code>是环回地址，用于回路测试），因此全世界大约有<code>16000</code>个<code>B</code>类网络；主机号占<code>16bit</code>，每个网络可以连接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>65</mn><mo separator="true">,</mo><mn>534</mn></mrow><annotation encoding="application/x-tex">2^{16}-2=65,534</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">3</span><span class="mord">4</span></span></span></span> 台主机。 适用于中等规模网络。</p><p><strong>C类地址</strong>，网络号占<code>21bit</code>，网络数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>21</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mn>097</mn><mo separator="true">,</mo><mn>150</mn></mrow><annotation encoding="application/x-tex">2^{21}-2=2,097,150</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">9</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span></span></span></span> 个<code>C</code>类网络；主机号占<code>8bit</code>，每个网络可以连接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>254</mn></mrow><annotation encoding="application/x-tex">2^8-2=254</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">4</span></span></span></span> 台主机。适用于小型网络。</p><p>这些<code>IP地址</code>通常写成四个十进制的数，每个整数对应一个字节，叫做点分十进制法。可以通过第一个十进制整数的区间来区分地址种类。</p><table><thead><tr><th style="text-align:center">种类</th><th style="text-align:center">范围</th></tr></thead><tbody><tr><td style="text-align:center">A类</td><td style="text-align:center">0.0.0.0　到　127.255.255.255</td></tr><tr><td style="text-align:center">B类</td><td style="text-align:center">128.0.0.0　到　191.255.255.255</td></tr><tr><td style="text-align:center">C类</td><td style="text-align:center">192.0.0.0　到　223.255.255.255</td></tr><tr><td style="text-align:center">D类</td><td style="text-align:center">224.0.0.0　到　239.255.255.255</td></tr><tr><td style="text-align:center">E类</td><td style="text-align:center">240.0.0.0　到　247.255.255.255</td></tr></tbody></table><h3 id="端口"><a class="markdownIt-Anchor" href="#端口"></a> 端口</h3><p>Unix系统将 1~1023 之间的端口号设置为保留端口，只有具有超级用户特权的进程才能使用。大多数<code>TCP/IP</code>实现临时端口分配为 1024~5000 之间的端口号，大于 5000 为其他服务器预留的。</p><p>服务器一般都通过<code>知名</code>端口号来识别，例如：<code>FTP</code>是21，<code>SSH</code>是22，<code>Telnet</code>是23等等。</p><blockquote><p>大多数Unix系统文件<code>ect/services</code>中都包含了熟知的端口号。</p></blockquote><h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3><p>当应用程序用 <code>TCP</code>传送数据时，发送端将数据分段并送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），由此形成的信息被称为<strong>分组</strong>，分组通过网络发送到目的端系统，再被装配成初始数据。</p><blockquote><p>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起，分组交换机从它 一条入通信链路接收到达的分组并从它一条出通信链路转发分组。</p><p>最常见的分组交换机就是<strong>路由器</strong>和<strong>链路层交换机</strong>。</p></blockquote><img src="/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/数据封装.png" alt="数据封装" style="max-height:300px"><span class="image-caption">数据封装</span><p>由于<code>TCP</code>、<code>UDP</code>、<code>ICMP</code>和<code>IGMP</code>都要向<code>IP</code>传送数据，因此<code>IP</code>必须在生成的<code>IP</code>首部中加入某种标识，以表明数据属于哪一层。因此，<code>IP</code>在首部存入一个长度为<code>8bit</code>的数值，叫作协议域。</p><p><code>1</code>表示<code>ICMP</code>协议</p><p><code>2</code>表示<code>IGMP</code>协议</p><p><code>6</code>表示<code>TCP</code>协议</p><p><code>17</code>表示<code>UDP</code>协议</p><p>同样的，应用程序都可以使用<code>TCP</code>或<code>UDP</code>来传送数据，通过都用一个<code>16bit</code>的端口号来表示不同的应用程序，运输层协议在生成报文首部时将应用程序的的源端口和目标端口分别存入，作为应用程序标识符。</p><p>网络接口同样要发送和接收<code>IP</code>、<code>ARP</code>和<code>RARP</code>数据，因此也必须在以太网的帧首部加入相应标识（也是<code>16bit</code>），以指明生成数据的网络层协议。</p><blockquote><p>当主机收到一个以太网数据帧时，数据就开始由从协议栈中由底向上升，执行封装相反的操作，去掉各个协议的首部，并检查首部中的协议标识，以确定数据的上层协议，这个过程叫作<code>分用</code>。</p></blockquote><h3 id="网络数据交换"><a class="markdownIt-Anchor" href="#网络数据交换"></a> 网络数据交换</h3><h4 id="分组交换"><a class="markdownIt-Anchor" href="#分组交换"></a> 分组交换</h4><p>为了从源端系统向目标端系统发送报文，源将长报文划分为较小的数据块，称之为<strong>分组</strong>。通过通信链路和分组交换机进行传送。</p><ul><li><p>存储转发</p><p>多数分组交换机在链路输入端使用<strong>存储转发传输</strong>机制，即在交换机在传输该分组的第一个比特之前，必须先接收到整个分组，否则就要先缓存该分组的比特，直到接收完该分组全部比特后，才能向链路输出该分组。</p></li><li><p>排队</p><p>每台分组交换机有多条链路与之相连，对于每条链路，该分组交换机具有一个<strong>输出队列</strong>,它用于存储路由器准备发往那条链路的分组。当分组需要传输到某条链路，此时该链路正忙于传输其他分组，该到达分组就会进入队列等待。因此会产生一定延时。</p><blockquote><p>网络延时除了排队延时外，还包括传输过程中的所消耗的时间。</p></blockquote></li><li><p>丢包</p><p><strong>输出队列</strong>的缓存空间大小有限，当一个到达的分组发现队列已满时，到达的分组或排除的分组将被丢弃，这种现象称为<strong>丢包</strong>。</p></li><li><p>吞吐量</p><p>单位时间内处理网络请求的数量或速率。</p></li></ul><h4 id="电路交换"><a class="markdownIt-Anchor" href="#电路交换"></a> 电路交换</h4><p>在端系统通信会话期间，预留了端系统沿路径通信所需要的资源（缓存、链路传输速率）。与不预留的分组交换相比，不需要排队等待。传统的电话网络就是电路交换的典型应用。</p><p>电路交换网络中的复用：</p><ul><li><p>频分复用(FDM)</p><p>将用于传输信道的总带宽划分成若干个子频带（或称子信道）,每个子信道传输一路信号。频分复用要求总频率宽度大于各个子信道频率之和，同时为了保证各子信道中所传输的信号互不干扰，应在各子信道之间设立隔离带，保证了各路信号互不干扰。这样所有子信道传输的信号以并行的方式工作，每一路信号传输时可不考虑传输时延。</p></li><li><p>时分复用(TDM)</p><p>对一条链路，时间被划分为固定期间的帧，每个帧又被划为固定数量的时隙。当网络跨越一条链路创建一条链接时，网络在每个帧中为该链接指定一个时隙，单独为传输数据使用。</p></li></ul><img src="/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/电路交换网络复用.png" alt="电路交换网络复用" style="max-height:300px"><span class="image-caption">电路交换网络复用</span><blockquote><p>分组交换与电路交换相比，分组交换端到端的时延是不可预测的，因此在实时服务方面有待商榷。但是它提供了比电路交换更好的带宽共享，比电路交换更简单、有效且经济。</p></blockquote><h3 id="isp"><a class="markdownIt-Anchor" href="#isp"></a> ISP</h3><p>端系统通过 <strong>因特网服务提供商(Internet Service Provider, ISP)</strong> 接入因特网，<code>ISP</code>包括本地电缆或电话公司住宅ISP、公司ISP、大学ISP、wifi接入的ISP、蜂窝数据ISP等。</p><blockquote><p>每个<code>ISP</code>自身就是一个由多台分组交换机和多段通信链路组成的网络。因特网就是将端系统彼此互联，因此为端系统提供接入的<code>ISP</code>之间也也必须互联起来。</p><p>较低层的<code>ISP</code>通过国家、国际较高层<code>ISP</code>互联起来。较高层<code>ISP</code>是通过高速光纤链路互联的高速路由器组成。</p><p>每个<code>ISP</code>都是独立管理，通过<code>IP</code>协议，遵从相应的命名和地址规则。</p></blockquote><h3 id="物理媒体"><a class="markdownIt-Anchor" href="#物理媒体"></a> 物理媒体</h3><p>一个比特从一个端系统开始传输，通过一系列路由器和链路，到达另一个端系统。这个比特当从源到目的地传输时，通过一系列“发射器—接收器”对，通过跨越一种<strong>物理媒体</strong>传播电磁波或光脉冲来发送该比特。</p><p><code>分类</code>：</p><ul><li><strong>导引型媒体</strong> 电波沿着固体媒体前行。如：光缆、双绞铜线、同轴电缆</li><li><strong>非导引型媒体</strong> 电波在空气或外层空间传播。如：无线局域网、数字卫星频道。</li></ul><h4 id="双绞铜线"><a class="markdownIt-Anchor" href="#双绞铜线"></a> 双绞铜线</h4><p>由两根绝缘的铜线组成，每根大约1mm粗，以规则螺旋状绞合起来以减少临近的双绞线的电气干扰。通常许多双绞线捆扎在一起形成一根电缆，并在这这些双绞线外面涂上防护层。它是最便宜且最常用的导引型传输媒体，一般用于电话网、局域网中。目前局域网中的双绞线数据速率从<code>10Mbps</code>到<code>10Gbps</code>，所能达到的速率取决于线的粗细以及传输方和接收方的距离。</p><blockquote><p>双绞线也常用于住宅网络接入，家庭的 DSL 调制解调器得到数字后，将其转换为高频音，以通过电话线传输给本地中心局。因此，家庭电话同时承载了数据和传统的电话信号，它们用不同的频率进行编码。</p></blockquote><h4 id="同轴电缆"><a class="markdownIt-Anchor" href="#同轴电缆"></a> 同轴电缆</h4><p>与双绞线类似，同轴电缆由两个铜导体组成，但这两个铜导体是同心的而不是并行的。借助这种结构及特殊的绝缘体和保护层，同轴电缆能够到达较高的的数据传输速率。通常用于电视线路中。与电缆调制解调器（光猫）结合起来，形成电缆接入网能够达到数十<code>Mbps</code>的因特网速率。</p><h4 id="光纤"><a class="markdownIt-Anchor" href="#光纤"></a> 光纤</h4><p>一种细而柔软的、能够引导光脉冲的媒体。每个脉冲表示一个比特，一根光纤能够支持高达，数十甚至数百<code>Gbps</code>的速率。它们不受电磁干扰，<code>100km</code>的光缆信号衰减极低，并且很难窃听。这些特性使光纤成为跨海链路等长途导引型媒体。</p><h4 id="路地无线电信道"><a class="markdownIt-Anchor" href="#路地无线电信道"></a> 路地无线电信道</h4><p>无线电信道中承载电磁频谱中的信号，它不需要物理线路，并具有穿透墙壁、提供与移动用户长距离承载信号的能力。</p><p><code>分类</code>：</p><ul><li>一类运行在<code>1</code>到<code>2</code>米的很短距离。</li><li>第二类运行在局域，通常在十到几百米。</li><li>第三类运行在广域，跨越数万米。</li></ul><h4 id="卫星无线通道"><a class="markdownIt-Anchor" href="#卫星无线通道"></a> 卫星无线通道</h4><p>一颗通信卫星连接地球上的两个或多个微波发射器/接收器，它们被称为地面站。该卫星在一个频段上接收传输，使用一个转发器再生信号，并在另一个频率上发射信号。</p><p><code>分类</code>：</p><ul><li><strong>同步卫星</strong> 永久停留在地球上方的相同点，从地面站到卫星再回到地面站的巨大距离的信号传播，延时仅为<code>280ms</code>，传输速率确能达到数百<code>Mbps</code>。常用于无法使用<code>DSL</code>或电缆因特网接入的区域。</li><li><strong>近地轨道卫星</strong> 放置的非常靠近地球，并且不是永久停留在地球上面的一个点的卫星。它们围绕地球旋转，彼此之间可进行通信。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络 </tag>
            
            <tag> TCP/IP学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-图</title>
      <link href="2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
      <url>2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="图的定义"><a class="markdownIt-Anchor" href="#图的定义"></a> 图的定义</h3><p>在图中的数据元素称之为<code>顶点(Vertex)</code>;任意两顶点之间可能存在关系，顶点间的关系叫做<code>边(Edge)</code>。在图结构中不允许没有顶点，因此<code>图(Graph)</code>是由顶点的有穷非空集合和顶点之间边的集合组成的数据结构，通常表示为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> ,G 表示一个图，V 表示顶点集合，E 表示边集合。</p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210426153932729.png" alt="图1|图2"><span class="image-caption">图1|图2</span></p><h4 id="无向图"><a class="markdownIt-Anchor" href="#无向图"></a> 无向图</h4><p>若顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">V_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">V_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之间的边没有方向，则称这条边为<code>无向边</code>，用无序偶对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V_A,V_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 来表示。当一个图中任意两顶点间的边都是无向边时，则称该图为<code>无向图</code>。</p><p>如图1，由于没有方向顶点 A 和 B 的边可以表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A,B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>，也可以写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(B,A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span>。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">图</mi><mi mathvariant="normal">：</mi><msub><mi>G</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mn>1</mn></msub><mo separator="true">,</mo><mo stretchy="false">{</mo><msub><mi>E</mi><mn>1</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">图：G_1=(V_1,\{E_1\})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">图</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">顶</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">：</mi><msub><mi>V</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">顶点集合：V_1=\{A,B,C,D\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">}</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">边</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">：</mi><msub><mi>E</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">边集合：E_1=\{(A,B),(A,C),(A,D),(B,C),(B,D)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p><ul><li><p><strong>顶点与边的关系</strong></p><p>如果边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(v,v&#x27;) \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> ，则称顶点 v 和 v’ 相邻接，即两顶点相关联。和顶点相关联的边的数量，称之为顶点的<code>度</code>，记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TD(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>。</p><blockquote><p>如图1，A 和 B 相联接，互为邻接点，顶点 A 的度为 3。</p><p>通过观察发现图的边数，其实是各个顶点度数和的一半，多出的一半是因为重复记了两次。</p></blockquote></li></ul><h4 id="有向图"><a class="markdownIt-Anchor" href="#有向图"></a> 有向图</h4><p>若顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">V_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">V_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之间的边有方向，则称这条边为<code>有向边</code>（也称为<code>弧</code>)，用有序偶对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><msub><mi>V</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>B</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;V_A,V_B&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span> 来表示，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">V_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 称为弧尾 (<code>Tail</code>)，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">V_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 称为弧头 (<code>Head</code>)。</p><p>当一个图中任意两顶点间的边都是有向边时，则称该图为<code>有向图</code>。</p><p>如图2，A 和 B 的边表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;A,B&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>，注意不能写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;B,A&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">图</mi><mi mathvariant="normal">：</mi><msub><mi>G</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mn>2</mn></msub><mo separator="true">,</mo><mo stretchy="false">{</mo><msub><mi>E</mi><mn>2</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">图：G_2=(V_2,\{E_2\})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">图</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">顶</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">：</mi><msub><mi>V</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">顶点集合：V_1=\{A,B,C,D\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">}</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">边</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">：</mi><msub><mi>E</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>C</mi><mo>&gt;</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">边集合：E_1=\{&lt;A,B&gt;,&lt;A,C&gt;,(C,B),(B,D)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p><ul><li><p><strong>顶点与边的关系</strong></p><p>如果边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>v</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal">′</mo></msup><mo>&gt;</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">&lt;v,v&#x27;&gt; \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> ，则称顶点 v 邻接到顶点 v’。以顶点 v 为尾的边数量，称之为顶点的<code>出度</code>，记录  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ID(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>  ;  反之以顶点 v 为头的边的数量，称之为顶点的<code>入度</code>，记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">OD(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>。</p><blockquote><p>如图2，顶点 B 的入度为 2 (从 A 到 B，从 C 到 B) ，出度为 1 (从 B 到 D)，所以顶点 B 的度为 2+1 = 3。</p><p>通过观察发现该图的边数与图的入度或出度数相等。</p></blockquote></li></ul><h3 id="图的存储"><a class="markdownIt-Anchor" href="#图的存储"></a> 图的存储</h3><h4 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h4><p>图的邻接矩阵存储方式，采用两个数组来表示图。一个一维数组存储顶点信息，一个二维数组存储边信息。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">若</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi><mi mathvariant="normal">或</mi><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mo>∈</mo><mi>E</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">反</mi><mi mathvariant="normal">之</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">arc[i][j]=\begin{cases} 1,若(v_i,v_j)\in E 或 &lt;v_i,v_j&gt; \in E \\0,反之\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">若</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">或</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">反</span><span class="mord cjk_fallback">之</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li><strong>根据图1的无向图，得到如下：</strong></li></ul><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210426194907500.png" alt="图3"><span class="image-caption">图3</span></p><blockquote><p>矩阵的对角线值都为 0，因为不存在顶点到自身的边。</p><p>由于是无向图，所以边是对称的，即 A 到 B 存在边，意味着 B 到 A 也存在边，值为1。所以无向图的边数组矩阵是一个对称矩阵。</p></blockquote><p><strong>根据图3可得到的信息有：</strong></p><p>1）可以判断任意两点是否存在边，即值为1有边，值为0无边。</p><p>2）顶点的度就是该顶点的第 i 行（或第 i 列）的元素之和。</p><p>3）顶点的邻接点，就是将第 i 行元素描述一遍，<code>arc[i][j]</code>为1就是邻接点。</p><ul><li><p><strong>根据图2有向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210426195002314.png" alt="图4"><span class="image-caption">图4</span></p></li></ul><blockquote><p>矩阵的对角线仍然为 0。</p><p>由于是有向图，所以矩阵不再对称，即 A 到 B 存值为 1，而 B 到 A 值为 0。</p></blockquote><p><strong>根据图4可得到的信息有：</strong></p><p>1）顶点的出度值正好为顶点所在行的各数之和 。</p><p>2）顶点的入度值正好为顶点所在列的各数之和。</p><p>3）同无向图一样判断任意两点是否存在边，即值为 1 有边，值为 0 无边。</p><h4 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h4><p>邻接矩阵存储图的问题在于，当存储边数相较顶点来说较少的图时，邻接矩阵大多数值均为 0，此时这种结构浪费了大量存储空间。</p><p>针对顺序结构存在预先分配内存可能造成存储空间浪费问题，可以采用链式存储结构。这种数组与链表相结合的存储方法称为邻接表。</p><p><strong>邻接表的存储结构如下：</strong></p><p>​1）顶点用一个一维数组存储，数组中每个数据的元素内还需要存储指向第一个邻接点的指针，以便查找该顶点的边信息。</p><p>​2）每个顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的所有邻接点构成一个线性表，由于邻接点数量不确定，所以采用间链表存储。无向图称为顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的边表，有向图称为顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的出边表。</p><ul><li><p><strong>根据图1无向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210427103510225.png" alt="图5"><span class="image-caption">图5</span></p><p>​图5中，顶点表的各个结点由 <code>data</code> 和 <code>firstedge</code> 两个域表示，其中 <code>data</code> 是数据域存，储顶点信息 ; <code>firstedge</code> 是指针域，指向边表的第一个邻接点。</p><p>​边表各结点由 <code>adjvex</code> 和 <code>next</code> 两个域组成，其中 <code>adjvex</code> 邻接点域，存储某顶点的邻接点在顶点表中的下标 ; <code>next</code> 存储指向边表中下一个结点的指针。</p><blockquote><p>如 C 顶点，与 A、B 互为邻接点，所以顶点 C 的边表中 <code>adjvex</code> 分别为 A、B 所对应的下标 0 和 1。</p></blockquote></li><li><p><strong>根据图2有向图，得到如下：</strong></p><p>与无向图类似，但由于边是有方向，所以以顶点为尾来存储边表，这样可得到出度的邻接表。</p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210427105900040.png" alt="图6"><span class="image-caption">图6</span></p><p>有时为了确定顶点的入度，可以以顶为点头来存储边表，这样可得到入度的邻接表，称之为<strong>逆邻接表</strong>。</p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210427111107678.png" alt="图7"><span class="image-caption">图7</span></p></li></ul><h4 id="十字链表"><a class="markdownIt-Anchor" href="#十字链表"></a> 十字链表</h4><p>对于有向图来说，邻接表是有缺陷的。建立出度邻接表时，想要获得入度就必须要遍历整个图，反之亦然。而十字链表法，解决了这个问题。</p><p><strong>十字链表存储结构如下：</strong></p><p>1）顶点表增加入边表头指针( <code>firstin</code>) 指向该顶点的入边表中的第一个结点 ; 出边表头指针( <code>firstout</code>)指向该顶点的出边表中的第一个结点。</p><p>2）边表增加弧的起点(<mark>出边顶点</mark>)在顶点表的坐标 (<code>tailvex</code>) 、弧的终点(<mark>入边顶点</mark>)在顶点表的坐标 (<code>headvex</code>) 和入边表指针域 (<code>headlink</code>)指向终点相同的下一条边、出边表指针域(<code>taillink</code>)指向起点相同的下一条边。</p><ul><li><p><strong>根据图2有向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210427172645472.png" alt="图8"><span class="image-caption">图8</span></p><p><strong>十字链表步骤解析：</strong></p><p>1）第一步画出邻接表，步骤完全相同， <code>firstout</code>为第一个邻接点指针，<code>headvex</code> 就是邻接表  <code>adjvex</code> 值 ; <code>taillink</code> 就是邻接表<code>next</code>值。</p><p>2）根据图2可知，顶点 <code>A</code> 没有入边所以 <code>firstin</code> 为空，用 <code>^</code> 标识。</p><p>3）顶点 <code>B</code> 第一个入边为 <code>&lt;A,B&gt;</code> 坐标为 <code>(0,1)</code> ，所以 <code>firstin</code> 指针指向图中的 <code>①</code> 。</p><p>4）因为顶点 <code>B</code> 存在第二个入边 <code>&lt;C,B&gt;</code> 坐标为 <code>(2,1)</code> ，所以入边顶点的 <code>headlink</code> 指针继续向下指向图中的 <code>②</code>。此时顶点 <code>B</code> 已经没有其他入边，所以该顶点的入边链表在此结点终止，将该结点的 <code>headlink</code> 标记为 <code>^</code>。</p><p>5）同理顶点 <code>C</code> 和 <code>D</code> 也能画出各自的入边链表，如图 <code>③</code> 、<code>④</code>。</p><blockquote><p>十字链表的优点就是把邻接表和逆邻表整合在了一起，从而更容易获得顶点的出度与入度，并且创建图的算法时间复杂度和邻接表相同。其缺点就是结构更加复杂。</p></blockquote></li></ul><h4 id="邻接多重表"><a class="markdownIt-Anchor" href="#邻接多重表"></a> 邻接多重表</h4><p>对于无向图，邻接表也存在一些问题。当关注的重点不是顶点而是边时，如图1，要删除 <code>(A,B)</code> 边，对应的邻接表需要删除下图图9灰色两个结点，比较烦琐。可以通过邻接多重表解决这个问题。</p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210428110929769.png" alt="图9"><span class="image-caption">图9</span></p><p><strong>邻接多重表存储结构：</strong></p><p>1）顶点表保持不变</p><p>2）边表增加 <code>ivex</code>、<code>ilink</code>、<code>jvex</code>、<code>jlink</code>，其中 <code>ivex</code> 和 <code>jvex</code> 是某条边的两个顶点在顶点表中的下标 ; <code>ilink</code> 指向顶点 <code>ivex</code> 的下一条边，<code>jlink</code> 指向顶点 <code>jvex</code> 的下一条边。</p><ul><li><p><strong>根据图1无向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210428143752903.png" alt="图10"><span class="image-caption">图10</span></p><p><strong>邻接多重表步骤解析：</strong></p><p>1）先画出顶点表的 4 个顶点和 5 条边。因为是无向边，所以 <code>ivex</code> 和 <code>jvex</code> 可以是两个顶点中的任意一个。如 <code>(A,B)</code> 边，无论 <code>ivex</code> 为 0 、<code>jvex</code> 为 1，还是反过来都可以，一般为了规范，通常都将 <code>ivex</code> 值与左侧顶点下标相同。</p><p>2）首先连线 <code>①②③④</code> ，就是将顶点指向一条边。</p><p>3）顶点 <code>A</code> 的  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_A,v_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 边的邻边有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>C</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">和</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>D</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_A,v_C)和(v_A,v_D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">和</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，因此步骤 <code>⑤</code> 中的 <code>ilink</code> 指向顶点 <code>ivex</code> 的下一条边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>C</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_A,v_C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 坐标为 <code>(0,2)</code> 因为是无向边，所以指向的也就是边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>C</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_C,v_A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 坐标 <code>(2,0)</code> 。</p><p>4）继续链接指向顶点 <code>jvex</code> 的 <code>jlink</code> ，即指向顶点 <code>jvex</code> 的下一条边，此处是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>D</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_A,v_D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 坐标为 <code>(0,3)</code> 见步骤 <code>⑥</code>。</p><p>5）同上一步，继续链接指向顶点 <code>jvex</code> 的 <code>jlink</code>，此时发现顶点 <code>jvex</code> 即顶点 <code>A</code> 不存在其他边了，所以为空，将 <code>jlink</code> 标记为 <code>^</code>。</p><p>6）顶点 <code>A</code> 链接完成，重复上述 2-5 步，继续链接顶点 <code>B</code>、<code>C</code>、<code>D</code>。</p><blockquote><p>注意 <code>ilink</code> 所指向的结点 <code>jvex</code> 一定要和它本身的 <code>ivex</code> 值相同。</p><p>由此可见，邻接多重表与邻接表的区别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。若要删除 <code>(A,B)</code> 边时，只需要将 <code>⑦</code> 的链接指向改为 <code>^</code> 即可。</p></blockquote></li></ul><h4 id="边集数组"><a class="markdownIt-Anchor" href="#边集数组"></a> 边集数组</h4><p>边集数组是由两个一维数组组成构成。一个存储顶点的信息 ; 另一个存储边信息。边数组每个数据元素由一条边的起点下标 (<code>begin</code>)、终点下标 (<code>end</code>) 和权重 (<code>weight</code>)组成，没有权重可以省略。</p><ul><li><p><strong>根据图2有向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210428154142890.png" alt="图11"><span class="image-caption">图11</span></p></li></ul><blockquote><p>边集数组是边的集合，在边集数组中要查找一个顶点的度，需要遍历整个数组，效率不高。因此它更适合对边依次进行处理的操作，而不适合对顶点的操作。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六月记</title>
      <link href="2020/06/04/blog/%E5%85%AD%E6%9C%88%E8%AE%B0/"/>
      <url>2020/06/04/blog/%E5%85%AD%E6%9C%88%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>乘风而起，浮尘而行，蹉跎莫遣韶光老！</p></blockquote><p>白驹转瞬，年过半载。突如其来的疫情打乱了全部的计划， 在当前这个经济萧条，资金动荡的大环境下，导致向来乐享天命的我多了一丝忧愁。也就是这一丝忧愁尤如我前行路上的鸣钟，在向我发出善意的警示。</p><p>以前只想着每天对生活热情满满，对工作认真严谨，未来的事儿，顺其自然就好了。然而事与愿违，顺其自然的往往都不是什么很好的结果。俗话说“人无远虑，必有近忧！”，当近忧来扰的时候，求变的欲望从心底油然而生。</p><p>鼠年貌似一直以来就是不怎么平静的年头， 今年的新冠，零八年汶川的地震都在给这个普通的生肖年一次一次的增添不寻常轨迹。但是这一年对于我来说又是一个具有特殊意义的一年，人生为数不多的大事，在这半年时间完成了两个。希望我在人生的中段也能热忱的迎接每一个挑战，而为了更好的完成我的责任与义务，我也必须改变提升自我。把现实中放了的太多口号，回归到脚踏实地，一步一个脚印。</p><p>总是和朋友开玩笑说，自己空有一身本领，却无处施展。归根结底，造成这种境地的原因还是缺少远虑。人人都向往自由职业、梦想自由财务，却很少想过怎么为之努力奋斗，而我就被包括到了其中。</p><p>从此刻起，提升自身认知，学习理财，学习英语，实践想法，这不再是一个简单的口号，而是迎接我即将到来的“六月”的礼物。</p><p><em><strong>“我只管努力，其他的交给天意！”</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法学习-排序</title>
      <link href="2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/"/>
      <url>2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="排序稳定性"><a class="markdownIt-Anchor" href="#排序稳定性"></a> 排序稳定性</h3><p>已知序列 r，排序前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 领先于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">r_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>)。当排序后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>　仍领先于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">r_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，则所用排序方法是<strong>稳定的</strong>;反之，则称排序方法<strong>不稳定</strong>。</p><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/WX20200312-172502@2x.png" style="height:200px;"><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><p>冒泡排序(Bubble Sort)是一种简单的排序算法，它重复地遍历要排序的数列，每次两两比较相邻记录，如果第一个元素比第二个元素大，则交换他们位置。同理继续比较第二个与第三个元素，重复这个操作直到所有最大元素排到最右侧为止。<br><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/maopao.webp" alt="冒泡排序示意图" style="height:200px;"><span class="image-caption">冒泡排序示意图</span></p><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 冒泡排序 * @param nums 序列 * @param numsSize 序列大小 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (nums) &#123;        <span class="hljs-keyword">int</span> i, j;        printNums(nums, numsSize);        boolean flag = TRUE; <span class="hljs-comment">// 当序列前面元素都小于后面元素时说明排序已完成，不需要进行无意义的循环，所以增加 flag 标识结束循环操作</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; numsSize - <span class="hljs-number">1</span> &amp;&amp; flag; i++) &#123; <span class="hljs-comment">// 倒数第二次比较就可以完成所有排序，所以用i &lt; numsSize - 1 代替 i &lt; numsSize 可以少循环一次</span>            flag = FALSE;            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; numsSize - i - <span class="hljs-number">1</span>; j++) &#123; <span class="hljs-comment">// i &lt; numsSize - i - 1 是因为 j 要与 j + 1 比较</span>                <span class="hljs-keyword">if</span> (newNums[j] &gt; newNums[j + <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">int</span> temp = newNums[j + <span class="hljs-number">1</span>];                    newNums[j + <span class="hljs-number">1</span>] = newNums[j];                    newNums[j] = temp;                    flag = TRUE;                    printNums(nums, numsSize);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h4><p>最好的情况，序列本身是有序的，可以推断出算法进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次比较，没有数据交换，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br>最坏的情况，序列本身是逆序的，当：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">i=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次<br>…<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br>总共比较了</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n)=\sum^{n}_{i=2}(i-1)=1+2+3+...+(n-1)=\frac{(1+n-1)(n-1)}{2}=\frac{n(n-1)}{2}=\frac{1}{2}n^2-\frac{1}{2}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>次，根据复杂度推导原则，去掉常数和最高项等其复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度"></a> 空间复杂度</h4><p>空间很杂度就是在交换元素时 temp 临时变量所占的内存空间。<br>最好情况，是序列已排好序，则空间复杂度为 0;<br>最坏情况，是序列本身逆序，则空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br>所以算法平均空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h4 id="稳定性"><a class="markdownIt-Anchor" href="#稳定性"></a> 稳定性</h4><p>冒泡排序是稳定的原地排序算法。</p><h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3><p>选择排序的原理是，先从给定序列中选出一个最小元素 min (通常是无序区间第一个元素)，然后与后面元素进行比较，选出最小元素与之交换，min 位置前面就变成了有序区间，min 位置后面则是无序区间，继续在无序区间重复前面操作直到全部变成有序区间后，排序完成。</p><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/xuanze.gif" alt="选择排序示意图" style="height:200px;"><span class="image-caption">选择排序示意图</span><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 选择排序(每次找出最小元素与数组第一个元素交换) * @param nums 序列 * @param numsSize 序列大小 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">chooseSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-keyword">int</span> i, j;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;            <span class="hljs-keyword">int</span> temp;            <span class="hljs-keyword">int</span> min = i;            <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; numsSize; j++) &#123;                <span class="hljs-keyword">if</span> (newNums[j] &lt; newNums[min]) min = j;            &#125;            temp = newNums[i];            newNums[i] = newNums[min];            newNums[min] = temp;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度-2"><a class="markdownIt-Anchor" href="#时间复杂度-2"></a> 时间复杂度</h4><p>该算法最大特点就是交换移动数据次数很少，可以节约相应时间。但是它的比较次数无论是最好或最差情况下都是一样多，当<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次　<br>…<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次　<br>总共比较了</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n)=\sum^{n-1}_{i=1}(n-i)=(n-1)+(n-2)+...+2+1=\frac{n(n-1)}{2}=\frac{1}{2}n^2-\frac{1}{2}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>次，根据复杂度推导原则，去掉常数和最高项等其复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h4 id="稳定性-2"><a class="markdownIt-Anchor" href="#稳定性-2"></a> 稳定性</h4><p>由于选择元素之后发生交换操作，所以很可能把前面元素交换到后面，所以该排序算法是不稳定的。</p><h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3><p>插入排序采用<code>in-place</code>在数组上实现的算法，<br><strong>具体步骤是</strong>：</p><ol><li>从第一个元素开始，认为该元素是有序序列，取出下一个元素作为临时元素，在有序序列中从后向前逐一比较。</li><li>如果有序序列中元素大于临时元素，则将该元素向后移动一位。</li><li>如果该元素小于等于临时元素，则将临时元素插入到该位置，此时有序序列长度增加一。</li><li>临时元素索引加一继续作为临时元素，重复前面步骤，直到临时元素索引超出序列长度，排序完成。</li></ol><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/charu.gif" alt="插入排序示意图" style="height:300px;width: 655px;"><span class="image-caption">插入排序示意图</span><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 插入排序 * @param nums 序列 * @param numsSize 序列大小 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-keyword">int</span> i, j;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; numsSize; i++) &#123;            <span class="hljs-keyword">if</span> (newNums[i - <span class="hljs-number">1</span>] &gt; newNums[i]) &#123;                <span class="hljs-keyword">int</span> temp = newNums[i];                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; newNums[j] &gt; temp; j--) &#123;                    newNums[j + <span class="hljs-number">1</span>] = newNums[j];                &#125;                newNums[j + <span class="hljs-number">1</span>] = temp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度-3"><a class="markdownIt-Anchor" href="#时间复杂度-3"></a> 时间复杂度</h4><p>对于 n 个元素，外层循环执行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(n)=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次，内层循环，当：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时，执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次<br>…<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br>总共执行了</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>i</mi><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n)=\sum^{n-1}_{i=1}i=1+2+...+(n-1)=\frac{n(n-1)}{2}=\frac{1}{2}n^2-\frac{1}{2}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>次，根据复杂度推导原则，去掉常数和最高项等其复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度-2"><a class="markdownIt-Anchor" href="#空间复杂度-2"></a> 空间复杂度</h4><p>插入排序通常采用<code>in-place</code>排序，所以空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h4 id="稳定性-3"><a class="markdownIt-Anchor" href="#稳定性-3"></a> 稳定性</h4><p>因为排序比较时，当两个数相等时，不会进行移动，因此前后次序不会发生变化，所以该排序算法是稳定的。</p><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><p>希尔排序是 D.L.Shell 于 1959 年提出的一种排序算法，之前排序算法时间复杂度基本都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，希尔排序是突破这个时间复杂度的第一批算法之一。</p><p>插入排序通常在小规模数据或是序列基本有序时十分高效，但是满足这两个条件是比较困难。希尔排序就是对插入排序的改进算法，<br><strong>基本思路是</strong>：</p><ul><li>将原有大量记录序列进行分组，侵割成若干个子序列。</li><li>在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，再对整个序列进行一次直接插入排序，完成排序。</li></ul><blockquote><p>所谓基本有序，指的是序列中较小元素基本在前面，较大元素基本在后面，不大不小元素基本在中间，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">{2, 1, 3, 6, 4, 7, 5, 8, 9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span></span></span></span></span><br>为了使整个序列基本有序，采取跳跃分割策略，<strong>将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列排序后整个序列基本有序，而不是局部有序</strong>。</p></blockquote><p><strong>步骤</strong>：<br>以增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">gap=length/2=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 方式计算，首先将序列可逻辑分成四组子序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>5</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[5,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>7</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[7,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>8</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[8,4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>，如下：<br><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/shellSort1.png" alt="希尔排序分组示意图" style="width:500px;"><span class="image-caption">希尔排序分组示意图</span></p><p>分别对各个子序列进行插入排序可得到逻辑子序列分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,7]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,8]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span> 总序列为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2,4,3,5,7,8,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>，如图：<br><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/shellSort2.png" alt="希尔排序子序列排序示意图" style="width:500px;"><span class="image-caption">希尔排序子序列排序示意图</span></p><p>然后继续以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi><mo>=</mo><mi>g</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">gap=gap/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord">/</span><span class="mord">2</span></span></span></span> &amp;&amp; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">gap&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 方式计算，重复上述步骤。<br>最后根据得到的基本有序序列再一次进入直接插入排序，最终完成排序。</p><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 希尔排序 * @param nums 序列 * @param numSize 序列大小 * @return */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = numsSize / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; numsSize; i++) &#123;                <span class="hljs-keyword">if</span> (newNums[i - gap] &gt; newNums[i]) &#123;                    <span class="hljs-keyword">int</span> j;                    <span class="hljs-keyword">int</span> temp = newNums[i];                    <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; newNums[j] &gt; temp; j -= gap) &#123;                        newNums[j + gap] = newNums[j];                    &#125;                    newNums[j + gap] = temp;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度-4"><a class="markdownIt-Anchor" href="#时间复杂度-4"></a> 时间复杂度</h4><p>希尔排序算法的时间复杂度与其增量<code>gap</code>设置有关，迄今为止还没有能证明出来的增量序列，不过有实验表明当增量序列为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，时间复杂度最坏情况为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="稳定性-4"><a class="markdownIt-Anchor" href="#稳定性-4"></a> 稳定性</h4><p>虽然插入排序是稳定的，但是希尔排序在插入的时候是跳跃性插入的，有可能破坏其稳定性，所以希尔排序是不稳定的。</p><h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3><p>归并排序(Merging Sort) 就是将待排序的数分成两半后排好序，然后再将两个排好序的序列合并成一个有序序列。 归并排序是一个比较占用内存，但效率高的算法。<br><strong>基本原理是</strong>：<br>将有<code>n</code> 个元素的序列看成是<code>n</code> 个有序的子序列，每个子序列长度为<code>1</code>(一个元素认为它有序的)， 然后两两归并，…重复归并，直至得到一个长度为<code>n</code> 的有序序列为止，这种方法称为<strong>2路归并法</strong>。</p><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/guibing.webp" alt="归并排序示意图" style="height:200px;"><span class="image-caption">归并排序示意图</span><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 归并排序 * @param nums 序列 * @param numSize 序列大小 * @return */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;       mSort(newNums, <span class="hljs-number">0</span>, numSize - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *newNums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &lt; right) &#123;        <span class="hljs-comment">// 将序列一分为二</span>        <span class="hljs-keyword">int</span> center = (left + right) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// 排序左边数组</span>        mSort(newNums, left, center);        <span class="hljs-comment">// 排序右边数组</span>        mSort(newNums, center + <span class="hljs-number">1</span>, right);        <span class="hljs-comment">// 合并两个序列</span>        mSortMerge(newNums, left, center, right);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mSortMerge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *newNums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> center, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = left;    <span class="hljs-keyword">int</span> j = center + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> *tempNums = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(newNums));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++) &#123;        <span class="hljs-comment">// j &gt; right 时，表示右子序列元素全部放入到了临时数组(tempNums) 中，此时只剩下左子序列有元素，由于单侧子序列都是有序的，所以直接将左子序列元素顺序放入临时数组(tempNums)中即可。</span>        <span class="hljs-comment">// 反之，当 j &lt;= right 且 i &gt; center 时，表示左子序列元素全部放入到了临时数组中，此时只剩下右子序列有元素，所以直接将右子序列元素顺序放入临时数组中即可。</span>        <span class="hljs-comment">// 该操作通过递归函数重复调用直到排序完成为止</span>        <span class="hljs-keyword">if</span> (j &gt; right || newNums[i] &lt;= newNums[j])            tempNums[k] = newNums[i++];        <span class="hljs-keyword">else</span>            tempNums[k] = newNums[j++];    &#125;    <span class="hljs-comment">// 将排好序的临时数组元素复制到原数组中</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++) &#123;        newNums[k] = tempNums[k];    &#125;    <span class="hljs-built_in">free</span>(tempNums);&#125;</code></pre><p><strong>递归实现的执行步骤如下</strong>：</p><pre class="highlight"><code class>排序序列：54321------------------------------L-&gt;C-&gt;R：024分割序列：54321------------------------------L-&gt;C-&gt;R：012分割序列：543------------------------------L-&gt;C-&gt;R：001分割序列：54------------------------------L-&gt;C-&gt;R：001待排序序列：54序列中较小元素：4序列中较小元素：5排序完成序列：45------------------------------L-&gt;C-&gt;R：012待排序序列：453序列中较小元素：3序列中较小元素：4序列中较小元素：5排序完成序列：345------------------------------L-&gt;C-&gt;R：334分割序列：34------------------------------L-&gt;C-&gt;R：334待排序序列：34序列中较小元素：1序列中较小元素：2排序完成序列：34512------------------------------L-&gt;C-&gt;R：024待排序序列：34512序列中较小元素：1序列中较小元素：2序列中较小元素：3序列中较小元素：4序列中较小元素：5排序完成序列：12345</code></pre><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 归并排序(非递归实现) *  实现原理：首先将序列中每个元素作为子序列，把相临子序列两两配对排序; *  然后，再将两个排好序的子序列作为一个子序列，再对相临子序列进行排序，重复上面步骤直到排序完成 * @param nums 序列 * ‧param numSize 序列大小 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">mergeSortNonRecursive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-comment">// 定义子序列的大小分别为 1、2、4、8...逐渐递增</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; numSize; i += i) &#123;            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> center = left + i - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> right = center + i;            <span class="hljs-comment">// 对子序列时行两两合并</span>            <span class="hljs-keyword">while</span> (right &lt; numSize) &#123;                <span class="hljs-comment">// 合并两序列</span>                mSortMerge(newNums, left, center, right);                left = right + <span class="hljs-number">1</span>;                center = left + i - <span class="hljs-number">1</span>;                right = center + i;            &#125;            <span class="hljs-comment">// 因为不可能每个子序列的大小都刚好为</span>            <span class="hljs-comment">// i，所以可能存在遗漏元素没有合并，因此最后要对遗漏元素进行合并</span>            <span class="hljs-keyword">if</span> (left &lt; numSize &amp;&amp; center &lt; numSize) &#123;                mSortMerge(newNums, left, center, numSize - <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度-5"><a class="markdownIt-Anchor" href="#时间复杂度-5"></a> 时间复杂度</h4><p>由于归并排序数据结构属于完全二杈树，而由完全二杈树的深度可知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n)=log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span> 次。排序最后要将临时数组元素复制到原数组中，此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 次。因此，总时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><h4 id="稳定性-5"><a class="markdownIt-Anchor" href="#稳定性-5"></a> 稳定性</h4><p>归并排序中不存在跳跃，只有两两比较，因此是一种稳定排序。</p><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><p>所谓快速排序，也是一种采用分治思想的排序方法，其<strong>基本思路是</strong>：<br>首先，在要排序的序列(<code>nums</code>)中任意选取一个元素(通常选择第一个元素)，该元素被称为<code>中枢元素</code>。然后根据中枢元素进行排序，将小于等于中枢元素的元素放在中枢元素的左边，将大于等于中枢元素的元素放在中枢元素的右边。然后再把序列根据中枢元素位置(<code>pivot</code>)分割成两个子序列，即左子序列(<code>nums[low,pivot-1]</code>) 和右子序列(<code>nums[pivot+1,high]</code>)，继续重复前面步骤直到整个序列有序。</p><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/kuaisu.jpeg" style="width:300px;" alt="快速排序示意图"><span class="image-caption">快速排序示意图</span><blockquote><p>上面整个排序过程的主要目的是选出中枢元素，然后将中枢元素交换到有序位置(即中枢元素大于其左侧所有元素，小于其右侧所有元素)，然后再将序列分割成左、右子序列，分别在两个序列中选出中枢元素继续交换到有序位置，直到序列大小最终被分割为 1 为止(当序列只有 1 个元素时，即可认为该序列有序)。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 快速排序 * @param nums 序列 * @param numsSize 序列大小 * @date 2020-03-30 16:47 * @author Windus */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qSortRecursion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>;        qSortRecursion(newNums, <span class="hljs-number">0</span>, numsSize - <span class="hljs-number">1</span>);    &#125;<span class="hljs-keyword">return</span> newNums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qSortRecursion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>;        <span class="hljs-comment">// 获取中枢元素，并根据中枢将子序列排序</span>        <span class="hljs-keyword">int</span> pivot = partition(nums, low, high);        <span class="hljs-comment">// 对左子序列进行排序</span>        qSortRecursion(nums, low, pivot - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 对右子序列进行排序</span>        qSortRecursion(nums, pivot + <span class="hljs-number">1</span>, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">int</span> pivot = low;    <span class="hljs-keyword">while</span> (low &lt; high) &#123;        <span class="hljs-comment">// 从左向右扫描比中枢元素大的元素</span>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= nums[high]) low++;        <span class="hljs-comment">// 从右向左扫描比中枢元素小的元素</span>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= nums[pivot]) high--;        <span class="hljs-comment">// 当左侧指针位置大于或等于右侧指针时，跳出循环，不进行左右元素交换(因为左指针元素已经小于等于中枢元素，不需要移动位置了)</span>        <span class="hljs-keyword">if</span> (low &gt;= high) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 交换两指针元素元素，使左指针元素小于右指针元素</span>        temp = nums[high];        nums[high] = nums[low];        nums[low] = temp;    &#125;    <span class="hljs-comment">// 交换中枢元素，使中枢元素处于有序位置</span>    temp = nums[high];    nums[high] = nums[pivot];    nums[pivot] = temp;    <span class="hljs-keyword">return</span> pivot;&#125;</code></pre><blockquote><p>中枢元素的选取直接影响快速排序性能，当中枢元素处于整个序列中间位置时最优，但在现实中，待排序序列极有可能是基本有序的，此时，如果固定选取某一元素作为中枢元素并不是好的排序办法。因此可以通过随机或取中间数的方法来选取中枢元素。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> pivot;<span class="hljs-comment">// 计算中间元素的下标</span><span class="hljs-keyword">int</span> m = (high - low) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(nums[low] &gt; nums[high])    swap(nums, low, high); <span class="hljs-comment">// 交换左、右两侧元素，保证左侧元素较小</span><span class="hljs-keyword">if</span>(nums[m] &gt; nums[high])    swap(nums, high, m); <span class="hljs-comment">// 交换中间与右侧元素，保证中间较小 </span><span class="hljs-keyword">if</span>(nums[m] &gt; nums[low])    swap(nums, m, low); <span class="hljs-comment">// 交换中间与左侧元素，保证左侧元素较小</span><span class="hljs-comment">/* 此时 nums[low] 已经成为三个元素的中间值，用于当作中枢元素 */</span>pivot = low;</code></pre><h4 id="时间复杂度-6"><a class="markdownIt-Anchor" href="#时间复杂度-6"></a> 时间复杂度</h4><p>虽然快速排序的平均时间复杂度也是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，但是不需要像归并排序那样，需要一个临时数组辅助排序，这样可以节省掉一些空间消耗。同时也不需要像归并排序那样，把两部分有序子序列汇总到临时数组之后，再复制回源数组 ，这样也可以节省很多时间。</p><h4 id="稳定性-6"><a class="markdownIt-Anchor" href="#稳定性-6"></a> 稳定性</h4><p>该排序是不稳定的，因为在整个序列扫描时，中枢元素与 high 位置发生交换的时候，可能破坏其稳定性。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习-复杂度分析</title>
      <link href="2020/03/11/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%8D%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>2020/03/11/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%8D%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h3><p>算法时间复杂度，即算法的时间量度，采用<strong>大O</strong>记法( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> )：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>表示随问题规模 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的增大，算法执行时间的增长率和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的增长率相同，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 是问题规模 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的菶函数。<br>通常，随着 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的增大，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 增长最慢的算法为最优算法。</p><blockquote><p>推导时间复杂度大 O 方法：</p><ol><li><strong>因为常数项对函数的增长速度影响不大，所以用常数 1 取代运行时间中的所有加法常数</strong>。如：<br> <br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">T(n) = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> // 把常数 2 用 1 取代，所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><br> </li><li><strong>因为高次项对于函数的增长速度的影响最大( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup><mo>&gt;</mo><msup><mi>n</mi><mn>2</mn></msup><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n^3 &gt; n^2 &gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> )，所以在修改后的运行次数函数中，只保留最高项</strong>。如：<br> <br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>n</mi><mn>3</mn></msup><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>29</mn></mrow><annotation encoding="application/x-tex">T(n) = n^3 + n^2 + 29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">9</span></span></span></span> // 只保留最高项 n^3，所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo>+</mo><mn>29</mn></mrow><annotation encoding="application/x-tex">T(n) = n + 29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">9</span></span></span></span> // 只保留最高项 n，所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br> </li><li><strong>因为函数的阶数对函数的增长速度影响最显著，所以如果最高项存在且不是1，则去除与这个项相乘的常数</strong>。<br> <br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">T(n) = 3n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> // 最高项存在且不是 1，所以去除相乘常数后时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ol></blockquote><h4 id="常数时间o1"><a class="markdownIt-Anchor" href="#常数时间o1"></a> 常数时间<code>O(1)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>,n = <span class="hljs-number">100</span>; <span class="hljs-comment">// 执行一次 时间复杂度 O(1)</span>sum = (<span class="hljs-number">1</span>+n) * n/<span class="hljs-number">2</span>;   <span class="hljs-comment">// 执行一次 时间复杂度 O(1)</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,sum);    <span class="hljs-comment">// 执行一次 时间复杂度 O(1)</span>&#125;</code></pre><p>函数 afunc 运行次数的函数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">T(n) = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。根据大 O 推导方法，把常数项 3 改为 1。然后保留最高项，其最高项就是常数项，所以这个算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h4 id="线性时间on"><a class="markdownIt-Anchor" href="#线性时间on"></a> 线性时间<code>O(n)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 循环次数 n ，时间复杂度为 O(n)</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!"</span>); <span class="hljs-comment">// 时间复杂度 O(1)</span>   &#125;&#125;</code></pre><p>循环的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，循环体内时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，则这个循环的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n × 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，根据推导方法第三步去掉最高项相乘的常数，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h4 id="平方时间on2"><a class="markdownIt-Anchor" href="#平方时间on2"></a> 平方时间<code>O(n^2)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)&#123; <span class="hljs-comment">// 循环次数为 n，时间复杂度为 O(n)</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123; <span class="hljs-comment">// 循环次数为 n，时间复杂度为 O(n)</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!"</span>); <span class="hljs-comment">// 时间复杂度为 O(1)</span>        &#125;    &#125;&#125;</code></pre><p>此时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo>×</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n × n × 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123; <span class="hljs-comment">// 循环次数为 n，时间复杂度为 O(n)</span>        <span class="hljs-keyword">for</span>(j = i; j &lt; n; j++)&#123; <span class="hljs-comment">// 注意 j = i而不是0</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!"</span>); <span class="hljs-comment">// 时间复杂度为 O(1)</span>        &#125;    &#125;&#125;</code></pre><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，内循环执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 次，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，执行了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次，……当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = n -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，执行了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次。所以总执行次数为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>1</mn><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">n + ( n - 1 ) + ( n - 2 ) + ... + 1 = \frac{n ( n + 1 )}{ 2 } = \frac{ n^2 }{2} + \frac{ n }{ 2 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>用<strong>大O</strong>推导方法，保留最高阶项 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{ n^2 }{ 2 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，然后去除这个项相乘的常数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{ 1 }{ 2 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，得出时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="对数时间ologn"><a class="markdownIt-Anchor" href="#对数时间ologn"></a> 对数时间<code>O(logn)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">int</span> count  = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(count &lt; n)&#123;    count =  count * <span class="hljs-number">2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello Word!"</span>);&#125;&#125;</code></pre><p>从此例中可以看出当循环执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2^x = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">x = log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span> 次时结束。所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> (<em>底数2可以省略</em>)</p><h4 id="指数时间o2n"><a class="markdownIt-Anchor" href="#指数时间o2n"></a> 指数时间<code>O(2^n)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> aFunc(n - <span class="hljs-number">1</span>) + aFunc( n - <span class="hljs-number">2</span> );    &#125;&#125;</code></pre><p>此代码可以看出，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">，</mi><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(0) = T(1) = 1，T(n) = T(n - 1) + T(n - 2) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。通过归纳法证明，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n &gt;= 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo stretchy="false">(</mo><mn>5</mn><mi mathvariant="normal">/</mi><mn>3</mn><msup><mo stretchy="false">)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">T(n) &lt; (5/3)^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">/</span><span class="mord">3</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n &gt; 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn><msup><mo stretchy="false">)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">T(n) &gt;= (3/2)^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">/</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，所以简化后的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="常用时间复杂度"><a class="markdownIt-Anchor" href="#常用时间复杂度"></a> 常用时间复杂度</h4><img src="/2020/03/11/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%8D%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/WX20200312-111638@2x.png" alt="图：常用的时间复杂度" style="height:200px;"><span class="image-caption">图：常用的时间复杂度</span><p>常用的时间复杂度所耗费时间从小到大依次是：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，深入到函数进行分析。</p></blockquote><h3 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度"></a> 空间复杂度</h3><p>空间复杂度是对一个算法在运行过程中临时战胜存储空间大小的量度。<br>计算公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n) = O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>　<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为问题规模，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 为语句关于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 所占存储空间的函数。</p><p>比如插入排序的空间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，而一般递归算法就要有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的空间复杂度，因为每次递归都要存储返回信息。</p><blockquote><p>有时也可以用空间换时间的方法，如要判断某年是不是闰年，可以写一个算法，每次给一个年份来计算出结果，还有另一个方法就是，事先建立一个有 2050 个元素的数组，然后把所有年份按下标数字对应如果是闰年，此数组项值为1，反之为0。如此一来就可以实现闰年判断。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix编程学习笔记－文件和目录</title>
      <link href="2020/02/27/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
      <url>2020/02/27/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="函数stat"><a class="markdownIt-Anchor" href="#函数stat"></a> 函数<code>stat</code></h3><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> pathname, struct stat *<span class="hljs-keyword">restrict</span> buf)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *buf)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> pathname, struct stat *<span class="hljs-keyword">restrict</span> buf)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fstatat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> pathname, struct stat *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 这四个函数返回值：成功返回0;出错返回-1</span></code></pre><p>(1) 当给出 pathname 时：</p><ul><li>stat 函数将返回与此命名文件有关的信息结构。</li><li>fstat 函数获得已在描述符 fd 上打开文件的有关信息。</li><li>lstat 函数类似于 stat，但当命名文件是一个符号链接时，lstat 返回该符号链接的有关信息，而不是由该符号链接引用的文件信息。此外，当以降序遍历目录层次结构时，需要用到此函数。</li><li>fstatat 函数为一个相对于当前打开目录(由 fd 参数指向)的路径名返回文件统计信息。<ul><li><code>flag</code> 参数表示是否跟随一个符号链接。设置<code>AT_SYMLINK_NOFOLLOW</code>标志表示不会跟随符号链接，而是返回符号本身的信息。否则默认返回符号链接所指向的实际文件的信息。</li><li><code>fd</code> 参数值为<code>AT_FDCWD</code>,并且 pathname 参数是一个相对路径名，函数将会计算相对于当前目录的 pathname 参数;如果 pathname 是一个绝对路径，fd 参数就会被忽略。这两种情况，根据 flag 的取值，函数作用跟 stat 或 lstat 一样。</li></ul></li></ul><p>(2) buf 参数是一个指向<code>struct stat</code>结构的指针。结构的实际定义可能根据气体实现有所不同，但基本形式如下：</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><span class="hljs-keyword">dev_t</span>       st_dev;     <span class="hljs-comment">/* ID of device containing file -文件所在设备的ID*/</span>      <span class="hljs-keyword">ino_t</span>       st_ino;     <span class="hljs-comment">/* inode number -inode节点号*/</span>        <span class="hljs-keyword">mode_t</span>      st_mode;    <span class="hljs-comment">/* protection -保护模式?*/</span>        <span class="hljs-keyword">nlink_t</span>     st_nlink;   <span class="hljs-comment">/* number of hard links -链向此文件的连接数(硬连接)*/</span>        <span class="hljs-keyword">uid_t</span>       st_uid;     <span class="hljs-comment">/* user ID of owner -user id*/</span>        <span class="hljs-keyword">gid_t</span>       st_gid;     <span class="hljs-comment">/* group ID of owner - group id*/</span>        <span class="hljs-keyword">dev_t</span>       st_rdev;    <span class="hljs-comment">/* device ID (if special file) -设备号，针对设备文件*/</span>        <span class="hljs-keyword">off_t</span>       st_size;    <span class="hljs-comment">/* total size, in bytes -文件大小，字节为单位*/</span>        <span class="hljs-keyword">blksize_t</span>   st_blksize; <span class="hljs-comment">/* blocksize for filesystem I/O -系统块的大小*/</span>        <span class="hljs-keyword">blkcnt_t</span>    st_blocks;  <span class="hljs-comment">/* number of blocks allocated -文件所占块数*/</span>        <span class="hljs-keyword">time_t</span>      st_atime;   <span class="hljs-comment">/* time of last access -最近存取时间*/</span>        <span class="hljs-keyword">time_t</span>      st_mtime;   <span class="hljs-comment">/* time of last modification -最近修改时间*/</span>        <span class="hljs-keyword">time_t</span>      st_ctime;   <span class="hljs-comment">/* time of last status change - */</span>&#125;</code></pre><p>使用 stat 函数最多的地方可能就是<code>ls -l</code>命令，用其可以获得有关文件的所有信息。</p><h3 id="文件类型"><a class="markdownIt-Anchor" href="#文件类型"></a> 文件类型</h3><p>Unix 的文件类型主要包括下列几种：</p><ul><li><p><code>普通文件( regular file )</code>最常用的文件类型，包含了某种形式的数据，数据或是二进制数据，但对于 UNIX 内核来说并无区别。对普通文件内容的解释由处理该文件的应用程序进行。</p><blockquote><p>值得注意的是二进制可执行文件。为了执行程序，内核必须理解其格式。所有二进制可执行文件都遵循一种标准化的格式，通过这种格式内核能够确定程序文本和数据的加载位置。</p></blockquote></li><li><p><code>目录文件( directory file )</code>包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。进程必须通过系统函数才能更改目录。</p></li><li><p><code>块特殊文件( block special file )</code>提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行。</p><blockquote><p>FreeBSD 不再支持块特殊文件。对设置的所有访问需要通过字符特殊文件进行。</p></blockquote></li><li><p><code>字符特殊文件( character special file )</code>提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是志特殊文件。</p></li><li><p><code>FIFO</code>用于进程间通信，有时也称为<code>命名管道( named pipe )</code>。</p></li><li><p><code>套接字( socket )</code>用于进程间的网络通信。也可用于在一台宿主机上进程之间的非网络通信。</p></li><li><p><code>符号链接( symbolic link )</code>指向另一个文件。</p></li></ul><p>文件类型信息包含在 stat 结构的 st_mode 成员中，可以使用定义的宏确定文件类型，宏参数都是 stat 结构中的 st_mode 成员。</p><table><thead><tr><th>宏</th><th>文件类型</th></tr></thead><tbody><tr><td>S_ISREG()</td><td>普通文件</td></tr><tr><td>S_ISDIR()</td><td>目录文件</td></tr><tr><td>S_ISCHR()</td><td>字符特殊文件</td></tr><tr><td>S_ISBLK()</td><td>块特殊文件</td></tr><tr><td>S_ISFIFO()</td><td>管道或FIFO</td></tr><tr><td>S_ISLNK()</td><td>符号链接</td></tr><tr><td>S_ISSOCK()</td><td>套接字</td></tr></tbody></table><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"common/apue.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">buf</span>;</span>    <span class="hljs-keyword">int</span> r = stat(<span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_c.c"</span>, &amp;buf);    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">-1</span>) &#123;        <span class="hljs-keyword">if</span> (S_ISREG(buf.st_mode))            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"普通文件类型"</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"程序出错，编号：%d"</span>, errno);    &#125;&#125;</code></pre><p>POSIX.1 允许实现将进程间通信(IPC)对象(如消息队列和信号量等)说明为文件。可以通过下列宏确定 IPC 对象的类型，它们的参数是指向 stat 结构的指针，而并非 st_mode。</p><table><thead><tr><th>宏</th><th>对象的类型</th></tr></thead><tbody><tr><td>S_TYPEISMQ()</td><td>消息队列</td></tr><tr><td>S_TYPEISSEM()</td><td>信号量</td></tr><tr><td>S_TYPEISSHM()</td><td>共享存储对象</td></tr></tbody></table><h3 id="函数access和faccessat"><a class="markdownIt-Anchor" href="#函数access和faccessat"></a> 函数<code>access</code>和<code>faccessat</code></h3><p>这两个是按实际用户ID和实际组ID进行访问权限测试的函数。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> mode)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">faccessat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> mode, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 两个函数的返回值：成功返回0; 失败返回-1</span></code></pre><p><code>mode</code>参数可选值：</p><ul><li><code>F_OK</code>测试文件存在</li><li><code>R_OK</code>测试读权限</li><li><code>W_OK</code>测试写权限</li><li><code>X_OK</code>测试执行权限</li></ul><p><strong>faccessat 函数与 access 函数在下面两种情况下是相同的：</strong></p><ol><li>pathname 参数为绝对路径</li><li>fd 参数取值为 AT_FDCWD 而 pathname 参数为相对路径，否则 faccessat 计算相对于打开目录(fd 参数指向)的 pathname。</li></ol><p><code>flag</code>参数，设置为 AT_EACCESS，访问检查调用进程的有效用户 ID 和有效组 ID，而不是实际用户 ID 和实际组 ID。</p><h3 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h3><p>所有文件类型都有访问权限，st_mode 值也包含了对文件的访问权限位。每个文件有9个访问权限位，可将它们分类3类：</p><ul><li><code>S_IRUSR</code> 用户读</li><li><code>S_IWUSR</code> 用户写</li><li><code>S_IXUSR</code> 用户执行</li></ul><hr><ul><li><code>S_IRGRP</code> 组读</li><li><code>S_IWGRP</code> 组写</li><li><code>S_IXGRP</code> 组执行</li></ul><hr><ul><li><code>S_IROTH</code> 其他读</li><li><code>S_IWOTH</code> 其他写</li><li><code>S_IXOTH</code> 其他执行</li></ul><h4 id="函数umask"><a class="markdownIt-Anchor" href="#函数umask"></a> 函数<code>umask</code></h4><p>函数为进程设置文件模式屏蔽字，并返回之前的值。即在创建新文件或目录时屏蔽掉希望新文件或目录不应有的访问权限。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt; // 返回值：设置前的文件创建权限</span></span><span class="hljs-keyword">mode_t</span> umask(<span class="hljs-keyword">mode_t</span> cmask);</code></pre><p><code>cmask</code>参数由 9 个访问权限位常量(S_IRUSR、S_IWUSR等)中的若干个按位“或”(<code>|</code>)构成。<br>在进程创建一个新文件或目录时，就一定会使用文件模式创建屏蔽字。</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 0表示不设置任何屏蔽字，即使用默认屏蔽字</span>    umask(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (creat(<span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/tttttttt.d"</span>, <span class="hljs-number">0777</span>) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"创建d文件失败"</span>);    &#125;    <span class="hljs-comment">// 设置用户读、用户写屏蔽字</span>    umask(S_IRUSR | S_IWUSR);    <span class="hljs-keyword">if</span> (creat(<span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/tttttttt.r"</span>, <span class="hljs-number">0777</span>) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"创建r文件失败"</span>);    &#125;&#125;<span class="hljs-comment">// 在bash中查看文件权限</span>$ ll-rwxrwxrwx   <span class="hljs-number">1</span> windus  staff     <span class="hljs-number">0B</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span> <span class="hljs-number">13</span>:<span class="hljs-number">54</span> tttttttt.d---xrwxrwx   <span class="hljs-number">1</span> windus  staff     <span class="hljs-number">0B</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span> <span class="hljs-number">13</span>:<span class="hljs-number">54</span> tttttttt.r</code></pre><p>UNIX 所有 shell 都有内置命令<code>umask</code>设置默认屏蔽字，<strong><a href="/2017/09/13/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/#%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90-umask">更多关于 umask 命令<sup>1</sup></a></strong>。</p><h4 id="函数chmod"><a class="markdownIt-Anchor" href="#函数chmod"></a> 函数<code>chmod</code></h4><p>这3个函数可以更改现有文件访问权限。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchmod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchmodat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>chmod 函数在对定文件上进行操作。<br>fchmod 函数在对已打开文件进行操作。</p><p><strong>fchmodat 函数与 chmod 函数作用相同的两种情况：</strong></p><ol><li>pathname 参数为绝对路径。</li><li>fd 参数取值为 AT_FDCWD 而 pathname 参数为相对路径。</li></ol><p>否则，fchmodat 函数就是对于打开目录(fd 参数指向)的 pathname 进行操作。<br><code>flag</code>参数设置为 AT_SYMLINK_NOFOLLOW 时，fchmodat 并不会跟随符号链接。<br><code>mode</code>参数是除了文件的9个权限访问位常量外，还有下面6个常量的按位或组合：</p><ul><li><code>S_IRWXU</code> 用户(所有者)读、写和执行</li><li><code>S_IRWXG</code> 组读、写和执行</li><li><code>S_IRWXO</code> 其他读、写和执行</li><li><code>S_ISUID</code> 文件特殊权限 SUID 权限</li><li><code>S_ISGID</code> 文件特殊权限 SGID 权限</li><li><code>S_ISVTX</code> 文件特殊权限 SBIT 权限(粘着位)</li></ul><p><em><strong><a href="/2017/09/13/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/#%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90">更多关于文件特殊权限<sup>2</sup></a></strong></em></p><blockquote><p>为了改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或者该进程必须具有超级用户权限。</p></blockquote><h4 id="函数chown"><a class="markdownIt-Anchor" href="#函数chown"></a> 函数<code>chown</code></h4><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chown</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">uid_t</span> owner, <span class="hljs-keyword">gid_t</span> group)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">uid_t</span> owner, <span class="hljs-keyword">gid_t</span> group)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchownat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">uid_t</span> owner, <span class="hljs-keyword">gid_t</span> group, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lchown</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">uid_t</span> owner, <span class="hljs-keyword">gid_t</span> group)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>当操作的文件不是符号链接时，这4个函数作用类似。<br>当操作文件是符号链接时，lchown 和 fchownat(设置了 AT_SYMLINK_NOFOLLOW 标志)更改符号链接本身的所有者，而不是该符号链接所指向的文件所有者。<br>fchown 函数操作已打开(fd 参数指向)文件的所有者。既然它在一个已打开的文件上操作，就不能用于改变符号链接的所有者。</p><p><strong>fchownat、chown、lchown作用相同的两种情况：</strong></p><ol><li>pathname 参数为绝对路径。</li><li>fd 参数取值为 AT_FDCWD 而 pathname 参数为相对路径。</li></ol><p>如果 flag 参数清除了 AT_SYMLINK_NOFOLLOW 标志(即设置为 AT_SYMLINK_FOLLOW )，则 fchownat 与 chown 作用相同。<br>如果 fd 参数设置为打开目录的文件描述符，并且 pathname 参数是一个相对路径名，fchownat 函数将作用于打开的目录。</p><blockquote><p>基于 BSD 的系统规定只有超级用户才能更改一个文件的所有者，原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。System V 则允许任一用户更改他们所拥有的文件的所有者。<br>按照 POSIX.1 允许通过设置 _POSIX_CHOWN_RESTRICTED 的值在这两种形式的操作中选用一种。<br>对于 SOLARIS 10 HX 此功能是个配置选项，其默认值是施加限制。而 FreeBSD 8.0、Linux 3.2.0和Mac OS X 10.6.8则总对 chown 施加限制。</p></blockquote><p>若 _POSIX_CHOWN_RESTRICTED 对指定文件生效，则：</p><ol><li>只有超级用户进程能更改该文件的用户ID。</li><li>如果进程拥有此文件(其有效用户ID等于该文件的用户ID)，参数 ower 等于 -1 或文件的用户ID，并且参数 group 等于进程的有效组 ID 或进程的附属组 ID 之王，那么非超级用户进程可以一颗心该文件的组ID。</li></ol><blockquote><p>这意味着，当 _POSIX_CHOWN_RESTRICTED 有效时，不能更改其他用户文件的用户ID，可以一颗心你所拥有的文件的组 ID，但只能改到你所属的组。</p></blockquote><h3 id="文件长度与截断"><a class="markdownIt-Anchor" href="#文件长度与截断"></a> 文件长度与截断</h3><p>stat 结构成员 st_size 表示以字节为单位的文件长度，此字符只对普通文件、目录文件和符号链接有意义。</p><blockquote><p>FreeBSD、Mac OS X 10.6.8和 Solaris 10对管道也定义了文件长度，它表示可从该管道中读到的字节数。</p></blockquote><p>对于符号链接，文件长度是在文件名中的实际字节数，如下面例子，文件长度 10 就是路径名<code>private/tmp</code>的长度：</p><pre class="highlight"><code class="bash">$ ll /lrwxr-xr-x@  1 root  admin    11B 10 30 17:00 tmp -&gt; private/tmp</code></pre><p>大多数现代 UNIX 系统提供字段 st_blksize 和 st_blocks。其中，第一个是文件 I/O 块长度，第二个是所分配的实际块数。</p><p>为了截断文件可以调用函数<code>truncate</code>和<code>ftruncate</code>:</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">truncate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">off_t</span> length)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ftruncate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> length)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>这两个函数将一个现有文件长度截断为 lenth。如果该文件长度大于 length，则超过部分不能再访问;如果长度小于 length，文件长度将增加，其数据读作0(也就是可能在文件中创建了一个空洞)。</p><h3 id="函数link-unlink"><a class="markdownIt-Anchor" href="#函数link-unlink"></a> 函数<code>link</code>、<code>unlink</code></h3><p>创建一个指向现有文件的硬链接的方法是使用函数 link 或 linkat 函数：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *existingpath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newpath)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">linkat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> efd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *existingpath, <span class="hljs-keyword">int</span> nfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newpath, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>这两个函数创建一个新目录项 newpath，它引用现有文件 existingpath。如果 newpath 已经存在，则返回出错。函数只创建 newpath 中的最后一个分量，路径中的其他部分应当已经存在。</p><p>linkat 函数，现有文件是通过 efd 和existingpath 参数指定的，新的路径名是通过 nfd 和 newpath 参数指定。默认情况下，如果两个路径名中的任一个是相对路径，两个文件描述符中的任一个设置为 AT_FDCWD，相应的路径名就通过相对于当前目录进行计算。如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略。</p><p>当现有文件是符号链接时，flag 参数设置 AT_SYMLINK_FOLLOW 标志，则创建指向符号链接目标的链接;反之，则创建一个指向符号链接本身的链接。<br><strong><a href="/2017/09/29/Linux/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/#%E5%AE%9E%E6%97%B6%E8%BF%90%E8%A1%8C%E5%8C%BA-realtime-section">更多关于文件链接<sup>3</sup></a></strong></p><p>创建的链接可以通过 unlink 函数删除：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unlinkat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>如果 pathname 参数是相对路径名，fd 文件描述符参数代表的目录的路径名。如果 fd 参数设置 AT_FDCWD，相当于调用当前工作目录路径。如果 pathname 参数是绝对路径名，fd 参数被忽略。</p><p>如果 pathname 是符号链接，那么 unlink 删除该符号链接，而不是删除由该链接所引用的文件。给出符号链接名的情况下，没有一个函数能删除由该链接所引用的文件。</p><p>如果文件系统支持，超级用户可以调用 unlink 删除一个指定目录，但通常应当使用 rmdir 函数。</p><p>flag 参数设置为 AT_REMOVEDIR 标志时，unlinkat 函数功能类似于 rmdir 命令一样删除目录;反之则与 unlink 函数功能相同。</p><p>也可以用 remove 函数解除对一个文件或目录的链接。对于文件，remove 的功能与 unlink 相同。对于目录，remove 的功能与 rmdir 相同。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p>删除文件链接，必须对包含该目录项的目录具有写和执行权限。如果对该目录设置了粘着位(SBIT)，则对该目录必须具有写权限，并且具备下面三个条件之一：</p><ul><li>拥有该文件</li><li>拥有该目录</li><li>具有超级用户权限</li></ul><blockquote><p>删除文件内容的两个条件：(1)当链接计数为0时，文件内容可以被删除　(2)没有进程打开了该文件，其内容才能被删除。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"common/apue.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> fd;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">buf</span>;</span>    <span class="hljs-keyword">char</span> *pathName = <span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c"</span>;    <span class="hljs-keyword">char</span> *newPathName = <span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test_link.c"</span>;    <span class="hljs-comment">// 第一步 测试未打开之前文件链接数</span>    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第二步 打开已存在的文件 测试链接数</span>    fd = open(pathName, O_RDONLY);    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第三步 关闭文件 测试链接数</span>    close(fd);    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第四步 创建硬链接 测试链接数</span>    link(pathName, newPathName);    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"4) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第五步 删除硬链接 测试链接数</span>    unlink(newPathName);    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"5) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第六步 打开已存在的文件</span>    fd = open(pathName, O_RDONLY);    <span class="hljs-comment">// 第七步 删除文件 测试链接数 </span>    <span class="hljs-comment">// (此处我用 fstat 函数而非 stat，因为 unlilnk 已经删除文件名，所以不可以通过   文件名访问，</span>    <span class="hljs-comment">// 但是 fd 仍然是打开着的，文件内容还没有被真正删除，依旧可以使用 fd 获得文件信息。)</span>    unlink(pathName);    fstat(fd, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"7) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第八步 关闭文件 文件内容被删除</span>    close(fd);&#125;<span class="hljs-comment">// 返回结果</span>--------------------------------------------------------------------------<span class="hljs-number">1</span>) link=<span class="hljs-number">1</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">2</span>) link=<span class="hljs-number">1</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">3</span>) link=<span class="hljs-number">1</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">4</span>) link=<span class="hljs-number">2</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">5</span>) link=<span class="hljs-number">1</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">7</span>) link=<span class="hljs-number">0</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c</code></pre><blockquote><p>unlink 这种特性经常被程序用来确保即使是在程序崩溃时，它所创建的临时文件也不会遗留下来。进程用 open 或 creat 创建一个文件，然后立即调用 unlink，因为该文件仍旧是打开的，所以不会将其内容删除。只有当进程关闭该文件或终止时(内核关闭该进程所打开的全部文件)，该文件的内容才被删除。</p></blockquote><h3 id="函数rename和renameat"><a class="markdownIt-Anchor" href="#函数rename和renameat"></a> 函数<code>rename</code>和<code>renameat</code></h3><p>文件或目录可以用这两个函数进行重命名。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *oldname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newname)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">renameat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *oldname, <span class="hljs-keyword">int</span> newfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newname)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><blockquote><p>ISO C 对文件定义了 rename 函数(C 标准不处理目录)。POSIX.1 扩展此定义，使其包含了目录和符号链接。</p></blockquote><h3 id="符号链接"><a class="markdownIt-Anchor" href="#符号链接"></a> 符号链接</h3><p>符号链接是对一个文件的间接指针，它与硬链接有所不同，硬链接直接指向文件的 i 节点。引入符号链接的原因是为了避开硬链接的一些限制：</p><ul><li>硬链接通常要求链接和文件位于同一文件系统中。</li><li>只有超级用户才能创建指向目录的硬链接(在底层文件系统支持的情况下)。</li></ul><p>当使用以名字引用文件的函数时，应当了解该函数是否处理符号链接，即该函数是否跟随符号链接到达它所链接的文件。下图中说明了各函数是否处理符号链接，图中没有列出 mkdir、mkinfo、mknod 和 rmdir 等函数，其原因是当路径名是符号链接时，它们都出错返回。以文件描述符作为参数的一些函数(如 fstat、fchmod等)也未列出，其原因是，对符号链接的处理是由返回文件描述符的函数(通常是 open )进行的。chown 是否跟随符号链接取决于实现，在所有现代的系统中，chown 函数都跟随符号链接。</p><blockquote><p>符号链接由 4.2BSD 引入，chown 最初并不跟随符号链接，现在，所有平台都实现了 lchown，它可以改变符号链接自身的所有权。</p></blockquote><img src="/2020/02/27/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/hsdfhljdcl1800.png" alt="各函数对符号链接的处理" style="height:400px;"><span class="image-caption">各函数对符号链接的处理</span><p>同时用 O_CREAT 和 O_EXCL 两者调用 open 函数时，若路径名引用符号链接，open 将出错返回，errno 设置为 EEXIST。这种处理方式的意图是堵塞一个安全性漏洞，以防止具有特权的进程被诱骗写错误的文件。</p><p>使用符号链接可能在文件系统中引入循环。大多数查找路径名的函数在这种情况发生时都出错返回，errno 值为 ELOOP。</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 创建一个新目录</span>$ mkdir<span class="hljs-comment"># 创建一个0长度的文件</span>$ touch foo/a<span class="hljs-comment"># 创建一个符号链接</span>$ ls -s ../foo foo/testdir<span class="hljs-comment"># 查看目录结构</span>$ ls -l foo-rw-r----- 1 sar 0 Jan 22 00:16 alrwxrwxrwx 1 sar 6 Jan 22 00:16 testdir -&gt; ../foo// 使用 Solaris 的标准函数 ftw(3) 以降序遍历文件结构，打印每个路径名，则输出是：foofoo/afoo/testdirfoo/testdir/afoo/testdir/testdirfoo/testdir/testdir/afoo/testdir/testdir/testdirfoo/testdir/testdir/testdir/a(更多行，直到函数出错返回，此时 errno 值为 ELOOP)</code></pre><blockquote><p>注意，Linux的 ftw 和 nftw 函数记录了所有看到的目录并避免多次得利处理一个目录，因此这两个函数不显示这种程序运行行为。</p></blockquote><p>想要消除这种循环，可以用 lstat 代替 stat 以阻止它跟随符号链接; 也可以用 unlink 文件 foo/testdir，因为 unlink 也不跟随符号链接。<br>但是如果创建了一个构成这种循环的硬链接，那么就很难消除它。<strong>这就是为什么 link 函数不允许构造指向目录的硬链接的原因</strong>。</p><h4 id="创建符号链接"><a class="markdownIt-Anchor" href="#创建符号链接"></a> 创建符号链接</h4><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *actualpath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sympath)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">symlinkat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *actualpath, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sympath)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p>函数创建一个指向 actualpath 的新目录项 sympath。在创建之前，并不要求 actualpath 已经存在。并且，actualpath 和 sympath 并不需要位于同一文件系统中。</p><p>symlinkat 函数与 symlink 函数功能类似，但 sympath 参数根据打开的文件描述符引用的目录(fd 参数)指定的，如果 sympath 参数指定的是绝对路径或者 fd 参数设置了 AT_FDCWD 值，那么 symlinkat 就等同于 symlink 函数。</p><h4 id="读取符号链接"><a class="markdownIt-Anchor" href="#读取符号链接"></a> 读取符号链接</h4><p>因为 open 函数跟随符号链接，所以需要有一种方法打开该链接本身，并读该链接中的名字的函数：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-keyword">ssize_t</span> readlink(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">restrict</span> pathname, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-keyword">size_t</span> bufsize);<span class="hljs-keyword">ssize_t</span> readlinkat(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">restrict</span> pathname, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-keyword">size_t</span> bufsize);<span class="hljs-comment">// 返回值：若成功，返回读取的字节数;若出错返回-1</span></code></pre><h3 id="文件的时间"><a class="markdownIt-Anchor" href="#文件的时间"></a> 文件的时间</h3><p>SUS 2008年版为了提高 stat 结构中时间字段的精度，从原来的秒提高到秒加上纳秒。每个文件属性所保存的实际精度依赖于文件系统的实现。对于时间戳记录在秒级的文件系统来说，纳秒这个字段就会被填充为0。对于时间戳的记录精度高于秒级的文件系统来说，不足秒的值被转换成纳秒并记录在纳秒这个字段中。</p><p>每个文件维护3个时间字段：</p><table><thead><tr><th>字段</th><th>说明</th><th>例子</th><th>ls(1)选项</th></tr></thead><tbody><tr><td>st_atim</td><td>文件数据的最后访问时间</td><td>read</td><td>-u</td></tr><tr><td>st_mtim</td><td>文件数据的最后修改时间</td><td>write</td><td>默认</td></tr><tr><td>st_ctim</td><td>i 节点状态的最后更改时间</td><td>chmod、chown</td><td>-c</td></tr></tbody></table><blockquote><p>状态更改时间是该文件的 i 节点最后一次被修改的时间。包括一颗心文件的访问权限、更改用户ID、更改链接数等操作。因为 i 节点中的所有信息都是与文件的实际内容分开存放的，所以需要单独记录更改 i 节点中信息的时间。系统并不维护对一个 i 节点的最后一次访问时间，所以 access 和 stat 函数并不更改这3个时间中的任何一个。</p></blockquote><p><strong><a href="/2017/09/13/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/#%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4">更多关于文件时间<sup>4</sup></a></strong></p><h3 id="函数futimens-utimensat和utimes"><a class="markdownIt-Anchor" href="#函数futimens-utimensat和utimes"></a> 函数<code>futimens</code>、<code>utimensat</code>和<code>utimes</code></h3><p>修改文件的访问和修改时间可以使用这几个函数。其中 futimens 和 utimensat 函数可以指定纳秒级精度的时间戳。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">futimens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> struct timespec times[<span class="hljs-number">2</span>])</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">utimensat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> struct timespec times[<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p>这两个函数<code>times</code>数组参数的第一个元素包含访问时间，第二元素包含修改时间。这两个时间是日历时间，自特定时间(1970年1月1日 00:00:00)以来所经过的秒数。不足秒的部分用纳秒表示。<br><strong>时间戳可以按下列4种方式之王进行指定：</strong></p><ol><li>如果 times 参数是一个空指针，则访问时间和修改时间两者都设置为当前时间。</li><li>如果 times 参数指向两个 timespec 结构的数组，任数组元素的 tv_nsec 字段的值为 UTIME_NOW，相应的时间戳就设置为当前时间，忽略相应的 tv_sec 字段。</li><li>如果 times 参数指向两个 timespec 结构的数组，任一数组元素的 tv_nsec 字段值为 UTIME_OMIT，相应的时间戳保持不变，忽略相应的 tv_sec 字段。</li><li>如果 times 参数指向两个 timespec 结构的数组，且 tv_nsec 字段的值为既不是 UTIME_NOW 也不是 UTIME_OMIT，相应的时间戳设置为相应的 tv_sec 和 tv_nsec 字段的值。</li></ol><p><strong>执行这些函数所要求的优先权取决于 times 参数的值：</strong></p><ul><li>如果 times 是一个空指针，或者任一 tv_nsec 字段设为 UTIME_NOW，则进程的有效用户ID必须等于该文件的所有者ID;进程对该文件必须具有写权限，或者进程是一个超级用户进程。</li><li>如果 times 是非空指针，并且任一 tv_nsec 字段值既不是 UTIME_NOW 也不是 UTIME_OMIT，则进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个超级用户进程。对文件只具有写权限是不够的。</li><li>如果 times 是非空指针，并且两个 tv_nsec 字段的值都为 UTIME_OMIT，就不执行任何的权限检查。</li></ul><p><code>flag</code>参数设置 AT_SYMLINK_NOFOLLOW 标志，则符号链接本身的时间会被修改(如果路径名指向的是符号链接)。默认行为是跟随符号链接，并把文件的时间改成符号链接的时间。</p><p>上面两个函数都包含在 POSIX.1 中，第3个函数包含在 SUS 的 XSI 扩展选项中：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/time.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">utimes</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">const</span> struct timeval times[<span class="hljs-number">2</span>])</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p><code>times</code>参数包含两个时间戳(访问时间和修改时间)，元素的数组的指针，两个时间戳是用秒和微秒表示的。</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span><span class="hljs-keyword">time_t</span> tv_sec; <span class="hljs-comment">/* secons */</span><span class="hljs-keyword">long</span> tv_usec; <span class="hljs-comment">/* microseconds */</span>&#125;</code></pre><h3 id="函数mkdir-mkdirat和rmdir"><a class="markdownIt-Anchor" href="#函数mkdir-mkdirat和rmdir"></a> 函数<code>mkdir</code>、<code>mkdirat</code>和<code>rmdir</code></h3><p>用 mkdir 和 mkdirat 函数创建一个新的空目录。其中，<code>.</code>和<code>..</code>目录项是自动创建的。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mkdirat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;出错返回-1</span></code></pre><blockquote><p>早期 UNIX 版本并没有 mkdir 函数，进程调用 mknod 函数创建一个新目录，但是只有超级用户进程才能使用 mknod 函数。</p></blockquote><p>用 rmdir 函数可以删除一个空目录(空目录只包含<code>.</code>和<code>..</code>目录)。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rmdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><h3 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h3><p>早期系统每个目录项是16个字节，其中14个字节是文件名，2个字节是 i 节点编号。而对于4.2BSD，由于它允许更长的文件名，所以每个目录项的长度是可变的。因此，读目录的程序与系统相关，为了简化读目录 UNIX 包含了一套与目录有关的例程，它们是 POSIX.1 的一部分。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;dirent.h&gt;</span></span><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-function">DIR *<span class="hljs-title">fdopendir</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-comment">// 返回值：成功返回指针;失败返回 NULL</span><span class="hljs-function">struct dirent *<span class="hljs-title">readdir</span><span class="hljs-params">(DIR *dp)</span></span>;<span class="hljs-comment">// 返回值：成功返回指针;若在目录尾或出错返回 NULL</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewinddir</span><span class="hljs-params">(DIR *dp)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dp)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dp)</span></span>;<span class="hljs-comment">// 返回值：与 dp 关联的目录中的当前位置</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dp, <span class="hljs-keyword">long</span> loc)</span></span>;</code></pre><p>DIR 结构是一个内部结构，上述7个函数用这个内部结构保存当前正在被读的目录的有关信息。</p><p>由 opendir 和 fdopendir 返回的指向 DIR 结构的指针由另外5个函数使用。opendir 执行初始化操作，使第一个 readdir 返回目录中的第一个目录项。当 DIR 结构由 fdopendir 创建时，readdir 返回的第一项取决于传给 fdopendir 函数的文件描述符相关联的文件偏移量。</p><p>目录中各目录的顺序与实现有关，它们通常并不按字母顺序排序。</p><h3 id="函数chdir-fchdir和getcwd"><a class="markdownIt-Anchor" href="#函数chdir-fchdir和getcwd"></a> 函数<code>chdir</code>、<code>fchdir</code>和<code>getcwd</code></h3><p>每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。当用户登录到 UNIX 系统时，其当前工作目录通常是口令文件( /etc/passwd )中该用户登录项的第6个字段——用户的起始目录(home directory)。当前工作目录是进程的一个属性，起始目录则是登录名的一个属性。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchdir</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p>进程调用这两个函数可以更改当前工作目录。因为当前目录是进程的一个属性，所以它只影响调用 chdir 的进程本身，而不影响其他进程。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"apue.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">if</span> (chdir(<span class="hljs-string">"/tmp"</span>) &lt; <span class="hljs-number">0</span>)        err_sys(<span class="hljs-string">"chdir failed"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"chdir to /tmp succeeded\n"</span>);    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-comment">// 调用程序测试</span>$ pwd /usr/lib$ mycd chdir to /tmp succeeded $ pwd /usr/lib</code></pre><p>从上示例代码中执行程序后，shell 的当前工作目录并没有改变。因为每个程序运行在独立的进程中，shell 的当前工作目录并不会随着程序调用 chdir 而改变。</p><p>系统内核并不保存该目录的完整路径名，只为每个进程只保存指向该目录 v 节点的指针等目录本身的信息。可以通过 getcwd 函数获取：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> size)</span></span>;<span class="hljs-comment">// 返回值：成功返回 buf;失败返回 NULL</span></code></pre><p>该函数必须传递两个参数，一个是缓冲区地址 buf，该缓冲区必须有足够长度以容纳绝对路径名再加上一个终止 null 字节，否则返回出错;另一个是缓冲区长度 size(以字节为单位)。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Unix 编程学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix编程学习笔记－文件IO</title>
      <link href="2020/02/24/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6IO/"/>
      <url>2020/02/24/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6IO/</url>
      
        <content type="html"><![CDATA[<h3 id="文件io"><a class="markdownIt-Anchor" href="#文件io"></a> 文件IO</h3><p><code>不带缓冲的IO</code>，其中<code>不带缓冲</code>指的是每一个<code>read</code>、<code>write</code>都调用内核中的一个系统调用。不带缓冲的IO不是<code>ISO C</code>的组成部分，但是，它们是<code>POXSIX.1</code>和 <code>SUS</code>的组成部分。</p><h3 id="文件描述符"><a class="markdownIt-Anchor" href="#文件描述符"></a> 文件描述符</h3><p>文件描述符是一个非负整数，当打开一个现有文件或创建一个新文件时，内核向该进程返回一个文件描述符。当读写一个文件时，使用open或creat返回的文件描述符标识该文件，将其作为参数传送给read或write。所有打开的文件都通过文件描述符引用。</p><p>通常，UNIX 系统 shell 把文件描述符 0 与进程的标准输入关联，文件描述符 1 与标准输出关联，文件描述符 2 与标准错误关联。可以把它们替换成符号常量<code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>、<code>STDERR_FILENO</code>以提高可读性。这些常量定义在头文件<code>&lt;unistd.h&gt;</code>中。</p><h3 id="函数open和openat"><a class="markdownIt-Anchor" href="#函数open和openat"></a> 函数<code>open</code>和<code>openat</code></h3><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflag, ... <span class="hljs-comment">/* mode_t mode */</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">openat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflag, ... <span class="hljs-comment">/* mode_t mode */</span>)</span></span>;</code></pre><p><code>path</code>参数是要打开或创建文件的路径和文件名<br><code>oflag</code>参数用来说明此函数的多个选项(必须指定下列常量中一个且只能一个)</p><ul><li><code>O_RDONLY</code> 只读打开</li><li><code>O_WRONLY</code> 只写打开</li><li><code>O_RDWR</code> 读写打开</li><li><code>O_EXEC</code> 只执行打开</li><li><code>O_SEARCH</code> 只搜索打开(应用于目录)<br>用于在目录打开时验证它的搜索权限。对目录的文件描述符的后续操作就不需要再次检查对该目录的搜索权限。此常量支持系统较少。<br><strong>其他可选常量</strong></li><li><code>O_APPEND</code> 每次写时都追加到文件的尾端。</li><li><code>O_CLOEXEC</code> 把 FD_CLOEXEC 常量设置为文件描述符标志。</li><li><code>O_CREAT</code> 若此文件不存在则创建它。使用此选项时，oppen 和 openat 函数需同时说明最后一个参数 mode，用mode指定该新文件的访问权限。</li><li><code>O_DIRECTORY</code> 如果 path 引用的不是目录，则出错。</li><li><code>O_EXCL</code> 如果同时指定了 O_CREAT，而文件已经存，则出错。用此可以测试一个文件是否存在，如果不存在，则创建此文件，这使测试和创建成为一个原子操作。</li><li><code>O_NOCTTY</code> 如 path 引用的是终端设备，则不将该设备分配为此进程的控制终端。</li><li><code>O_NOFOLLOW</code> 如果 path 引用的是一个符号链接，则出错。</li><li><code>O_NONBLOCK</code> 如果 path 引用的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的 I/O 操作设置非阻塞方式。</li><li><code>O_SYNC</code> 使每次 write 等待物理 I/O 操作完成，包括由该 write 操作引起的文件属性更新所需的 I/O_TRUNC，于是也就不再需要单独的creat函数。</li><li><code>O_TRUNC</code> 如果此文件存在，而且为只写或读-写成功打开，则将其长度截断0。</li><li><code>O_TTY_INIT</code> 如果打开一个还未打开的终端设备，设置非标准 termios 参数值，使其符合 Single UNIX Specification。</li><li><code>O_DSYNC</code> 使每次 write 要等待物理 I/O 操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需要等待文件属性被更新。</li><li><code>O_RSYNC</code> 使第一个以文件描述符作为参数进行的 read 操作等待，直至所有对文件同一部分挂起的写操作完成。</li></ul><p><code>fd</code>参数把两个函数区分开，共有3种可能性：<br>(1) path 参数指定的是绝对路径名，在这种情况下，fd参数被忽略，openat 函数就相当于open 函数。<br>(2) path 参数指定的是相对路径名，fd参数指出了相对路径在文件系统中的开始地址。fd参数是通过打开相对路径名所在的目录来获取。<br>(3) path 参数指定了相对路径名，fd参数具有特殊值<code>AT_FDCWD</code>。在这种情况下路径名在当前工作目录中获取，openat 函数在操作上与open 函数类似。</p><hr><p>openat 函数是POSIX.1最新版本中新增的一类函数之一，希望解决两个问题：<br>(1) 让纯种可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。<br>(2) 可以避免<code>time-of-check-to-time-of-use(TOCTTOU)</code>错误。</p><hr><blockquote><p><code>TOCTTOU</code>错误是：如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间文件可能改变了，这样也就造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。</p></blockquote><ul><li><p><strong>文件名和路径截断</strong></p><p>如果<code>NAME_MAX</code>是14，而试图创建一个文件名包含15个字符的新文件，早期的<code>System V</code>版本允许这种使用方法，但问题将文件名截断为14个字符，而且不给出任何信息，而<code>BSD</code>类的系统则返回出错状态，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。无声无息的截断文件名会引起无法确定该文件的原始名以及无法判断该文件名是否被截断过等问题。</p><p>在<code>POSIX.1</code>中，常量<code>_POSIX_NO_TRUNC</code>决定是要截断过长的文件名或路径名，还是返回一个出错。不同文件系统的类型，此值可以变化。可以用<code>fpathconf</code>或<code>pathconf</code>来查询目录具体支持何种行为。</p><p>若<code>_POSIX_NO_TRUNC</code>有效，则在整个路径名超过<code>PATH_MAX</code>或路径名中的任一文件名超过<code>NAME_MAX</code>时，出错返回，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。</p><blockquote><p>大多数的现代文件系统支持文件名的最大长度可以为255.因为文件名通常比这个限制要短，因此对大多数应用程序来说这个限制还未出现什么问题。</p></blockquote></li></ul><h3 id="函数creat"><a class="markdownIt-Anchor" href="#函数creat"></a> 函数<code>creat</code></h3><p>创建新文件可以调用<code>creat</code>函数：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-comment">// 返回值：若成功，返回为只写打开的文件描述符;若出错，返回-1</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">mode_t</span> mode)</span></span>; </code></pre><p>此函数等效于：</p><pre class="highlight"><code class="c">open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</code></pre><blockquote><p>在早期的 UNIX 系统版本中，open 的第二个参数只能是0、1或2。无法打开一个尚未存在的文件，因此需要另一个系统调用creat以创建新文件.现在，open 函数提供了选项 O_CREAT 和 O_TRUNC，于是也就不再需要单独的creat函数。<br>creat 的一个不足之处是它以只写方式打开所创建的文件，在提供 open 的新版本之前，如果要创建一个临时文件，并要先写该文件，然后又读该文件，则必须先调用creat、close, 然后再调用open。现在则可如下直接调用open实现。</p></blockquote><pre class="highlight"><code class="c">open(path, O_RDWR | O_CREAT | O_TRUNC, mode);</code></pre><h3 id="函数close"><a class="markdownIt-Anchor" href="#函数close"></a> 函数<code>close</code></h3><p>close函数可以关闭一个打开的文件：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;</code></pre><p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。当一个进程终止时，内核自动关闭它所有的打开文件，而不用显式地用 close 关闭打开文件。</p><h3 id="函数lseek"><a class="markdownIt-Anchor" href="#函数lseek"></a> 函数<code>lseek</code></h3><p>每个打开文件都有一个与其相关联的<code>当前文件偏移量</code>，通常是一个非负整数。系统默认情况，当打开一个文件时，除非指定<code>O_APPEND</code>选项，否则该偏移量被设置为<code>0</code>。<br>调用lseek函数可以显式地设置打开文件的偏移量：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：成功返回新的文件偏移量;失败返回-1</span><span class="hljs-keyword">off_t</span> lseek(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset, <span class="hljs-keyword">int</span> whence);</code></pre><p><code>offset</code> 参数的解释与参数<code>whence</code>的值有关：</p><ul><li>若 whence 是<code>SEEK_SET</code>，则将该文件的偏移量设置为距文件开始处 offset 个字节。</li><li>若 whence 是<code>SEEK_CUR</code>，则将该文件的偏移量设置为其当前值加 offset，offset 可为正或负。</li><li>若 whence 是<code>SEEK_END</code>，则将该文件的偏移量设置为文件长度加 offset，offset 可正可负。</li></ul><blockquote><p>对于普通文件，其偏移量必须是非负值，但某些设备允许负的偏移量。如果文件描述符指向的是一个管道、FIFO或网络套接字，则 lseek 返回-1，并将 errno 设置为 ESPIPE。</p></blockquote><p>因为偏移量可能是负值，所以在比较 lseek 的返回值时，不要比较它是否小于0，而要比较它是否等于-1。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"common/apue.h"</span></span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[]) &#123;    <span class="hljs-keyword">if</span> (lseek(STDIN_FILENO, <span class="hljs-number">0</span>, SEEK_CUR) == <span class="hljs-number">-1</span>) <span class="hljs-comment">// 与-1比较</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"cannot seek\n"</span>);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"seek OK\n"</span>);    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre><pre class="highlight"><code class="bash">$ ./test.o &lt; /etc/passwd // 普通文件seek OK$ cat &lt; /etc/passwd | ./test.o // 管道返回-1cannot seek$ ./test.o &lt; /var/spool/cron/FIFO // FIFO返回-1cannot seek</code></pre><p>lseek 仅将当前的文件偏移量记录在内核中，它并不引起任何 I/O 操作，该偏移量用于下一个读或写操作。<br>文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，文件中没有被写过的字节都被读为0。文件中的空洞并不占用磁盘存储区。</p><h3 id="函数read"><a class="markdownIt-Anchor" href="#函数read"></a> 函数<code>read</code></h3><p>调用 read 函数可以从打开文件中读取数据。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：读到的字节数，若已到文件尾，返回0;若出错返回-1</span><span class="hljs-keyword">ssize_t</span> read(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbytes);</code></pre><h3 id="函数write"><a class="markdownIt-Anchor" href="#函数write"></a> 函数<code>write</code></h3><p>调用 write 函数向打开文件写数据。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：若成功，返回已写的字节数;若出错，返回-1</span><span class="hljs-keyword">ssize_t</span> write(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbytes);</code></pre><h3 id="原子操作"><a class="markdownIt-Anchor" href="#原子操作"></a> 原子操作</h3><p><code>场景:</code>假定有两个独立的进程A和B都对同一文件进行追加写操作。每个进程都已打开该文件，但未使用<code>O_APPEND</code>标志。此时，每个进程都有它自己的文件表项，但是共享一个 v 节点表项如下图：</p><img src="/2020/02/24/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6IO/fileio38.png" style="height:400px"><p>当进程 A 调用了 lseek 函数将该文件当前进程领衔量设置为 1500 字节(当前文件尾端处)。然后内核切换到进程 B 执行 lseek 函数，也将其对该文件的当前偏移量设置为 1500 字节(当前文件尾端处)。然后 B 调用 write 函数，将 B 的该文件当前文件偏移量增加至 1600。因为该文件的长度已经增加了，所以内核将 v 节点中的的当前文件长度更新为 1600。然后，内核切换到里程 A 调用 write 函数，就从其当前文件偏移量(1500)处开始将数据写入到文件。此时覆盖了进程 B 写入到该文件中的数据。</p><hr><p>上面场景中问题出在逻辑操作“先定位到文件尾端，然后写”，它使用了两个分开的函数调用。可以通过使用两个操作对其他进程而言成为一个原子操作的方法解决问题。<br>UNIX 系统为这样的操作提供了一种原子操作方法，即在打开文件时设置<code>O_APPEND</code>标志。这样使得内核在每次写操作之前，都将进程的当前偏移量设置到该文件的尾端处，于是在每次写之前就不再需要调用 lseek 函数。</p><h4 id="函数pread和pwrite"><a class="markdownIt-Anchor" href="#函数pread和pwrite"></a> 函数<code>pread</code>和<code>pwrite</code></h4><p>这两个函数是<code>SUS</code>扩展允许原子性定位并执行 I/O 的扩展函数。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：读到的字节数，若已到文件尾，返回0;若出错，返回-1</span><span class="hljs-keyword">ssize_t</span> pread(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbytes, <span class="hljs-keyword">off_t</span> offset);<span class="hljs-comment">// 返回值：若成功，返回已写的字节数;若出错，返回-1</span><span class="hljs-keyword">ssize_t</span>　pwrite(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbytes,<span class="hljs-keyword">off_t</span> offset);</code></pre><p>调用 pread 相当于调用 lseek 后调用 read，但是 pread 又与这种顺序调用有下列重要区别：</p><ul><li>调用 pread 时，无法中断其定位和读操作。</li><li>不更新当前文件偏移量</li></ul><p>调用 pwrite 也是类似的区别。</p><h3 id="函数dup和dup2"><a class="markdownIt-Anchor" href="#函数dup和dup2"></a> 函数<code>dup</code>和<code>dup2</code></h3><p>两个函数都可用来复制一个现有的文件描述符。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> fd2)</span></span>;<span class="hljs-comment">// 两函数的返回值：若成功，返回新的文件描述符;若出错，返回-1</span></code></pre><p>dup 函数返回的新文件描述符一定是当前可用文件描述符中的最小数值。<br>dup2 函数参数 fd 表示已经存在的打开的文件描述符，fd2 表示指定新的文件描述符，如果 fd2 等于 fd，直接返回;如果 fd2 存在并且打开，则先关闭(close)后重新打开;如果 fd2 不存在或者没有打开则打开 fd2，并且指向 fd 所指向的文件。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"common/apue.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[]) &#123;    <span class="hljs-keyword">int</span> fd, refd;    <span class="hljs-keyword">char</span> *buf = <span class="hljs-string">"dup2 stdout!\n"</span>;    fd = open(<span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0644</span>);    <span class="hljs-keyword">if</span> (fd != <span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">// 重定向标准输出到目标文件</span>        refd = dup2(fd, fileno(<span class="hljs-built_in">stdout</span>));        <span class="hljs-keyword">if</span> (refd != <span class="hljs-number">-1</span>) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"refd值：%d"</span>, refd);            write(refd, buf, <span class="hljs-built_in">strlen</span>(buf));            close(fd);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"errno=%d\n"</span>, errno);    &#125;    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre><p>查看 unix_test.txt 文件内容如下：</p><pre class="highlight"><code class="bash">$ cat unix_test.txtdup2 stdoutrefd值：1    <span class="hljs-comment"># 从printf打印的信息也被写入进来</span></code></pre><p>从结果可以看出，由于标准输出文件描述符被复制为目标文件描述符，把标准输出重定向到目标文件。所以，原本应该到标准输出(stdout)的信息，也写入到了文件中。</p><h3 id="函数sync-fsync和fdatasync"><a class="markdownIt-Anchor" href="#函数sync-fsync和fdatasync"></a> 函数<code>sync</code>、<code>fsync</code>和<code>fdatasync</code></h3><p>传统的 UNIX 系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘 I/O 都通过缓冲区进行。当向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式被称为<strong>延迟写(delayed write)</strong>。当内核需要征用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。<br>为保证磁盘上实际文件系统与缓冲区中内容的一致性，UNIX 系统提供了<code>sync</code>、<code>fsync</code>和<code>fdatasync</code>三个函数。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fdatasync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;出错返回-1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><p>sync 只是将所有修改过的块缓冲区排入写队列，然后就返回，并不等待实际写磁盘操作结束。通常，称为 update 的系统守护进程周期性地调用(一般每隔30秒) sync 函数。这就保证了定期冲洗(flush)内核的块缓冲区。命令 sync<sup>(1)</sup>也调用 sync 函数。</p><p>fsync 函数只对由文件描述符 fd 指定的一个文件起作用，并且等待写磁盘操作结束才返回。fsync 可用于数据库这样需要确保修改过的块立即写到磁盘的应用程序。</p><p>fdatasync 函数类似于 fsync，但它只影响文件的数据部分。而 fsync 除数据外，还会同步更新文件的属性。</p><h3 id="函数fcntl"><a class="markdownIt-Anchor" href="#函数fcntl"></a> 函数<code>fcntl</code></h3><p>此函数可以修改已经打开文件的属性。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-comment">// 返回值：成功，则依赖于cmd;出错返回-1</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> cmd, ... <span class="hljs-comment">/* int arg */</span>)</span></span>;</code></pre><p><code>cmd</code>参数选项：<br>(1) <strong>复制一个已有的描述符</strong></p><ul><li><code>F_DUPFD</code> 复制文件描述符 fd。新文件打桩符作为函数值返回。它是尚未打开的各描述符中大于或等于第3个参数值(取为整型值)中各值的最小值。新描述第二符与 fd 共享同一文件表项。但是，有它自己的在套文件描述符标志，其 FD_CLOEXEC 文件描述符标志被清除(表示该描述符在 exec 时仍保持有效)。</li><li><code>F_DUPFD_CLOEXEC</code> 复制文件描述符，设置与新描述符关联的 FD_CLOEXEC 文件描述符标志的值，返回新文件描述符。</li></ul><p>(2) <strong>获取 / 设置文件描述符标志</strong></p><ul><li><p><code>F_GETFD</code> 对应于 fd 的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志 FD_CLOEXEC。</p></li><li><p><code>F_SETFD</code> 对 fd 设置文件描述符标志。新标志值按第3个参数(取为整型值)设置。</p><blockquote><p>很多现有与文件描述符标志有关的程序并不使用常量 FD_CLOEXEC，而是将此标志设置为0(系统默认，在 exec 时不关闭)或1(在 exec 时关闭)。</p></blockquote></li></ul><p>(3) <strong>获取 / 设置文件状态标志</strong></p><ul><li><code>F_GETFL</code> 对应于 fd 的文件状态标志作为函数值返回。即 open / openat 函数 oflag 参数中的常量所对应的状态。</li><li><code>F_SETFL</code> 将文件状态标志设置为第3个参数的值(取为整型值)。可以更改的标志有：<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_SYNC</code>、<code>O_DSYNC</code>、<code>O_RSYNC</code>、<code>O_FSYNC</code>和<code>O_ASYNC</code>。</li></ul><p>(4) <strong>获取 / 设置异步I/O所有权</strong></p><ul><li><code>F_GETOWN</code> 获取当前接收 SIGIO 和 SIGURG 信号的进程 ID 或进程组 ID。</li><li><code>F_SETOWN</code> 设置接收 SIGIO 和 SIGURG 信号的进程 ID 或进程组 ID。正的 arg 指定一个进程 ID，负的 arg 表示等于 arg 绝对值的一个进程组 ID。</li></ul><p>(5) <strong>获取 / 设置记录锁</strong></p><ul><li><code>F_GETLK</code></li><li><code>F_SETLK</code></li><li><code>F_SETLKW</code></li></ul><h3 id="函数ioctl"><a class="markdownIt-Anchor" href="#函数ioctl"></a> 函数<code>ioctl</code></h3><h3 id="devfd"><a class="markdownIt-Anchor" href="#devfd"></a> <code>/dev/fd</code></h3><p>较新的系统都提供名为 /dev/fd 的目录，其目录项是名为0、1、2的文件。打开文件 /dev/fd/n 等效于复制描述符 n(假定描述符 n 是打开的)。</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 大多数系统忽略它所指定的mode，另外一些系统则要求 mode 必须是所引用的文件初始打开时所使用的打开模式的一个子集</span>fd = open(<span class="hljs-string">"/dev/fd/0"</span>, mode);<span class="hljs-comment">// 等效于</span>fd = dup(<span class="hljs-number">0</span>);</code></pre><p>由上可知描述符 0 和 fd 共享同一文件表项。若描述符 0 先前被打开为只读，那么也只能对 fd 进行读操作，即使设置其他模式，仍然无法改变。</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 0 描述符为只读，所以对于 O_RDWR 模式的 fd 也不能进行写操作</span>fd = open(<span class="hljs-string">"/dev/fd/0"</span>, O_RDWR);</code></pre><blockquote><p>Linux实现中的 /dev/fd 是个例外。它把文件描述符映射成指向底层物理文件的符号链接。如打开 /dev/fd/0 时，事实上正在打开与标准输入关联的文件，因此返回的新文件描述符的模式与 /dev/fd 文件描述符的模式其实并不相关。</p></blockquote><p>可以使用 /dev/fd 作为路径名参数调用 creat，这与调用 O_CREAT 作为第2个参数作用相同。</p><blockquote><p>在 Linux 上必须非常小心，因为 Linux 实现使用指向实际文件的符号链接，在 /dev/fd 文件上使用 creat 会导致底层文件被截断。</p></blockquote><p>像 mac 等一些系统提供路径名 /dev/stdin、/dev/stdout 和 /dev/stderr，这些等效于 /dev/fd/0、/dev/fd/1、/dev/fd/2。</p><p>/dev/fd 文件主要由 shell 使用，它允许使用路径名作为调用参数，如 cat 命令：</p><pre class="highlight"><code class="bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'abc'</span> | cat -abc<span class="hljs-comment"># 等效于</span>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'abc'</span> | cat /dev/fd/0abc</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Unix 编程学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="2019/10/15/c/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2019/10/15/c/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><ul><li>char 字符型，点一个字节。</li><li>int 整型，通常代表机器中整数的自然长度。</li><li>short int 短整型，通常为16位(int可以省略)。</li><li>long int 长整型，通常为32位(int可以省略)。</li><li>float 单精度浮点型</li><li>double 双精度浮点型</li><li>long double 高精度的浮点数</li></ul><p><code>signed</code>和<code>unsigned</code>用于限定char类型和任何整型，<code>unsigned</code>类型的数值总是正值或0。</p><h2 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h2><p>语法：<code>#define 常量名 常量值</code></p><ul><li><strong>整数常量</strong><br>包含<code>int</code>和<code>long</code>类型常量。<code>long</code>类型以<code>l</code>或<code>L</code>结尾。<br>当一个整数无法用<code>int</code>表示时，也被当作<code>long</code>类型处理。<br>无符号常量以<code>u</code>或<code>U</code>结尾，无符号长整型使用<code>ul</code>或<code>UL</code>结尾。<br>前缀<code>0</code>表示八进制形式，<code>0x</code>表示十六进制形式。</li><li><strong>浮点数常量</strong><br>没有后缀的常量为<code>double</code>类型。<br>后缀加<code>f</code>或<code>F</code>表示<code>float</code>类型。<br>后缀加<code>l</code>或<code>L</code>表示<code>long double</code>类型。</li><li><strong>字符常量</strong><br>一个字符常量是一个整数，如<code>'0'</code>值为48，它与数值0无关。<br>转义字符通常只表示一个字符，如<code>'\013'</code>。<br>字符常量<code>'\0'</code>表示值为0的字符，即空字符(null)。</li><li><strong>字符串常量</strong><br>与字符常量的区别是字符串常量用<code>&quot; &quot;</code>双引号括起来。其实就是字符数组，内部使用<code>空字符('\0')</code>作为结尾，因此，字符串常量占据的存储单元比双引号内的字符数大1。</li><li><strong>枚举常量</strong><br>语法：<code>enum 枚举名 &#123;枚举列表&#125;</code><br>枚举常量是另外一种类型常量，是一个常量整型值的列表，如：<pre class="highlight"><code class="C"><span class="hljs-keyword">enum</span> boolean &#123;NO, YES&#125;;</code></pre>未显示声明的枚举，第一个枚举名的值为0，第二值为1，依此类推。<br>如果指定部分枚举值，未指定枚举值将向后递增。<pre class="highlight"><code class="c"><span class="hljs-keyword">enum</span> colors &#123;WHITE=<span class="hljs-number">0</span>,BLACK,RED,YELLOW&#125;BLACK--&gt;<span class="hljs-number">1</span>RED--&gt;<span class="hljs-number">2</span>YELLOW--&gt;<span class="hljs-number">3</span></code></pre></li></ul><p>常量表达式是仅仅包含常量的表达式。这种表达式只在编译时求值，而不在运行时求值。</p><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><p>变量必须先声明再使用，一个变量声明只能指定一种类型，后面可以有一个或多个该类型变量。如：int lower,upper…;<br>任何</p><ul><li><p><strong>外部变量</strong><br>定义在函数之外的变量叫做外部变量。由于定义在函数之外，因此可以在所有函数中使用。由于C语言不允许在一个函数中定义其它函数，因此函数本身是“外部的”。变量都可以使用<code>const</code>限定符限定为不可被修改变量。</p><blockquote><p>如果要在外部变量定义之前使用变量，或者外部变量的定义与变量的使用不在同一个源文件中，必须在相应变量声明中强制使用关键字<code>extern</code>。外部变量的定义中数组必须指定长度，但<code>extern</code>声明不一定要指定数组长度。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 10;</span><span class="hljs-keyword">int</span> a;<span class="hljs-keyword">double</span> b[MAXSIZE]; </code></pre><pre class="highlight"><code class="c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a; <span class="hljs-comment">//使用a.c文件中的变量a</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> b[]; <span class="hljs-comment">//使用a.c文件中的b省略了数组大小</span></code></pre></li><li><p><strong>自动变量</strong><br>定义在函数内的变量叫做“局部变量”，也叫“自动变量”。由于定义在函数之内，因此只可以函数内使用，多次调用函数不保留前次调用时的赋值。</p></li><li><p><strong>静态变量</strong><br>用<code>static</code>修饰的变量，叫做静态变量。静态变量的存储方式与全局变量相同，都是静态存储方式。全局变量的作用域是整个源程序，即源程序源的所有文件中有效。静态变量作用域则是只在当前变量所在源文件中可以使用，其次静态变量的值在函数调用后一直保持不会消失。即使在函数中声明的，每次调用函数，其值都会保存上一次调用后值。</p></li><li><p><strong>寄存器变量</strong><br>使用<code>register</code>关键字声明的变量，叫做寄存器变量。<code>register</code>变量放在机器的寄存器中，这样可以使程序更小，执行速度更快。<code>register</code>声明只适用于自动变量或函数的形式参数形式：</p><pre class="highlight"><code class="c">test(<span class="hljs-keyword">register</span> variA,<span class="hljs-keyword">register</span> variB)&#123;<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> variC;...&#125;</code></pre><blockquote><p>实际上，底层硬件环境对寄存器变量的使用会有一些限制。每个函数中只有很少的变量可以保存在寄存器中，且只允许某些变量类型的变量。编译器可以忽略过量的或不支持的寄存器变量声明，因此过量的寄存器变量声明并没有什么害处。但是注意，无论寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的。不同的机器，对寄存器变量的限制不同。</p></blockquote></li></ul><h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2><ul><li><p><strong>自述运算符</strong><br><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code><br><em><strong><code>c/c++</code>和<code>java</code>语言中取模运算(%)就是取余运算,而<a href="/2018/08/09/python/Python3%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(v3.7)/#%E6%95%B4%E6%95%B0%E3%80%81%E6%B5%AE%E7%82%B9">python</a>则有些不同</strong></em></p></li><li><p><strong>关系运算符</strong><br><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code></p></li><li><p><strong>逻辑运算符</strong><br><code>||</code>、<code>&amp;&amp;</code>、<code>!</code></p></li><li><p><strong>按位运算符</strong><br>按位运算就是将数值转换为二进制位，然后进行运算得到最终值：<br><code>&amp;</code> 按位与(AND)</p><blockquote><p>运算规则是两个为真才为真 <code>1&amp;1=1, 1&amp;0=0, 0&amp;1=0, 0&amp;0=0</code>。如 <code>3</code> 二进制位是 <code>0000 0011</code>，<code>5</code> 的二进制位是 <code>0000 0101</code>，由按位与规则可得，<code>001 &amp; 101</code>等于<code>0000 0001</code>，最终值为<code>1</code>。</p></blockquote><p><strong>求模运算时当被除数为 2 的 n 方时，可以用按位与运算替换更高效，公式为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><mi>a</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\%2^n=a\&amp;(2^n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>(不分前后也可以写成，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">(2^n-1) \&amp; a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mord mathdefault">a</span></span></span></span>) 即，</strong></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>14</mn><mi mathvariant="normal">%</mi><mn>8</mn><mo>=</mo><mn>14</mn><mi mathvariant="normal">%</mi><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>14</mn><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mn>3</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">14\%8=14\%2^3=14\&amp;(2^3-1)=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">%</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9196679999999999em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">%</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span></span></p><p><code>|</code> 按位或(OR)</p><blockquote><p>运算规则是一个为真则为真<code>1|0=1, 1|1=1, 0|0=0, 0|1=1</code>。如<code>6</code>二进制位是<code>0000 0110</code>，<code>2</code> 的二进制位是<code>0000 0010</code>，由按位或规则可得，<code>110 | 010</code>等于<code>110</code>，最终值为<code>6</code>。</p></blockquote><p><code>^</code> 按位异或(XOR)</p><blockquote><p>运算规则是如果两个值不相同，则为真，相同则为假<code>1^0=1, 1^1=0, 0^1=1, 0^0=0</code>。如<code>5</code>二进制位是<code>0000 0101</code>，<code>9</code> 的二进制位是<code>0000 1001</code>，由按位异或规则可得，<code>0110 ^ 1001</code> 等于<code>1100</code>，最终值为<code>12</code></p></blockquote><p><code>&lt;&lt;</code>左位移</p><blockquote><p>运算规则是将左侧数值的二进制位向左移动右侧数值位。移动后右边补<code>0</code>，正数左边第一位补 <code>0</code>，负数补<code>1</code>，结果相当于乘以 2 的 n 次方。如：<code>5&lt;&lt;2</code>，就是<code>5</code>的二进制位向左移<code>2</code>位，即<code>0000 0101</code> 把<code>101</code>向左移两位得到<code>0001 0100</code>，最终值为<code>5</code>乘以 2 得 2 次方，等于<code>20</code>。</p></blockquote><p><code>&gt;&gt;</code>右位移</p><blockquote><p>运算规则是将左侧数值的二进制位向右移动右侧数值位。移动后正数第一位补<code>0</code>，负数补<code>1</code>，结果相当于除以 2 的 n 次方。如：<code>5&gt;&gt;2</code>，就是<code>5</code> 的进制位向右移动<code>2</code>位，即<code>0000 0101</code>把<code>101</code>右移两位后得到<code>0000 0001</code>，最终值为<code>5</code> 除以 2 得 2 次方，等于<code>1</code>。</p></blockquote><p><code>~</code>按位求反(一元运算符)</p><blockquote><p>运算规则是取位数值相反值<code>~0=1, ~1=0</code>。 如<code>5</code> 二进制位是<code>0000 0101</code>，取反后为<code>1111 1010</code>，最终值为<code>-6</code>。</p></blockquote></li><li><p><strong>自增运算符</strong><br><code>++</code> 可以作为前缀运算符，表示先作自增，后赋值;也可以作为后缀运算符，表示先赋值，再作自增。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> x, n;n = <span class="hljs-number">1</span>;x = ++n; <span class="hljs-comment">//x值为2,n为2</span>x = n++;　<span class="hljs-comment">//x值为2,n为3</span></code></pre></li><li><p><strong>自减运算符</strong><br><code>--</code> 用法同自增运算符</p></li><li><p><strong>三元运算符</strong><br><code>表达式 ? 表达式 : 表达式</code></p></li></ul><h2 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h2><ul><li><p><strong>if…else 语句</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">if</span> (表达式)语句<span class="hljs-keyword">else</span>语句</code></pre></li><li><p><strong>switch 语句</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">switch</span> (表达式) &#123;<span class="hljs-keyword">case</span> 常量表达式:语句  <span class="hljs-keyword">case</span> 常量表达式:语句  <span class="hljs-keyword">default</span>:语句 &#125;</code></pre><blockquote><p>注意，case后必须为整数值常量或常量表达式。</p></blockquote></li><li><p><strong>while 循环</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">while</span>(表达式)语句</code></pre><p>如果希望while循环体至少被执行一次可以使用<code>do...while</code>循环：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">do</span> 语句<span class="hljs-keyword">while</span> (表达式);</code></pre></li><li><p><strong>for 循环</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">for</span>(表达式<span class="hljs-number">1</span>;表达式<span class="hljs-number">2</span>;表达式<span class="hljs-number">3</span>)语句</code></pre></li><li><p><strong>break / continue 语句</strong><br>用于继续或结束循环语句。</p></li><li><p><strong>goto 语句</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">for</span> ( ... )<span class="hljs-keyword">for</span> ( ... ) &#123;<span class="hljs-keyword">if</span> (disaster) <span class="hljs-keyword">goto</span> error;&#125; error:</code></pre><blockquote><p>大多数情况，使用goto语句比不使用goto语句程序段要难以理解和维护，少数情况除外。尽管该问题不太严重，但还是建议尽可能少的使用。</p></blockquote></li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><p>函数定义：<br><code>返回值类型 函数名(参数列表)&#123; 函数体 &#125;</code></p><blockquote><p>函数定义可以不带有<code>返回类型</code>，默认返回int类型。函数在源文件中出现的次序可以是任意的，只要保证一个函数不被分离到多个文件中即可。被调用函数通过<code>return 表达式</code>向调用者返回值，return后面表达式可以省略。</p></blockquote><h2 id="预处理器"><a class="markdownIt-Anchor" href="#预处理器"></a> 预处理器</h2><p>预处理器是编译过程中单独执行的第一个步骤，最常用的预处理器指令是<code>#include</code>和<code>#define</code>。</p><ul><li><p><strong>文件包含</strong><br>文件包含指令(<code>#include</code>)用于在编译期间把指定文件的内容包含进当前文件中。形式如下：<br><code>#include &quot;文件名&quot;</code><br>或<br><code>#include &lt;文件名&gt;</code>。</p><blockquote><p>当文件名用引号引起来(通常用于包含程序目录中的文件)，则在源文件所在位置查找该文件;如果该位置没有该文件或者文件名用尖括号括起来(通常用于包含编译器的类库路径里面的头文件)，则根据相应规则查找该文件，该规则同具体实现有关。如果某个包含文件内容发生了变化，那么所有依赖于该包含的文件的源文件都必须重新编译。</p></blockquote></li><li><p><strong>宏替换</strong><br>宏替换指令(<code>#define</code>)用于用任意字符序列替代一个标记。形式如下：<br><code>#define 标识符 记号序列</code></p><p>替换文本前后空格会被忽略，两次定义同一标识符是错误的，除非两次记号序列相同(所有空白分割符被认为是相同的)。<br>该定义的名字作用域从其定义点开始，到被编译的源文件末尾处结束。定义超过一行使用反斜杠(<code>\</code>)换行。</p><p>替换的文本可以是任意的，如：</p><pre class="highlight"><code class="c"><span class="hljs-comment">//为无限循环定义一个名字</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> forever for(;;) </span><span class="hljs-comment">//定义带参数宏</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max(A,B) ((A) &gt; (B) ? &lt; (A) : (B))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> square(x) x * x </span>main()&#123;<span class="hljs-keyword">int</span> i, z;i = z = <span class="hljs-number">2</span>;max(++i,i++); <span class="hljs-comment">// 结果为4</span>square(z+<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为5</span>&#125;</code></pre><blockquote><p>宏定义也有一些缺陷，如上面<code>max</code>，它对每个参数执行两次自增操作。<code>square</code>没有增加括号而导致计算次序错误。</p></blockquote><p>可以通过<code>#undef</code>取消名字的宏定义：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> max</span></code></pre><p><code>#</code>运算符可以使得宏定义的实际参数替换为带引号的字符串：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dprint(expr) printf(#expr + <span class="hljs-meta-string">"=%d"</span>)</span>调用结果x = <span class="hljs-number">4</span>,y = <span class="hljs-number">2</span>:dprint(x/y) --&gt; x/y=<span class="hljs-number">2</span> </code></pre><p><code>##</code>运算符可以使得宏定义的实际参数相连接：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> paste(x,y) x ## y</span>调用结果：paste(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) --&gt; <span class="hljs-number">12</span></code></pre></li><li><p><strong>条件编译</strong></p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 常量表达式</span>　文本<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> 常量表达式</span>　文本<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>　文本<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>当预处理器检测到常量表达式值为非0时，对相应表达式下面文本进行编译，后续表达式及文本将会被抛弃。常量表达式可以使用<code>define 标识符</code>或<code>define(标识符)</code>表达式，当<code>标识符</code>已经定义时，其值为1，否则为0。</p><pre class="highlight"><code class="c"><span class="hljs-comment">//检测HDR标识符，没有定义时将其定义</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(HDR)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HDR </span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>等价于<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HDR</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HDR</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>如上所示，可以使用<code>#ifdef 标识符</code>和<code>#ifndef 标识符</code>控制指令替换<code>#if define 标识符</code>。</p></li><li><p><strong>预定义标识符</strong></p><table><thead><tr><th>识符</th><th>说明</th></tr></thead><tbody><tr><td>__LINE__</td><td>当前所在源文件行数的十进制常量</td></tr><tr><td>__FILE__</td><td>被编译的源文件名字的字符串</td></tr><tr><td>__DATE__</td><td>被编译的源文件编译日期的字符串，格式：“Mmm dd yyyy”</td></tr><tr><td>__TIME__</td><td>被编译的源文件编译时间的字符串，格式：“hh:mm:ss”</td></tr><tr><td>__STDC__</td><td>整型常量1（只有在遵循标准的实现中该标识符才被定义为1）</td></tr></tbody></table></li><li><p><strong>其他预处理指令</strong><br><strong><code>#line 常量　&quot;文件名&quot;</code></strong>　以十进制整型常量的形式定义下一行源代码的行号。其中<code>&quot;文件名&quot;</code>可以省略，表示设置当前编译的源文件。<br><strong><code>#error 信息</code></strong>　当预处理器遇到此指令时停止编译并输出定义的错误消息。通常与<code>#if...#endif</code>等指令一起使用。<br><strong><code>#pragam 记号序列</code></strong>　使处理器执行一个与具体实现相关的操作。无法识别的pragma(编译指示)将被忽略掉。<br><strong><code>#</code></strong>　空指令。预处理器行不执行任何操作。</p></li></ul><h2 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h2><p>为了便于记忆，指针的声明形式是在变量声明的基础上加一个<code>*</code>间接寻址或间接引用运算符：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> *p; <span class="hljs-comment">//声明一个int类型的指针*p</span></code></pre><p>通过一元运算符<code>&amp;</code>获取一个对象的地址：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;p = &amp;x;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,*p); --&gt; 打印<span class="hljs-number">1</span></code></pre><p>一元运算符<code>*</code>和<code>&amp;</code>的优先级比算术运算符优先级高，因此在进行算术运算时不需要加括号：</p><pre class="highlight"><code class="c">*p += <span class="hljs-number">1</span>;或++*p;或(*p)++;</code></pre><blockquote><p>语句<code>(*p)++</code>中的圆括号是必需的，否则，表达式将对p进行加一运算，而不是对ip指向的对象进行加一运算，原因在于一元运算符表达式遵循从右到左的顺序。</p></blockquote><p>由于指针也是变量，所以可以直接使用，而不必通过间接引用的方法使用：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> *pp;pp = ip; <span class="hljs-comment">//通过变量的形式将指针pp指向指针ip指向的对象</span></code></pre><p>同其他类型变量一样，指针也可以初始化，对指针有意义的初始化值只能是<code>0</code>或表示地址的表达式。C语言保证<code>0</code>永远不是有效的数据地址，因此，返回<code>0</code>可用来表示发生了异常事件。</p><blockquote><p>指针与整数之间不能相互转换，但<code>0</code>是唯一的例外。常量<code>0</code>可以赋值给指针，指针也可以与常量<code>0</code>进行比较。程序中通常使用<code>符号常量(NULL)</code>代替常量0，其定义在<code>stddef.h</code>头文件中。</p></blockquote><ul><li><p><strong>指针与函数参数</strong><br>C语言是以传值的方式将参数值传递给被调用函数，因此，被调用函数不能直接修改主调函数中变量的值。</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> temp;temp = x;x = y;y = temp;&#125;调用：　swap(x,y);</code></pre><p>由于参数传递是传值方式，所以上述函数无法成功交换变量。可以通过将交换的变量的指针传递给被调用函数的方法实现该功能：</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *px,<span class="hljs-keyword">int</span> *py)</span></span>&#123;<span class="hljs-keyword">int</span> temp;temp = *px;*px = * py;*py = temp;&#125;调用：　swap(&amp;x,&amp;y);</code></pre></li><li><p><strong>指针与数组</strong><br>数组其实是由N个对象组成的集合，这些对象存储在相邻的内在区域中。因此可以将指针变量指向数组的每个对象。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> *pa;pa = &amp;a[<span class="hljs-number">0</span>]; <span class="hljs-comment">//将pa指向数组第0个元素</span></code></pre><p>根据指针运算的定义，<code>pa+1</code>指向数组下一个对象，<code>pa+i</code>指向pa所指向数组对象之后的第i个对象，<code>pa-i</code>指向pa所指向数组对象之前的第i个元素。<br>由于数组名所代表的就是该数组最开始的一个元素的地址，因此下面两等式作用相同：</p><pre class="highlight"><code class="c">pa = &amp;a[<span class="hljs-number">0</span>];或pa = a;</code></pre><p>由上面等式，对数组元素<code>a[i]</code>的引用也可以写成<code>*(a+i)</code>形式。实际上，在C语言计算<code>a[i]</code>元素时就是先将其转换成<code>*(a+i)</code>的形式，然后再求值。</p><blockquote><p>数组名和指针的不同之处在于，指针是一个变量，数组名却不是变量。因此语句<code>pa=a</code>和<code>pa++</code>是合法的，而<code>a=pa</code>和<code>a++</code>形式是非法的。</p></blockquote><p>当两个指针指向同一个数组的成员时，两个指针可以进行比较运算(==＝、!=、&lt;、&gt;=)：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">char</span> c[] = <span class="hljs-string">"hello"</span>;<span class="hljs-keyword">char</span> *pc1 = c;<span class="hljs-keyword">char</span> *pc2 = &amp;c[<span class="hljs-number">1</span>];运算：pc2 &gt; pc1 --&gt; True　<span class="hljs-comment">//比较运算返回True</span>pc2 - pc1 + <span class="hljs-number">1</span> --&gt; <span class="hljs-number">2</span> <span class="hljs-comment">//返回两指针指向的元素之间元素的数目</span></code></pre><blockquote><p>由上面代码可知，指向数组元素位越置靠前的指针，指针值越大。但是，指向不同数组的元素的指针之间的算术或比较运算没有意义。</p></blockquote><p>根据指针上面的特性，可以写出返回字符串长度函数的两个指针实现版本：</p><pre class="highlight"><code class="c"><span class="hljs-comment">/* strlen函数，返回客串s的长度 */</span>版本一：<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>;*s != <span class="hljs-string">'\0'</span>;s++)n++;<span class="hljs-keyword">return</span> n;&#125;版本二：<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;<span class="hljs-keyword">char</span> *p = s;<span class="hljs-keyword">while</span> (*p != <span class="hljs-string">'\0'</span>)p++;<span class="hljs-keyword">return</span> p - s;&#125;</code></pre><blockquote><ul><li>指针算术运算具有一致辞性，如果处理的数据类型是比字符型占据更多的存储空间的浮点类型，并且p是一个指向浮点类型的指针，那么在执行<code>p++</code>后，p将指向下一个浮点数的地址。所有的指针运算都会自动考虑它所指向的对象长度。</li><li>有效的指针运算包括相同类型指针之间的赋值运算；指针同整数之间的加减法运算；指向相同数组中元素的两个指针间的减法或比较去处；将指针赋值为0或与0之间的比较运算。其他所有形式的指针运算都是非法的。</li></ul></blockquote><p>C语言数组可以使用花括号<code>&#123;&#125;</code>括起来初值表进行初始化。同时也支持多维数组，如果将二维数组作为参数传递给函数，函数的参数声明中可以不指定数组的行数，但必须指明数组的列数，因为，二维数组在内存中的排列方式是按行排列的，即第一行排完之后再排列第二行，依此类推。当给出数组的列数时，通过列数与行数的关系，即可找到对应的地址。</p><pre class="highlight"><code class="c">f (<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span>][<span class="hljs-number">13</span>]);<span class="hljs-comment">//可以写成</span>f (<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[][<span class="hljs-number">13</span>]);<span class="hljs-comment">//还可以写成</span>f (<span class="hljs-keyword">int</span> (*<span class="hljs-built_in">array</span>)[<span class="hljs-number">13</span>]);<span class="hljs-comment">//错误写法</span>f (<span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>[<span class="hljs-number">13</span>]); --&gt; 因为[]的优先级高于*的优先级，如果声明时不使用()时，相当于声明了一个指向指针的一维数组。</code></pre><blockquote><p>由于指针本身也是变量，所以它也可以像其他变量一样被存储在数组中。因为<code>[]</code>优先级高于<code>*</code>的优先级，所以上例中<code>int *array[13];</code>相当于声明了一个指向指针的一维数组。</p></blockquote><p>指针数组与二维数组的区别是，二维数组是分配了固定存储空间(行*列)的，而指针数组只是定义了指定个数的指针，而没有对它们初始化，它们的初始化必须以显式的方式进行。因此，指针数组优于二维数组的重要一点是，指针数组每一行长度可以不同。</p><pre class="highlight"><code class="c"><span class="hljs-comment">//二维数组</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">10</span>][<span class="hljs-number">20</span>]; --&gt; 固定<span class="hljs-number">10</span>行<span class="hljs-number">20</span>列长度的二维数组<span class="hljs-comment">//指针数组　</span><span class="hljs-keyword">char</span> *monthName = &#123;<span class="hljs-string">"January"</span>,<span class="hljs-string">"February"</span>,<span class="hljs-string">"March"</span>&#125;; --&gt; 长度不固定的指针数组<span class="hljs-comment">//调用</span><span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];monthName[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; --&gt;返回 J**monthName; --&gt;等价于下标方式 返回 J</code></pre></li><li><p><strong>命令行参数</strong><br>调用主函数数(<code>main</code>)时，有两个参数。第一个参数(<code>argc</code>)用于参数计数，表示运行程序时命令行中参数的个数;第二个参数(<code>argv</code>)，是一个指向字符串数组的指针，其中每个字符串对应一个参数。另外，ANSI标准要求，argv[argc]的值必须为一个空指针。main函数返回值为0表示正常退出，返回非0值表示代表程序异常退出。如echo程序，它将命令行参数回显在屏幕上的一行中，其中命令行中各参数之间用空格隔开：</p><pre class="highlight"><code class="bash"><span class="hljs-built_in">echo</span> hello, world<span class="hljs-comment"># 打印输出</span>hello, world</code></pre><pre class="highlight"><code class="c"><span class="hljs-comment">// 版本一：将argv看成是一个字符指针数组</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[]) &#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; argc; i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s%s"</span>, argv[i], (i &lt; argc - <span class="hljs-number">1</span>) ? <span class="hljs-string">" "</span> : <span class="hljs-string">""</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 版本二：通过指针方式实现</span>main(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])&#123;<span class="hljs-keyword">while</span> (--argc &gt; <span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s%s"</span>, *++argv, (argc &gt; <span class="hljs-number">1</span>) ? <span class="hljs-string">" "</span> : <span class="hljs-string">""</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;注意：<span class="hljs-built_in">printf</span>的格式化参数也可以是表达式。如：<span class="hljs-built_in">printf</span>((argc&gt;<span class="hljs-number">1</span>) ? <span class="hljs-string">"%s "</span> : <span class="hljs-string">"%s"</span>, *++argv);</code></pre></li><li><p><strong>指向函数的指针</strong><br>C语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值。调用指向函数的指针时，它们是函数的地址，因为它们是函数，所以同数组名一样，前面不需要加<code>&amp;</code>运算符。<br>由于任何类型的指针都可以转换为<code>void *</code>类型，并且在将它转换回原来的类型时不会丢失信息，因此，函数指针数组参数的类型通常用void指针类型。定义形式：<br><code>类型 (*指针变量名) (参数列表)</code></p><blockquote><p>注意上面<code>(*指针变量名)</code>括号不能省略。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-comment">/* 实现operate()函数传入不同函数指针实现相关函数功能 */</span> <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">double</span> (*nump)(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len))</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span></span>;main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[]) &#123;<span class="hljs-keyword">double</span> num[] = &#123;<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">5.3</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">int</span> len = <span class="hljs-number">8</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f"</span>, operate(num, len, min)); --&gt; <span class="hljs-number">1.5</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f"</span>, operate(num, len, max)); --&gt; <span class="hljs-number">5.3</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f"</span>, operate(num, len, avg)); --&gt; <span class="hljs-number">2.7875</span>&#125;<span class="hljs-comment">//获取数组最大值</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<span class="hljs-keyword">double</span> temp;temp = *num++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++, num++)<span class="hljs-keyword">if</span> (temp &lt; *num)temp = *num;<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-comment">// 获取数组最小值</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<span class="hljs-keyword">double</span> temp;temp = *num++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++, num++)<span class="hljs-keyword">if</span> (temp &gt; *num)temp = *num;<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-comment">//获取数组平均值</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span> </span>&#123;assert(len != <span class="hljs-number">0</span>);<span class="hljs-keyword">double</span> ti;ti = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++, num++)ti += *num;<span class="hljs-keyword">return</span> ti / len;&#125;<span class="hljs-comment">// 通过函数指针调用不同的方法</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">double</span> (*nump)(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len))</span> </span>&#123;<span class="hljs-keyword">return</span> nump(num, len);&#125;</code></pre></li><li><p><strong>指针别名(Pointer aliasing)</strong><br>指两个及以上的指针指向同一数据，即不同的名字指针指向同一内在地址，则称一个指针是另一个指针的别名。如：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> *a = &amp;i;<span class="hljs-keyword">int</span> *b = &amp;i; <span class="hljs-comment">// 指针b是指针a别名</span></code></pre></li><li><p><strong><code>restrict</code>指针限定符</strong><br>该关键字是 C99 标准中新引入的一个指针类型修饰符，它只可应用于限定和约束指针，主要作用是限制指针别名，表明当前指针是访问一个数据对象的唯一方式，所有修改该指针所指向的内存中内容操作都必须通过该指针来修改，而不能通过其他途径修改。这样做的用处是帮助编译器更好的优化代码，生成更有效率的汇编代码。如果该指针与另外一个指针指向同一对象，将会导致未定义行为。</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 未加指针限定符的指针参数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span></span>&#123;*a = <span class="hljs-number">10</span>;*b = <span class="hljs-number">12</span>;<span class="hljs-keyword">return</span> *a + *b;&#125;<span class="hljs-comment">// 添加指针限定符的指针参数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-keyword">restrict</span> a, <span class="hljs-keyword">int</span> *<span class="hljs-keyword">restrict</span> b)</span></span>&#123;*a = <span class="hljs-number">10</span>;*b = <span class="hljs-number">12</span>;<span class="hljs-keyword">return</span> *a + *b;&#125;<span class="hljs-comment">// 调用两个方法</span><span class="hljs-keyword">int</span> i,j;add(&amp;i, &amp;j);  <span class="hljs-comment">// 返回值22，编译器无法确定内存是否被其他指针别名修改(即函数指针参数未设置 restrict 限定符)，无法作出优化</span>add2(&amp;i, &amp;j); <span class="hljs-comment">// 返回值22，生成的汇编代码会进行优化操作</span>add2(&amp;i, &amp;i); <span class="hljs-comment">// 返回值24，因为传递参数违反了 restrict 限定符对函数内部实现的约束(两个参数指向同一内存地址，导致互为指针别名)，导致未定义行为。</span></code></pre></li></ul><h2 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h2><p>结构是一个或多个变量的集合，这些变量可以是不同的类型。ANSI标准定义了定义了结构的赋值操作————结构可以拷贝、赋值、函数参数，函数返回值。声明形式如下：<br><code>struct 结构标记 &#123; 结构成员 &#125;</code></p><blockquote><p>结构成员、结构标记和普通变量(非成员)可以使用相同名字，而不会冲突，因为通过上下文分析可以对它们进行区分。</p></blockquote><p>struct声明定义了一种数据类型。在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其他基本类型的变量声明是相同的：</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>...&#125; x, y, z;</code></pre><p>如果结构声明的后面不带变量表，则不会为它分配存储空间，它仅仅描述了一个结构的模板或轮廓。如果结构声明中带有标记，就可以使用该标记定义结构实例：<br><code>struct 结构标记 结构名 [ = &#123;结构初始化值&#125; ]</code></p><p>上面结构初始化值可以省略，在表达式中可以使用<code>结构成员运算符(.)</code>引用某个特定结构中的成员:<br><code>结构名.成员</code></p><pre class="highlight"><code class="c"><span class="hljs-comment">// 声明结构</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> y;&#125;<span class="hljs-comment">// 定义结构实例</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pt</span> = &#123;</span><span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;; --&gt; 可以通过花括号的方式进行初始化<span class="hljs-comment">// 引用结构成员</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,pt.x); --&gt; 打印<span class="hljs-number">100</span></code></pre><p>结构可以进行嵌套，例如：</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 声明嵌套结构</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">react</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pt1</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pt2</span>;</span>&#125;<span class="hljs-comment">// 定义结构实例,并初始化</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rect</span> <span class="hljs-title">screen</span> = &#123;</span>&#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>&#125;, --&gt; 花括号可以省略，但不建议&#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;&#125;;<span class="hljs-comment">// 引用结构成员</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,screen.pt2.x); --&gt; 打印<span class="hljs-number">300</span></code></pre><p>结构类型的参数和其他类型的参数一样，都是值传递。因此，下面例子不会改变原结构 <strong>p1</strong> 的值：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> y;&#125;;main() &#123;<span class="hljs-function">struct point <span class="hljs-title">addpoint</span><span class="hljs-params">(struct point p1, struct point p2)</span></span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p1</span> = &#123;</span><span class="hljs-number">100</span>, <span class="hljs-number">200</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p2</span> = &#123;</span><span class="hljs-number">200</span>, <span class="hljs-number">300</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p</span> = <span class="hljs-title">addpoint</span>(<span class="hljs-title">p1</span>, <span class="hljs-title">p2</span>);</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%d\t%d"</span>, p.x, p.y); <span class="hljs-comment">// 打印300 500</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%d\t%d"</span>, p1.x, p1.y); <span class="hljs-comment">// 打印100 200 </span>&#125;<span class="hljs-function">struct point <span class="hljs-title">addpoint</span><span class="hljs-params">(struct point p1, struct point p2)</span> </span>&#123;p1.x += p2.x;p1.y += p2.y;<span class="hljs-keyword">return</span> p1;&#125;</code></pre><ul><li><p><strong>结构数组</strong><br>当有一组信息需要存储到结构体时，可以使用结构数组。结构数组和普通数组声明类似，就是在定义结构实例时增加一个<code>中括号[数组大小]</code>即可，如：</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pa</span>[50];</span> <span class="hljs-comment">// 定义结构数组pa</span></code></pre><blockquote><p>当使非字符数组时，结尾不是以<code>\0</code>结束，所以不容易判断数组长度。通常有三种解决方法：</p><ul><li>手工计算，直接写入具体长度。缺点是不得扩展，当列表变更时，需要手动维护，不安全。</li><li>在初值表的结尾处加上一个空指针，然后遍历循环，直到讲到尾部的空指针为止。</li><li>使用编译时一元运算符<code>sizeof 对象</code>或<code>sizeof (类型名)</code>，它可以计算任一对象的长度，即指定对象或类型占用的存储空间字节数。因为数组的长度在编译时已经完全确定，它等于 <strong>数组项的长度 * 项数</strong>，因此，得出数组项数为 <strong>数组长度 / 数组项的长度</strong>。</li></ul></blockquote><p><code>sizeof</code>反回一个无符号整型值，其类型为<code>size_t</code>，该类定义在头文件&lt;stddef.h&gt;中。一般用法如下：</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 预处理器中的应用，如返回上面结构数组的大小</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PA_LENGTH (sizeof(pa) / sizeof(pa[0])) </span>或　<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PA_LENGTH (sizeof(pa) / sizeof(struct point))  --&gt; 两者作用相同，但当类型改变时此种写法需要同步修改，因此，建议使用前者方法。</span><span class="hljs-comment">// 同结构一样其他类型数组也可使用上面方法获取数组大小</span><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">12</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1234</span>&#125;;<span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]) --&gt; <span class="hljs-number">4</span>或<span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) --&gt; <span class="hljs-number">4</span></code></pre></li><li><p><strong>结构指针</strong><br>当传递给函数的结构很大时，使用结构指针方式的效率比复制整个结构的效率高。结构指针和普通指针声明类似，如：</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 声明结构指针</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> *<span class="hljs-title">pp</span>;</span><span class="hljs-comment">// 访问结构成员</span>(*pp).x;(*pp).y;</code></pre><blockquote><p>上面示例，访问指针结构成员<code>(*pp).x</code>中的圆括号，是必需的。因为 <strong>结构成员运算符</strong>(<code>.</code>)的优先级高于 <strong>指针运算符</strong>(<code>*</code>)。</p></blockquote><p>结构指针使用频率非常高，为了用不用方便，C语言提供了另一种简写方式引用结构成员：<br><code>p-&gt;结构成员</code></p><pre class="highlight"><code class="c"><span class="hljs-comment">//声明结构数组指针*ppa和结构指针*pp</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> *<span class="hljs-title">ppa</span>, *<span class="hljs-title">pp</span>;</span><span class="hljs-comment">// 结构数组指针指向结构数组</span>ppa = pa;<span class="hljs-comment">// 结构指针指向结构数组第二项　</span>pp = &amp;pa[<span class="hljs-number">1</span>];ppa-&gt;y;  --&gt; <span class="hljs-number">200</span>pp-&gt;y;   --&gt; <span class="hljs-number">400</span><span class="hljs-comment">// 运算符 . 和 -&gt; 都是从左至右结合，所以下面表达式等价</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rect</span> <span class="hljs-title">r</span>, *<span class="hljs-title">rp</span> = &amp;<span class="hljs-title">r</span>;</span>r.pt1.x ;rp-&gt;pt1.x ;(r.pt1).x ;(rp-&gt;pt1).x ;</code></pre><blockquote><p>在所有运算符中，<strong>结构运算符</strong><code>.</code>、<code>-&gt;</code>、<strong>用于函数用的</strong><code>()</code>及<strong>用于下标的</strong><code>[]</code> 优先级最高。</p></blockquote></li><li><p><strong>自引用结构</strong><br>一个包含自身实例的结构是非法的，但将实例声明为指针是允许的。如：</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> <span class="hljs-title">left</span>;</span> --&gt; 非法声明&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">left</span>;</span> --&gt; 合法声明&#125;<span class="hljs-comment">// 结构互相引用</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">t</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s</span> *<span class="hljs-title">p</span>;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">t</span> *<span class="hljs-title">q</span>;</span>&#125;</code></pre></li></ul><h3 id="类型定义"><a class="markdownIt-Anchor" href="#类型定义"></a> 类型定义</h3><p>C语言可以通过<code>typedef</code>来建立新的数据类型名，形式如下：</p><p><code>typedef 类型 类型名</code></p><blockquote><p><code>typedef</code>声明的类型在变量名的位置出现，而不是紧接在关键字<code>typedef</code>之后。建议使用大写字母开头定义类型名，以示区分。<br><code>typedef</code>声明并没有创建一个新类型，只是为某个已存在的类型增加一个新的名称而已。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-comment">// 定义一个 String 类型</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> *String;<span class="hljs-comment">// 定义一个结构类型</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">Point</span>;</span>Point pp = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;pp.x; --&gt; <span class="hljs-number">5</span>pp.y; --&gt; <span class="hljs-number">6</span></code></pre><p><code>typedef</code>类似于<code>#define</code>语句，但<code>typedef</code>是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。如：</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 定义类型`PFI`是一个指向函数的指针，该函数接收两个`char *`类型的参数，返回`int`类型</span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*PFI)</span> <span class="hljs-params">(<span class="hljs-keyword">char</span> *, <span class="hljs-keyword">char</span> *)</span></span>;<span class="hljs-function">function <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *,<span class="hljs-keyword">char</span> *)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;PFI pfi = &amp;func;pfi(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); --&gt; 返回<span class="hljs-number">0</span></code></pre><blockquote><p><code>typedef</code>除了表达方式更简洁之外，使用它还有两个重要原因。一是它可以使程序参数化，以提高程序的可移植性。如声明的数据类型同机器有关，当程序需要移植到其他机器上时，只需改变<code>typedef</code>类型定义就可以了。另一个原因是它可以为程序提供更好的说明性。如 <strong>PFI</strong> 类型明显比一个指向复杂结构的指针更容易让人理解。</p></blockquote><h3 id="联合"><a class="markdownIt-Anchor" href="#联合"></a> 联合</h3><p>联合实际上就是一个结构，只不过联合的不同成员都保存在同一个存储空间，也就是联合中所有成员相对于基地址的偏移量都为0，因此联合空间要大到足够容纳最“宽”的成员。</p><p>定义：<code>union 联合标记 &#123; 联合成员 &#125;</code></p><p>联合可以给任何一个成员赋值，但每次的赋值将会覆盖上一次赋值，因此读取的类型必须是最近一次存入的类型，否则其返回结果取决于计算机的具体实现。</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 定义联合u</span><span class="hljs-keyword">union</span> myunion &#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">float</span> f;<span class="hljs-keyword">char</span> c;<span class="hljs-keyword">char</span> *pc;&#125; u;<span class="hljs-comment">// 赋值</span>u.i = <span class="hljs-number">10</span>; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%d"</span>, u.i); --&gt; <span class="hljs-number">10</span>u.c = <span class="hljs-string">'a'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%c"</span>, u.c); --&gt; <span class="hljs-function">a <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-string">"\n%d"</span>, u.i)</span></span>; --&gt; <span class="hljs-number">97</span> <span class="hljs-comment">// 因为 u.i 被最后一次 u.c 赋值覆盖，所以字符 'a' 对应的ASCII整数值为 97</span></code></pre><p>如同上示例，访问联合成员与访问结构成员方式相同：</p><p><code>联合.成员</code> 或 <code>联合指针-&gt;成员</code></p><h2 id="输入与输出"><a class="markdownIt-Anchor" href="#输入与输出"></a> 输入与输出</h2><ul><li><p><strong>格式化输出/输出</strong></p><p>输出函数：<code>int printf(char *format,...)</code></p><p>输入函数：<code>int scanf(char *format,...)</code></p><p>函数格式化参数以<code>%</code>开始，并以一个转换转换字符结束。在<code>%</code>和转换字符之间依次可以包含：</p><ul><li><code>负号</code>，用于指定被转换的参数按照左对齐的形式输出。</li><li><code>数</code>，用于指定最小字段宽度。</li><li><code>小数点</code>，用于将字段和精度分开。</li><li><code>数</code>，用于指定精度，即要打印的最大字符数、浮点数点后的位数、整型最少最少输出的数字数目。</li><li>字母<code>h</code>或<code>l</code>，表示将整数作为<code>short</code>类型或<code>long</code>类型打印。</li></ul></li></ul><table><thead><tr><th>转换符</th><th>描述</th></tr></thead><tbody><tr><td>d, i</td><td>int 类型;十进制数</td></tr><tr><td>o</td><td>int 类型，打印无符号八进制数(没有前导0)。</td></tr><tr><td>x, X</td><td>int 类型，打印无符号十六进制数(没有前导0x或0X)。</td></tr><tr><td>u</td><td>int 类型，打印无符号十进制数。</td></tr><tr><td>c</td><td>int 类型，单个字符。</td></tr><tr><td>s</td><td>char *类型，打印字符串。</td></tr><tr><td>f</td><td>double 类型十进制小数，精度默认为6。</td></tr><tr><td>e, E</td><td>double 类型，输入格式为指数形式，精度默认是6。如：m.dddddd e +/-。</td></tr><tr><td>g, G</td><td>double 类型，尾部的0和小数不打印。</td></tr><tr><td>p</td><td>void *类型。</td></tr><tr><td>%</td><td>打印 % 号。</td></tr></tbody></table><ul><li><p><strong>可变参数函数</strong><br>像<code>printf</code>函数一样，函数参数的数量和类型是可变的。使用<code>...</code>定义可变参数。<br>头文件<code>&lt;stdarg.h&gt;</code>中提供了<code>va_list</code>类型用于声明一个**参数指针(ap)**变量；宏<code>va_start</code>将<code>ap</code>针初始化为指向第一个无名参数的指针，参数表必须至少包括一个有名参数(如:char *format)，<code>va_start</code>将最后一个有名参数作为起点。<br>每次调用<code>va_arg</code>，该函数将返回一个参数，并将<code>ap</code>指向下一个参数。<code>va_arg</code>使用一个类型名来决定返回的对象类型、指针移动的步长。最后，在函数返回之前调用<code>va_end</code>以完成一些必要的清理工作。</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fmt,...)</span></span>&#123;va_list ap;<span class="hljs-keyword">char</span> *p, *sval;<span class="hljs-keyword">int</span> ival;<span class="hljs-keyword">double</span> dval;va_start(ap, fmt);<span class="hljs-keyword">for</span> (p = fmt; *p; p++) &#123;<span class="hljs-keyword">if</span> (*p != <span class="hljs-string">'%'</span>) &#123;<span class="hljs-built_in">putchar</span>(*p);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">switch</span> (*++p) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'d'</span>:ival = va_arg(ap, <span class="hljs-keyword">int</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, ival);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'f'</span>:dval = va_arg(ap, <span class="hljs-keyword">double</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f"</span>, dval);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-built_in">putchar</span>(*p);<span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> C </tag>
            
            <tag> C学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lua学习笔记(v5.3)</title>
      <link href="2019/07/29/Lua/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2019/07/29/Lua/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>Lua是一门扩展式、动态类型的程序设计语言，它没有<code>main</code>程序的概念只能嵌入一个宿主程序中工作，特点是轻量、可扩展。</p></blockquote><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><ul><li><p><strong>nil类型</strong>，值为<code>nil</code>。</p></li><li><p><strong>boolean类型</strong>，值为<code>true</code>和<code>false</code>(<em><strong>nil</strong></em> 和 ***false***都会导致条件判断为假，其他任何值都为真，包括0和空字符串)。</p></li><li><p><strong>number类型</strong>，值为<code>整数</code>和<code>符点数</code>。</p></li><li><p><strong>string类型</strong>，值为一个不可变的字节序列。</p></li><li><p><strong>function类型</strong>，由 C 或 Lua 编写的函数。</p><pre class="highlight"><code class="Lua">形式一:<span class="hljs-function"><span class="hljs-keyword">function</span> 函数名...函数体...<span class="hljs-title">end</span>形式二:函数名 = <span class="hljs-title">function</span>...函数体...<span class="hljs-title">end</span></span></code></pre><p>函数可以通过三点<code>...</code>来接收可变参数:</p><pre class="highlight"><code class="Lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">study</span><span class="hljs-params">(a,b,...)</span></span>  <span class="hljs-built_in">print</span>(a,b)  <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>&#123;...&#125; <span class="hljs-keyword">do</span>      <span class="hljs-built_in">print</span>(<span class="hljs-string">'可变参数'</span>,v)  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>study(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">'study'</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)</code></pre><p>同样，Lua函数也可有多个返回值用逗号<code>,</code>分割，也可在函数定义前使<code>local</code>关键字定义局部函数。</p></li><li><p><strong>userdata类型</strong>，表示任意存储在变量中的 C 数据结构(通常是 struct 和 指针)。</p></li><li><p><strong>thread类型</strong>，表示了一个独立的执行序列，被用于实现协程。</p></li><li><p><strong>table类型</strong>，表示一个关联数组，除了 <code>nil</code> 和 <code>NaN</code>(Not a Number 是一个特殊的数字，它用于表示未定义或表示不了的运算结果，比如 0/0。) 之外的所有 Lua 值 都可以做索引。除了<code>[ ]</code>的方方式外，Lua也提供了<code>.</code>操作符的方式访问表元素的语法糖。表中的值也可以是任意类型，即使是一个函数。</p><pre class="highlight"><code class="Lua"><span class="hljs-comment">-- 表索引遵循直接比较规则原则，即1.0==1为true，所以 a[1.0]=a[1]</span>&gt; a=&#123;&#125; <span class="hljs-comment">-- 初始化表</span>&gt; a[<span class="hljs-number">1.0</span>] = <span class="hljs-number">4</span>&gt; a[<span class="hljs-number">1</span>]<span class="hljs-number">4</span></code></pre><p>table其实就是一个Key Value的数据结构，它的元素形式可有多种，如：</p><pre class="highlight"><code class="Lua">a = &#123; [f(<span class="hljs-number">1</span>)] = g; <span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>; x = <span class="hljs-number">1</span>, f(x), [<span class="hljs-number">30</span>] = <span class="hljs-number">23</span>; <span class="hljs-number">45</span> &#125;其形式等价于：a = &#123; [f(<span class="hljs-number">1</span>)] = g; [<span class="hljs-number">1</span>] = <span class="hljs-string">"x"</span>,[<span class="hljs-number">2</span>] = <span class="hljs-string">"y"</span>; [<span class="hljs-string">"x"</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">3</span>] = f(x), [<span class="hljs-number">30</span>] = <span class="hljs-number">23</span>; [<span class="hljs-number">4</span>]=<span class="hljs-number">45</span> &#125;</code></pre><blockquote><p>由上可以发现，Lua的索引下标是从<code>1</code>开始的，并且表中没有键的值会默认从下标1开始作为键。</p></blockquote></li></ul><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3><p>– 单行注释<br>–[[<br>多行注释<br>]]</p><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>Lua中的标识符，是由非数字开头的任意字母下划线和数字构成的非保留关键字的字符串，且大小写敏感。作为一个约定，程序应避免创建以下划线加一个或多个大写字母构成的名字 （例如 _VERSION）。</p><p>字符串可以用<code>单引号</code>和<code>双引号</code>括起，并且支持C类型的转义：’\a’ （响铃）， ‘\b’ （退格）， ‘\f’ （换页）， ‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横项制表）， ‘\v’ （纵向制表）， ‘\’ （反斜杠）， ‘&quot;’ （双引号）， 以及 ‘’’ (单引号)</p><p>多行字符串通过<code>[[ ]]</code>来定义，如下几种定义完全相同：</p><pre class="highlight"><code class="Lua">a = <span class="hljs-string">'alo\n123"'</span>a = <span class="hljs-string">"alo\n123\""</span>a = <span class="hljs-string">'\97lo\10\04923"'</span> <span class="hljs-comment">-- \10 为换行编码</span>a = <span class="hljs-string">[[alo　123"]]</span>　<span class="hljs-comment">-- 采用多行定义语法</span>a = <span class="hljs-string">[==[alo123"]==]</span>　<span class="hljs-comment">-- 注意：开括号( [[ )后的换行符会被忽略</span></code></pre><ul><li><p>全局变量</p><p>所有没有显示声明为局部变量的变量全部为全局变量。</p></li><li><p>局部变量</p><p>变量前加<code>local</code>关键字为局部变量。</p></li><li><p>table 中的域</p></li></ul><blockquote><p>没有赋值的变量，默认值均为<code>nil</code></p></blockquote><h3 id="表达式"><a class="markdownIt-Anchor" href="#表达式"></a> 表达式</h3><ul><li><p><strong>数学操作符</strong></p><p><code>+</code> 加法<br><code>-</code> 减法<br><code>*</code> 乘法<br><code>/</code> 浮点除法<br><code>//</code> 向下取整除法<br><code>%</code> 取模<br><code>^</code> 乘方<br><code>-</code> 取负</p><p>乘方和浮点除法总是将整数转换为浮点数。</p></li><li><p><strong>位操作符</strong></p><p><code>&amp;</code> 按位与<br><code>|</code> 按位或<br><code>~</code> 按位异或<br><code>&gt;&gt;</code> 右移<br><code>&lt;&lt;</code> 左移<br><code>~</code> 按位非</p><p>所有的位操作都将操作数先转换为整数 ， 然后按位操作，其结果是一个整数。<br>对于右移和左移，均用零来填补空位。 移动的位数若为负，则向反方向位移； 若移动的位数的绝对值大于等于 整数本身的位数，其结果为零 （所有位都被移出）。</p></li><li><p><strong>比较操作符</strong></p><p><code>==</code> 等于<br><code>~=</code> 不等于<br><code>&lt;</code> 小于<br><code>&gt;</code> 大于<br><code>&lt;=</code> 小于等于<br><code>&gt;=</code> 大于等于</p></li><li><p><strong>逻辑操作符</strong></p><p><code>and</code>、<code>or</code>、<code>not</code><br>所有的逻辑操作符把 false 和 nil 都作为假， 而其它的一切都当作真。</p></li><li><p><strong>字符串连接操作符</strong></p><p>字符串的连接操作符写作两个点<code>..</code>。如果两个操作元素都是字符串或是数字，连接操作符将会把其转换成字符串，否则会调用元方法<code>__concat()</code>。</p></li><li><p><strong>取长度操作符</strong></p><p>取长度操作符写作一元前置符<code>#</code></p><pre class="highlight"><code class="Lua"><span class="hljs-keyword">local</span> t = &#123;  <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<span class="hljs-built_in">print</span>(#t)<span class="hljs-number">5</span></code></pre></li></ul><h3 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h3><ul><li><p><strong>代码块</strong></p><p>Lua可以采用<code>;</code>分割语句，或开始一个代码块，或者连续使用两个分号表示一个<code>空语句</code>。</p><p>函数调用和赋值语句都能以小括号开头，这可能让Lua语法产生歧义：</p><pre class="highlight"><code class="Lua">a = b + c(<span class="hljs-built_in">print</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>)(<span class="hljs-string">'done'</span>)</code></pre><p>从语法上说，可能有两种解释方式：</p><pre class="highlight"><code class="Lua">a = b + c(<span class="hljs-built_in">print</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>)(<span class="hljs-string">'done'</span>) 或a = b + c; (<span class="hljs-built_in">print</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>)(<span class="hljs-string">'done'</span>)</code></pre><p>解析器总是用第一种结构来解析， 它会将括号看成函数调用的参数传递开始处。 为了避免这种二义性， 在一条语句以小括号开头时，建议在前面放一个分号。</p><pre class="highlight"><code class="Lua">;(<span class="hljs-built_in">print</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>)(<span class="hljs-string">'done'</span>)</code></pre><p>一个代码块可以通过<code>do ... end</code>显示的被定界为单条语句，这种做法通常是为了控制内部变量声明的作用域，或是在一个语句块中间插入<code>return</code>。</p><p>Lua把代码块当成一个拥有不定参数的匿名函数，因此代码块内可以定义局部变量，它可以接收参数，返回若干值。</p></li><li><p><strong>赋值</strong></p></li></ul><p>Lua允许同时对多个变量赋值，等号左边放一个变量列表，右边放一个值列表，两边列表元素用<code>,</code>隔开，如果<br>值列表的数量多于变量列表，多余值将剔除;反之，则多余变量将被赋值为<code>nil</code>。</p><pre class="highlight"><code class="Lua">&gt; i = <span class="hljs-number">3</span> &gt; i,a[i],c = i+<span class="hljs-number">1</span>,<span class="hljs-number">20</span>&gt; <span class="hljs-built_in">print</span>(c)<span class="hljs-literal">nil</span></code></pre><ul><li><strong><code>if...else</code>语句</strong></li></ul><pre class="highlight"><code class="Lua"><span class="hljs-keyword">if</span> 表达式 <span class="hljs-keyword">then</span>    ...代码块...<span class="hljs-keyword">elseif</span> 表达式 <span class="hljs-keyword">then</span>     ...代码块...<span class="hljs-keyword">else</span>    ...代码块...<span class="hljs-keyword">end</span></code></pre><ul><li><strong><code>while</code>循环</strong></li></ul><pre class="highlight"><code class="Lua"><span class="hljs-keyword">while</span> 表达式 <span class="hljs-keyword">do</span>    ...代码块...<span class="hljs-keyword">end</span></code></pre><ul><li><strong><code>repeat</code>循环</strong></li></ul><pre class="highlight"><code class="Lua"><span class="hljs-keyword">repeat</span>    ...代码块...util 表达式</code></pre><ul><li><strong><code>for</code>循环</strong></li></ul><pre class="highlight"><code class="Lua"><span class="hljs-keyword">for</span> 变量=表达式<span class="hljs-number">1</span>, 表达式<span class="hljs-number">2</span> [,表达式<span class="hljs-number">3</span>] <span class="hljs-keyword">do</span>    ...代码块...<span class="hljs-keyword">end</span></code></pre><p>for语句将循环变量。 从<code>表达式1</code>值开始起，直到<code>表达式2</code>的值为止， 其步长为<code>表达式3</code>，默认步长为<code>1</code>。</p><pre class="highlight"><code class="Lua"><span class="hljs-keyword">for</span> a=<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span> <span class="hljs-keyword">do</span>    <span class="hljs-built_in">print</span>(a)<span class="hljs-keyword">end</span></code></pre><p>for语句还有一种迭代方式<code>for...in</code>，每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 nil 时，循环停止。</p><pre class="highlight"><code class="Lua"><span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 列表表达式　<span class="hljs-keyword">do</span>    ...代码块...<span class="hljs-keyword">end</span></code></pre><blockquote><p>循环语句可以通过<code>break</code>、<code>return</code>、<code>goto</code>来退出。只要 <code>goto</code> 没有进入一个新的局部变量的作用域，它可以跳转到任意可见<code>标签</code>(<code>::标签名::</code>)处。</p></blockquote><h2 id="元表及元方法"><a class="markdownIt-Anchor" href="#元表及元方法"></a> 元表及元方法</h2><p>Lua中的每个值都可以有一个<code>元表(metatable)</code>，这个表就是一个普通的<code>表(table)</code>，它用于定义在特定操作下的行为。当想要改变一个值在特定操作下的行为时，可以在它的元表中设置对应键(事件)的<code>元方法(metamethod)</code>。</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>__add</td><td>(+)加操作，如果任何不是数字的值（包括不能转换为数字的字符串）做加法， Lua 就会尝试调用元方法。</td></tr><tr><td>__sub</td><td>(-)减操作</td></tr><tr><td>__mul</td><td>(*)乘操作</td></tr><tr><td>__div</td><td>(/)除操作</td></tr><tr><td>__idiv</td><td>(//)向下取整操作</td></tr><tr><td>__pow</td><td>(^)次方操作</td></tr><tr><td>__mod</td><td>(%)余操作</td></tr><tr><td>__unm</td><td>(-)取负操作</td></tr><tr><td>__band</td><td>(&amp;)按位与操作</td></tr><tr><td>__bor</td><td>(|)按位或操作</td></tr><tr><td>__bxor</td><td>(~)按位异或操作</td></tr><tr><td>__bnot</td><td>(~)按位非操作</td></tr><tr><td>__shl</td><td>(&lt;&lt;)左位移操作</td></tr><tr><td>__shr</td><td>(&gt;&gt;)右位移操作</td></tr><tr><td>__concat</td><td>(…)连接操作</td></tr><tr><td>__len</td><td>(#)取长度操作</td></tr><tr><td>__eq</td><td>(==)等于操作</td></tr><tr><td>__lt</td><td>(&lt;)小于操作</td></tr><tr><td>__le</td><td>(&lt;=)小于等于操作</td></tr><tr><td>__index</td><td>索引 table[key]。 当 table 不是表或是表 table 中不存在 key 这个键时，这个事件被触发。 此时，会读出 table 相应的元方法。</td></tr><tr><td>__newindex</td><td>索引赋值 table[key] = value 。 和索引事件类似，它发生在 table 不是表或是表 table 中不存在 key 这个键的时候。 此时，会读出 table 相应的元方法。</td></tr><tr><td>__call</td><td>函数调用操作<code>func(args)</code>。当 Lua 尝试调用一个非函数的值的时候会触发这个事件 （即 func 不是一个函数）。 查找 func 的元方法， 如果找得到，就调用这个元方法， func 作为第一个参数传入，原来调用的参数（args）后依次排在后面。</td></tr><tr><td>__tostring</td><td>字符串输出</td></tr><tr><td>__metatable</td><td>保护元表。当调用<code>setmetatable</code>方法时，如果元表中包括此事件，则会抛出一个错误。同样，当调用<code>getmetatable</code>时，会返回此事件关联的值。</td></tr></tbody></table><h3 id="元表的使用"><a class="markdownIt-Anchor" href="#元表的使用"></a> 元表的使用</h3><ul><li><strong><code>__add</code></strong></li></ul><pre class="highlight"><code class="Lua">Set = &#123;&#125;　<span class="hljs-comment">-- 声明一个全局集合对象</span><span class="hljs-keyword">local</span> mt = &#123;&#125; <span class="hljs-comment">-- 声明一个局部元表</span><span class="hljs-comment">--[[-- 创建新集合，并设置元表为mt方法--]]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set.new</span><span class="hljs-params">(dataSet)</span></span><span class="hljs-keyword">local</span> reSet = &#123;&#125;<span class="hljs-built_in">setmetatable</span>(reSet,mt) <span class="hljs-comment">-- 设新集合元表为mt</span><span class="hljs-comment">-- 遍历传入数据集并将数据写入新集合中(键值相同)</span><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dataSet) <span class="hljs-keyword">do</span>reSet[i] = v <span class="hljs-keyword">end</span><span class="hljs-keyword">return</span> reSet;<span class="hljs-keyword">end</span><span class="hljs-comment">--[[-- 获取传入集合的并集方法--]]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set.union</span><span class="hljs-params">(dataSetA,dataSetB)</span></span><span class="hljs-keyword">local</span> reSet = Set.new&#123;&#125; <span class="hljs-comment">-- 创建新集合，相当于Set.new(&#123;&#125;)</span><span class="hljs-comment">-- 遍历A数据集</span><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dataSetA) <span class="hljs-keyword">do</span> reSet[i] = v<span class="hljs-keyword">end</span><span class="hljs-comment">-- 遍历B数据集</span><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dataSetB) <span class="hljs-keyword">do</span> reSet[i] = v<span class="hljs-keyword">end</span><span class="hljs-keyword">return</span> reSet<span class="hljs-keyword">end</span><span class="hljs-comment">-- 测试new方法创建集合元表是为相同</span><span class="hljs-keyword">local</span> set1 = Set.new(&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;)<span class="hljs-keyword">local</span> set2 = Set.new(&#123;[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>,[<span class="hljs-number">4</span>]=<span class="hljs-number">2</span>&#125;)<span class="hljs-built_in">assert</span>(<span class="hljs-built_in">getmetatable</span>(set1) ~= <span class="hljs-built_in">getmetatable</span>(set2)) <span class="hljs-comment">-- 返回table: 0x7fa2a8c072e0，assertion failed! 说明两元表相同</span><span class="hljs-comment">-- 以加操作为例，原本table没有加操作，通过元表附予table加操作</span>mt.<span class="hljs-built_in">__add</span> = Set.union <span class="hljs-comment">-- 给元表增加__add事件，并将事件的行赋予Set.union</span><span class="hljs-keyword">local</span> set3 = set1 + set2 <span class="hljs-comment">-- 表之间可以相加，并且set3内容为set1和set2的并集 &#123;10,20,30,1,2&#125;</span></code></pre><blockquote><p>上例中<code>Set.union</code>就是元表的<code>元方法</code>，Lua中不同元素都有相同或不同的元表，在执行不同操作时选择元哪个元表，Lua按照以下步骤进行：<br>1、对于二元操作符，如果第一个操作数有元表，并且元表中有所需要的事件定义，如<code>__add</code>事件的定义，Lua就以这个元表的事件方法为元方法，而与第二个操作数无关；<br>2、对于二元操作符，如果第一个操作数有元表，但是元表中没有所需要的事件定义，如<code>__add</code>元方法定义，Lua就去查找第二个操作数的元表；<br>3、如果两个操作数都没有元表，或者都没有对应的元方法定义，Lua就抛出一个错误。</p></blockquote><ul><li><strong><code>__tostring</code></strong></li></ul><p>Lua中当表调用<code>tostring()</code>、<code>print()</code>等方法时会，会去寻找<code>__tostring</code>事件的元方法，可以通过自定义元方法实现个性打印。</p><pre class="highlight"><code class="Lua"><span class="hljs-comment">--[[-- 定义自符串输出方法--]]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set.toString</span><span class="hljs-params">(dataSet)</span></span><span class="hljs-keyword">local</span> tb = &#123;&#125;<span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dataSet) <span class="hljs-keyword">do</span> tb[i] = v<span class="hljs-keyword">end</span><span class="hljs-keyword">return</span> <span class="hljs-string">'&#123;'</span> .. <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(tb,<span class="hljs-string">','</span>) .. <span class="hljs-string">'&#125;'</span> <span class="hljs-comment">-- table.concat()返回列表的元素连接的字符串</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 设置元表mt的__tostring的元方法</span>mt.<span class="hljs-built_in">__tostring</span> = Set.toString<span class="hljs-comment">-- 直接打印集合set3</span><span class="hljs-built_in">print</span>(set3) &gt; &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;</code></pre><ul><li><strong><code>__metatable</code></strong></li></ul><p>Lua元素元表可以随时通过<code>setmetatable</code>方法修改，灵活方便同时也增加了风险，可以通<code>__metatable</code>事件，使元素元表受到保护不可被修改。当再次调用<code>setmetatable</code>方法时，将会抛出一个受保护的错误;当调用<code>getmetatable</code>方法时，会返回事件关联的值。</p><pre class="highlight"><code class="Lua"><span class="hljs-comment">-- 设置元表__matatable事件</span>mt.<span class="hljs-built_in">__metatable</span> = <span class="hljs-string">'不允许修改元表'</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getmetatable</span>(set1)) <span class="hljs-comment">-- 获取元表返回设置的内容</span>&gt;&gt; 不允许修改元表<span class="hljs-built_in">setmetatable</span>(set1,&#123;&#125;) <span class="hljs-comment">-- 修改元表提示受保护元表不可以被改变</span>&gt;&gt; cannot change a protected metatable </code></pre><h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2><p><em><strong>持续更新中…</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
            <tag> Lua学习笔记 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这一世的缘</title>
      <link href="2019/07/09/blog/%E8%BF%99%E4%B8%80%E4%B8%96%E7%9A%84%E7%BC%98/"/>
      <url>2019/07/09/blog/%E8%BF%99%E4%B8%80%E4%B8%96%E7%9A%84%E7%BC%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vim编辑器进阶学习(一)</title>
      <link href="2019/04/16/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
      <url>2019/04/16/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="缓冲区"><a class="markdownIt-Anchor" href="#缓冲区"></a> 缓冲区</h2><p>如同一般编辑器都有的<code>tab</code>标签一样，<code>vim</code>也类似的功能叫<code>buffer(缓冲区)</code>，可以通过<code>:help buffer</code>查看详细文档。</p><table><thead><tr><th>常用命令</th><th>描述</th></tr></thead><tbody><tr><td>:ls[flags]</td><td>展示所有(指定flags的)buffer</td></tr><tr><td>:b[数字/文件名]</td><td>切换指定buffer</td></tr><tr><td>:sb[数字/文件名]</td><td>分割屏幕显示指定buffer</td></tr><tr><td>:bn</td><td>显示下一个buffer</td></tr><tr><td>:bp</td><td>显示前一个buffer</td></tr><tr><td>:bf</td><td>显示第一个buffer</td></tr><tr><td>:bl</td><td>显示最后一个buffer</td></tr><tr><td>:bd[数字]</td><td>删除指定buffer</td></tr><tr><td>:e[文件名]</td><td>编辑文件在新buffer中(当前文件必须保存)</td></tr><tr><td>:e![文件名]</td><td>强制编辑文件在新buffer中，没有保存文件将丢失</td></tr></tbody></table><ul><li><code>:ls</code>命令标识符号(同一列上的符号不可能同时出现)</li></ul><p><code>u</code>列表外缓冲区 (只有使用 [!] 才能看到) |unlisted-buffer|<br><code>%</code>当前窗口里的缓冲区<br><code>#</code>用 “:e #” 或 CTRL-^ 可切换到的轮换缓冲区<br><code>a</code>激活缓冲区: 已载入内存并且可见<br><code>h</code>隐藏缓冲区: 已载入内存但是没有窗口显示它|hidden-buffer|<br><code>-</code>不可更改的缓冲区，选项 ‘modifiable’ 被关闭。<br><code>=</code>只读缓冲区<br><code>+</code>已经更改的缓冲区<br><code>x</code>有读错误的缓冲区</p><ul><li><code>ls</code>[flags] 可以是下面字符的组合，用来限制列出的缓冲区</li></ul><p><code>+</code>修改过的缓冲区(常用)<br><code>-</code>‘modifiable’ 关闭的缓冲区<br><code>=</code>只读缓冲区<br><code>a</code>激活的缓冲区<br><code>u</code>列表外缓冲区 (覆盖 “!”)<br><code>h</code>隐藏缓冲区<br><code>x</code>有读入错误的缓冲区<br><code>%</code>当前缓冲区(常用)<br><code>#</code>轮换缓冲区</p><h2 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h2><p>一个标签页可以容纳多个buffer，可以通过切换标签页达到每个标签页做不同的工作。</p><table><thead><tr><th>常用命令</th><th>描述</th></tr></thead><tbody><tr><td>:tabnew</td><td>在当前页之后打开带新窗口的标签页</td></tr><tr><td>:tabs</td><td>显示所有标签页<code>&gt;</code>代表当前窗口,<code>+</code>表示修改过的缓冲区</td></tr><tr><td>:tabc[数字]</td><td>关闭当前(第几个)标签页,屏幕上只有一个标签页时无法关闭</td></tr><tr><td>:tabo</td><td>关闭其他标签页</td></tr><tr><td>:tabn[数字]</td><td>循环显示下一个标签页(转到下几个标签页,首个标签页编号是1)</td></tr><tr><td>:tabp[数字]</td><td>循环显示上一个标签页(转到下上个标签页,首个标签页编号是1)</td></tr><tr><td>[数字]gt</td><td>跳转到指定编号标签（首个标签页编号是 1）</td></tr><tr><td>:tabfir[st]</td><td>显示第一个标签页</td></tr><tr><td>:tabl</td><td>显示最后一个标签页</td></tr><tr><td>:tabf [文件名]</td><td>打开新的标签，并编辑指定文件，和<code>:find</code>命令类似(需要设置查找路径<code>set path=.</code>)</td></tr></tbody></table><h2 id="分屏"><a class="markdownIt-Anchor" href="#分屏"></a> 分屏</h2><h3 id="目录分屏"><a class="markdownIt-Anchor" href="#目录分屏"></a> 目录分屏</h3><ul><li><p>把当前窗口上下分屏，并进行目录浏览：<br><code>:He</code> 在下边分屏浏览目录<br><code>:He!</code> 在上分屏浏览目录</p></li><li><p>把当前窗口左右分屏，并进行目录浏览：<br><code>Ve</code> 在左边分屏间浏览目录<br><code>Ve!</code> 在右边分屏间浏览目录</p></li></ul><h3 id="同步滚屏help-scroll-binding"><a class="markdownIt-Anchor" href="#同步滚屏help-scroll-binding"></a> 同步滚屏(help scroll-binding)</h3><p>在需要同步滚动的窗口输入<code>:set scb</code>命令，取消同步滚动输入<code>:set noscb</code>命令。默认情况，两窗口偏移量是从当前行开始，可以通过<code>:syncbind</code>命令强制同步偏移量。</p><h3 id="调整窗口大小"><a class="markdownIt-Anchor" href="#调整窗口大小"></a> 调整窗口大小</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>:res[ize] (+/-)[数字]</td><td>调整窗口高度为(加/减)指定行数</td></tr><tr><td>:vertical res[ize] (+/-)[数字]</td><td>调整窗口宽度为(加/减)指定列数</td></tr></tbody></table><h2 id="会话保存"><a class="markdownIt-Anchor" href="#会话保存"></a> 会话保存</h2><p>通过<code>:mksession</code>命令可以保存当前编辑器的设置和已打开的文件或标签等以便下次直接打开。</p><pre class="highlight"><code class="vim"><span class="hljs-comment">" 保存会话</span>:<span class="hljs-keyword">mksession</span> ~/.mysession.<span class="hljs-keyword">vim</span><span class="hljs-comment">" 打开会话</span><span class="hljs-keyword">vim</span> -S ~/.mysession.<span class="hljs-keyword">vim</span></code></pre><h2 id="快捷键映射"><a class="markdownIt-Anchor" href="#快捷键映射"></a> 快捷键映射</h2><p><code>vim</code>快捷键映射用于改变输入键的含义，<code>:map</code>命令查看所有映射。可以通过<code>help map.txt</code>查看完整文档。</p><h3 id="映射模式"><a class="markdownIt-Anchor" href="#映射模式"></a> 映射模式</h3><ul><li><p><strong>Normal Mode(普通模式)</strong></p><p>前缀<code>n</code>，表示普通模式下生效，也就是进入vim后的默认模式。即：<code>:nmap</code></p></li><li><p><strong>Visual Mode(可视化模式)</strong></p><p>前缀<code>v</code>，表示在可视模式下生效，也就是进入vim后按<code>v</code>键时的模式。即：<code>:vmap</code></p></li><li><p><strong>Insert Mode(插入模式)</strong></p><p>前缀<code>i</code>，表示在插入模式下生效，也就是进入vim后按<code>i</code>键时的模式。即：<code>:imap</code></p></li><li><p><strong>Command-Line/Ex Mode(命令行模式)</strong></p><p>前缀<code>c</code>，表示在命令行模式下生效，也就是进入vim后按<code>:</code>键的模式。即：<code>:cmap</code></p></li><li><p><strong>Select Mode(选择模式)</strong></p><p>前缀<code>s</code>，表示选择模式下生效，也就是用鼠标拖选区域的时候的模式。gvim下常用的模式。即：<code>:smap</code></p></li><li><p><strong>普通、可视、选择和操作符等模式</strong><br>前缀<code>&lt;Space&gt;</code>，表示这几种模式下均生效。即：<code>:map</code></p></li><li><p><strong>插入和命令行模式</strong></p><p>后缀<code>!</code>，表示在插入和命令行模式下生效。即：<code>:map!</code></p></li><li><p><strong>操作符等待模式</strong></p><p>前缀<code>o</code>，表示在操作符等待模式下生效，也就是在操作一个命令时的间隔时间段的模式，一般该模式非常短暂。比如，执行一个命令，此时操作符等待模式被激活，当执行时间较长时可以通过按<Esc>终止该操作，返回到普通模式。即：<code>:omap</code></Esc></p></li><li><p><strong>非递归映射</strong><br>前缀<code>nore</code>，表示非递归映射。map映射默认都是递归映射，即如果键a被映射成了b，c又被映射成了a，那么c就被映射成了b。可与上述模式组合使用。即：<code>:noremap</code></p></li></ul><h3 id="映射命令"><a class="markdownIt-Anchor" href="#映射命令"></a> 映射命令</h3><p><code>:map &#123;lhs&#125; &#123;rhs&#125;</code><br>表示将<code>&#123;lhs&#125;</code>映射为<code>&#123;rhs&#125;</code>，其中<code>&#123;rhs&#125;</code>可以递归映射。</p><p><code>:unmap &#123;lhs&#125;</code><br>表示解除映射</p><p><code>:mapclear</code><br>清除所有映射，危险操作，慎用！</p><blockquote><p><code>&#123;lhs&#125;</code>之前可能显示一个特殊字符：<br>  <code>*</code> 表示不可重映射<br>  <code>&amp;</code> 表示脚本的局部映射可以被重映射<br>  <code>@</code> 表示缓冲区的局部映射</p></blockquote><h3 id="特殊参数"><a class="markdownIt-Anchor" href="#特殊参数"></a> 特殊参数</h3><p>特殊参数可以按任意顺序使用，但必须紧跟在命令后面，其它任何参数之前。</p><ul><li><p><strong><code>&lt;buffer&gt;</code></strong></p><p>如果命令后面第一个参数是<code>&lt;buffer&gt;</code>，表示映射将只局限于当前的缓冲区内，当绥中区被删除时，映射也会被删除。如<code>:map &lt;buffer&gt; ,w /[.,;]&lt;CR&gt;</code>。</p></li><li><p><strong><code>&lt;nowait&gt;</code></strong></p><p>定义局部于缓冲区的映射 “,” 时，可能有另一个全局映射也以 “,” 开始。此时需要键入另一个字符，Vim 才能知道是用 “,” 映射还是更长的那个字符。为了避免这个问题，使用<nowait> 参数，这样映射一旦匹配就会被使用，Vim 不会等待更多字符的输入。但如果那些字符已经输入了，还是会使用的。</nowait></p></li><li><p><strong><code>&lt;silent&gt;</code></strong></p><p>定义一个映射时不在命令行上回显该映射。</p></li><li><p><strong><code>&lt;unique&gt;</code></strong></p><p>定义新的键映射或者缩写命令的同时检查是否该键已经被映射，如果该映射或者缩写已经存在，则该命令会失败。</p></li><li><p><strong><code>&lt;Leader&gt;和mapleader变量</code></strong></p><p>mapleader变量对所有map映射命令起效，它的作用是将参数<leader>替换成mapleader变量的值。如：<br><code>:map &lt;Leader&gt;A oanother line&lt;Esc&gt;</code><br>如果mapleader变量没有设置，则用默认的反斜杠代替，因此这个映射等效于：<br><code>:map \A oanother line&lt;Esc&gt;</code><br>如果设置了mapleader变量，如：<br><code>let mapleader = &quot;,&quot;</code> <br>那么就等效于： <br><code>:map ,A oanother line&lt;Esc&gt;</code></leader></p></li></ul><h3 id="特殊键符"><a class="markdownIt-Anchor" href="#特殊键符"></a> 特殊键符</h3><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>&lt;k0&gt; - &lt;k9&gt;</td><td>小键盘 0 到 9</td></tr><tr><td>&lt;S-…&gt;</td><td>Shift＋键</td></tr><tr><td>&lt;C-…&gt;</td><td>Control＋键</td></tr><tr><td>&lt;M-…&gt;</td><td>Alt＋键 或 meta＋键</td></tr><tr><td>&lt;A-…&gt;</td><td>同 &lt;M-…&gt;</td></tr><tr><td>&lt;Esc&gt;</td><td>Escape 键</td></tr><tr><td>&lt;Up&gt;</td><td>光标上移键</td></tr><tr><td>&lt;Space&gt;</td><td>插入空格</td></tr><tr><td>&lt;Tab&gt;</td><td>插入Tab</td></tr><tr><td>&lt;CR&gt;</td><td>等于&lt;Enter&gt;</td></tr><tr><td>&lt;C-U&gt;前缀</td><td>表示在命令模式中删除所有的文本(如：nnoremap &lt;silent&gt; &lt;C-T&gt; :&lt;C-u&gt;Ydc&lt;CR&gt;)</td></tr></tbody></table><h2 id="全局搜索"><a class="markdownIt-Anchor" href="#全局搜索"></a> 全局搜索</h2><table><thead><tr><th>常用命令</th><th>描述</th></tr></thead><tbody><tr><td>:vim[grep] /{pattern}/[g][j] {file} …</td><td>在 {file}（支持正则） 文件中搜索 /{pattern}/ 内容（支持正则）,结果将会显示在 Quickfix 中。｜</td></tr><tr><td>:cw[indow] [height]</td><td>打开 Quickfix 窗口</td></tr><tr><td>:cope[on] [height]</td><td>打开一个窗口显示当前错误列表，如果存在一个 Quickfix 时，将会打开该窗口。此时可以代替 :cw 命令。</td></tr><tr><td>ccl[ose]</td><td>关闭当前 Quickfix 窗口。</td></tr><tr><td>:lv[imgrep] /{pattern}/[g][j][f] {file} …</td><td>作用同 :vim 命令，不同之处是该结果显示在 location list 窗口。</td></tr><tr><td>:lw[indow] [height]</td><td>打开 location list 窗口。</td></tr><tr><td>:lop[en] [height]</td><td>作用同 :lw 命令类似。</td></tr><tr><td>:lcl[ose]</td><td>关闭 location list 窗口。</td></tr></tbody></table><blockquote><p>quickfix list 是全局的，相对于窗口而言，不同的窗口共用一个quickfix list；而 loaction list 是局部于某个特定窗口的，<br>即不同窗口的 location list 可以不同。</p></blockquote><h2 id="粘贴模式"><a class="markdownIt-Anchor" href="#粘贴模式"></a> 粘贴模式</h2><p><code>vim</code>编辑器<code>insert</code>模式下粘贴文本有时会丢失数据，原因是它把文本当作命令执行了，可以通过<code>:set paste</code> 和 <code>:set nopaste</code> 设置和取消粘贴模式来解决这个问题。</p><h2 id="插件"><a class="markdownIt-Anchor" href="#插件"></a> 插件</h2><h3 id="vim-scriptsemmetvim"><a class="markdownIt-Anchor" href="#vim-scriptsemmetvim"></a> vim-scripts/Emmet.vim</h3><p>html/css代码生成插件　<a href="https://github.com/vim-scripts/Emmet.vim">GitHub</a></p><pre class="highlight"><code class="vim"><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">" emmet Setting</span><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">" 快捷键 Ctrl+e</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:user_emmet_expandabbr_key</span> = <span class="hljs-string">'&lt;c-e&gt;'</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:use_emmet_complete_tag</span> = <span class="hljs-number">1</span></code></pre><h3 id="scrooloosenerdtree"><a class="markdownIt-Anchor" href="#scrooloosenerdtree"></a> scrooloose/nerdtree</h3><p>vim导航插件,通过<code>:NERDTree</code>命令打开　<a href="https://github.com/scrooloose/nerdtree">GitHub</a></p><h3 id="luochen1990rainbow"><a class="markdownIt-Anchor" href="#luochen1990rainbow"></a> luochen1990/rainbow</h3><p>彩虹插件　<a href="https://github.com/luochen1990/rainbow">GitHub</a></p><pre class="highlight"><code class="vim"><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">" rainbow Setting</span><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">"0 if you want to enable it later via :rainbowtoggle</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:rainbow_active</span> = <span class="hljs-number">1</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:rainbow_conf</span> = &#123;    \   <span class="hljs-string">'guifgs'</span>: [<span class="hljs-string">'royalblue3'</span>, <span class="hljs-string">'darkorange3'</span>, <span class="hljs-string">'seagreen3'</span>, <span class="hljs-string">'firebrick'</span>],    \   <span class="hljs-string">'ctermfgs'</span>: [<span class="hljs-string">'lightblue'</span>, <span class="hljs-string">'lightyellow'</span>, <span class="hljs-string">'lightcyan'</span>, <span class="hljs-string">'lightmagenta'</span>],    \   <span class="hljs-string">'operators'</span>: <span class="hljs-string">'_,_'</span>,    \   <span class="hljs-string">'parentheses'</span>: [<span class="hljs-string">'start=/(/ end=/)/ fold'</span>, <span class="hljs-string">'start=/\[/ end=/\]/ fold'</span>, <span class="hljs-string">'start=/&#123;/ end=/&#125;/ fold'</span>],    \   <span class="hljs-string">'separately'</span>: &#123;    \       <span class="hljs-string">'*'</span>: &#123;&#125;,    \       <span class="hljs-string">'tex'</span>: &#123;    \           <span class="hljs-string">'parentheses'</span>: [<span class="hljs-string">'start=/(/ end=/)/'</span>, <span class="hljs-string">'start=/\[/ end=/\]/'</span>],    \       &#125;,    \       <span class="hljs-string">'lisp'</span>: &#123;    \           <span class="hljs-string">'guifgs'</span>: [<span class="hljs-string">'royalblue3'</span>, <span class="hljs-string">'darkorange3'</span>, <span class="hljs-string">'seagreen3'</span>, <span class="hljs-string">'firebrick'</span>, <span class="hljs-string">'darkorchid3'</span>],    \       &#125;,    \       <span class="hljs-string">'vim'</span>: &#123;    \           <span class="hljs-string">'parentheses'</span>: [<span class="hljs-string">'start=/(/ end=/)/'</span>, <span class="hljs-string">'start=/\[/ end=/\]/'</span>, <span class="hljs-string">'start=/&#123;/ end=/&#125;/ fold'</span>, <span class="hljs-string">'start=/(/ end=/)/ containedin=vimfuncbody'</span>, <span class="hljs-string">'start=/\[/ end=/\]/ containedin=vimfuncbody'</span>, <span class="hljs-string">'start=/&#123;/ end=/&#125;/ fold containedin=vimfuncbody'</span>],    \       &#125;,    \       <span class="hljs-string">'html'</span>: &#123;    \           <span class="hljs-string">'parentheses'</span>: [<span class="hljs-string">'start=/\v\&lt;((area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)[ &gt;])@!\z([-_:a-za-z0-9]+)(\s+[-_:a-za-z0-9]+(\=("[^"]*"|'</span>.<span class="hljs-string">"'"</span>.<span class="hljs-string">'[^'</span>.<span class="hljs-string">"'"</span>.<span class="hljs-string">']*'</span>.<span class="hljs-string">"'"</span>.<span class="hljs-string">'|[^ '</span>.<span class="hljs-string">"'"</span>.<span class="hljs-string">'"&gt;&lt;=`]*))?)*\&gt;/ end=#&lt;/\z1&gt;# fold'</span>],    \       &#125;,    \       <span class="hljs-string">'css'</span>: <span class="hljs-number">0</span>,    \   &#125;    \&#125;</code></pre><h3 id="vim-scriptstaglistvim"><a class="markdownIt-Anchor" href="#vim-scriptstaglistvim"></a> vim-scripts/taglist.vim</h3><p>文件标签导航插件  <a href="https://github.com/vim-scripts/taglist.vim">GitHub</a></p><h3 id="vim-scriptsctrlpvim"><a class="markdownIt-Anchor" href="#vim-scriptsctrlpvim"></a> vim-scripts/ctrlp.vim</h3><p>文件查找插件,默认快捷键<code>Ctrl+p</code>  <a href="https://github.com/vim-scripts/ctrlp.vim">GitHub</a></p><h3 id="scrooloosenerdcommenter"><a class="markdownIt-Anchor" href="#scrooloosenerdcommenter"></a> scrooloose/nerdcommenter</h3><p>自动注释插件  <a href="https://github.com/scrooloose/nerdcommenter">GitHub</a><br>默认快捷键<br>[count]<leader>cc 单行注释</leader></p><h3 id="jiangmiaoauto-pairs"><a class="markdownIt-Anchor" href="#jiangmiaoauto-pairs"></a> jiangmiao/auto-pairs</h3><p>括号自动补全插件  <a href="https://github.com/jiangmiao/auto-pairs">GitHub</a></p><h3 id="vim-scriptstaghighlight"><a class="markdownIt-Anchor" href="#vim-scriptstaghighlight"></a> vim-scripts/TagHighlight</h3><p>关键字高亮插件  <a href="https://github.com/vim-scripts/TagHighlight">GitHub</a></p><h3 id="vim-airlinevim-airline"><a class="markdownIt-Anchor" href="#vim-airlinevim-airline"></a> vim-airline/vim-airline</h3><p>状态栏插件  <a href="https://github.com/vim-airline/vim-airline">GitHub</a></p><pre class="highlight"><code class="vim"><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">" airline Setting</span><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">" Integrating with powerline fonts</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:airline_powerline_fonts</span> = <span class="hljs-number">1</span><span class="hljs-comment">" beautify tab line</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:airline</span>#extensions#tabline#enabled = <span class="hljs-number">1</span><span class="hljs-comment">" airline Theme</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:airline_theme</span> = <span class="hljs-string">'bubblegum'</span></code></pre><h3 id="vim-airlinevim-airline-themes"><a class="markdownIt-Anchor" href="#vim-airlinevim-airline-themes"></a> vim-airline/vim-airline-themes</h3><p>状态栏插件主题  <a href="https://github.com/vim-airline/vim-airline-themes">GitHub</a></p><h3 id="ianvavim-youdao-translater"><a class="markdownIt-Anchor" href="#ianvavim-youdao-translater"></a> ianva/vim-youdao-translater</h3><p>有道翻译插件  <a href="https://github.com/ianva/vim-youdao-translater">GitHub</a></p><pre class="highlight"><code class="vim"><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">" 有道翻译 Setting</span><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-keyword">vnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> <span class="hljs-symbol">&lt;C-T&gt;</span> :<span class="hljs-symbol">&lt;C-u&gt;</span>Ydv<span class="hljs-symbol">&lt;CR&gt;</span><span class="hljs-keyword">nnoremap</span> <span class="hljs-symbol">&lt;silent&gt;</span> <span class="hljs-symbol">&lt;C-T&gt;</span> :<span class="hljs-symbol">&lt;C-u&gt;</span>Ydc<span class="hljs-symbol">&lt;CR&gt;</span><span class="hljs-keyword">noremap</span> <span class="hljs-symbol">&lt;leader&gt;</span>yd :<span class="hljs-symbol">&lt;C-u&gt;</span>Yde<span class="hljs-symbol">&lt;CR&gt;</span></code></pre><p>在普通模式下，按 ctrl+t， 会翻译当前光标下的单词；<br>在 visual 模式下选中单词或语句，按 ctrl+t，会翻译选择的单词或语句；<br>点击引导键再点y，d，可以在命令行输入要翻译的单词或语句；</p><h3 id="yianwillisvimcdoc"><a class="markdownIt-Anchor" href="#yianwillisvimcdoc"></a> yianwillis/vimcdoc</h3><p>vim 文档中文翻译插件 <a href="https://github.com/yianwillis/vimcdoc">GitHub</a></p><h3 id="valloricyoucompleteme"><a class="markdownIt-Anchor" href="#valloricyoucompleteme"></a> Valloric/YouCompleteMe</h3><p>自动完成插件 <a href="https://github.com/ycm-core/YouCompleteMe">GitHub</a></p><pre class="highlight"><code class="vim"><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">" youcompleteme Setting</span><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:ycm_max_num_candidates</span> = <span class="hljs-number">10</span><span class="hljs-comment">" python配置</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:ycm_python_interpreter_path</span> = <span class="hljs-string">'/users/windus/.pyenv/shims/python'</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:ycm_python_sys_path</span> = [<span class="hljs-string">''</span>, <span class="hljs-string">'/users/windus/.pyenv/versions/3.7.3/lib/python37.zip'</span>, <span class="hljs-string">'/users/windus/.pyenv/versions/3.7.3/lib/python3.7'</span>, <span class="hljs-string">'/users/windus/.pyenv/versions/3.7.3/lib/python3.7/lib-dynload'</span>, <span class="hljs-string">'/users/windus/.pyenv/versions/3.7.3/lib/python3.7/site-packages'</span>]<span class="hljs-keyword">let</span> <span class="hljs-variable">g:ycm_extra_conf_vim_data</span> = [  \  <span class="hljs-string">'g:ycm_python_interpreter_path'</span>,  \  <span class="hljs-string">'g:ycm_python_sys_path'</span>  \]<span class="hljs-keyword">let</span> <span class="hljs-variable">g:ycm_global_ycm_extra_conf</span> = <span class="hljs-string">'~/global_extra_conf.py'</span></code></pre><h3 id="python-modepython-mode"><a class="markdownIt-Anchor" href="#python-modepython-mode"></a> python-mode/python-mode</h3><p>python开发插件 <a href="https://github.com/python-mode/python-mode">GitHub</a></p><pre class="highlight"><code class="vim"><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">" python-mode Setting</span><span class="hljs-comment">"-------------------------------------------------------------------------------</span><span class="hljs-comment">" 禁用每行后面带颜色线条</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:pymode_options_colorcolumn</span> = <span class="hljs-number">0</span><span class="hljs-comment">" 行最大长度提示</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:pymode_options_max_line_length</span> = <span class="hljs-number">100</span><span class="hljs-comment">" 设置python-mode sys_path</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:pymode_paths</span> = [<span class="hljs-string">''</span>, <span class="hljs-string">'/users/windus/.pyenv/versions/3.7.3/lib/python37.zip'</span>, <span class="hljs-string">'/users/windus/.pyenv/versions/3.7.3/lib/python3.7'</span>, <span class="hljs-string">'/users/windus/.pyenv/versions/3.7.3/lib/python3.7/lib-dyn    load'</span>, <span class="hljs-string">'/users/windus/.pyenv/versions/3.7.3/lib/python3.7/site-packages'</span>]<span class="hljs-comment">" run python 快捷键</span><span class="hljs-keyword">let</span> <span class="hljs-variable">g:pymode_run_bind</span> = <span class="hljs-string">'&lt;leader&gt;r'</span></code></pre><h3 id="chiel92vim-autoformat"><a class="markdownIt-Anchor" href="#chiel92vim-autoformat"></a> Chiel92/vim-autoformat</h3><p>代码格式化插件 <a href="https://github.com/Chiel92/vim-autoformat">GitHub</a></p><h3 id="w0rpale"><a class="markdownIt-Anchor" href="#w0rpale"></a> w0rp/ale</h3><p>语法检查插件 <a href="https://github.com/w0rp/ale">GitHub</a></p><h2 id="文件操作"><a class="markdownIt-Anchor" href="#文件操作"></a> 文件操作</h2><pre class="highlight"><code class="vim">:<span class="hljs-keyword">file</span> 显示当前文件名:<span class="hljs-keyword">file</span> [name] 设置或修改当前文件名</code></pre><h2 id="其他资料"><a class="markdownIt-Anchor" href="#其他资料"></a> 其他资料</h2><ul><li><a href="https://vim-adventures.com/">vim大冒险游戏</a></li><li><a href="https://jonasjacek.github.io/colors/">vim颜色值</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见了，Q!!!</title>
      <link href="2019/03/03/blog/%E5%86%8D%E8%A7%81%E4%BA%86Q/"/>
      <url>2019/03/03/blog/%E5%86%8D%E8%A7%81%E4%BA%86Q/</url>
      
        <content type="html"><![CDATA[<p>常规的不开心的一个周末，常规的出门，常规的一如既往，却又那么的不常规，因为我们不再同路，因为我们不再同处，既然决定就不想再继续彼此伤害，不想再继续强求。</p><p>触景生情的我记起了第一次与你的相见，你第一次来到这个家一周时害怕的我24小时的待命，第一次外出恐惧的我的鼓励，第一次生病挣扎的我的拯救。那时的我对你的一切是那么的上心，然而真的是时光如飞梭，快到我想倒退，却不得其法。可是我们的关系终将不是单方的付出可以维续的，终于我也无法满足你想要的自由，你也无法给我想要的忠诚，我们距离已悄然越来越远。</p><p>就是这样的一个下午我站着静静的看着你离我越来越远的背影，纵使我有千般留恋，万般不舍。因为我们彼此无法满足彼此的追求，因为我们彼此可能也受够了对方的所有，所以对于你决绝的离去，我也就坦然自若了。</p><p>往后余生，可能我们不在齐头并进，可能……可能……<br>依旧祝你好运，再见了，Q!!!</p>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过年回家(三)</title>
      <link href="2019/01/31/blog/%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6(%E4%B8%89)/"/>
      <url>2019/01/31/blog/%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<p>今天，已是距离新年放假的倒数第二个工作日了，后天即将启程返家。</p><p>或许是在外漂泊久了，习惯了，当我想描述2017年年末是如何抢票回家的时候，脑海中已经模糊不清，记不得了。现在只清楚的知道，不知不觉，当知道该抢今年回家的票的时候，我已是泰然处之，并没有守着放票时间点去抢票，甚至连哪天放的票也不知道，只想着，没事，过两天仔细计划下哪天回家，再抢票就好了，肯定会有票的。此时的我，已经习惯了抢票的各种套路，已经学会了这个技能，所以，并不担心，哈哈～</p><p>其实，这也是有原因的。今年10月份，终于鼓起勇气，辞别了毕业后的第一家公司，刚刚好再有两个月，就待了整三年了。曾经因为工作内容和工资的原因，多少次想跳个槽，只是最终都没有勇气。后来，在面对现实后，毅然决然的、在还没有面试到下家的时候，离职走了。而现在，在新的公司，还没有过试用期，公司也一直没有正式通知什么时候放假。所以，也不知道过年什么时候回家，所以一直没有着急抢票。</p><p>当放票几天后，在宝贝贝的一直提醒下，我才开始问有经验的“老同事”，之前一般什么时候放假，过完年什么时候上班，我如果几号几号走，会不会太早。。。问了几天，确定完时间后，才着手开始慢慢的抢票，在智行、美团上建了几个抢票任务，然后带着红包，分享到各个微信群聊、朋友圈，让大家帮忙加速，虽然并没有加到所谓的光速、vip。一切准备工作做完后，就心安理得的等着抢到票付款的那一刻。并没有着急，因为心里一直想着：肯定会抢到的，等着就行（此处一个偷笑的表情）。哈哈～</p><p>其实，真的会有的。没几天，就抢到回家的票了，哈哈。返京的票倒是有些曲折。一开始抢到一张高铁，是某一天的早上六点多。哇塞，时间有点早啊，这么早，我怎么去火车站啊，那还得提前一天晚上到郑州租个宾馆呢吧，好累。。。不对啊，这张票我是咋建的任务，为什么会选择这么早的车。郁闷半天，不知道建抢票任务时，是怎么选上的这趟车，估计是不小心点上的吧。。。直接就想退票，宝贝贝说：先留着吧，万一买不到其他票呢？于是，我就先留着了，同时也在默默的抢着其他车次的票。又没过几天，又抢到一张是晚上的硬卧，嗯～～满意，优秀的美团，果断把那张高铁票退了。</p><p>由于公司一直没有正式通知年后什么时候上班，我这抢了初八晚上的硬卧，初九早上才能到北京，初九还有精力上班么？要是按国家规定的节假日，初七都开始上班了，我这新入职的会不会请假请的时间有点长？不行，还得再抢，据说公司应该会多放几天假，如果我抢一个初八当天到京的票是不是就完美了，即使请假，时间也不会长，初九还能上班。要是公司多放两天，那我的时间刚刚好。于是，又建了抢票任务，初八的高铁，立志要初八当天能返京，默默等着抢到票就好了。优秀的美团，总没有让我失望，抢票杠杠滴，灰常心满意足的一张初八下午的高铁到手了，从家出发时间也方便，到京时间也好。开森，完美，哈哈～</p><p>本以为今年抢票大战就此结束，然而，并没有。。。</p><p>在一个加班的晚上（我已经下班回家了），领导告诉大家，为了奖励我们部门年前辛苦的加班，要给我们多放假几天，初十（周四）以后上班，但不准超过十五十六回来（因为十五十六刚好是新的一周的开始），但是具体上班时间，并没有说清楚。我掐指一算，诶？那我初八的票是不是回来的早了，本可以在家待到十二十三呢。翻着日历，往后看了几天。哇，初十是情人节呢，咋办，还想和宝贝贝一起过呢，生活需要仪式感。而且，在家待得久了，别人都上班走了，我还在家，碰见熟人的时候，肯定该说老大不小了，被催婚之类的。如今奔三还未婚的，应该都有此感吧，各种想躲避，不安。好吧，那我再推后一天，抢一个初九的高铁就完美了，可以在家多待一天，和别人差不多走，还可以和宝贝贝过一个情人节，哈哈。。。</p><p>所以，现在的我，留着初八的票备用，还在抢着初九的高铁。。。还是那句话，肯定会有票的，不用担心。</p><p>后天即将回家了，可是却一直没有再像以前一样那样的激动，早早的为回家准备着，今年只是提前买了一些糖果寄回了家，然后，走的时候，打包两身衣服就行了，并不想带太多。</p><p>第一年，或许是因为刚到北京，第一次这么远距离的坐火车回家，第二年，或许是因为收获了宝贝贝过的第一个年头儿，又一起度过了甜蜜热恋的一年，所以，都记得很清楚。这后两年，无论是在外漂泊工作，还是感情方面，都比较习惯了。习惯了工作模式，习惯了和宝贝贝的相处模式。过了热恋期，这是属于磨合期的两年，虽然中间磕磕绊绊，曲曲折折，分分合合，有极其的开心，也有极度的悲伤，翻看彼此的空间，不再像2016年那么甜蜜可爱，各自都多了很多闹别扭时愤怒、抱怨、刺痛、伤害，一串一串的。。。甜蜜的事情，总是惹人回忆，惹人向往。而这些伤痛的，我想这些空间里的说说，估计我们再不愿去翻看，去触碰吧，回忆起来，连呼吸都是哽咽的。。。或许，这是让我们慢慢的多几分成熟、习惯、亲情吧，习惯、喜欢身边有你的日子。</p><p>纵使不会再像热恋那么可爱的模样，希望在新的一年，我们能给彼此更多的理解、包容、宽容、忍让、珍惜，永远活成年轻幸福的模样。</p><p>过年回家～<br>完。</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过年回家(二)</title>
      <link href="2019/01/30/blog/%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6(%E4%BA%8C)/"/>
      <url>2019/01/30/blog/%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>第二年，2016年年末，身边多了一个宝贝贝。那是在回龙观和平西府的日子。</p><p>虽然离过年还有些日子，但是铁路局会提前一个月放票啊，自己没注意时间，反倒是被周围同事给提醒了。记得2016年我目标抢票的日子刚好是一个周六的早上，不用上班。但是我和宝贝贝早早的准备好，设置了闹钟，也按时早早的起床了，没有暖气的房间，坐起来冷呵呵的，还要穿着厚厚的外套。看准了车次和时间，就等着时间一到，开抢，胸有成竹的样纸～<br>结果。。。瞬间没票了。。。沮丧了。。。幸好！给远方的发小之前发起了求助，神助攻得一张高铁，那个开心啊！！！</p><p>然后，安心的躺下又接着睡了，哈哈～～</p><p>票买到了，又开始数着回家的倒计时，各种心理准备，想着带点啥回家呢，给家里买点啥呢，穿什么衣服呢，想着过年哪天要干啥干啥，哪天和小伙伴们约啊，和同学聚啊。时间越近，越是着急联络各方小伙伴聚会的时间。短短一个多星期的放假+请假时间，还没回家，都已全部安排好了，时间满满的。天天都在数日子，想还有多久回家，还能做些什么，准备些什么，生怕漏了啥，好像过了年就不会再来北京了一样。。激动的心情，难以言表。</p><p>同时，我和宝贝贝一起度过了幸福快乐的第一年。从春风和煦、草长莺飞、柳絮飘飘，乐在其中，往来穿梭；到骄阳似火、鸟语蝉鸣、绿树成荫，泛舟湖上，莲叶满池；到秋高气爽、北雁南飞、金风玉露，登高望远，心旷神怡；再到岁暮天寒、腊梅怒放、玉树琼枝，伴步踏雪，寻奇景归。我欲与君相知，长命无绝衰。</p><p>这也是分别的倒计时，相思的倒计时，好似要几年未见似的，当然充满了万般的不舍和留恋。</p><p>我放假早，先回了家。在两天后的一个萧瑟的晚上，宝贝贝在空间里留下了一张一个人拉着行李，在小区里的昏黄的影子的照片，也回家了。</p><p><strong>“又一年！”</strong></p><p>是啊，又一年，回家！！！</p><hr><p><em><strong>未完，待续…</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>过年回家(一)</title>
      <link href="2019/01/29/blog/%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6(%E4%B8%80)/"/>
      <url>2019/01/29/blog/%E8%BF%87%E5%B9%B4%E5%9B%9E%E5%AE%B6(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>年难过，年难过，年年难过，年年过;<br>事无成，事无成，事事无成，事事成。</p></blockquote><p>波波折折，又是一年了。</p><p>再有两天，就该放假回家了。今年已是来北京要过的第4个春节。猛然想起来，好像和刚来北京的前两年完全不一样了。</p><p>第一年，2015年，因为是12月份才到的北京，12月中旬找到工作开始上班。刚入公司没多久，就听同事开始讨论抢回家的火车票了。</p><p>那时，因为以前基本没坐过火车，没有买票的经验，仅有的几次坐火车出玩，也都是同学帮忙给买的。于是乎，处于茫然的态度，开始问同事、问同学，这个火车票是怎么抢的，还激动的定个闹钟，盯着放票时间点抢票。想着刚入职，还是毕业后的第一份工作，都还没转正呢，还是收敛点吧，直接买了国家规定的法定节假日的票-除夕当天，心里还想着，我是有工作的人了，需要回去的晚点。因为以前一直上学，一直过着学生时代该有的寒暑假，突然要这么晚才能回家过年，心中到底还是不习惯的。</p><p>后来和同事一起说话的时候，大家听到我的时间，都一通说：你怎么那么晚啊。。。不用那么晚。。。可以请假。。跟经理说声就行了，会让你走的。。。你那么晚，早都没人了。。。我们都抢二十几二十几的票呢。。。一通喧哗过后，我决定重新抢票，时间提前了，定的都是和大家差不多的时间。或许从大北京到我们大中原交通枢纽郑州的车太多，用同事给的抢票方法，一天刷出来3张火车票，挑了一张时间最满意的付款了。。。结果，本来最后一个走的我，变成了部门第一个要走的，心里还是扑通扑通的，怕经理会生气，不准许，因此对自己的印象不好。。。然而并没有。某次开小会，经理问大家都什么时候走，我在众人汇报的时候，默默的偷偷加入回家的时间，经理知晓，并没有什么反应，好想是很自然的态度。于是，我就顺理成章、名正言顺、心安理得的第一个放假回家了。。记得第一年从帝都大北京回家，激动了好久、准备了好久，冥思苦想的要给家里带一些好东西、稀奇的东西。一个月心里都是激动满满，不停的数着回家倒计时的日子。。。</p><hr><p><em><strong>未完，待续…</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>南下深圳</title>
      <link href="2018/11/20/blog/%E5%8D%97%E4%B8%8B%E6%B7%B1%E5%9C%B3/"/>
      <url>2018/11/20/blog/%E5%8D%97%E4%B8%8B%E6%B7%B1%E5%9C%B3/</url>
      
        <content type="html"><![CDATA[<p>难以想像下午还在京城的我，两三个小时后，已出差来到了远在千里之外的深圳。白天还还穿着秋裤坐在暖气房里，晚上已经换上了单衣半袖，真是”坐地日行八万里，巡天遥看一千河”。而此时的地我更是坐地日行八万四千里了，从“鸡脖”来到了“鸡腹”部。</p><p>对于一个第一次越过长江以南的北方人，如果不是亲身的感受，真的无法想像十一二月的南方竟然如此舒适。可能是靠着海边的原因，阵阵暖风佛面而过，竟然还有点小热……。最令怀念的是下飞机后的那顿潮汕牛肉火锅了，味美肉滑，回味无穷，关键是价格还很亲民。晚饭过后回到了公司在这边的宿舍，是一个环境非常好的小区，屋子也很大，很漂亮，据说罗湖区这附近这样的小区房价都在千万了。。。啥家庭啊，这都是。。。</p><p>出差的是日子总是苦逼的，和程序员(虽然我也是)一起出差的日子更是苦逼中的苦逼，不是在上班、加班，就是在上班的路上，耽误我欣赏祖国的大好河山。终于在即将结束本次出差的前一天晚上，有了一点时间。虽然时间已经有点晚了，但来到一个地方，即使随便走走也好，否则总感觉少了些什么。打开地图导航了一下附近选定了<code>红树林自然保护区</code>，本来就是想看看夜景，也就没有搭乘公交或地铁，找了个共享单车刷街。原本只有我自己想出来转转，后来另外两个同事中的一个也想去。</p><p>不得不说这里的空气真的是京城无法相比的，感觉清新的有些醉氧了，哈哈。街道干净整洁，只是为什么不设计专门的自行车道呢，居然行人和自行车道混在一起，感觉骑的好难受(虽然京城的好多自行车道几乎快被汽车攻陷了，但至少还有很多好骑路段)。道路两侧有很多的棕榈树和椰子树，觉得比北方街道种的树漂亮好多。开始看地图以为没有多远，可后来发现一点也不近，骑了将近三四十分钟，才骑到目的地。还好这地方人还挺多，也没有关门，我们就走了进去，只是路两侧灯光昏暗，看不太清什么，就是顺着路往里走，没多大一会儿就到了海边，海的对面就是香港了，站在海边呆了一会儿，拍了拍照片。</p><p>深圳之行匆匆忙忙的结束了，回到了熟悉的暖器房里，迎接着即将忙碌的一个月。回想着几天来的种种感受还是很好的，让我印象最深刻的一件事儿是，“过马路的时候，司机师傅竟然在很远的地方就开始刹车，然后慢慢停了下来，让我们先过。原本我在慢慢的往路口走，离路口还有一段距离，想着等这车过去再过马路，结果看到司机师傅远远的就给我们让路，让我心里还有点过意不去，急忙小跑着过了马路，呵呵”。主要是咱也不知道，咱也不敢过啊，在北方从来没有发生过这种事情，只要人没有站在斑马线中间，车就敢挤着你过去，甚至你站在路中间，他也能滴滴你挤过去。。。真心要为这样的司机师傅点赞，应该大力宣传这种行为啊！</p><p>喜欢去到每一个不曾到达过的地方，领略不一样的气候环境，不一样风土人情。可能真的是应了那句话<code>“你喜欢的可能是你永远无法得到的”</code>，真的是也曾梦想仗从剑走天涯，看一看世间的繁华，不知今生还能否实现！</p>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“自驾”野三坡</title>
      <link href="2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/"/>
      <url>2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/</url>
      
        <content type="html"><![CDATA[<p>上周末部门团队建设自驾游，目的地保定涞水野三坡，说是自驾其实是坐车，可能没有人会让我这样一个几个月的新手来开，即使我自认为没有问题。其实自从驾照下来几个月内我也没少开，包括朋友车和时租车等等，不得不承认技术上确实还有很多不足，但我自认为能达到安全驾驶的程度。可即使这样也没有人相信你，感觉“论资排辈”的理论真是害人啊！</p><p>早上7点多出发，中途在韩家河服务区休息了一会儿，中午12点左右到达目的地。小憩一会儿后，直接去了漂流，说是漂流实际就是划船，那水速真叫一个慢，还不如之前去的十渡，反正想以后漂流不会再来这儿了。漂流无趣只能自找乐趣，打水仗再好不过了，湿身是每个人幸免不了的结果…</p><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/WechatIMG2.jpeg" width="490px" alt="漂流"><span class="image-caption">漂流</span><p>漂流后返回住地午饭后小憩一会儿，直接去了号称“天下第一峡”的百里夹，是不是天下第一我不知道，但是景观还不错，各种奇观异景，怪石嶙峋，不得不感叹大自然的神奇，据说这里10亿年前这里曾是一片海洋，有一段峡谷很像是电影神话中蒙毅战死的那个峡谷。</p><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/04C151B79FDEB7088299A0335202C411.jpg" width="490px" alt="一线天"><span class="image-caption">一线天</span><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/62F1889E7A9AAB2E407E993132C68AE7.jpg" width="490px" alt="回首观音"><span class="image-caption">回首观音</span><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/B13ABB9CA467D17F6B0BF460A975C77A.jpg" alt="登顶"><span class="image-caption">登顶</span><p>这个地方应该松鼠挺多的，到处都是松鼠雕塑，开车途中马路上看到一只松鼠，上山前还发现了一条蚯蚓大小的小蛇。<br><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/29CF12150939C7B4931271D5AB2BE0B9.jpg" width="490px"></p><p>俗话说上山容易下山难啊，到了山顶之后就感觉膝盖酸痛，所以下山时候坐的缆车，现在的我基本上已经告别爬山了，岁月不饶人啊！晚上回到住处，吃饭、烧烤、喝酒、唱歌、打牌各种项目，后来我实在扛不住了，就先睡了。</p><p>第二天，又开车去了鱼骨洞，这是一座形成几亿年的地下溶洞，我是第一次进入溶洞，完全超出了我想像，原本以为里面很小，结果进去后才发现我的想法有多可笑，据说里面总共有五层，从入口到出口整体是一个半圆形，一会儿向前，一会向上，一会又向下，整整走了半个多小时，里面景色也很是壮观，也可能我没去过其它溶洞吧，反正我感觉这次游玩，最好的项目就是这个溶洞了。</p><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/82EF8B393F1F717EE75931520083B5A8.jpg" width="490px"><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/5041FC6092A8A4702B940C9664C6B5FD.jpg" width="490px"><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/88891AED71676E35A224554C48133E5C.jpg" width="490px"><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/298965989E965D8DC5ACB639060FC826.jpg" width="490px"><p>然而，能游览的区域仅仅是这溶洞的冰山一角，还有很多区域没有开发，导游说溶洞下面还有地下暗河，可惜的是目前正在开发中，不对外开放。</p><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/B5A8C193763EF30B241E6630CFA6C943.jpg" width="490px"><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/DC498F20FC6898470B5B5A0CDBF933E5.jpg" width="490px"><img src="/2018/09/11/blog/%E8%87%AA%E9%A9%BE%E9%87%8E%E4%B8%89%E5%9D%A1/503AD3163055FBC7AC5225FA708F3347.jpg" width="490px" alt="人工隧道出口"><span class="image-caption">人工隧道出口</span><p>快乐的时光总是短暂的，午饭后开车回家，原本想走其它线路，后来发现路程有点远还可能堵车，所以就原路返回了。<div style="color:white;">一路比较畅通，并没有遇到大的堵车到家还挺早，这两天也没机会开上车，被弄的手痒痒，手里有几张共享汽车优惠券，于是找了辆车开了两个时，完美，哈哈！</div></p>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 徒步 </tag>
            
            <tag> 自驾 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假前的兴奋</title>
      <link href="2018/09/07/blog/%E5%81%87%E5%89%8D%E7%9A%84%E5%85%B4%E5%A5%8B/"/>
      <url>2018/09/07/blog/%E5%81%87%E5%89%8D%E7%9A%84%E5%85%B4%E5%A5%8B/</url>
      
        <content type="html"><![CDATA[<p>云蒸霞蔚　中非蓝景;夕阳西下，下班回家，又一个美好的生活从周五下午开始，虽然还没到下班的时间但我的心已经飞到了家中，周五总是一个让我难以静心工作的日子，再加上明天的公司团队自驾团建更加强这种感觉。种种情景让我想起那些年学生时代的种种，一样的心情，一样的平淡，一样的简单。虽然没有那些年我们一起追过的女孩，但并没有让我感到遗憾，唯一可惜的是逝去的韶华和失去的朋友。</p><img src="/2018/09/07/blog/%E5%81%87%E5%89%8D%E7%9A%84%E5%85%B4%E5%A5%8B/pic1.jpeg" width="490px" alt="“中非蓝”夜幕下的北京"><span class="image-caption">“中非蓝”夜幕下的北京</span><p>当周末已然变成上班中唯数不多的乐趣，感叹奔波谋生的无奈，感觉自己能掌控的事情越来越少，想舍弃没勇气，想追求的没魄力，所以也只能来到这只属于我自己的一亩三分地发个感慨了。对于一个无欲无求的人来说真不知道未来将会如何，甚至有些莫名的恐慌，想做些什么却总感觉力有不逮，所以只能报怨自己时运不济缺少机遇。可是这些终将成为无能的借口，也许这就是一个失败的而立之年的人的现实，或许还可以等到不惑吧？</p><img src="/2018/09/07/blog/%E5%81%87%E5%89%8D%E7%9A%84%E5%85%B4%E5%A5%8B/pic2.jpeg" width="490px" alt="云蒸霞蔚的晚霞"><span class="image-caption">云蒸霞蔚的晚霞</span><p>追求简单不知道对错与否，我只想看到一(两三)人安详的背影，该有多好！</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>评论系统Valine实现邮件提醒</title>
      <link href="2018/09/04/tech_stack/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/"/>
      <url>2018/09/04/tech_stack/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/</url>
      
        <content type="html"><![CDATA[<p>对于我这个用静态博客的人来说，最难受的就是两件事儿，一是内容加密，一个就是评论系统了。前者还好说，大不了隐私的内容就不发了，后者还是让我费了一翻力气。几经对比最后选择了Valine评论系统，之所以选择它主要的就是看在外观比较简洁、加载速度快和并且支持MD。但是它也有一些问题，因为是无后端评论系统，所以不能进行后端信息验证，导致刷了无数匿名和无联系方式的内容。此外，其自带邮件提醒配置方法依托LeanCloud重置密码邮件模板功能，每天发送次数受限、不能定位具体页面等多方面问题。</p><p>对于博客系统评论无提醒是不可接受的，于是四处搜索解决办法，找到了一个开源项目，<a href="https://panjunwen.com/valine-admin-document/">D大神的Valine-Admin</a>，结果还发生了一些小误会，把原作者弄错了，实在抱歉，博主很厉害，把常用功能方面几乎都实现了。我也按照文档配置了一下，可能是我比较笨试了几遍也没成功，主要是我之前用的是腾讯企业邮，实在搞不懂他的用户账号和管理员账号之间的关系，晦涩难懂。于是乎我注销了腾讯企业邮箱，开通网易免费企业邮箱，感觉还不错。</p><p>由于之前配置多次也没成功的烦躁所以也没再试，于是生出了自己写的一个的想法，一来这样可以知道每一步的实现，控制问题来源也更爽一些，且自由度更高一些，二来也是一个不错的学习机会。本来想用JAVA开发的由于LeanCloud免费版配置过低，运行JAVA可能会卡顿，甚至挂掉，于是改用Python实现。</p><p>本项目基本思路参考上面博主，所以一些配置信息基本相同，配置步骤如下：</p><h3 id="配置valine评论系统"><a class="markdownIt-Anchor" href="#配置valine评论系统"></a> 配置Valine评论系统</h3><p>按照<a href="https://valine.js.org/quickstart.html">Valine文档</a>配置评论系统，注意不要配置邮件提醒，如果按照其文档方式配置邮件提醒，将会收到两次邮件。</p><h3 id="配置云引擎"><a class="markdownIt-Anchor" href="#配置云引擎"></a> 配置云引擎</h3><p>登陆<a href="https://leancloud.cn/dashboard/login.html#/signin">LeanCloud官网</a></p><ul><li>布署云引擎项目<br>将<code>https://github.com/WindusL/LeanCloud-ACE.git</code>填入，点击保存。</li></ul><p><img src="/2018/09/04/tech_stack/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/QQ20180903-164838@2x.png" alt="配置代码库"><span class="image-caption">配置代码库</span></p><ul><li>配置环境变量</li></ul><pre class="highlight"><code class>SITE_NAME  站点名称作为邮箱发送人名称　如：风尘SITE_URL　站点域名　如：https://blog.fcwalkers.comSMTP_USER 邮箱用户名SMTP_PASS 邮箱密码SMTP_HOST 邮箱的SMTP服务地址　如：网易smtp.ym.163.comSMTP_PORT 邮箱的SMTP服务端口  如：网易25SENDER_NAME 发送邮件的主题 如：风尘博客－评论提醒</code></pre><p><img src="/2018/09/04/tech_stack/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/QQ20180903-161530@2x.png" alt="配置信息"><span class="image-caption">配置信息</span></p><ul><li>域名绑定</li></ul><p><img src="/2018/09/04/tech_stack/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/QQ20180903-165808@2x.png" alt="域名绑定"><span class="image-caption">域名绑定</span></p><p>然后配置域名解析到绑定后提示的 CNAME 地址：<br><img src="/2018/09/04/tech_stack/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9FValine%E5%AE%9E%E7%8E%B0%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92/202006122ifkljfw.png" alt="域名解析"><span class="image-caption">域名解析</span></p><h3 id="休眠策略"><a class="markdownIt-Anchor" href="#休眠策略"></a> 休眠策略</h3><p>由于LeanCloud免费实例有<a href="https://leancloud.cn/docs/leanengine_plan.html#hash633315134">强制休眠策略</a>，休眠时评论实例会被启动，但是此次不会再发送邮件，下次请求才会发送。</p><p>针对此问题，<strong>Valine-Admin</strong>采用的是Linux服务器cron定时访问策略激活服务器，但是如果没有Linux服务器比较麻烦。经过我自己的研究和实践后，发现一种解决思路，就是在评论代码加载页面加入一段ajax代码来访问实例，达到激活的目的，此种方法可以达到效果是用户可能发生评论动作前激活，页面半小时无人访问后休眠，大部分时间可以保证正常使用。</p><pre class="highlight"><code class="js"><span class="hljs-keyword">new</span> Valine(&#123;            <span class="hljs-attr">el</span>: <span class="hljs-string">'#vcomments'</span> ,            <span class="hljs-attr">appId</span>: <span class="hljs-string">''</span>,            <span class="hljs-attr">appKey</span>: <span class="hljs-string">''</span>,            <span class="hljs-attr">notify</span>:<span class="hljs-literal">false</span>,             <span class="hljs-attr">verify</span>:<span class="hljs-literal">true</span>,             <span class="hljs-attr">avatar</span>:<span class="hljs-string">'mm'</span>,             <span class="hljs-attr">placeholder</span>: <span class="hljs-string">'做一个有头有脸的发言人！'</span>        &#125;);<span class="hljs-comment">// 激活leancloud</span>$(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  $.<span class="hljs-keyword">get</span>('http://lcapi.fcwalkers.com');　// lcapi.fcwalkers.com为上面配置的web主机域名&#125;);</code></pre><p>此方法需要项目中引入JQuery，也可以使用隐藏的iframe标签达到相同目的(可能影响页面加载速度)。目前还在测试中，暂时没发现问题，可以根据自己的喜好选择自己喜欢的方式。</p><h3 id="功能实现"><a class="markdownIt-Anchor" href="#功能实现"></a> 功能实现</h3><p>目前此项目仅实现了表单验证和邮件通知的简单功能，后续可能会按需要增加如下功能：</p><blockquote><p><s>后端表单信息验证</s><br><s>基于SMTP配置评论邮件通知</s><br>基于Akismet垃圾评论过滤<br>自定义邮件主题<br>评论管理页面</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链技术分享</title>
      <link href="2018/09/03/tech_stack/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
      <url>2018/09/03/tech_stack/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="区块链基本概念"><a class="markdownIt-Anchor" href="#区块链基本概念"></a> 区块链基本概念</h2><p>区块链的本质是一个分布式的公共账本，从技术角度来讲就是一个分布式的数据库。任何人都可对这个账本进行核查，但不存在单一的用户可以对它控制。最大特点是：去中心化、</p><p>区块链本身不是新技术，而是一种技术架构。区块链原本是比特币等加密货币存储数据的一种独特方式，是一种自引用的数据结构，用来存储大量交易信息，每条记录从后向前有序链接起来，具备公开透明、无法篡改、方便追溯的特点。</p><p><strong>交易(transaction)</strong>：一次对账本的操作，导致状态改变，如添加一条转账记录。</p><pre class="highlight"><code class>交易包含大致内容：付款地址付款人资金来源交易ID交易金额收款人地址时间戳交易是否已经处理交易输入之和是否大于输出之和...省略</code></pre><p>以上内容检查都通过，交易将被标记为合法未确认交易，并在网络上广播。</p><p><strong>区块(block)</strong>：记录一段时间内所有交易状态的结果，是对当前账本状态的一次共识。</p><pre class="highlight"><code class>区块包含大致内容：4字节的区块大小信息80字节的区块头信息交易个数计数器所有交易具体内容上一个区块头的SHA256值　(区块成为区块链的关键字段)难度指标Nonce串...省略</code></pre><p><strong>链(chain)</strong>：由区块按照时间顺序串联而成，是整个账本状态变化的日志记录。</p><h2 id="比特币运行原理与动作机制"><a class="markdownIt-Anchor" href="#比特币运行原理与动作机制"></a> 比特币运行原理与动作机制</h2><h3 id="以物易物的村庄"><a class="markdownIt-Anchor" href="#以物易物的村庄"></a> 以物易物的村庄</h3><p><img src="/2018/09/03/tech_stack/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/QQ20180822-114443@2x.png" alt="物换物"><span class="image-caption">物换物</span></p><h3 id="实物货币"><a class="markdownIt-Anchor" href="#实物货币"></a> 实物货币</h3><p>由于以物易物实在太不方便，所以出现了实物货币<br><img src="/2018/09/03/tech_stack/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/QQ20180822-115739@2x.png" alt="实物货币"><span class="image-caption">实物货币</span></p><h3 id="符号货币纸币"><a class="markdownIt-Anchor" href="#符号货币纸币"></a> 符号货币(纸币)</h3><p>实物货币的弊端也出现了。因为村子附近金矿并不多，开采和冶炼金子太费时费力了。<br><img src="/2018/09/03/tech_stack/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/QQ20180822-142339@2x.png" alt="纸币"><span class="image-caption">纸币</span></p><p>老村长就承担了政府和银行的角色。</p><h3 id="中央系统虚拟货币"><a class="markdownIt-Anchor" href="#中央系统虚拟货币"></a> 中央系统虚拟货币</h3><p>老村长由于每天都要核对大量的旧纸币，写新的纸币，还要把各种账目仔细做好记录。一来二去，老村长操劳过度不幸驾鹤西去了。老村长儿子二狗子接笔负责。</p><p>二狗子发明虚拟货币，每个村民都不需要用实物支付，支付过程变成了二狗子那边维护的账本上数字的变更。</p><p><img src="/2018/09/03/tech_stack/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/QQ20180822-143251@2x.png" alt="虚拟货币"><span class="image-caption">虚拟货币</span></p><h3 id="分布式虚拟货币"><a class="markdownIt-Anchor" href="#分布式虚拟货币"></a> 分布式虚拟货币</h3><p>中央系统虚拟货币存在问题：</p><ul><li>这个体系完全依赖于账本持有人的个人信用，如果这个人不守规矩，随意篡改账本，那么整个货币系统就会崩溃</li><li>如果这个人家里失火或者账本失窃，同样也会为整个体系带来毁灭性的打击</li></ul><p>村里能人中本聪，计了一套不依赖任何中央处理人的叫比特币的虚拟货币系统，可以解决上述问题。</p><p>最小单位：聪　(10<sup>-8</sup> 比特币）</p><h4 id="账簿公开"><a class="markdownIt-Anchor" href="#账簿公开"></a> 账簿公开</h4><p>对现有账簿进行如下改造：</p><ol><li>账簿上不再记载每户村民的余额，而只记载每一笔交易。即记载每一笔交易的付款人、收款人和付款金额。只要账簿的初始状态确定，每一笔交易记录可靠并有时序，当前每个人持有多少钱是可以推算出来的。</li><li>账簿由私有改为公开，只要任何村民需要，都可以获得当前完整的账簿，账簿上记录了从账簿创建开始到当前所有的交易记录。</li></ol><h4 id="hash算法"><a class="markdownIt-Anchor" href="#hash算法"></a> HASH算法</h4><p>能将任意长度二进制明文串映射为较短(通常是固定长度)二进制串(Hash值)，并且***不同明文很难映射为相同的Hash值***</p><p>Hash算法不是一种加密算法，但是常用于对口令的保存上，如后台可以保存密码的Hash值，防止数据库泄露，密码明文暴露。</p><pre class="highlight"><code class>特点：正向快速逆向困难 (有限时间内基本不可能逆推出明文)输入敏感 (原始信息发生一点变化，新产生Hash值会发生很大变化)冲突避免 (很难找到两段明文不同的内容，Hash值一致的情况)</code></pre><ul><li>常见算法</li></ul><p>MD4、MD5、SHA</p><blockquote><p>目前MD5、SHA1已经被破解，一般推荐使用SHA2-256或其它更安全的算法应用于商业场景。</p></blockquote><h4 id="加密算法"><a class="markdownIt-Anchor" href="#加密算法"></a> 加密算法</h4><table><thead><tr><th>算法类型</th><th>特点</th><th>优势</th><th>缺陷</th><th>代表算法</th></tr></thead><tbody><tr><td>对称加密</td><td>加解密密钥相同</td><td>计算效率高　加密效率高</td><td>需提前共享密钥易泄露</td><td>DES　3DES</td></tr><tr><td>非对称加密</td><td>加解密密钥不相关</td><td>无需提前共享密钥</td><td>计算效率低存</td><td>RSA</td></tr></tbody></table><h4 id="身份与签名机制公钥加密系统"><a class="markdownIt-Anchor" href="#身份与签名机制公钥加密系统"></a> 身份与签名机制（公钥加密系统）</h4><p>账户地址经过Hash160或SHA256及编码运算后生成的160位(20字节)的字符串。一般可见的地址都是对其进行Base58Check编码优化后的字符串。</p><p>这套机制下，任何人都不使用真实身份交易，而是使用一个唯一的代号交易。比特币地址是一个由数字和字母组成的字符串，由公钥生成的比特币地址以数字<code>1</code>开始，可以看作是收款账户。</p><p>每个帐户其实就是一对公私匙，有私匙的人就是帐户的主人。如果 A 要给 B 转一笔钱，A 就把钱的数量加上 B 的公匙，用自己的钥匙签名。而 B 看到这个签名，就可以了解，的确是 A 转给了他如数的 BTC 。</p><hr><p>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</p><hr><ul><li>输入与输出</li></ul><p>整个区块链不记录输入，只记录输出，输入实际上是对上一次输出的引用。所有输出总和就是该账户</p><ul><li>找零</li></ul><p><img src="/2018/09/03/tech_stack/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/QQ20180822-171411@2x.png" alt="账户交易"><span class="image-caption">账户交易</span></p><p>A向B支付8BTC，需要使用包含20BTC的未消费支出，设置支出为8BTC。比特币会把消费时所用的地址余额设置为0，当支付金额小于可用余额时，必须设置<code>找零地址</code>。该地址可以是原有账户地址，也可以是一个新地址。</p><blockquote><p>因为比特币每一笔交易在全球公链上永久可见，因此任何人都可以在上面跟踪查询，容易暴露隐私，可以把找零地址设置为一个新地址，使其追踪增加难度。</p></blockquote><h4 id="区块链原理"><a class="markdownIt-Anchor" href="#区块链原理"></a> 区块链原理</h4><ul><li>创世块</li></ul><p>区块链的第一个区块被称为<code>创世块</code>。现在比特币把创世区块号定为0</p><p>创世块50BTC交易被发送到如下地址：<br>1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa 该交易被称为创世交易。</p><blockquote><p>比特币把区块和交易存储在两个数据库中，当客户端发现区块数据库为空时，就会用代码直接生成一个创世块，但没有把创世交易存储到客户端的交易数据库中，当收到创世交易的输出交易时，因为在交易数据库中找不到记录，而会拒绝此次交易。</p></blockquote><p>创世区块信息如下：<br><img src="/2018/09/03/tech_stack/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/QQ20180822-173940@2x.png" alt="创世区块内容"><span class="image-caption">创世区块内容</span></p><ul><li>区块长链与短链</li></ul><p>每个区块必须包含前一个区块链的Hash值，所以使得从创世块当现在块开始形成了一条块链，每个区块必须按照时间顺序跟在前一个区块之后。诚实的矿工只会在最长链的基础上生成后续区块。所以想要改变一个已经在区块链上存在很长时间的区块，从计算上来说是不可行的。这些特性使得<strong>双花</strong>比特币非常困难。</p><p><img src="/2018/09/03/tech_stack/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/QQ20180822-174928@2x.png" alt="区块链示意图"><span class="image-caption">区块链示意图</span></p><p>当两个区块生成时间仅相差几秒时，可能产生区块链的一个分叉。当出现此种现象时，矿工节点会根据区块时间，在先收到的区块基础上继续挖矿，哪个区块先出现哪个区块就会被包括进总链，因为这条链更长。短区块链中的交易将被重新加入到交易池，并被包括到另一个区块中。短区块链中的区块收益不会出现在长区块链中，因而这些区块收益将会丢失。</p><h4 id="挖矿原理pow工作证明"><a class="markdownIt-Anchor" href="#挖矿原理pow工作证明"></a> 挖矿原理(PoW，工作证明)</h4><ul><li>挖矿收益来源</li></ul><p>交易费：最低0.0001BTC<br>系统本身产出，目前每10分钟左右产出一个不到1M的区块(记录10分钟内验证过的交易)，最初系统每个区块的成功提交者奖励50个BTC，每隔21万个区块自动减半，即4年时间，最终比特币总量稳定在2100万个。因此比特币是一种通缩的货币。</p><p>系统每隔两周(即2016个区块)会根据上一周挖矿时间来调整挖矿难度，调节生成区块的时间稳定在10分钟左右。</p><ul><li>计算原理：</li></ul><p><code>SHA256(SHA256(block_header+nonce))&lt; difficulty</code></p><p>将比特币的80个字节长度的区块头数据进行两次SHA256运算，运算结果就是一个256位（32字节）长度的字符串。通过比较与当前难度值的大小判断当前区块是否合法。合法则挖矿成功，反之Nonce+1重复上述动作。</p><p>Nonce理论上是随机数，但实际情况下，因为Hash值不可逆只有穷举法才能最容易计算出目标值，所以每次计算Nonce从0开始穷举。</p><ul><li>难度值规则</li></ul><p>挖矿计算目标值target是一个十六进制以连续0开头，且连续0越多，越符合命中规则。</p><p>Hash值：<code>00000000000000001e8d6829a8a21adc5d38d0a473b144b6765798e61f98bd1d</code></p><pre class="highlight"><code class>比如：当前target值为连续20个0开头的十六进制数字；一个不透明的口袋里有俩形状一模一样的乒乓球，一个红色（1），一个蓝色（0）；每次抓阄抓到蓝色则标记位0，红色标记位1，那么如果矿工想要“挖矿”成功，意味着：至少连续20次抓阄均抓到篮球。</code></pre><hr><p><em><strong>本文中村庄故事引用自<a href="http://blog.codinglabs.org/articles/bitcoin-mechanism-make-easy.html">一个故事告诉你比特币的原理及运作机制</a>，部分内容来源于网络。</strong></em></p><hr>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
            <tag> 比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于本站的一些声明</title>
      <link href="2018/08/30/blog/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A3%B0%E6%98%8E/"/>
      <url>2018/08/30/blog/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99%E7%9A%84%E4%B8%80%E4%BA%9B%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>最近在回顾一些Python相关的知识，也发了一些相关方面的学习笔记的文章。在自己这一亩三分地发这些东西，其实就是想自己时间长忘了的时候跟据自己当时的理解能快速的回忆起来。本来是没什么大不了的不值一提的事情，偏偏有些人拿这东西做文章，所以我觉得有必要做一些声明了，省得类似这种苍蝇到处乱叫。</p><p>事情得从一条评论说起，昨天早上起来后在我博客里面看见一条匿名评论：<em><strong>你这是从××地方搬运来的吧，不需要声明一下吗？</strong></em><br>看到这条评论让我立马就感觉不爽了，其实从我笔记发表时间可以看出，从8月初开始总结这些内容，用了一个多月的时间，结果被一个缩头缩脑的质问是<strong>搬来的</strong>。</p><p>首先，本站部分技术或图片内容来源于网络，毕竟本人水平有限，只能自己创造部分内容，但本站绝对保证，本站大部分内容，都是根据自己的理解方式一字一字手打出来(包括同样内容)，绝对不是简单的复制而来。如对本站内容有任何异议请及时与我沟通，我会认真采纳每位朋友的意见，但前提是语气平和、心态平稳，并且留下您尊贵的联系方式，以便沟通。做一个有头有脸的发言人，对于匿名带刺评论，恕不接待，一律删除，并且本站此刻开始正式关闭匿名评论功能，给大家带来不便，敬请谅解！</p><p>关于近期发表的Python系列学习笔记，部分内容参考了<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰</a>老师的教程，还有一些其它大神包括<a href="https://ilovefishc.com/">小甲鱼</a>老师等以及自己的实践想法总结而来，在此非常感谢几位老师的解惑。</p><p>其次，本站技术相关内容仅供自己学习而用，并不是权威教程，其中不乏错误理解、错别字及表述不清等问题，欢迎大家指正共同交流。</p><p>最后，<em><strong>再次声明本站部分内容或图片来源于网络，仅供自己学习研究使用，如有侵权，请联系删除。</strong></em></p><div style="text-align:right;">完！<p>2018年8月30日</p></div>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python3网络编程与电子邮件(v3.7)</title>
      <link href="2018/08/22/python/Python3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6(v3.7)/"/>
      <url>2018/08/22/python/Python3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6(v3.7)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2><p>IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。</p><p>IPv4实际上是一个32位整数，通常采用点分十进制表示法表示。如：<code>192.168.0.1</code><br>IPv6实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示。如：<code>2001:0db8:85a3:0042:1000:8a2e:0370:7334</code></p><p>TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。<br>许多常用的更高级的协议都是建立在TCP协议基础上的，比如用于浏览器的HTTP协议、发送邮件的SMTP协议等。</p><h3 id="tcp编程"><a class="markdownIt-Anchor" href="#tcp编程"></a> TCP编程</h3><p>Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。</p><pre class="highlight"><code class="python"><span class="hljs-comment">#!/usr/bin/env python3</span><span class="hljs-comment"># -*-coding: utf-8 -*-</span><span class="hljs-string">"""服务端代码AF_INET　指定使用IPv4协议AF_INET6　指定使用IPv6协议SOCK_STREAM　指定使用TCP协议SOCK_DGRAM　指定使用UDP协议"""</span><span class="hljs-comment"># 导入socket模块</span><span class="hljs-keyword">import</span> socket, threading<span class="hljs-comment"># 创建socket</span>s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<span class="hljs-comment"># 监听接口</span>s.bind((<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">9999</span>))<span class="hljs-comment"># 等待最大连接数</span>s.listen(<span class="hljs-number">5</span>)print(<span class="hljs-string">'Waiting for connection...'</span>)<span class="hljs-comment"># 定义线程处理方法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tcplink</span><span class="hljs-params">(*args)</span>:</span>    print(<span class="hljs-string">'Accept new connection from %s:%s...'</span> % addr)    sock.send(<span class="hljs-string">b'Welcome!'</span>)    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        <span class="hljs-comment"># 接收消息</span>        data = sock.recv(<span class="hljs-number">1024</span>)        <span class="hljs-comment"># 遇到exit时退出连接</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data <span class="hljs-keyword">or</span> data.decode(<span class="hljs-string">'utf-8'</span>) == <span class="hljs-string">'exit'</span>:            <span class="hljs-keyword">break</span>        <span class="hljs-comment"># 发送接收加工后的消息</span>        sock.send(<span class="hljs-string">'Hello %s'</span>.encode(<span class="hljs-string">'utf-8'</span>) % data)        print(data.decode(<span class="hljs-string">'utf-8'</span>))    <span class="hljs-comment"># 关闭当前连接</span>    sock.close()    print(<span class="hljs-string">'Connection from %s:%s closed.'</span> % addr)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-comment"># 接收一个新连接</span>    sock, addr = s.accept()    print(<span class="hljs-string">'---&gt;'</span>,sock,addr)    <span class="hljs-comment"># 创建新线程来处理TCP连接</span>    t = threading.Thread(target=tcplink, args=(sock, addr))    t.start()</code></pre><pre class="highlight"><code class="python"><span class="hljs-comment">#!/usr/bin/env python3</span><span class="hljs-comment"># -*-coding: utf-8 -*-</span><span class="hljs-string">"""客户端代码"""</span><span class="hljs-keyword">import</span> sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<span class="hljs-comment"># 连接到服务端</span>s.connect((<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">9999</span>))<span class="hljs-comment"># 接收欢迎消息</span>print(s.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">'utf-8'</span>))<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-comment"># 输入发送的消息</span>    msg = input(<span class="hljs-string">"请输入内容："</span>)    <span class="hljs-comment"># 发送消息</span>    s.send(msg.encode(<span class="hljs-string">'utf-8'</span>))    <span class="hljs-comment"># 接收消息</span>    data = s.recv(<span class="hljs-number">1024</span>)    print(<span class="hljs-string">'回复：'</span>,data.decode(<span class="hljs-string">'utf-8'</span>))    <span class="hljs-comment"># 输入exit退出连接会话</span>    <span class="hljs-keyword">if</span> msg == <span class="hljs-string">'exit'</span>:        <span class="hljs-keyword">break</span>;<span class="hljs-comment"># 关闭连接</span>s.close()print(<span class="hljs-string">'已退出会话'</span>)</code></pre><blockquote><p>TCP是建立可靠连接，并且通信双方都可以以流的形式发送数据。相对TCP，UDP则是面向无连接的协议。使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，UDP传输数据不可靠，但它的优点是和TCP比，速度快。</p></blockquote><h2 id="电子邮件"><a class="markdownIt-Anchor" href="#电子邮件"></a> 电子邮件</h2><p>Pythoy提供<code>mail</code>(构造邮件)和<code>smtplib</code>(发送邮件)两个模块对SMTP支持。</p><pre class="highlight"><code class="python"><span class="hljs-comment">#!/usr/bin/env python3</span><span class="hljs-comment"># -*-coding: utf-8 -*-</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> logging<span class="hljs-keyword">import</span> smtplib<span class="hljs-keyword">from</span> email.header <span class="hljs-keyword">import</span> Header<span class="hljs-keyword">from</span> email.utils <span class="hljs-keyword">import</span> formataddr<span class="hljs-keyword">from</span> email.mime.text <span class="hljs-keyword">import</span> MIMETextlogging.basicConfig(level=logging.DEBUG)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MailSMTP</span><span class="hljs-params">(object)</span>:</span>    __site_name = os.environ[<span class="hljs-string">'SITE_NAME'</span>]    __smtp_user = os.environ[<span class="hljs-string">'SMTP_USER'</span>]    __smtp_pass = os.environ[<span class="hljs-string">'SMTP_PASS'</span>]    __smtp_host = os.environ[<span class="hljs-string">'SMTP_HOST'</span>]    __smtp_port = os.environ[<span class="hljs-string">'SMTP_PORT'</span>]    __sender_name = os.environ[<span class="hljs-string">'SENDER_NAME'</span>]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, to_addr)</span>:</span>        self.__to_addr = to_addr    <span class="hljs-comment"># 发送邮件</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_mail</span><span class="hljs-params">(self, msg)</span>:</span>        logging.debug(msg)        <span class="hljs-comment"># 封装消息</span>        message = MIMEText(msg, <span class="hljs-string">'html'</span>, <span class="hljs-string">'utf-8'</span>)        message[<span class="hljs-string">'From'</span>] = formataddr([<span class="hljs-string">'%s'</span> % self.__site_name, <span class="hljs-string">'%s'</span> % self.__smtp_user])        message[<span class="hljs-string">'To'</span>] = formataddr([<span class="hljs-string">'我'</span>, <span class="hljs-string">'%s'</span> % self.__to_addr[<span class="hljs-number">0</span>]])        message[<span class="hljs-string">'Subject'</span>] = Header(<span class="hljs-string">'来自%s...'</span> % self.__sender_name, <span class="hljs-string">'utf-8'</span>)        <span class="hljs-comment"># 设置服务参数</span>        server = smtplib.SMTP(self.__smtp_host, self.__smtp_port)        server.set_debuglevel(<span class="hljs-number">1</span>)        server.login(self.__smtp_user, self.__smtp_pass)        server.sendmail(self.__smtp_user, self.__to_addr, message.as_string())        server.quit()        <span class="hljs-meta">&gt;&gt;&gt; </span>to_addr = [],msg = <span class="hljs-string">''</span>    <span class="hljs-meta">&gt;&gt;&gt; </span>mail_smtp = MailSMTP(to_addr)<span class="hljs-meta">&gt;&gt;&gt; </span>mail_smtp.send_mail(msg)    </code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Python3学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3进程与线程(v3.7)</title>
      <link href="2018/08/21/python/Python3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B(v3.7)/"/>
      <url>2018/08/21/python/Python3%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B(v3.7)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="多进程"><a class="markdownIt-Anchor" href="#多进程"></a> 多进程</h2><h3 id="unix-like-进程"><a class="markdownIt-Anchor" href="#unix-like-进程"></a> Unix-like 进程</h3><p>Unix/Linux操作系统提供了一个fork()系统调用，与普通函数不同，该函数调用一次返回两次。因为操作系统把当前进程(父进程）复制一份(子进程)，然后分别在父进程和子进程返回。子进程永远返回0，父进程返回子进程的ID。Python在os模块封装了常见的系统调用。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> osprint(<span class="hljs-string">'Process (%s) starting...'</span> % os.getpid())pid = os.fork()<span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span> :    print(<span class="hljs-string">'child process (%s) , parent process is (%s) '</span> % (os.getpid(),os.getppid()))<span class="hljs-keyword">else</span> :    print(<span class="hljs-string">'(%s) just create child process (%s) '</span> % (os.getpid(),pid))执行结果：Process (<span class="hljs-number">51481</span>) starting...(<span class="hljs-number">51481</span>) just create child process (<span class="hljs-number">51482</span>)child process (<span class="hljs-number">51482</span>) , parent process <span class="hljs-keyword">is</span> (<span class="hljs-number">51481</span>)</code></pre><h3 id="跨平台进程"><a class="markdownIt-Anchor" href="#跨平台进程"></a> 跨平台进程</h3><blockquote><p>Windows系统没有fork调用，想要在Window平台实现需要使用跨平台版本多进程模块<code>multiprocessing</code>，该模块提供了一个<code>Process</code>进程对象。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<span class="hljs-keyword">import</span> os<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_proc</span><span class="hljs-params">(name)</span>:</span>    print(<span class="hljs-string">'Run child process %s (%s)...'</span> % (name, os.getpid()))<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    print(<span class="hljs-string">'Parent process (%s)'</span> % os.getpid())    p = Process(target=run_proc, args=(<span class="hljs-string">'test'</span>,))    print(<span class="hljs-string">'Child process will start.'</span>)    p.start()    p.join()    print(<span class="hljs-string">'Child process end.'</span>)    执行结果：Parent process (<span class="hljs-number">61595</span>)Child process will start.Run child process test (<span class="hljs-number">61596</span>)...Child process end.</code></pre><p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用<code>start()</code>方法启动，<code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p><h3 id="进程池pool"><a class="markdownIt-Anchor" href="#进程池pool"></a> 进程池Pool</h3><p>当要启用大量子进程时，可以使用进程池指创建子进程。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> os,time,random<span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">long_time_task</span><span class="hljs-params">(name)</span>:</span>    print(<span class="hljs-string">'Run task %s (%s)...'</span> % (name, os.getpid()))    start = time.time()    time.sleep(random.random() * <span class="hljs-number">3</span>)    end = time.time()    print(<span class="hljs-string">'Task %s runs %0.2f seconds.'</span> % (name, (end - start)))<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    print(<span class="hljs-string">'Parent process %s.'</span> % os.getpid())    p = Pool(<span class="hljs-number">4</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):        p.apply_async(long_time_task, args=(i,))        print(<span class="hljs-string">'Waiting for all subprocesses done...'</span>)    p.close()    p.join()    print(<span class="hljs-string">'All subprocesses done.'</span>)执行结果：Parent process <span class="hljs-number">71982.</span>Waiting <span class="hljs-keyword">for</span> all subprocesses done...Run task <span class="hljs-number">0</span> (<span class="hljs-number">71983</span>)...Run task <span class="hljs-number">1</span> (<span class="hljs-number">71984</span>)...Run task <span class="hljs-number">2</span> (<span class="hljs-number">71985</span>)...Run task <span class="hljs-number">3</span> (<span class="hljs-number">71986</span>)...Task <span class="hljs-number">1</span> runs <span class="hljs-number">0.89</span> seconds.Run task <span class="hljs-number">4</span> (<span class="hljs-number">71984</span>)...Task <span class="hljs-number">2</span> runs <span class="hljs-number">1.02</span> seconds.Task <span class="hljs-number">3</span> runs <span class="hljs-number">1.86</span> seconds.Task <span class="hljs-number">0</span> runs <span class="hljs-number">1.95</span> seconds.Task <span class="hljs-number">4</span> runs <span class="hljs-number">1.12</span> seconds.All subprocesses done.</code></pre><p><code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>。</p><p><strong>注意：</strong> 上面先执行完task<code>0</code>、<code>1</code>、<code>2</code>、<code>3</code>而task<code>4</code>在前面某个task执行完毕才执行，这是因为前面Pool大小设置为4，因此最多同时执行4个进程，这是Pool有意设计的限制，并不是操作系统的限制。Pool的默认大小是CPU核数。</p><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2><p>Python的线程是真正的 <em><strong>Posix Thread</strong></em>，而不是模拟出来的线程。<br>Python的标准库提供了两个模块：<code>_thread</code>和<code>threading</code>，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p><p>启动一个线程就是把一个函数传入<strong>Thread</strong>并创建实例实例，然后调用<code>start()</code>方法：</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> threading, time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>:</span>    g = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>))    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> g:        print(<span class="hljs-string">'thread %s is running %s'</span> % (threading.current_thread().getName(), n))        time.sleep(<span class="hljs-number">2</span>)    print(<span class="hljs-string">'thread %s ended'</span> % threading.current_thread().getName())print(<span class="hljs-string">'thread %s is running...'</span> % threading.current_thread().getName())t = threading.Thread(target=func, name=<span class="hljs-string">'FuncThread'</span>)t.start() <span class="hljs-comment">#开始一个线程</span>t.join()　<span class="hljs-comment">#同步FuncThread线程</span>print(<span class="hljs-string">'thread %s ended.'</span> % threading.current_thread().name)</code></pre><h3 id="线程锁"><a class="markdownIt-Anchor" href="#线程锁"></a> 线程锁</h3><p>多线程和多进程的最大不同之处在于，多进程中同一变量各自有一拷贝存在每个进程中互不影响。而多线程中所有变量由所有线程共享。因此，线程之间共享数据最大的危险在于多个线程同时改一个变量。为避免这种情况，Python引入线程锁<code>threading.Lock()</code>。</p><pre class="highlight"><code class="python">lock = threading.Lock()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run_thread</span><span class="hljs-params">(n)</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100000</span>):        <span class="hljs-comment"># 获取锁</span>        lock.acquire()        <span class="hljs-keyword">try</span>:            <span class="hljs-comment"># 修改变量</span>            ...        <span class="hljs-keyword">finally</span>:            <span class="hljs-comment"># 释放锁</span>            lock.release()</code></pre><p>当多个线程同时执行<code>lock.acquire()</code>时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用try…finally来确保锁一定会被释放。</p><h2 id="多核cpu"><a class="markdownIt-Anchor" href="#多核cpu"></a> 多核CPU</h2><p>正常情况多核CPU可以同时执行多个线程，要想把N核CPU跑满，必须启动N个死循环线程。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> threading, multiprocessing<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span>:</span>    x = <span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        x = x ^ <span class="hljs-number">1</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(multiprocessing.cpu_count()):    t = threading.Thread(target=loop)    t.start()</code></pre><p>上面代码在四核CPU上启动，监控发现只占用了100％左右的CPU也就是只使用了1核，而不是使用400％的CPU，因为Python解释器执行代码时有一个<code>GIL锁</code>(Global Interpreter Lock),任何线程执行前必须先获取GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p><blockquote><p>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p></blockquote><h2 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> ThreadLocal</h2><p><code>ThreadLocal</code>是一个全局变量，但每个线程都只能读写自己线程的独立副本互不干扰，并且通过ThreadLocal变量不用管理锁的问题，ThreadLocal内部会自己处理。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> threading<span class="hljs-comment"># 创建全局ThreadLocal对象</span>tl = threading.local()<span class="hljs-comment">#在线程内对tl.变量名进行读取和赋值</span>...代码省略</code></pre><h2 id="进程与线程比较"><a class="markdownIt-Anchor" href="#进程与线程比较"></a> 进程与线程比较</h2><p>要实现多任务，通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务。</p><p>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。<br>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</p><blockquote><p>多进程模式优点：稳定性高，一个子进程崩溃了，不会影响主进程和其他子进程。（主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低）。<br>多进程模式缺点：创建进程的代价大，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的。</p></blockquote><p>多线程模式通常比多进程快一点，但是也快不到哪去，多线程模式致命的缺点是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。</p><p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式。</p><h2 id="分布式进程"><a class="markdownIt-Anchor" href="#分布式进程"></a> 分布式进程</h2><p>暂无记录</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Python3学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3 IO编程(v3.7)</title>
      <link href="2018/08/20/python/Python3%20IO%E7%BC%96%E7%A8%8B(v3.7)/"/>
      <url>2018/08/20/python/Python3%20IO%E7%BC%96%E7%A8%8B(v3.7)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="文件读写"><a class="markdownIt-Anchor" href="#文件读写"></a> 文件读写</h2><p>Python内置读写文件函数，用法与C语言兼容。在磁盘上读写文件的功能都是由操作系统提供的，现代系统不允许普通程序直接操作磁盘。</p><h3 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h3><p>Python内置<code>open()</code>函数读取文件对象，如果文件不存在函数会抛出<code>IOError</code>错误。</p><pre class="highlight"><code class="python">f = open(<span class="hljs-string">'/Users/Windus/person.py'</span>, <span class="hljs-string">'r'</span>)f.read() <span class="hljs-comment">#读取全部内容</span></code></pre><blockquote><p>Python把内容读取到内存中，用str对象表示，<code>read()</code>会一次性读取所有内容，如果文件过大内存就会溢出，所以也可以调用<code>read(size)</code>函数限制每次最多读取多少字节(size)的内容;<code>readline()</code>每次读取一行;<code>readlines</code>一次读取所有内容并返回list。</p></blockquote><p>打开一个文件对象后，必须调用<code>close()</code>方法关闭，因为文件对象会占用操作系统资源，并且操作系统同一时间能打开的文件数量也是有限的。</p><pre class="highlight"><code class="python">f.close() <span class="hljs-comment">#关闭文件对象</span></code></pre><p>因为文件读写时有可能产生<code>IOError</code>，一旦出错后面<code>close()</code>将不会执行，为了保证无论错误与否都能关闭文件对象，需要使用<code>try...finally</code>。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">try</span> :    f = open(<span class="hljs-string">'/Users/Windus/person.py'</span>, <span class="hljs-string">'r'</span>)    print(f.read()) <span class="hljs-comment">#读取全部内容</span><span class="hljs-keyword">finally</span> :    <span class="hljs-keyword">if</span> f:        f.close()</code></pre><p>上面写法太过麻烦，Python中引入<code>with</code>语句来简化此写法，下面写法等同于try…finally写法，但是更加简洁且可省略调用close()方法：</p><pre class="highlight"><code class="python"><span class="hljs-keyword">with</span> open(<span class="hljs-string">'/Users/Windus/person.py'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:    print(f.read())</code></pre><p>open()函数还可以传入<code>encoding</code>参数设置文件编码，<code>errors</code>参数设置遇到错误如何处理，如设置<code>ignore</code>忽略错误。</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = open(<span class="hljs-string">'/Users/Windus/person_gbk.py'</span>, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">'gbk'</span>, errors=<span class="hljs-string">'ignore'</span>)</code></pre><h3 id="写文件"><a class="markdownIt-Anchor" href="#写文件"></a> 写文件</h3><p>写文件与读取唯一区别就是<code>open()</code>标识符参数设置为<code>w</code>或<code>wb</code>表示写入文本文件或二进制文件。然后反复调用<code>write()</code>方法把字符写入文件。</p><pre class="highlight"><code class="python">f = open(<span class="hljs-string">'/Users/Windus/person.py'</span>, <span class="hljs-string">'w'</span>)f.write(<span class="hljs-string">'Hello IO'</span>)f.close()</code></pre><blockquote><p>写入文件时，操作系统不一定会立刻把数据写入磁盘，而是放入内存中缓存起来，空闲时再写入。只有调用close()方法时，才能保证把没有写入磁盘的数据全部写入，所以写入文件后一定要调用close()方法，或者直接使用with语句。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-keyword">with</span> f = open(<span class="hljs-string">'/Users/Windus/person.py'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:    f.write(<span class="hljs-string">'Hello IO'</span>)</code></pre><p><strong>open()标识符w或wb时，如果文件已存在会被覆盖，如果想要追加信息需要使用a标识符，更多方法参考<a href="https://docs.python.org/3/library/functions.html#open">官方文档</a>。</strong></p><h3 id="file-like-object"><a class="markdownIt-Anchor" href="#file-like-object"></a> file-like Object</h3><p>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。</p><h2 id="内存io"><a class="markdownIt-Anchor" href="#内存io"></a> 内存IO</h2><p>有时候数据读写不一定是文件，也可以在内存中读写。此时可以使用StringIO和BytesIO。</p><h3 id="stringio"><a class="markdownIt-Anchor" href="#stringio"></a> StringIO</h3><p>StringIO需要引入io模块中的StringIO类，用于读写内存中的字符数据。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIOf = StringIO()f.write(<span class="hljs-string">'Hello StringIO'</span>)print(f.getvalue()) --&gt; Hello StringIO</code></pre><h3 id="bytesio"><a class="markdownIt-Anchor" href="#bytesio"></a> BytesIO</h3><p>BytesIO需要引入io模块中的BytesIO类，用于读写内存中的二进制数据。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIOf = BytesIO()f.write(<span class="hljs-string">'中文'</span>.encode(<span class="hljs-string">'utf-8'</span>))print(f.getvalue())</code></pre><p><strong>StringIO和BytesIO都可以通过初始化赋值，然后通过read()等方法读取</strong></p><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> StringIOf = StringIO(<span class="hljs-string">'abc\ndef'</span>)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> :    s = f.readline()    <span class="hljs-keyword">if</span> s == <span class="hljs-string">''</span>:        <span class="hljs-keyword">break</span>    print(s.strip())</code></pre><h2 id="文件与目录操作"><a class="markdownIt-Anchor" href="#文件与目录操作"></a> 文件与目录操作</h2><p>Python内置<code>os</code>模块提供了相关操作函数。os中的某些函数是与操作系统相关的，如：<code>os.uname()</code>在Windows系统中不提供此函数。</p><ul><li>os模块常用的属性和函数</li></ul><pre class="highlight"><code class="python">os.name <span class="hljs-comment">#操作系统类型posix表示系统是Linux、Unix或Mac OS X，如果是nt，表示Windows系统</span>os.uname()　<span class="hljs-comment">#系统详细信息（Windows系统不提供此函数）</span>os.environ　<span class="hljs-comment">#获取系统环境变量，可以通过get函数获取具体变量值os.environ.get('PATH')</span></code></pre><ul><li>文件与目录操作</li></ul><p>操作文件与目录的函数一部分放在os模块中，一部分放在os.path模块中，常用函数如下：</p><pre class="highlight"><code class="python">os.path.abspath(<span class="hljs-string">'.'</span>) <span class="hljs-comment">#查看当前目录的绝对路径</span>os.path.join(<span class="hljs-string">'/Users/Windus'</span>,<span class="hljs-string">'testdir'</span>) <span class="hljs-comment">#把两个路径合并为一个路径</span>os.mkdir(<span class="hljs-string">'/Users/Windus/testdir'</span>) <span class="hljs-comment">#创建目录</span>os.rmdir(<span class="hljs-string">'/Users/Windus/testdir'</span>) <span class="hljs-comment">#删除目录</span>os.rename(<span class="hljs-string">'test.txt'</span>,<span class="hljs-string">'test.py'</span>) <span class="hljs-comment">#文件重命名</span>os.remove(<span class="hljs-string">'test.py'</span>) <span class="hljs-comment">#删除文件</span></code></pre><blockquote><p>把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分。</p></blockquote><p>os模块中不存在复制文件函数，原因在于复制文件并非由操作系统提供的系统调用，可以通过文件读写完成复制，也可以通过<code>shutil</code>模块提供的<code>copyfile()</code>函数完成复制，此模块中还包含很多有用的方法，可以看作是os模块的补充模块。</p><h2 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h2><p>把变量从内存中变成可存储或传输的过程称之为序列化，Python中序列化叫作<code>pickling</code>，反序列化称为<code>unpickling</code>。Python提供了<code>pickle</code>模块实现序列化。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pickled = dict(name=<span class="hljs-string">'Bob'</span>, age=<span class="hljs-number">20</span>, score=<span class="hljs-number">88</span>)pickle.dumps(d) <span class="hljs-comment">#序列化一个字典对象为file-like Object</span>||Vf = open(<span class="hljs-string">'dump.txt'</span>, <span class="hljs-string">'wb'</span>)pickle.dump(d, f) <span class="hljs-comment">#序列化一个字典对象并写入文件</span>f.close()||Vf = open(<span class="hljs-string">'dump.txt'</span>, <span class="hljs-string">'rb'</span>)d = pickle.load(f) <span class="hljs-comment">#反序列化文件内容到一个对象</span>f.close()</code></pre><blockquote><p>pickle和所有编程语言序列化问题都一样，就是它只能作用于自己的语言(Python)，并且不同版本Python可能都不兼容。因此，只能用pickle保存不能成功反序列化也没有关系的不重要数据。</p></blockquote><h2 id="json"><a class="markdownIt-Anchor" href="#json"></a> JSON</h2><h3 id="字典的序列化操作"><a class="markdownIt-Anchor" href="#字典的序列化操作"></a> 字典的序列化操作</h3><p>在不同语言间传递对象，须要使用标准对象格式，如：XML。更好的方法是序列为JSON。Python内置<code>json</code>模块提供JSON处理。</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json<span class="hljs-meta">&gt;&gt;&gt; </span>d = dict(name=<span class="hljs-string">'Bob'</span>, age=<span class="hljs-number">20</span>, score=<span class="hljs-number">88</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>json.dumps(d) <span class="hljs-comment">#把Python对象转换为JSON对象</span><span class="hljs-string">'&#123;"age": 20, "score": 88, "name": "Bob"&#125;'</span></code></pre><p>JSON序列化通过<code>dumps()</code>方法返回一个str，内容就是标准的JSON。类似的，<code>dump()</code>方法可以直接把JSON写入一个file-like Object。<br>把JSON反序列化为Python对象通过<code>load()</code>或<code>loads()</code>方法，前者可以把JSON字符串反序列化，后者可以从<code>file-like Object</code>中读取字符串并反序列化。</p><h3 id="class的序列化操作"><a class="markdownIt-Anchor" href="#class的序列化操作"></a> class的序列化操作</h3><p>像上述方法通过<code>json.dumps()</code>序列化一个类会报<code>TypeError</code>，想要把一个类序列化需要使用<code>dumps()</code>方法的另一个可选参数<code>default</code>，只需要为一个类写一个转换函数即可：</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,age)</span>:</span>        self.name= name        self.age = age        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">person2dict</span><span class="hljs-params">(p)</span>:</span>    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">'name'</span>: p.name,        <span class="hljs-string">'age'</span>: p.age    &#125;    <span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> json<span class="hljs-meta">&gt;&gt;&gt; </span>p = Person(<span class="hljs-string">'张三'</span>,<span class="hljs-number">30</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>json.dumps(p,default=person2dict)&#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'张三'</span>,<span class="hljs-string">'age'</span>: <span class="hljs-number">30</span>&#125;</code></pre><blockquote><p>通过转换函数虽然实现了类的序列化，但是针对不同的类，需要写相应的转换类，可以通过<code>__dict__</code>来简化此问题。通常class都有一个<code>__dict__</code>属性，它就是一个dict用来存储实例变量，也有少数例外，比如定义了__slots__的class。</p></blockquote><pre class="highlight"><code class="python">json.dumps(p,default=<span class="hljs-keyword">lambda</span> obj: obj.__dict__)</code></pre><p>把JSON反序列化为一个Person对象实例，<code>loads()</code>方法首先转换出一个dict对象，然后，我们传入的<code>object_hook</code>函数负责把dict转换为Student实例：</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dict2person</span><span class="hljs-params">(d)</span>:</span>    <span class="hljs-keyword">return</span> Student(d[<span class="hljs-string">'name'</span>], d[<span class="hljs-string">'age'</span>], d[<span class="hljs-string">'score'</span>])d = &#123;<span class="hljs-string">'name'</span>: <span class="hljs-string">'张三'</span>,<span class="hljs-string">'age'</span>: <span class="hljs-number">30</span>&#125;json.loads(json_str, object_hook=dict2person)| 优 || 化 || 代 |V 码 V<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSONObject</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,d)</span>:</span>        self.__dict__ = d <span class="hljs-comment">#直接把json对象转换为dict</span><span class="hljs-meta">&gt;&gt;&gt; </span>data = json.loads(json_str, object_hook=JSONObject)<span class="hljs-meta">&gt;&gt;&gt; </span>data.name<span class="hljs-string">'张三'</span></code></pre><blockquote><p>通过<code>json.dumps()</code>序列化后中文默认使用ascii编码，如果想要显示真正的中文需要加上可选参数<code>ensure_ascii=False</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Python3学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3异常处理与调试(v3.7)</title>
      <link href="2018/08/19/python/Python3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95(v3.7)/"/>
      <url>2018/08/19/python/Python3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E8%AF%95(v3.7)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h2><p>Python异常处理采用　<code>try...except...finally</code>　语法，其中finally可以省略。</p><p>Python所有错误其实是class，所有错误类型都继承自<code>BaseException</code>。<br><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">常见错误类型</a></p><pre class="highlight"><code class="python"><span class="hljs-keyword">try</span> :    print(<span class="hljs-string">'代码开始'</span>)    n = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>    print(<span class="hljs-string">'结果：%s'</span> % n)<span class="hljs-keyword">except</span> ZeroDivisionError <span class="hljs-keyword">as</span> ze :    print(ze)<span class="hljs-keyword">finally</span> :     print(<span class="hljs-string">'代码结束'</span>)print(<span class="hljs-string">'END'</span>)</code></pre><blockquote><p>当try中代码出现错误时被except捕获，try中后续代码中止执行，继续执行except中代码，最后执行finally中代码，无论except是否捕获错误finally都会执行。except后还可加else条件：</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-keyword">try</span> :    ...<span class="hljs-keyword">except</span> ... :    ...<span class="hljs-keyword">except</span> ... :    ...<span class="hljs-keyword">else</span> :    <span class="hljs-comment">#未捕获到异常执行此处代码</span><span class="hljs-keyword">finally</span> :    <span class="hljs-comment">#最后执行的代码</span></code></pre><blockquote><p>代码中通过<code>try...except...finally</code>捕获异常后其后续代码可以继续运行，如前面代码最终打印出“<em><strong>END</strong></em>”，如果没有捕获异常此处打印“<em><strong>END</strong></em>”将不会被执行，程序将退出终止执行。</p></blockquote><h3 id="错误记录"><a class="markdownIt-Anchor" href="#错误记录"></a> 错误记录</h3><p>Python内置logging模块可以用来记录错误信息，并可通过配置记录成本地文件。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> logging <span class="hljs-comment">#导入模块</span><span class="hljs-keyword">try</span> :    ...<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e :    logging.exception(e)</code></pre><h3 id="错误抛出"><a class="markdownIt-Anchor" href="#错误抛出"></a> 错误抛出</h3><p>抛出错误通过关键字<code>raise</code>实现。</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(param)</span> :</span>　<span class="hljs-comment">#默认参数为5</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(param,(int,float)) :<span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'invalid param'</span>) <span class="hljs-comment">#抛出异常</span><span class="hljs-keyword">if</span> param &lt; <span class="hljs-number">10</span> :<span class="hljs-keyword">return</span> param;<span class="hljs-keyword">else</span> :<span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;</code></pre><h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2><p>程序调试一种方法是可以通过print()打印，但它的缺点是将来须要将其删除;而另一种方法就是断言(assert)。</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foot</span><span class="hljs-params">(n)</span> :</span>    n = int(n)    <span class="hljs-keyword">assert</span> n &lt; <span class="hljs-number">10</span> ,<span class="hljs-string">'n too large!'</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> - n<span class="hljs-meta">&gt;&gt;&gt; </span>foot(<span class="hljs-number">20</span>)</code></pre><blockquote><p>assert语法为<code>assert 表达式,'断言内容'</code>，表达式中为True则断言成功，否则断言失败抛出AssertionError异常和断言内容，程序中止执行。可以通过启动增加<code>-o</code>参数关闭断言。</p></blockquote><pre class="highlight"><code class="python">python -o　app.py </code></pre><p>第三种调试方法就是logging(日志），它可以输出到文件，并且可以设置<code>DEBUG</code>、<code>INFO</code>、<code>WARNING</code>、<code>ERROR</code>等几个级别。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> logginglogging.basicConfig(level=logging.INFO)logging.info(<span class="hljs-string">''</span>) <span class="hljs-comment">#INFO级别日志</span></code></pre><p>第四种是启动Python调试器pdb，让程序以单步方式运行，可以随时查看程序运行状态。</p><pre class="highlight"><code class="python">python -m pdb app.py</code></pre><blockquote><p><code>-m pdb</code>参数启动Python后，pdb将定位到下一步要执行的代码，输入<code>l</code>命令查看代码，输入<code>n</code>单步查看代码，可以输入<code>p 变量名</code>查看变量，输入<code>q</code>退出程序</p></blockquote><p>也可以在代码中嵌入<code>pdb.set_trace()</code>,程序会在此处暂时进入pdb调试环境，可以使用<code>p 变量名</code>查看变量或者使用<code>c</code>命令继续运行。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> pdb <span class="hljs-comment">#嵌入pdb需要引入pdb模块</span>代码...pdb.set_trace() <span class="hljs-comment"># 运行到这里会自动暂停</span>代码...</code></pre><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><h3 id="单元测试"><a class="markdownIt-Anchor" href="#单元测试"></a> 单元测试</h3><p>Python单元测试需要引入<code>unittest</code>模块，测试类需要继承<code>unittest.TestCase</code>，并且测试方法需要以test开头，否则不被认为是单元测试，测试方法一般通过断言进行测试。</p><pre class="highlight"><code class="python"><span class="hljs-keyword">import</span> unittest<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDict</span><span class="hljs-params">(unittest.TestCase)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_init</span><span class="hljs-params">(self)</span> :</span>        d = Dict(a=<span class="hljs-number">1</span>, b=<span class="hljs-string">'test'</span>)        self.assertEqual(d.a, <span class="hljs-number">1</span>)        self.assertTrue(isinstance(d, dict))    ...省略        <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span> :        unittest.main() <span class="hljs-comment"># 执行脚本运行单元测试</span></code></pre><h3 id="文档测试"><a class="markdownIt-Anchor" href="#文档测试"></a> 文档测试</h3><p>Python内置文档测试<code>doctest</code>模块可以直接提取注释中代码并执行测试。<code>doctest</code>严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，才会有输出错误。</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dict</span><span class="hljs-params">(dict)</span> :</span>    <span class="hljs-string">'''    ...说明内容        &gt;&gt;&gt; d1 = Dict()    &gt;&gt;&gt; d1['x'] = 100    &gt;&gt;&gt; d1.x        ...省略    '''</span>        代码实现...        <span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:        <span class="hljs-keyword">import</span> doctest        doctest.testmod()</code></pre><blockquote><p>上面代码是文档测试的样例，注意<code>&gt;&gt;&gt;</code>后面代码，当执行文档测试时，该代码会被执行验证，同时此代码也可当作示例代码。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Python3学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3面向对象编程(v3.7)</title>
      <link href="2018/08/16/python/Python3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(v3.7)/"/>
      <url>2018/08/16/python/Python3%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B(v3.7)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="类和实例"><a class="markdownIt-Anchor" href="#类和实例"></a> 类和实例</h2><p>类是抽象的模板，实例是根据类创建出来的一个个对象，每个对象都拥有相同的属性和方法，但各自的数据可能不相同。</p><p>Python通过<code>class</code>关键字定义类，类名首字母通常大写,类名后面接继承的类(如下object)：</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名<span class="hljs-params">(object)</span> :</span>    <span class="hljs-keyword">pass</span></code></pre><p>实例是通过<code>类名+()</code>赋值给变量获得：</p><pre class="highlight"><code class="python">实例名 = 类名()</code></pre><p>可以通过__init__方法初始化一个实例，该方法第一个参数必须是self表示创建实例的本身：</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,age)</span> :</span>        self.name = name        self.age = age<span class="hljs-meta">&gt;&gt;&gt; </span>worker = Person(<span class="hljs-string">'张三'</span>,<span class="hljs-number">30</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>worker.name<span class="hljs-string">'张三'</span><span class="hljs-meta">&gt;&gt;&gt; </span>worker.age<span class="hljs-number">30</span></code></pre><blockquote><p>在类中定义函数和普通模块中定义函数不同的是函数第一个参数必须是实例变量self，调用时不用传入该参数。</p></blockquote><h2 id="私有成员"><a class="markdownIt-Anchor" href="#私有成员"></a> 私有成员</h2><p>Python私有变量或函数，可以把变量或函数前面加上<code>__</code>符号，私有变量或函数只允许内部访问，不允许外部访问的。</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,age)</span> :</span>        self.__name = name        self.__age = age    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span><span class="hljs-params">(self)</span> :</span>        <span class="hljs-keyword">return</span> self.__name        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_age</span><span class="hljs-params">(self)</span> :</span>        <span class="hljs-keyword">return</span> self.__age<span class="hljs-meta">&gt;&gt;&gt; </span>worker = Person(<span class="hljs-string">'张三'</span>,<span class="hljs-number">30</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>worker.nameAttributeError: <span class="hljs-string">'Person'</span> object has no attribute <span class="hljs-string">'name'</span><span class="hljs-meta">&gt;&gt;&gt; </span>worker.__ageAttributeError: <span class="hljs-string">'Person'</span> object has no attribute <span class="hljs-string">'__age'</span><span class="hljs-meta">&gt;&gt;&gt; </span>worker.get_name() <span class="hljs-comment">#通过自定义函数获取内部变量</span>张三</code></pre><blockquote><p>私有变量其实也并不是不能从外部访问，上面直接访问报错的原因是Python解释器把<code>name</code>变量变成了<code>_Person__name</code>，所以仍然可以通过此变量来访问，但是强烈建议不要这么使用。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>worker.__name = <span class="hljs-string">'李四'</span><span class="hljs-meta">&gt;&gt;&gt; </span>worker.__name<span class="hljs-string">'李四'</span><span class="hljs-meta">&gt;&gt;&gt; </span>worker.get_name()<span class="hljs-string">'张三'</span></code></pre><blockquote><p>上面代码问题在于Python编译器已经把<code>__name</code>属性变为<code>_Person__name</code>了，而外部直接给<code>__name</code>属性赋值相当于一个新变量，所以通过<code>get_name()</code>方法获取值还是以前的值。想要改变<code>__name</code>属性值可以自定义<code>set_name()</code>函数。</p></blockquote><p>在绑定属性时，如果直接把属性暴露出去，就无法检查属性的值，所以通常定义get和set方法进行读取操作，但是定义get和set方法又有些麻烦，可以通过@property装饰器来简化这一问题。</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span> :</span><span class="hljs-meta">    @property　#此装饰器可以实现[实例.sex]进行读取操作</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sex</span><span class="hljs-params">(self)</span> :</span>        <span class="hljs-keyword">return</span> self._sex        <span class="hljs-meta">    @sex.setter　#此装饰器可以实现[实例.sex=value]进行赋值操作</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sex</span><span class="hljs-params">(self,value)</span> :</span>        <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">2</span> :            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'无效赋值'</span>)        self._sex = value<span class="hljs-meta">&gt;&gt;&gt; </span>p = Person()<span class="hljs-meta">&gt;&gt;&gt; </span>p.sex = <span class="hljs-number">2</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(p.sex)<span class="hljs-number">2</span><span class="hljs-meta">&gt;&gt;&gt; </span>p.sex = <span class="hljs-number">3</span>ValueError: 无效赋值</code></pre><blockquote><p>把一个get方法变成属性调用只需要在方法上加上<code>@property</code>装饰器，然后就可以直接用<code>.</code>操作符调用属性了，<code>@property</code>装饰器会自动创建一个<code>@属性名.setter</code>装饰器，负责把set方法变成属性赋值。</p></blockquote><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><p>继承可以拥有父类的全部功能，语法就是在类名后面加上<code>(继承类)</code>。Python也支持多重继承，只需逗号分割即可。</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Person)</span> :</span>    <span class="hljs-keyword">pass</span>    <span class="hljs-meta">&gt;&gt;&gt; </span>worker = Worker(<span class="hljs-string">'张三'</span>,<span class="hljs-number">30</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>worker.get_name()　<span class="hljs-comment">#空类Worker因为继承Person也拥有了父类函数</span><span class="hljs-string">'张三'</span></code></pre><blockquote><p>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类,反过来就不行。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(worker,Worker)<span class="hljs-literal">True</span><span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(worker,Person)<span class="hljs-literal">True</span><span class="hljs-meta">&gt;&gt;&gt; </span>person = Person(<span class="hljs-string">'张三'</span>,<span class="hljs-number">30</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(person,Worker)<span class="hljs-literal">False</span></code></pre><blockquote><p>继承还可以一级一级地继承下来，而任何类，最终都可以追溯到根类object。子类还可以重写父类函数。</p></blockquote><h2 id="限制定义__slots__"><a class="markdownIt-Anchor" href="#限制定义__slots__"></a> 限制定义__slots__</h2><p>创建一个类的实例后，可以动态给实例绑定方法和属性，这是动态语言的灵活性，在静态语言中很难实现。但每个实例绑定元素其它实例无法使用，想要在所有实例中使用，可以在类中绑定。</p><pre class="highlight"><code class="python"><span class="hljs-comment">#实例绑定方法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">()</span> :</span>    print(<span class="hljs-string">'hi,Worker'</span>)    worker = Worker(<span class="hljs-string">'张三'</span>,<span class="hljs-number">30</span>)worker2 = Worker(<span class="hljs-string">'李四'</span>,<span class="hljs-number">25</span>)    worker.say_hi = say_hiworker.say_hi() --&gt; <span class="hljs-string">'hi,Worker'</span>worker2.say_hi() --&gt; AttributeError: <span class="hljs-string">'Worker'</span> object has no attribute <span class="hljs-string">'say_hi'</span><span class="hljs-comment">#类绑定函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_hi</span><span class="hljs-params">(self)</span> :</span> <span class="hljs-comment">#注意多了个self参数，调用时不用传递</span>    print(<span class="hljs-string">'hi,Worker'</span>)Worker.say_hi = say_hiworker.say_hi() --&gt; <span class="hljs-string">'hi,Worker'</span>worker2.say_hi() --&gt; <span class="hljs-string">'hi,Worker'</span></code></pre><p>如果想要限制实例可以定义的属性，使用<code>__slots__</code>变量用tuple类型绑定允许定义的变量：</p><pre class="highlight"><code class="python">__slots__ = (<span class="hljs-string">'name'</span>,<span class="hljs-string">'age'</span>)</code></pre><h2 id="定制类"><a class="markdownIt-Anchor" href="#定制类"></a> 定制类</h2><p>Python中有很多类似<code>__xxx__</code>这种形式的变量或函数是有特殊用途的，它们可以帮助定制类。</p><ul><li><code>__str__()</code></li></ul><p>定义一个类使用print()打印这个类实例:</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>print(Person(<span class="hljs-string">'张三'</span>,<span class="hljs-number">30</span>))&lt;__main__.Person object at <span class="hljs-number">0x109afb190</span>&gt;</code></pre><p>上面打印实例返回***&lt;<strong>main</strong>.Person object at 0x109afb190&gt;***，通过<code>__str__()</code>可以自定义出返回信息。</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span> :</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'Person object'</span>        <span class="hljs-meta">&gt;&gt;&gt; </span>print(Person())　<span class="hljs-comment">#打印实例返回自定义信息</span><span class="hljs-string">'Person object'</span></code></pre><ul><li><code>__repr__()</code></li></ul><p><code>__str__()</code>函数是调用print()起作用，而如果直接调用实例不使用print()函数时此方法不会起作用，此时需要使用<code>__repr__()</code>函数。</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>p = Person()<span class="hljs-meta">&gt;&gt;&gt; </span>p <span class="hljs-comment">#直接调用实例__str__()方法无效</span>&lt;__main__.Person object at <span class="hljs-number">0x109afb190</span>&gt;|改||进||代||码|V　V<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span> :</span>    ...省略        __repr__ = __str__    <span class="hljs-meta">&gt;&gt;&gt; </span>p<span class="hljs-string">'Person object'</span></code></pre><blockquote><p>通常<code>__str__()</code>和<code>__repr__()</code>函数代码都一样，所以可以直接把<code>__str__</code>赋值给<code>__repr__</code></p></blockquote><ul><li><code>__iter__()</code></li></ul><p>此函数可以使类实例作用于for…in循环，循环会通过<code>__next__()</code>方法拿到下一个值，直到遇到StopIteration时退出循环。</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fib</span><span class="hljs-params">(object)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,range)</span> :</span>        self.a,self.b = <span class="hljs-number">0</span>,<span class="hljs-number">1</span>        self.range = range    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span> :</span>        <span class="hljs-keyword">return</span> self            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span> :</span>        self.a,self.b = self.b,self.a+self.b                <span class="hljs-keyword">if</span> self.a &gt; self.range :            <span class="hljs-keyword">raise</span> StopIteration()        <span class="hljs-keyword">return</span> self.a        <span class="hljs-meta">&gt;&gt;&gt; </span>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> Fib(<span class="hljs-number">10</span>)][<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>]</code></pre><ul><li><code>__getitem__()</code></li></ul><p>此函数可以使类实例像列表(list)一样通过索引获取元素。</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FibList</span><span class="hljs-params">(object)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span><span class="hljs-params">(self,n)</span> :</span>        a,b = <span class="hljs-number">0</span>,<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(n) :            a,b = b,a+b        <span class="hljs-keyword">return</span> a<span class="hljs-meta">&gt;&gt;&gt; </span>FibList()[<span class="hljs-number">7</span>]<span class="hljs-number">13</span></code></pre><blockquote><p><code>__getitem__()</code>函数也可以根据<code>isinstance()</code>判断类型实现切片(slice)、字典(dict)等操作。类似的函数还有<code>__setitem__()</code>、<code>__delitem__()</code></p></blockquote><ul><li><code>__getattr__()</code></li></ul><p>正常情况，调用类中不存在的属性或方法会报错，如果用此函数预先定义可以避免此问题。</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span> :</span>        self.name = <span class="hljs-string">'Windus'</span><span class="hljs-meta">&gt;&gt;&gt; </span>Person().ageAttributeError: <span class="hljs-string">'Person'</span> object has no attribute <span class="hljs-string">'age'</span>|改||进||代||码|V　V<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span> :</span>        self.name = <span class="hljs-string">'Windus'</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self,attr)</span> :</span>        <span class="hljs-keyword">if</span> attr == <span class="hljs-string">'age'</span> :            <span class="hljs-keyword">return</span> <span class="hljs-number">30</span><span class="hljs-meta">&gt;&gt;&gt; </span>Person().age<span class="hljs-number">30</span></code></pre><blockquote><p>此函数仅在属性或函数不存在时才会被调用，默认返回值是<code>None</code>，如果想要类只响应特殊属性或函数可以抛出<code>AttributeError</code>异常。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span> :</span>        ...省略        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self,attr)</span> :</span>        <span class="hljs-keyword">if</span> attr == <span class="hljs-string">'age'</span> :            <span class="hljs-keyword">return</span> <span class="hljs-number">30</span>        <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">'Person object has no attribute:%s'</span> % attr)</code></pre><ul><li><code>__call__()</code></li></ul><p>一般而言一个实例可以调用其属性和方法而实例本身无法调用，Python中可以通过此方法直接调用实例。</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><span class="hljs-params">(object)</span> :</span>    ...省略        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">()</span> :</span>        print(<span class="hljs-string">'Person instance'</span>)        &gt;&gt;&gt;p = Person()&gt;&gt;&gt;p()Person instance</code></pre><p>**判断一个变量是函数还是对象，可以判断该对象能否被调用，能被调用就是一个callable对象，使用<code>callable()</code>。</p><h2 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h2><ul><li>定义枚举</li></ul><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> EnumMonth = Enum(<span class="hljs-string">'Months'</span>, (<span class="hljs-string">'Jan'</span>, <span class="hljs-string">'Feb'</span>, <span class="hljs-string">'Mar'</span>, <span class="hljs-string">'Apr'</span>, <span class="hljs-string">'May'</span>, <span class="hljs-string">'Jun'</span>, <span class="hljs-string">'Jul'</span>, <span class="hljs-string">'Aug'</span>, <span class="hljs-string">'Sep'</span>, <span class="hljs-string">'Oct'</span>, <span class="hljs-string">'Nov'</span>, <span class="hljs-string">'Dec'</span>))</code></pre><ul><li>遍历枚举</li></ul><pre class="highlight"><code class="python"><span class="hljs-keyword">for</span> name, member <span class="hljs-keyword">in</span> Month.__members__.items():    print(name, <span class="hljs-string">'=&gt;'</span>, member, <span class="hljs-string">','</span>, member.value)Jan =&gt; Months.Jan , <span class="hljs-number">1</span>Feb =&gt; Months.Feb , <span class="hljs-number">2</span>Mar =&gt; Months.Mar , <span class="hljs-number">3</span>Apr =&gt; Months.Apr , <span class="hljs-number">4</span>May =&gt; Months.May , <span class="hljs-number">5</span>Jun =&gt; Months.Jun , <span class="hljs-number">6</span>Jul =&gt; Months.Jul , <span class="hljs-number">7</span>Aug =&gt; Months.Aug , <span class="hljs-number">8</span>Sep =&gt; Months.Sep , <span class="hljs-number">9</span>Oct =&gt; Months.Oct , <span class="hljs-number">10</span>Nov =&gt; Months.Nov , <span class="hljs-number">11</span>Dec =&gt; Months.Dec , <span class="hljs-number">12</span></code></pre><ul><li>自定义枚举类</li></ul><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<span class="hljs-meta">@unique #装饰器保证没有重复值</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Color</span><span class="hljs-params">(Enum)</span> :</span>    red = <span class="hljs-number">1</span>  <span class="hljs-comment"># red的value被设定为1</span>    orange = <span class="hljs-number">2</span>    yellow = <span class="hljs-number">3</span>    green = <span class="hljs-number">4</span>    blue = <span class="hljs-number">5</span>    indigo = <span class="hljs-number">6</span>    purple = <span class="hljs-number">7</span></code></pre><h2 id="元类"><a class="markdownIt-Anchor" href="#元类"></a> 元类</h2><p>动态语言函数和类的定义不是在编译时定义，而是在运行时创建的。而创建class的方法就是<code>type()</code>函数。</p><p>通过type定义一个简单的类，type接收三个参数（类名，父类元组，类函数和属性字典字典）</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fn</span><span class="hljs-params">(self)</span> :</span>    print(<span class="hljs-string">'Hello Person'</span>)Person = type(<span class="hljs-string">'Person'</span>,(object,),dict(say_hello=fn))<span class="hljs-meta">&gt;&gt;&gt; </span>p = Person()<span class="hljs-meta">&gt;&gt;&gt; </span>say_hello()Hello Person</code></pre><p>除了type()函数外，还可以通过metaclass来创建类，metaclass被称为元类，一般元类类名都以Metaclass结尾。</p><pre class="highlight"><code class="python"><span class="hljs-comment"># metaclass是类的模板，所以必须从`type`类型派生</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListMetaclass</span><span class="hljs-params">(type)</span> :</span>    <span class="hljs-comment">#传入参数（cls:当前实例化的类(必传)name:类名bases:基类列表attrs:属性和函数字典</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls,name,bases,attrs)</span> :</span>        <span class="hljs-comment">#定义add方法</span>        attrs[<span class="hljs-string">'add'</span>] = <span class="hljs-keyword">lambda</span> self,value : self.append(value)        <span class="hljs-keyword">return</span> type.__new__(cls,name,bases,attrs)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList</span><span class="hljs-params">(list,metaclass = ListMetaclass)</span> :</span>    <span class="hljs-keyword">pass</span><span class="hljs-meta">&gt;&gt;&gt; </span>L = MyList()<span class="hljs-meta">&gt;&gt;&gt; </span>L.add(<span class="hljs-number">10</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>L.add(<span class="hljs-number">11</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>print(L)[<span class="hljs-number">10</span>, <span class="hljs-number">11</span>]</code></pre><blockquote><p>定义MyList类后自动就有了add()方法，而普通list没有add()方法。其实add()方法完全可以在MyList类里直接写，没必要通过元类动态修改，然而有些情况下非常有用,如下案例。</p></blockquote><p><code>案例一</code>：Django框架对象－关系映射简析</p><p>要编写一个ORM框架所有类都只能动态定义，因为只有使用者才能够根据表结构定义出对应的类。</p><p><strong>1、创建一个Field类，保存数据库表字段和字段类型</strong></p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Field</span><span class="hljs-params">(object)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name,column_type)</span> :</span>        self.name = name        self.column_type = column_type    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span> :</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;%s:%s&gt;'</span> % (self.__class__.__name__,self.name)    </code></pre><p>作用：在Field类实例化时将得到两个参数，name和column_type，它们将被绑定为Field的私有属性，如果要将Field转化为字符串时，将返回“Field:XXX” ， XXX是传入的name名称。</p><p><strong>2、在Field基础上，进一步抽象各类型Field</strong></p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringField</span><span class="hljs-params">(Field)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name)</span> :</span>        super(StringField,self).__init__(name,<span class="hljs-string">'varchar(100)'</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerField</span><span class="hljs-params">(Field)</span> :</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,name)</span> :</span>            super(IntegerField,self).__init__(name,<span class="hljs-string">'bigint'</span>)</code></pre><p>作用：在StringField,IntegerField实例初始化时，自动调用父类的初始化方式。</p><p><strong>3、编写Model元类</strong></p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelMetaclass</span><span class="hljs-params">(type)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span><span class="hljs-params">(cls, name, bases, attrs)</span>:</span>        <span class="hljs-comment">#排除对Model类的修改</span>        <span class="hljs-keyword">if</span> name == <span class="hljs-string">'Model'</span>:            <span class="hljs-keyword">return</span> type.__new__(cls, name, bases, attrs)        print(<span class="hljs-string">'found model　：%s'</span> % name)                <span class="hljs-comment">#声明属性和列的映射关系字典</span>        mappings = dict()        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> attrs.items():            <span class="hljs-keyword">if</span> isinstance(v, Field):                 print(<span class="hljs-string">'Found mappings %s===&gt;%s'</span> % (k, v))                <span class="hljs-comment">#把属性和列的映射关系放入mapping</span>                mappings[k] = v        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> mappings.keys():            <span class="hljs-comment">#从类属性中删除Field属性</span>            attrs.pop(k)            <span class="hljs-comment"># 保存属性和列的映射关系到类属性__mappings__中</span>            attrs[<span class="hljs-string">'__mappings__'</span>] = mappings              <span class="hljs-comment"># 假设表名与类名一致保存表名到类属性__table__中</span>            attrs[<span class="hljs-string">'__table__'</span>] = name          <span class="hljs-keyword">return</span> type.__new__(cls, name, bases, attrs)</code></pre><p><strong>4、编写基类Model类</strong></p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span><span class="hljs-params">(dict,metaclass=ModelMetaclass)</span> :</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,**kw)</span> :</span>        super(Model,self).__init__(**kw)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span><span class="hljs-params">(self,key)</span> :</span>        <span class="hljs-keyword">try</span>:            <span class="hljs-keyword">return</span> self[key]        <span class="hljs-keyword">except</span> KeyError :            <span class="hljs-keyword">raise</span> AttributeError(<span class="hljs-string">"'Model' object has no attribute '%s'"</span> % key)                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setattr__</span><span class="hljs-params">(self,key,value)</span> :</span>        self[key] = value    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span><span class="hljs-params">(self)</span> :</span>        fileds = []        args = []        <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> self.__mappings__.items() :            fileds.append(v.name)            args.append(getattr(self,k,<span class="hljs-literal">None</span>))            sql = <span class="hljs-string">'insert into %s (%s) values (%s)'</span> % (self.__table__, <span class="hljs-string">','</span>.join(fileds), <span class="hljs-string">','</span>.join([str(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> args]))            print(<span class="hljs-string">'SQL: %s'</span> % sql)            print(<span class="hljs-string">'ARGS: %s'</span> % str(args))</code></pre><p><strong>5、编写用户实现类User</strong></p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span><span class="hljs-params">(Model)</span>:</span>    <span class="hljs-comment"># 定义类的属性到列的映射，自动解析为Model.__setattr__(self, ‘id’, IntegerField(‘id’))，其它同理。</span>    id = IntegerField(<span class="hljs-string">'id'</span>)    name = StringField(<span class="hljs-string">'username'</span>)    email = StringField(<span class="hljs-string">'email'</span>)    password = StringField(<span class="hljs-string">'password'</span>)</code></pre><p><strong>6、调用实现类并返回结果</strong></p><pre class="highlight"><code class="python"><span class="hljs-comment">#调用Model.__setattr__，将键值载入私有对象</span><span class="hljs-meta">&gt;&gt;&gt; </span>u = User(id=<span class="hljs-number">12345</span>, name=<span class="hljs-string">'Batman'</span>, email=<span class="hljs-string">'batman@nasa.org'</span>, password=<span class="hljs-string">'iamback'</span>)　<span class="hljs-meta">&gt;&gt;&gt; </span>u.save()found model　：UserFound mappings id===&gt;&lt;IntegerField:id&gt;Found mappings name===&gt;&lt;StringField:username&gt;Found mappings email===&gt;&lt;StringField:email&gt;Found mappings password===&gt;&lt;StringField:password&gt;SQL: insert into User (id) values (<span class="hljs-number">12345</span>)ARGS: [<span class="hljs-number">12345</span>]SQL: insert into User (id,username) values (<span class="hljs-number">12345</span>,Batman)ARGS: [<span class="hljs-number">12345</span>, <span class="hljs-string">'Batman'</span>]SQL: insert into User (id,username,email) values (<span class="hljs-number">12345</span>,Batman,batman@nasa.org)ARGS: [<span class="hljs-number">12345</span>, <span class="hljs-string">'Batman'</span>, <span class="hljs-string">'batman@nasa.org'</span>]SQL: insert into User (id,username,email,password) values (<span class="hljs-number">12345</span>,Batman,batman@nasa.org,iamback)ARGS: [<span class="hljs-number">12345</span>, <span class="hljs-string">'Batman'</span>, <span class="hljs-string">'batman@nasa.org'</span>, <span class="hljs-string">'iamback'</span>]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Python3学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3模块(v3.7)</title>
      <link href="2018/08/15/python/Python3%E6%A8%A1%E5%9D%97(v3.7)/"/>
      <url>2018/08/15/python/Python3%E6%A8%A1%E5%9D%97(v3.7)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="模块定义与规范"><a class="markdownIt-Anchor" href="#模块定义与规范"></a> 模块定义与规范</h2><p>Python中每个<code>.py</code>文件被称为一个<strong>模块</strong>，按目录组织模块的方法被称为<strong>包</strong>。模块可以避免变量和函数名冲突，而包可以避免模块名冲突。</p><blockquote><p>每个包目录下面都必须有一个<code>__init__.py</code>文件，否则Python会把这个目录当成普通目录，而不是一个包。<code>__init__.py</code>可以是一个空文件，也可以有Python代码。因为<code>__init__.py</code>本身就是一个模块，它的模块名是其所在目录的包名。<br>自定义模块时要注意命名，不要与系统模块重名，否则导致命名冲突无法导入系统模块</p></blockquote><pre class="highlight"><code class="python">leancomment   <span class="hljs-comment">#普通目录没有__init__.py</span>|_ utils            <span class="hljs-comment">#包名utils</span>|  |_ convert.py    <span class="hljs-comment">#模块名utils.convert</span>|  |_ __init__.py   <span class="hljs-comment">#模块名utils</span>|_ start.py         <span class="hljs-comment">#模块名start</span></code></pre><h3 id="模块模板"><a class="markdownIt-Anchor" href="#模块模板"></a> 模块模板</h3><p>通常一个模块排版如下：</p><pre class="highlight"><code class="python"><span class="hljs-comment">#!/usr/bin/env python3　　＃指定运行环境，可以让py文件在Unix/Linux/Mac下运行</span><span class="hljs-comment"># -*- coding: utf-8 -*-  # 注释表示文件采用utf-8编码</span><span class="hljs-string">'此处为文档注释'</span>--author__ = <span class="hljs-string">'Windus'</span> <span class="hljs-comment">#模块作者</span><span class="hljs-keyword">import</span> sys  <span class="hljs-comment">#导入模块</span>...省略　　　<span class="hljs-comment">#自定义模块内容</span><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:　<span class="hljs-comment">#命令行运行测试</span>...省略</code></pre><blockquote><p>在命令行运行模块文件时，Python解释器会把一个特殊变量__name__赋值为’<strong>main</strong>’，而在其它地方导入模块时不会如此操作，因此上面if判断可以通过命令行如测试执行代码等，有些类似其它语言的main函数。</p></blockquote><h3 id="模块作用域"><a class="markdownIt-Anchor" href="#模块作用域"></a> 模块作用域</h3><p>Python中想要仅在模块内使用的私有函数或变量，可以通过<code>_</code>前缀来实现。正常函数和变量是公开的可以被其它模块引用，而以<code>_</code>开头的函数或变量不应该被其它模块引用。</p><p><code>自定义工具模块utils.convert</code>：</p><pre class="highlight"><code class="python"><span class="hljs-comment">#!/usr/bin/env python3</span><span class="hljs-comment"># -*-coding: utf-8 -*-</span><span class="hljs-string">'工具模块－转换函数'</span>__author__ = <span class="hljs-string">'Windus'</span><span class="hljs-keyword">import</span> functools<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_exponent</span><span class="hljs-params">(n,m)</span> :</span>    temp = n    <span class="hljs-keyword">while</span> m &gt; <span class="hljs-number">1</span> :        m -= <span class="hljs-number">1</span>        n *= temp    <span class="hljs-keyword">return</span> nexponent2 = functools.partial(_exponent,m=<span class="hljs-number">2</span>)<span class="hljs-keyword">if</span> __name__ ==<span class="hljs-string">'__main__'</span> :    print(exponent2(<span class="hljs-number">5</span>))</code></pre><p><code>自定义应用模块：app</code>:</p><pre class="highlight"><code class="python"><span class="hljs-comment">#!/usr/bin/env python3</span><span class="hljs-comment"># -*-coding: utf-8 -*-</span><span class="hljs-string">'装饰器函数'</span>__author__ = <span class="hljs-string">'Windus'</span><span class="hljs-keyword">import</span> utils.convert　<span class="hljs-comment">#引入工具模块</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span><span class="hljs-params">(level)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span><span class="hljs-params">(func)</span>:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kw)</span>:</span>            print(<span class="hljs-string">'[[%s]] 执行%s()'</span> % (level, func.__name__))            <span class="hljs-keyword">return</span> func(*args, **kw)        <span class="hljs-keyword">return</span> wrapper    <span class="hljs-keyword">return</span> decorator<span class="hljs-meta">@log(level='DEBUG')</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span>:</span>    print(utils.convert.exponent2(<span class="hljs-number">8</span>)) <span class="hljs-comment">#调用exponent2函数，不应该调用_exponent函数</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span> :    test2()</code></pre><blockquote><p>Python中没限制调用私有函数或变量的调用机制，而是从编程习惯上不应该被引用。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Python3学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3函数式编程(v3.7)</title>
      <link href="2018/08/13/python/Python3%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B(v3.7)/"/>
      <url>2018/08/13/python/Python3%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B(v3.7)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="高阶函数"><a class="markdownIt-Anchor" href="#高阶函数"></a> 高阶函数</h2><p>函数的特点：</p><ul><li>变量可以指向函数</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = abs <span class="hljs-comment">#把内置函数abs()函数本身赋值给变量</span><span class="hljs-meta">&gt;&gt;&gt; </span>f(<span class="hljs-number">-10</span>)<span class="hljs-number">10</span></code></pre><blockquote><p>调过变量f调用abs函数结果与abs函数结果相同，说明变量f已指向abs函数本身</p></blockquote><ul><li>函数名也是变量</li></ul><pre class="highlight"><code class="python">abs = <span class="hljs-number">10</span>abs(<span class="hljs-number">-10</span>)Traceback (most recent call last):  File <span class="hljs-string">"&lt;stdin&gt;"</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;TypeError: <span class="hljs-string">'int'</span> object <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> callable</code></pre><blockquote><p>把10赋值给函数名abs，结果abs就无法调用该函数了！因为abs也是一个变量，此时变量abs已经不指向求绝对值函数，而是指向一个整数10</p></blockquote><p><strong>高阶函数</strong>就是能接受函数作为参数的函数。</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(x,y,f)</span> :</span>　<span class="hljs-comment">#定义一个最简单的高阶函数</span><span class="hljs-keyword">return</span> f(x) + f(y)<span class="hljs-comment">#调用函数传入参数为函数</span>x = <span class="hljs-number">-5</span>y = <span class="hljs-number">6</span>add(x,y,abs) ==&gt; abs(<span class="hljs-number">-5</span>) + abs(<span class="hljs-number">6</span>) --&gt; <span class="hljs-number">11</span></code></pre><h2 id="内置高阶函数"><a class="markdownIt-Anchor" href="#内置高阶函数"></a> 内置高阶函数</h2><h3 id="mapreduce"><a class="markdownIt-Anchor" href="#mapreduce"></a> map/reduce</h3><ul><li>map函数<br>该函数接收两个参数一个是函数，另一个是Iterable对象。map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator对象返回。</li></ul><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(x)</span> :</span> <span class="hljs-comment">#定义一个求数平方的函数</span>    <span class="hljs-keyword">return</span> x * xr = map(func,[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)])print(list(r)) --&gt; [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]</code></pre><ul><li>reduce函数<br>该函数是把一个函数作用在一个序列上，这个函数必须接收两个参数。reduce把结果继续和序列的下一个元素做累计计算。效果如：<code>reduce(f,[x1,x2,x3,x4,x5])=f(f(f(f(x1,x2),x3),x4),x5)</code></li></ul><pre class="highlight"><code class="python"><span class="hljs-comment">#例如把序列[1, 3, 5, 7, 9]变换成整数13579</span><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(x,y)</span> :</span><span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y调用：reduce(func,[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>]) --&gt; <span class="hljs-number">13579</span></code></pre><h3 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> filter</h3><p>接收两个参数，一个函数，一个序列。filter根据把传入的函数作用于序列的每个元素，根据返回值True或False来决定保留或丢弃该元素,并把结果作为Iterator返回。</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_odd</span><span class="hljs-params">(x)</span> :</span><span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>list(filter(is_odd,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]))--&gt; [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]</code></pre><h3 id="sorted"><a class="markdownIt-Anchor" href="#sorted"></a> sorted</h3><p>sorted可以直接对list进行自然排序：</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>sorted([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">9</span>, <span class="hljs-number">-21</span>])[<span class="hljs-number">-21</span>, <span class="hljs-number">-12</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">36</span>]</code></pre><p>sorted高阶用法接收三个参数：排序列表, [keys=自定义函数], [reverse＝True|False]<br>自定义函数(可选参数)将会作用于每个元素后再进行排序。<br>reverse(可选参数)将会排序列表顺序反转。</p><pre class="highlight"><code class="python3">#普通排序&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])['Credit', 'Zoo', 'about', 'bob']#高阶排序&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)['about', 'bob', 'Credit', 'Zoo']#反转高阶排序&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about']</code></pre><h2 id="闭包"><a class="markdownIt-Anchor" href="#闭包"></a> 闭包</h2><p>闭包就是能够读取其他函数内部变量的函数。这种结构通常只有函数的子函数才能读取局部变量，所以闭包可以理解为“定义在一个函数内部的函数”。</p><pre class="highlight"><code class="python"><span class="hljs-comment">#定义求和函数数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calc_sum</span><span class="hljs-params">(*args)</span> :</span>ax = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> args :ax = ax + n<span class="hljs-keyword">return</span> ax</code></pre><p>上面函数调用会立即求和，如果想要定义一个函数，而不立刻求值，在需要时再计算，此时即可采用闭包：</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lazy_sum</span><span class="hljs-params">(*args)</span> :</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span><span class="hljs-params">()</span> :</span>ax = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> args :ax = ax + n<span class="hljs-keyword">return</span> ax<span class="hljs-keyword">return</span> sum</code></pre><p>当调用lazy_sum()时返回的不是求和结果而是sum()函数。<br>调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数：</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>f1 = lazy_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>f2 = lazy_sum(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>f1==f2<span class="hljs-literal">False</span></code></pre><blockquote><p>注意：返回闭包时,返回函数不要引用任何循环变量，或者后续会发生变化的变量。因为闭包是延迟执行的，可能发生与预期不同的结果。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-comment">#闭包引用循环变量</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span><span class="hljs-params">()</span>:</span>    fs = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>:</span>             <span class="hljs-keyword">return</span> i*i        fs.append(f)    <span class="hljs-keyword">return</span> fsf1, f2, f3 = count()<span class="hljs-meta">&gt;&gt;&gt; </span>f1() <span class="hljs-comment">#预期结果　--&gt; 1</span><span class="hljs-number">9</span> <span class="hljs-meta">&gt;&gt;&gt; </span>f2() <span class="hljs-comment">#预期结果　--&gt; 4</span><span class="hljs-number">9</span><span class="hljs-meta">&gt;&gt;&gt; </span>f3() <span class="hljs-comment">#预期结果　--&gt; 9</span><span class="hljs-number">9</span> --&gt; <span class="hljs-number">9</span>| || || |V V<span class="hljs-comment">#代码改进</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count</span><span class="hljs-params">()</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(j)</span>:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">g</span><span class="hljs-params">()</span>:</span>            <span class="hljs-keyword">return</span> j*j        <span class="hljs-keyword">return</span> g    fs = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):        fs.append(f(i)) <span class="hljs-comment"># f(i)立刻被执行，因此i的当前值被传入f()</span>    <span class="hljs-keyword">return</span> fs  <span class="hljs-meta">&gt;&gt;&gt; </span>f1, f2, f3 = count()<span class="hljs-meta">&gt;&gt;&gt; </span>f1()<span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;&gt; </span>f2()<span class="hljs-number">4</span><span class="hljs-meta">&gt;&gt;&gt; </span>f3()<span class="hljs-number">9</span></code></pre><h2 id="匿名函数"><a class="markdownIt-Anchor" href="#匿名函数"></a> 匿名函数</h2><p>当传入函数时，有些时候不需要显示定义函数，直接传入匿名函数更方便。因此Python中支持lambda匿名函数。<br>***语法：***<code>lambda : 函数参数 : 函数返回值表达式</code></p><blockquote><p>匿名函数只能有一个表达式，不用写retrun,返回值就是该表达式的结果。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-comment">#匿名函数赋值</span><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-keyword">lambda</span> x : x * x <span class="hljs-meta">&gt;&gt;&gt; </span>f(<span class="hljs-number">2</span>)<span class="hljs-number">4</span>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<span class="hljs-comment">#匿名函数作为返回值</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(x)</span> :</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> : x * x<span class="hljs-meta">&gt;&gt;&gt; </span>func(<span class="hljs-number">2</span>)() <span class="hljs-number">4</span></code></pre><h2 id="装饰器"><a class="markdownIt-Anchor" href="#装饰器"></a> 装饰器</h2><p>Python装饰器本质上就是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能，装饰器的返回值也是一个函数对象。</p><ul><li>#定义一个简单装饰器</li></ul><pre class="highlight"><code class="python"><span class="hljs-comment">#计算方法执行时间装饰器</span><span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timer</span><span class="hljs-params">(func)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kw)</span>:</span>        start_time = time.time()        func(*args,**kw)        stop_time = time.time()        print(<span class="hljs-string">'%s()方法运行时间:%s'</span> % (func.__name__, stop_time-start_time))    <span class="hljs-keyword">return</span> wrapper<span class="hljs-meta">@timer</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> :</span>    time.sleep(<span class="hljs-number">1</span>)test1()</code></pre><blockquote><p>timer()方法是一个装饰器，test()方法通过<code>@装饰器名</code>方法引用装饰器。原来test()函数仍然存在，只是指向了timer()返回函数wrapper()。wrapper()函数的参数(*args,**kw)表示接收任何参数调用。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-comment">#不带参数装饰器执行效果</span><span class="hljs-meta">&gt;&gt;&gt; </span>@timer <span class="hljs-comment">#相当于执行：test = timer(test)</span><span class="hljs-meta">&gt;&gt;&gt; </span>test() <span class="hljs-comment">#相当于执行：timer(test)()</span></code></pre><ul><li>定义一个带参数的装饰器</li></ul><pre class="highlight"><code class="python"><span class="hljs-comment">#打印log日志装饰器</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log</span><span class="hljs-params">(level)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decorator</span><span class="hljs-params">(func)</span>:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kw)</span>:</span>            print(<span class="hljs-string">'[[%s]] 执行%s()'</span> % (level, func.__name__))            <span class="hljs-keyword">return</span> func(*args, **kw)        <span class="hljs-keyword">return</span> wrapper    <span class="hljs-keyword">return</span> decorator<span class="hljs-meta">@log(level='DEBUG')</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'Hello test2'</span>)test2()</code></pre><p><strong>和不带参数装饰器比带有参数的装饰器多了一层嵌套,执行效果如下：</strong></p><pre class="highlight"><code class="python"><span class="hljs-comment">#带参数装饰器执行效果</span><span class="hljs-meta">&gt;&gt;&gt; </span>@log(level=<span class="hljs-string">'DEBUG'</span>) <span class="hljs-comment">#相当于执行log(level='DEBUG')(test2)</span><span class="hljs-meta">&gt;&gt;&gt; </span>test2() <span class="hljs-comment">#相当于执行log(level='DEBUG')(test2)()</span></code></pre><blockquote><p>以上两个函数test1()和test2()经过装饰器装饰之后变量指向被改变，所以它们的<code>__name__</code>属性已经从原来的test1和test2变成了wrapper。所以需要把原始函数的属性复制到wrapper()函数中。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>test1.__name <span class="hljs-comment">#名称已经被改变</span><span class="hljs-string">'wrapper'</span>|　优 ||　化 | |　代 |V　码 V<span class="hljs-comment">#使用Python内置的functools.wraps可以解决此问题,需要import functools导入functools</span><span class="hljs-keyword">import</span> functools<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timer</span><span class="hljs-params">(func)</span>:</span><span class="hljs-meta">    @functools.wraps(func)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(*args, **kw)</span>:</span>        start_time = time.time()        func(*args,**kw)        stop_time = time.time()        print(<span class="hljs-string">'%s()方法运行时间:%s'</span> % (func.__name__, stop_time-start_time))    <span class="hljs-keyword">return</span> wrapper</code></pre><h2 id="偏函数"><a class="markdownIt-Anchor" href="#偏函数"></a> 偏函数</h2><p>偏函数是Python的functools模块中的一个函数，它和数学中的偏函数不是一个概念。<br>函数在执行时，要带上所有必要的参数进行调用。但是，有时参数可以在调用之前提前获知。这种情况一个函数有一个或多个参数预先就可以使用，以便函数能更少的参数进行调用，functools.partial就可以实现这个功能。</p><p>如：int()函数可以将字符串转换为整数</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>int(<span class="hljs-string">'123'</span>)<span class="hljs-number">123</span><span class="hljs-meta">&gt;&gt;&gt; </span>int(<span class="hljs-string">'123'</span>,base=<span class="hljs-number">16</span>) <span class="hljs-comment">#传入base参数默认值是10，如果传入其它值，就可以做N进制的转换</span><span class="hljs-number">291</span></code></pre><blockquote><p>如果要转换大量N进制字符串，那么每次都要传入base参数，于是就可以利用partical定义一个intN()函数来减少每次传入参数。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-comment">#定义一个二进制转换函数</span><span class="hljs-meta">&gt;&gt;&gt; </span>int2 = functools.partial(int, base=<span class="hljs-number">2</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>int2(<span class="hljs-string">'1000000'</span>)<span class="hljs-number">64</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Python3学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3函数(v3.7)</title>
      <link href="2018/08/11/python/Python3%E5%87%BD%E6%95%B0(v3.7)/"/>
      <url>2018/08/11/python/Python3%E5%87%BD%E6%95%B0(v3.7)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="函数查询"><a class="markdownIt-Anchor" href="#函数查询"></a> 函数查询</h2><p>Python有很多内置函数使用<code>dir()</code>、<code>help()</code>方法查看。<br>dir()方法不带参数返回的是当前范围内的变量、方法和定义的列表;带参数返回的是当前参数的属性、方法列表</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>dir(__builtins__) <span class="hljs-comment">#查看内置函数</span><span class="hljs-meta">&gt;&gt;&gt; </span>dir(int) <span class="hljs-comment">#查看int下的函数</span><span class="hljs-meta">&gt;&gt;&gt; </span>help(int.numerator)　<span class="hljs-comment">#查看int下的numerator()函数用法</span></code></pre><h2 id="函数定义"><a class="markdownIt-Anchor" href="#函数定义"></a> 函数定义</h2><p>Python中使用<code>def</code>定义函数，语法为<code>def 函数名(参数) :</code>,然后在缩进块中编写函数体,返回值用<code>return</code></p><blockquote><p>Python没有大括号语法，使用缩进代替大括号。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(param)</span> :</span><span class="hljs-keyword">if</span> param &lt; <span class="hljs-number">10</span> :<span class="hljs-keyword">return</span> param;<span class="hljs-keyword">else</span> :<span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;</code></pre><blockquote><p>对于递归函数，如果调用过深会出现栈溢出问题，某些语言中如<code>javascript</code> 中可以采用尾递归优化解决这个问题，但大多数解释器(包括Python)都没有对此进行优化，所以即使在代码中对递归函数进行尾递归优化，也不会起作用</p></blockquote><p>函数后面后面可以使用<code>-&gt;</code>表达式，用于描述函数返回类型。</p><pre class="highlight"><code class>def func(param) -&gt; int :    if param &lt; 10 :    return param;else :    return param + 10;</code></pre><h2 id="空函数"><a class="markdownIt-Anchor" href="#空函数"></a> 空函数</h2><p>想定义一个没有任何动作的函数时通过<code>pass</code>语句实现。</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">non</span><span class="hljs-params">()</span> :</span><span class="hljs-keyword">pass</span></code></pre><p>pass语句还可以用在其它语句里，表示什么也不做：</p><pre class="highlight"><code class="python"><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> :<span class="hljs-keyword">pass</span></code></pre><blockquote><p>如果想让一个语句什么也不做使用<code>pass</code>语句，否则程序会报错。</p></blockquote><h2 id="常用函数"><a class="markdownIt-Anchor" href="#常用函数"></a> 常用函数</h2><ul><li>len() 获取字符串长度</li><li>ord() / chr()</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>ord(<span class="hljs-string">'中'</span>) <span class="hljs-comment">#获取字符的整数表示,注意ord函数只接收一个字符参数</span><span class="hljs-number">20013</span><span class="hljs-meta">&gt;&gt;&gt; </span>chr(<span class="hljs-number">20013</span>) <span class="hljs-comment">#编码转换为对应的字符</span><span class="hljs-string">'中'</span></code></pre><ul><li>字符串函数 help(str)</li></ul><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>capitalize()</td><td>把字符串第一个字符改为大写，其余字符改为小写</td></tr><tr><td>casefold()</td><td>把字符串所有大写字符改为小写</td></tr><tr><td>center(width, fillchar=’ ')</td><td>将字符串居中并使用fillchar(默认空格)填充至长度为width的新字符串</td></tr><tr><td>count(sub[, start[, end]])</td><td>返回字符串中sub出现的次数</td></tr><tr><td>encode(encoding=‘utf-8’, errors=‘strict’)</td><td>字符串编码</td></tr><tr><td>startswith(prefix[, start[, end]])</td><td>返回字符串是否以前缀字符开始</td></tr><tr><td>endswith(suffix[, start[, end]])</td><td>返回字符串是否以后缀字符结束</td></tr><tr><td>expandtabs(tabsize=8)</td><td>将字符串中tab字符(\t)转换为tabsize个空格(默认为8)</td></tr><tr><td>find(sub[,start[,end]])</td><td>查找字符串sub字符串的最小索引，找不到时返回-1</td></tr><tr><td>index(sub[, start[, end]])</td><td>作用同上，不同的是找不到时抛出ValueError错误</td></tr><tr><td>join(iterable)</td><td>把字符串作为分割符将iterable进行分割。<br>例: ‘.’.join([‘ab’, ‘pq’, ‘rs’]) -&gt; ‘<a href="http://ab.pq.rs">ab.pq.rs</a>’</td></tr><tr><td>lower()</td><td>将字符串转小写</td></tr><tr><td>upper()</td><td>将字符串转大写</td></tr><tr><td>lstrip(chars=None)</td><td>去掉字符串左空格用chars代替(默认值None)</td></tr><tr><td>rstrip(chars=None)</td><td>去掉字符串右空格用chars代替(默认值None)</td></tr><tr><td>strip(chars=None)</td><td>去掉字符串左右空格用chars代替(默认值None)</td></tr><tr><td>replace(old,new,count=-1)</td><td>将old字符串替换成new字符串，不超过count次(默认-1不限制次数)</td></tr><tr><td>split(sep=None, maxsplit=-1)</td><td>将字符串分割(默认以空格分割)</td></tr><tr><td>swapcase()</td><td>翻转字符串中的大小写</td></tr></tbody></table><h2 id="多返回值"><a class="markdownIt-Anchor" href="#多返回值"></a> 多返回值</h2><p>Python函数可以有多个返回值。</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helloPython</span><span class="hljs-params">()</span> :</span><span class="hljs-keyword">return</span> <span class="hljs-string">'hello'</span>,<span class="hljs-string">'Python'</span>x,y=helloPython()print(x)　--&gt; helloprint(y)  --&gt; Python</code></pre><blockquote><p>实际上，Python返回的是一个元组。但是，Python语法允许多个变量接收一个元组，只需按位置赋给对应值。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>print(helloPython())(<span class="hljs-string">'hello'</span>, <span class="hljs-string">'Python'</span>)  <span class="hljs-comment">#直接打印函数返回值结果是一个元组</span></code></pre><h2 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数</h2><h3 id="位置参数"><a class="markdownIt-Anchor" href="#位置参数"></a> 位置参数</h3><p>调用函数时，必须根据的函数定义的参数位置一一对应传递，且不可少。</p><h3 id="默认参数"><a class="markdownIt-Anchor" href="#默认参数"></a> 默认参数</h3><p>定义函数时，可以直接在参数后面用等式设置默认参数，调用时此参数可以不用传递任何值。</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(param=<span class="hljs-number">5</span>)</span> :</span>　<span class="hljs-comment">#默认参数为5</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(param,(int,float)) :<span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'invalid param'</span>)<span class="hljs-keyword">if</span> param &lt; <span class="hljs-number">10</span> :<span class="hljs-keyword">return</span> param;<span class="hljs-keyword">else</span> :<span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;</code></pre><blockquote><p>设置默认参数时，必须位置参数在前，默认参数在后，否则解释器会报错。调用时可以传递部分默认参数值，但必须指定默认参数名字。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(name,age,sex=<span class="hljs-string">'M'</span>,address=<span class="hljs-string">'Beijing'</span>)</span> :</span><span class="hljs-keyword">pass</span>func(<span class="hljs-string">'张三'</span>,<span class="hljs-number">21</span>,address=<span class="hljs-string">'Shanghai'</span>) <span class="hljs-comment">#传递部分默认参数</span></code></pre><blockquote><p>**注意：**默认参数必须指定不变对象，否则会被函数内赋值改变。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(param=[])</span> :</span> <span class="hljs-comment">#默认参数指向可变参数</span>param.append(<span class="hljs-string">'END'</span>)<span class="hljs-keyword">return</span> paramfunc()func()print(func()) --&gt; [<span class="hljs-string">'END'</span>,<span class="hljs-string">'END'</span>,<span class="hljs-string">'END'</span>]</code></pre><p>上面多次调用函数后，由于默认参数没有指定不变对象，而出现混乱。修改上面例子：</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(param=None)</span> :</span><span class="hljs-keyword">if</span> param <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> :param = []<span class="hljs-keyword">return</span> paramfunc()func()print(func()) --&gt; []</code></pre><h3 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h3><p>可变参数即函数参数可以是动态的可变的，调用函数时可随意传入0…N个可变参数。采用<code>*args</code>形式，在函数内部自动组装成一个元组。</p><pre class="highlight"><code class="python"><span class="hljs-comment">#定义可变参数函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(*numbers)</span> :</span>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers :        print(n)<span class="hljs-comment">#调用可变参数函数</span>L = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>];func(*L)</code></pre><h3 id="关键字参数"><a class="markdownIt-Anchor" href="#关键字参数"></a> 关键字参数</h3><p>类似可变参数，采用<code>**args</code>形式，调用函数时可随意传入0…N个关键字参数，在函数内部自动组装成一个字典。</p><pre class="highlight"><code class="python"><span class="hljs-comment">#定义关键字参数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(**kw)</span> :</span>    print(kw)<span class="hljs-comment">#调用关键字参数</span>kw=&#123;<span class="hljs-string">'address'</span>:<span class="hljs-string">'Beijing'</span>,<span class="hljs-string">'code'</span>:<span class="hljs-number">90</span>&#125;func(**kw)</code></pre><ul><li>命名关键字参数</li></ul><p>默认可以传入任何名字关键字参数，如果想要限制传入的关键字参数的名字，可使用<code>*</code>符号分割。</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(*,address,code)</span> :</span>print(kw)func(address＝<span class="hljs-string">'Beijing'</span>,code＝<span class="hljs-number">8</span>) --&gt; 正确func(name＝<span class="hljs-string">'Bob'</span>) --&gt;　<span class="hljs-comment">#错误 只允许传入address或code名字的关键字参数</span></code></pre><blockquote><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(*name,address,code)</span> :</span> <span class="hljs-comment">#address、code是关键字参数</span><span class="hljs-keyword">pass</span></code></pre><h3 id="参数组合"><a class="markdownIt-Anchor" href="#参数组合"></a> 参数组合</h3><p>在Python中定义函数，可以用位置参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：位置参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><blockquote><p>对于任意函数都可以使用<code>*args</code>、<code>**args</code>的形式调用它，无论它的参数是如何定义的。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(name,age,sex=<span class="hljs-string">'M'</span>,*args,**kw)</span> :</span>print(<span class="hljs-string">'name='</span>,name,<span class="hljs-string">'age='</span>,age,<span class="hljs-string">'sex='</span>,sex,<span class="hljs-string">'*args='</span>,args,<span class="hljs-string">'**kw='</span>,kw)args = [<span class="hljs-string">'张三'</span>,<span class="hljs-number">20</span>,<span class="hljs-string">'M'</span>,<span class="hljs-string">'Beijing'</span>]kw = &#123;<span class="hljs-string">'code'</span>:<span class="hljs-number">8</span>,<span class="hljs-string">'job'</span>:<span class="hljs-string">'teacher'</span>&#125;func(*args,**kw)结果：name= 张三 age= <span class="hljs-number">20</span> sex= M *args= (<span class="hljs-string">'Beijing'</span>,) **kw= &#123;<span class="hljs-string">'code'</span>: <span class="hljs-number">8</span>, <span class="hljs-string">'job'</span>: <span class="hljs-string">'teacher'</span>&#125;</code></pre><h3 id="参数检查"><a class="markdownIt-Anchor" href="#参数检查"></a> 参数检查</h3><p>由于Python是动态类型，函数参数无法确定是什么类型，因此如果传入不恰当类型会导致程序报错。所以一个完整的函数需要使用内置函数<code>isinstance()</code>做参数校验。</p><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(param)</span> :</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> isinstance(param,(int,float)) :<span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">'invalid param'</span>)<span class="hljs-keyword">if</span> param &lt; <span class="hljs-number">10</span> :<span class="hljs-keyword">return</span> param;<span class="hljs-keyword">else</span> :<span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;</code></pre><blockquote><p>当程序出现错误，python会自动引发异常，也可以通过raise显示地引发异常。一旦执行了raise语句，raise后面的语句将不能执行。</p></blockquote><h2 id="变量作用域"><a class="markdownIt-Anchor" href="#变量作用域"></a> 变量作用域</h2><p>python 一共有四种作用域：</p><ul><li><strong>L(Local)</strong> 函数内的区域，包括局部变量和形参。</li><li><strong>E(Enclosing)</strong> 外面嵌套函数的区域，通常是闭包外的函数。</li><li><strong>G(Global)</strong> 全局作用域。</li><li><strong>B(Built-in)</strong> 内建作用域。</li></ul><blockquote><p>Python变量作用域查找顺序为<code>L-&gt;E-&gt;G-&gt;B</code>。</p></blockquote><ul><li>关键字 <code>global</code>和<code>nonlocal</code><br>局部作用域中可以随时读取其他作用域变量，但是局部作用域修改其他作用域变量时需要使用相关关键字。<br><code>global</code>关键字用来在局部作用域中修改全局变量。<br><code>nonlocal</code>是<code>Python3</code>中新增的关键字，用来在嵌套函数中修改嵌套作用中的变量。</li></ul><pre class="highlight"><code class="java">x = <span class="hljs-number">50</span><span class="hljs-function">def <span class="hljs-title">func1</span><span class="hljs-params">()</span> :    global x# 全局变量 x<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">"x old value"</span>,x)</span>x </span>= <span class="hljs-number">20</span>print(<span class="hljs-string">"x new value"</span>,x)a = <span class="hljs-number">10</span><span class="hljs-function">def <span class="hljs-title">func2</span><span class="hljs-params">()</span> :    nonlocal a# <span class="hljs-title">func1</span><span class="hljs-params">()</span> 中嵌套变量 a<span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">"a old value"</span>,a)</span>a+</span>=<span class="hljs-number">1</span>print(<span class="hljs-string">"a new value"</span>,a)<span class="hljs-keyword">return</span> func2()func1()----------------------------------x old value <span class="hljs-number">50</span>x <span class="hljs-keyword">new</span> value <span class="hljs-number">20</span>a old value <span class="hljs-number">10</span>a <span class="hljs-keyword">new</span> value <span class="hljs-number">11</span></code></pre><blockquote><p>使用global关键字进行修饰的变量之前可以不存在，而使用nonlocal关键字进行修饰的变量在嵌套作用域中必须已经存在。</p></blockquote><h2 id="生成器"><a class="markdownIt-Anchor" href="#生成器"></a> 生成器</h2><p>对于列表生成式生成的列表受内存等原因限制列表容量有限，如果通过计算把list列表的后面元素推算出来，实现边循环边计算的机制，就不必提前生成列表，理论上就实现了无限大小，Python中把这种机制叫做生成器。</p><ul><li>创建生成器最简单的方法就是把列表生成式的<code>[　]</code>改成<code>(　)</code>即可：</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>g = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>))<span class="hljs-meta">&gt;&gt;&gt; </span>g&lt;generator object &lt;genexpr&gt; at <span class="hljs-number">0x10fa3ba20</span>&gt;<span class="hljs-meta">&gt;&gt;&gt; </span>next(g) <span class="hljs-comment">#通过next()方法调用</span><span class="hljs-number">0</span><span class="hljs-meta">&gt;&gt;&gt; </span>next(g)<span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;&gt; </span>next(g)<span class="hljs-number">2</span></code></pre><blockquote><p>如上生成器保存的是算法，而不是真正的数值，每次通过<code>next()</code>函数调用计算出g的下一个值，直到g没有更多元素时将会抛出<code>StopIteration</code>错误。通常我们通过for循环调用生成器，并且没有下一个元素时也不会抛出错误。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> g : <span class="hljs-comment">#通过for循环调用生成器</span>print(n)</code></pre><ul><li>如果函数定义中包含<code>yield</code>关键字,此时函数就是一个声明的生成器：</li></ul><pre class="highlight"><code class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(max)</span> :</span>    n,a,b = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> n &lt; max :        <span class="hljs-keyword">yield</span> b        a,b = b,a+b        n = n + <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">'done'</span>g = fib(<span class="hljs-number">10</span>)print(g) --&gt; &lt;generator object fib at <span class="hljs-number">0x1067a9480</span>&gt;</code></pre><blockquote><p>上面定义的的函数因为包括yield关键字，已经不是普通的函数了，而是一个生成器(如上：打印生成器g返回generator)。generator的执行顺序和普通函数不样，每次调用next()函数遇到yield返回其后面的值，再次执行时从上次返回的yield处继续执行，直到函数中没有yield抛出<code>StopIteration</code>错误为止。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> g : <span class="hljs-comment">#调用生成器函数</span>    print(x)</code></pre><blockquote><p>通过for循环调用生成器得不到函数中的return返回值，如果想要得到返回值，必须捕获<code>StopIteration</code>异常，其值在<code>StopIteration</code>的value中。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span> :<span class="hljs-keyword">try</span> :x = next(g)print(x) <span class="hljs-comment">#得到生成器yield返回值</span><span class="hljs-keyword">except</span> StopIteration <span class="hljs-keyword">as</span> e :print(e.value) <span class="hljs-comment">#得到函数中return返回值</span><span class="hljs-keyword">break</span></code></pre><p>关于更多错误处理请参见<a href="/2018/08/19/python/Python3异常处理与调试(v3.7)">Python3异常处理</a></p><h2 id="迭代器"><a class="markdownIt-Anchor" href="#迭代器"></a> 迭代器</h2><p>可以直接作用于for循环的对象称为<em><strong>可迭代对象***(Iterable)，包括<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>和<code>生成器</code>等。可以使用</strong>isinstatnce()<strong>判断一个对象是否为</strong>Iterable</em>*对象：</p><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Iterableisinstance([],Iterable) --&gt; <span class="hljs-literal">True</span></code></pre><p>生成器不但可以作用于<strong>for</strong>循环，还可以被<em><em>next()<strong>函数调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值。<br>可以被</strong>next()<strong>函数调用并返回下一个值的对象称为</strong></em>迭代器</em>**(Iterator)。同样，可以使用<strong>isinstatnce()<strong>判断一个对象是否为</strong>Iterator</strong>对象：</p><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Iteratorisinstance([],Iterator) --&gt; <span class="hljs-literal">False</span></code></pre><blockquote><p>生成器都是<strong>Iterator</strong>对象,但其它<strong>Iterable</strong>对象不是<strong>Iterator</strong>对象，可以使用<code>iter()</code>函数把其变成<strong>Iterator</strong>对象。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(iter([]),Iterator)<span class="hljs-literal">True</span></code></pre><blockquote><p><strong>Iterator</strong>对象表示一个数据流，不知道长度，只能通过<strong>next()<strong>函数调用计算下一个数据，因此</strong>Iterator</strong>对象是惰性的，只有在需要时才计算并返回下一个数据。甚至其可以表示无限大的数据流，而<strong>list</strong>等<strong>Iterable</strong>对象显然不能存储无限大数据，所以它们不是<strong>Iterator</strong>对象。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Python3学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python3基础语法(v3.7)</title>
      <link href="2018/08/09/python/Python3%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(v3.7)/"/>
      <url>2018/08/09/python/Python3%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(v3.7)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><h3 id="整数-浮点"><a class="markdownIt-Anchor" href="#整数-浮点"></a> 整数、浮点</h3><ul><li>除法计算<code>/</code>(除法）、<code>//</code>(取整除法)、<code>%</code>(取模)、<code>**</code>(幂运算)</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">10</span>/<span class="hljs-number">3</span><span class="hljs-number">3.3333333333333335</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">9</span>/<span class="hljs-number">3</span><span class="hljs-number">3.0</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">10</span>//<span class="hljs-number">3</span><span class="hljs-number">3</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">9</span>//<span class="hljs-number">3</span><span class="hljs-number">3</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">10</span>%<span class="hljs-number">3</span><span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">9</span>%<span class="hljs-number">3</span><span class="hljs-number">0</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">3</span>**<span class="hljs-number">2</span><span class="hljs-number">9</span></code></pre><blockquote><p>求模运算和求余运算在第一步不同: 取余运算在取值时，向0 方向舍入(fix()函数)；而取模运算在计算值时，向负无穷方向舍入(floor()函数)。当两变量符号一致时，求模运算和求余运算所得的值是一致的。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">-7</span>%<span class="hljs-number">4</span><span class="hljs-number">1</span>  <span class="hljs-comment"># python中为取模运算结果为1而不是3;在c/c++，java中用取余运算结果为-3。 </span></code></pre><p><strong>Python3中提供两种除法<code>/</code>计算结果是浮点值<code>//</code>叫做取整除法，计算结果是整数，即使除不尽。</strong></p><h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3><p>用单引号<code>'</code>或双引号<code>&quot;</code>括起来的任意文本。如：<code>abcdefg</code> 或 <code>&quot;abcdefg&quot;</code></p><p>Python3采取Unicode编码，因此Python3支持多语言。</p><h4 id="表示法"><a class="markdownIt-Anchor" href="#表示法"></a> 表示法</h4><ul><li>转义字符 <code>\</code>，如：(\n、\t、\)等等</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">'C:\new'</span>)C:ew<span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">'C:\\new'</span>)C:\new</code></pre><ul><li><code>r' '</code> 或　<code>r&quot; &quot;</code></li></ul><p>内部字符串默认不转义</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">r'C:\new'</span>)C:\new</code></pre><p>Python通过引入<code>re</code>模块<code>match()</code>方法进行正则匹配。正则表达式可以直接以<code>' '</code>或<code>&quot; &quot;</code>形式表示，因为Python字符串本身也用<code>\</code>符号转义，如果使用<code>r</code>正则表示法，就不再需要考虑<code>\</code>转义符。</p><pre class="highlight"><code class="python">s = <span class="hljs-string">'(?&lt;=@)\\S+(?=\\s)'</span> |_______________| 两种方法意思相同||￣￣￣￣￣￣￣￣￣Vs = <span class="hljs-string">r'(?&lt;=@)\S+(?=\s)'</span></code></pre><blockquote><p><code>r''</code>表示法最后不能有<code>\</code>，可以使用<code>r''+'\\'</code>方法代替。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">r'C:\new\'SyntaxError: EOL while scanning string literal&gt;&gt;&gt; r'</span>C:\new<span class="hljs-string">'+'</span>\\<span class="hljs-string">''</span>C:\\new\\<span class="hljs-string">'</span></code></pre><p>更多正则语法参考<a href="/2018/01/10/tech_stack/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/">正则表达式语法</a></p><ul><li><code>'''...'''</code> 或 <code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 自定义格式字符串</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>print(<span class="hljs-string">'''abc<span class="hljs-meta">... </span>   def<span class="hljs-meta">... </span>cc'''</span>)abc   <span class="hljs-function"><span class="hljs-keyword">def</span><span class="hljs-title">cc</span></span></code></pre><ul><li><code>b' '</code> 或 <code>b&quot; &quot;</code> 字节表示法<br>Python3对bytes类型用<code>b</code>作为前缀来表示。</li></ul><p>以Unicode表示的字符串可以通过encode() / decode() 函数编(解)码为字节或字符串</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'中'</span>.encode(<span class="hljs-string">'utf-8'</span>)<span class="hljs-string">b'\xe4\xb8\xad'</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">b'\xe4\xb8\xad'</span>.decode(<span class="hljs-string">'utf-8'</span>)<span class="hljs-string">'中'</span></code></pre><h4 id="格式化"><a class="markdownIt-Anchor" href="#格式化"></a> 格式化</h4><p>Python3中有两种格式化方法：一种是<code>%</code>，另一种是利用format()函数。<br>通常作用<code>%</code>方法比较简洁，具体用法如下：</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'Hello, %s'</span> % <span class="hljs-string">'Python3'</span><span class="hljs-string">'Hello, Python3'</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'%s got %d on the math test'</span> % (<span class="hljs-string">'Lili'</span>,<span class="hljs-number">100</span>)<span class="hljs-string">'Lili got 100 on the math test'</span></code></pre><p>format格式化</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>st = <span class="hljs-string">'a,&#123;0&#125;,c,&#123;1&#125;'</span>.format(<span class="hljs-string">'b'</span>,<span class="hljs-string">'d'</span>) <span class="hljs-comment">#位置格式化</span><span class="hljs-meta">&gt;&gt;&gt; </span>st<span class="hljs-string">'a,b,c,d'</span><span class="hljs-meta">&gt;&gt;&gt; </span>sk = <span class="hljs-string">'a,&#123;b&#125;,c,&#123;d&#125;'</span>.format(b=<span class="hljs-string">'b'</span>, d=<span class="hljs-string">'d'</span>) <span class="hljs-comment">#关键字格式化</span><span class="hljs-meta">&gt;&gt;&gt; </span>sk<span class="hljs-string">'a,b,c,d'</span><span class="hljs-meta">&gt;&gt;&gt; </span>sm = <span class="hljs-string">'a,&#123;b&#125;,c,&#123;0&#125;'</span>.format(<span class="hljs-string">'d'</span>, b=<span class="hljs-string">'b'</span>) <span class="hljs-comment">#混合使用格式化(位置参数在前，关键字参数在后）</span><span class="hljs-meta">&gt;&gt;&gt; </span>sm<span class="hljs-string">'a,b,c,d'</span><span class="hljs-meta">&gt;&gt;&gt; </span>sm = <span class="hljs-string">'a,&#123;b&#125;,c,&#123;0&#125;'</span>.format(b=<span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>) <span class="hljs-comment">#报错原因关键字参数在位置参数之后</span>SyntaxError: positional argument follows keyword argument<span class="hljs-meta">&gt;&gt;&gt; </span>sp2 = <span class="hljs-string">'&#123;0&#125; = &#123;1:.3f&#125;'</span>.format(<span class="hljs-string">'𝞹'</span>,<span class="hljs-number">3.1415926</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>sp2𝞹 = <span class="hljs-number">3.142</span> <span class="hljs-comment">#:表示格式化符号.3f表示保留3位浮点数，且自动四舍五入</span></code></pre><p>格式化符号：</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">%c</td><td style="text-align:center">格式化字符及其ASCII码</td></tr><tr><td style="text-align:center">%d</td><td style="text-align:center">整型</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">浮点型</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">字符型</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">十六进制</td></tr><tr><td style="text-align:center">%e</td><td style="text-align:center">科学计数法</td></tr></tbody></table><pre class="highlight"><code class="python"><span class="hljs-comment">#两种表示法意思相同</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'&#123;0:c&#125;,&#123;1:c&#125;'</span>.format(<span class="hljs-number">97</span>,<span class="hljs-number">98</span>)<span class="hljs-string">'a,b'</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'%c,%c'</span> % (<span class="hljs-number">97</span>,<span class="hljs-number">98</span>)<span class="hljs-string">'a,b'</span></code></pre><p>格式化辅助符号：</p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">m.n</td><td style="text-align:center">m表示显示最小总宽度,n表示小数点后位数</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">左对齐</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">正数前面显示+号</td></tr><tr><td style="text-align:center">#</td><td style="text-align:center">八进制前面显示(0)，十六进制前面显示(0x 或 0X)</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">数字前面填充0</td></tr></tbody></table><h3 id="布尔值"><a class="markdownIt-Anchor" href="#布尔值"></a> 布尔值</h3><p>布尔值有两种值<code>True</code>和<code>False</code>，实际上布尔值是特殊的整数True=1，False=0</p><ul><li>条件运算<code>and</code>、<code>or</code>、<code>not</code></li></ul><pre class="highlight"><code class="python"><span class="hljs-comment"># and</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">True</span><span class="hljs-literal">True</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span> <span class="hljs-keyword">and</span> <span class="hljs-literal">False</span><span class="hljs-literal">False</span><span class="hljs-comment"># or</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">True</span><span class="hljs-literal">True</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">True</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><span class="hljs-literal">True</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-literal">False</span> <span class="hljs-keyword">or</span> <span class="hljs-literal">False</span><span class="hljs-literal">False</span><span class="hljs-comment"># not</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">True</span><span class="hljs-literal">False</span><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">not</span> <span class="hljs-literal">False</span><span class="hljs-literal">True</span></code></pre><h3 id="空值"><a class="markdownIt-Anchor" href="#空值"></a> 空值</h3><p>python里用None表示空值</p><h3 id="列表list"><a class="markdownIt-Anchor" href="#列表list"></a> 列表(list)</h3><p>Python3内置数据类型，是一种可变的有序的集合。</p><ul><li>声明</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors=[<span class="hljs-string">'red'</span>,<span class="hljs-string">'black'</span>,<span class="hljs-string">'white'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-string">'red'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>len(colors)<span class="hljs-number">3</span></code></pre><ul><li>读取</li></ul><p>可以通过索引获取元素，索引从0开始</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-number">0</span>]<span class="hljs-string">'red'</span><span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-number">-1</span>] <span class="hljs-comment"># 可以通过负数从后往前读取</span><span class="hljs-string">'white'</span><span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-number">-2</span>]<span class="hljs-string">'black'</span></code></pre><ul><li>append() 追加元素</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors.append(<span class="hljs-string">'green'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-string">'red'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'green'</span>]</code></pre><ul><li>extend() 追加列表<br>append的函数一次只能追加一个元素，如果想要同时追加多个元素使用extend()方法,该方法接收一个iterable(迭代对象)参数。</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors.extend([<span class="hljs-string">'pink'</span>,<span class="hljs-string">'yellow'</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-string">'red'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>]</code></pre><blockquote><p>append()函数也可以接收一个如上面list参数，但与extend()区别是此函数会把此list当作一个元素追加到列表。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors.append([<span class="hljs-string">'blue'</span>,<span class="hljs-string">'purple'</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-string">'red'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>, [<span class="hljs-string">'blue'</span>, <span class="hljs-string">'purple'</span>]]</code></pre><ul><li>insert() 指定位置插入元素</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors.insert(<span class="hljs-number">1</span>,<span class="hljs-string">'purple'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-string">'red'</span>, <span class="hljs-string">'purple'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>, [<span class="hljs-string">'blue'</span>, <span class="hljs-string">'purple'</span>]]</code></pre><ul><li>pop(index=-1) 删除元素</li></ul><p>默认删除索引为-1的元素（也就是最后一个元素)。</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors.pop()[<span class="hljs-string">'blue'</span>, <span class="hljs-string">'purple'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-string">'red'</span>, <span class="hljs-string">'purple'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>colors.pop(<span class="hljs-number">2</span>) <span class="hljs-comment">#删除指定位置元素</span><span class="hljs-string">'black'</span><span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-string">'red'</span>, <span class="hljs-string">'purple'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>]</code></pre><ul><li>remove() 删除指定元素</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors.remove(<span class="hljs-string">'white'</span>)[<span class="hljs-string">'red'</span>, <span class="hljs-string">'purple'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>]</code></pre><blockquote><p>list可以存储不同数据类型，也可以存储list，因此读取元素类型为list的元素时可以看成是多维数组的读取。如：colors[0][1]</p></blockquote><h3 id="元组tuple"><a class="markdownIt-Anchor" href="#元组tuple"></a> 元组(tuple)</h3><p>tuple是一组有序不可变的元组，一旦初始化后，不能被改变。</p><ul><li>声明</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors=(<span class="hljs-string">'red'</span>,<span class="hljs-string">'black'</span>,<span class="hljs-string">'white'</span>)</code></pre><ul><li>读取</li></ul><p>与list一样采用索引方式读取，索引从0开始。但没有append()、pop()等方法，因为不可变。</p><blockquote><p>理论上tuple是不可变的，但可以通过两个tuple相加获取第三个tuple实现改变。如果tuple中的元素是list类型，则list元素里的内容也是可变的。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-comment"># tuple相加</span><span class="hljs-meta">&gt;&gt;&gt; </span>tup1 = (<span class="hljs-number">12</span>, <span class="hljs-number">34.56</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>tup2 = (<span class="hljs-string">'abc'</span>, <span class="hljs-string">'xyz'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>tup3 = tup1 + tup2<span class="hljs-meta">&gt;&gt;&gt; </span>tup3(<span class="hljs-number">12</span>, <span class="hljs-number">34.56</span>, <span class="hljs-string">'abc'</span>, <span class="hljs-string">'xyz'</span>)<span class="hljs-comment"># 改变tuple中list元素</span><span class="hljs-meta">&gt;&gt;&gt; </span>tup = (<span class="hljs-string">'red'</span>,[<span class="hljs-string">'black'</span>,<span class="hljs-string">'green'</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>tup[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-string">'pink'</span><span class="hljs-meta">&gt;&gt;&gt; </span>tup(<span class="hljs-string">'red'</span>, [<span class="hljs-string">'pink'</span>, <span class="hljs-string">'green'</span>])</code></pre><ul><li>空元组</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors=()<span class="hljs-meta">&gt;&gt;&gt; </span>colors()</code></pre><blockquote><p>当定义只有一个元素的tuple时，由于<code>()</code>既可以表示tuple又可以表示数学符号，因此会产生歧义。Python规定，这种情况按数学符号小括号进行计算，计算结果为1。所以声明只有一个元素的tuple时必须加一个<code>,</code>来消除歧义。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors=(<span class="hljs-string">'red'</span>,) <span class="hljs-comment">#声明一个元素的tuple</span></code></pre><p><strong>tuple也可以使用切片进行复制和读取。</strong></p><h3 id="字典dict"><a class="markdownIt-Anchor" href="#字典dict"></a> 字典(dict)</h3><p>字典采用键值对形式存储，也称为Map，查找速度快。</p><ul><li>声明</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>scores=&#123;<span class="hljs-string">'Math'</span>:<span class="hljs-number">95</span>,<span class="hljs-string">'Chi'</span>:<span class="hljs-number">98</span>,<span class="hljs-string">'Eng'</span>:<span class="hljs-number">92</span>&#125;</code></pre><ul><li>读取</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>scores[<span class="hljs-string">'Math'</span>] <span class="hljs-comment">#通过键名读取，如果key不存在会报错</span><span class="hljs-number">95</span><span class="hljs-meta">&gt;&gt;&gt; </span>scores.get(<span class="hljs-string">'Chi'</span>) <span class="hljs-comment">#通过get()方法读取，如果key不存在，会返回None，交互环境下不显示结果</span><span class="hljs-number">98</span></code></pre><p>－　键值判断 <code>in</code></p><p>为了以免key不存在而报错，除了上面的get()方法外，还可以通过<code>in</code>来判断。</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">'Eng'</span> <span class="hljs-keyword">in</span> scores<span class="hljs-literal">True</span></code></pre><ul><li>删除</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>scores.pop(<span class="hljs-string">'Math'</span>)<span class="hljs-number">95</span><span class="hljs-meta">&gt;&gt;&gt; </span>scores&#123;<span class="hljs-string">'Chi'</span>: <span class="hljs-number">98</span>, <span class="hljs-string">'Eng'</span>: <span class="hljs-number">92</span>&#125;</code></pre><blockquote><p>字典查找速度快，且不会随着key的增加而变慢。但需要占用大量内存，是用空间换时间的一种方法。而集合恰好相反，占用空间小，但会随着元素增加而变慢。</p></blockquote><h3 id="集合set"><a class="markdownIt-Anchor" href="#集合set"></a> 集合(set)</h3><p>是一组无序的不存在重复元素的集合。</p><ul><li>声明</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>names=set([<span class="hljs-string">'Micheal'</span>,<span class="hljs-string">'Jack'</span>,<span class="hljs-string">'Bob'</span>])<span class="hljs-meta">&gt;&gt;&gt; </span>names&#123;<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Jack'</span>, <span class="hljs-string">'Micheal'</span>&#125; <span class="hljs-comment">#存储时使用[]但读取时显示的是&#123;&#125;</span></code></pre><ul><li><p>读取</p></li><li><p>存储<br>集合通过add()方法添加元素，当添加的元素已存在时，不会报错，但是不会显示。</p></li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>names.add(<span class="hljs-string">'James'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>names.add(<span class="hljs-string">'Bob'</span>) <span class="hljs-comment">#重复添加Bob</span><span class="hljs-meta">&gt;&gt;&gt; </span>names&#123;<span class="hljs-string">'Bob'</span>, <span class="hljs-string">'Jack'</span>, <span class="hljs-string">'Micheal'</span>, <span class="hljs-string">'James'</span>&#125; <span class="hljs-comment">#依然显示一个Bob</span></code></pre><ul><li>删除</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>names.remove(<span class="hljs-string">'Bob'</span>)<span class="hljs-meta">&gt;&gt;&gt; </span>names&#123;<span class="hljs-string">'Jack'</span>, <span class="hljs-string">'Micheal'</span>, <span class="hljs-string">'James'</span>&#125;</code></pre><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>由于Python的动态语言特性，变量不需要声明也不需要指定类型。</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>test=<span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(test)<span class="hljs-number">1</span><span class="hljs-meta">&gt;&gt;&gt; </span>test=<span class="hljs-string">'abc'</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(test)abc<span class="hljs-meta">&gt;&gt;&gt; </span>test=<span class="hljs-literal">True</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(test)<span class="hljs-literal">True</span></code></pre><h3 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h3><p>Python没有严格意义上的常量，定义的常量仍然可以修改。习惯上用大写字母表示常量：</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>VERSION=<span class="hljs-string">'v1.0'</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(VERSION)v1<span class="hljs-number">.0</span><span class="hljs-meta">&gt;&gt;&gt; </span>VERSION=<span class="hljs-string">'V2.0'</span><span class="hljs-meta">&gt;&gt;&gt; </span>print(VERSION)v2<span class="hljs-number">.0</span></code></pre><h2 id="条件判断"><a class="markdownIt-Anchor" href="#条件判断"></a> 条件判断</h2><h3 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h3><pre class="highlight"><code class="python"><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> :print(<span class="hljs-string">'true'</span>)</code></pre><h3 id="else"><a class="markdownIt-Anchor" href="#else"></a> else</h3><pre class="highlight"><code class="python"><span class="hljs-keyword">if</span> <span class="hljs-literal">True</span> :print(<span class="hljs-string">'true'</span>)<span class="hljs-keyword">else</span> :print(<span class="hljs-string">'false'</span>)</code></pre><h3 id="elif"><a class="markdownIt-Anchor" href="#elif"></a> elif</h3><pre class="highlight"><code class="python">temp=input(<span class="hljs-string">'请输入一个数字：'</span>)guess=int(temp) <span class="hljs-comment">#input输入的为字符串需要先通过内置函数int()转换成整数</span><span class="hljs-keyword">if</span> guess &gt; <span class="hljs-number">10</span> :print(<span class="hljs-string">'大于10的数字'</span>)<span class="hljs-keyword">elif</span> guess &gt; <span class="hljs-number">20</span> :print(<span class="hljs-string">'大于20的数字'</span>)<span class="hljs-keyword">else</span> :print(<span class="hljs-string">'其它数字'</span>)</code></pre><h3 id="三元操作符"><a class="markdownIt-Anchor" href="#三元操作符"></a> 三元操作符</h3><p>Python从2.5版本后开始支持三元操作符，来简化if…else操作。</p><pre class="highlight"><code class="python">x = input()y = input()<span class="hljs-keyword">if</span> x &gt; y:    temp = x<span class="hljs-keyword">else</span>:    temp = y|优||化||代||码|V　V temp = x <span class="hljs-keyword">if</span> x &gt; y <span class="hljs-keyword">else</span> y</code></pre><h3 id="变量判断"><a class="markdownIt-Anchor" href="#变量判断"></a> 变量判断</h3><pre class="highlight"><code class="python"><span class="hljs-keyword">if</span> x :print(<span class="hljs-string">'True'</span>)</code></pre><p><strong>只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False</strong></p><h2 id="循环"><a class="markdownIt-Anchor" href="#循环"></a> 循环</h2><h3 id="forin"><a class="markdownIt-Anchor" href="#forin"></a> for…in</h3><p>for…in循环可以迭代出list、tuple、dict、set、str、range()等。</p><pre class="highlight"><code class="python"><span class="hljs-comment">#通过内置函数打印0到9的数字</span><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) :print(num)<span class="hljs-comment">#打印list中的名字</span><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> [<span class="hljs-string">'Micheal'</span>,<span class="hljs-string">'Jack'</span>] :print(name)</code></pre><blockquote><p>for循环，可作用于一切可迭代对象，无论该对象有无下标。当迭代字典时默认迭代的是key，如果想要迭代values可使用values()内置函数<code>for value in d.values()</code>,如果两者想要同时迭代可使用items()内置函数<code>for k,v in d.items()</code></p></blockquote><ul><li><code>range(start,stop[,step])</code>用法：<br>start参数，开始计数，默认0。range(3)等价于range(0,3)。<br>stop参数，结束计数（不包括）。<br>step参数，步长，默认1。range(0,3)等价于range(0,3,1);反向可传入负数 range(0,3,-1)。</li></ul><p><strong>既然for循环可以作用于一切可迭代对象，那么如何判断一个对象是否为可迭代对象呢？可以通过collections模块Iterable进行判断，如下：</strong></p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Iterable<span class="hljs-meta">&gt;&gt;&gt; </span>isinstance(d,Iterable) <span class="hljs-comment">#判断字典d是否可迭代对象</span><span class="hljs-literal">True</span></code></pre><p><strong>for循环实现下标循环(enumerate)：</strong></p><pre class="highlight"><code class="python">d=&#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'张三'</span>,<span class="hljs-string">'sex'</span>:<span class="hljs-string">'男'</span>,<span class="hljs-string">'age'</span>:<span class="hljs-string">'18'</span>&#125;<span class="hljs-keyword">for</span> i,value <span class="hljs-keyword">in</span> enumerate(d) :　<span class="hljs-comment">#通过enumerate函数实现下标循环</span>print(i,value)结果：<span class="hljs-number">0</span> name<span class="hljs-number">1</span> sex<span class="hljs-number">2</span> age</code></pre><h3 id="while"><a class="markdownIt-Anchor" href="#while"></a> while</h3><p>当while满足指定条件就会不断循环。</p><pre class="highlight"><code class="python">n=<span class="hljs-number">0</span><span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">10</span> :n += <span class="hljs-number">1</span> <span class="hljs-comment">#Python不支持++运算符</span>print(n)</code></pre><h3 id="break"><a class="markdownIt-Anchor" href="#break"></a> break</h3><p>在循环中可以通过<code>break</code>跳出循环。</p><pre class="highlight"><code class="python">n=<span class="hljs-number">0</span><span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">10</span> :n += <span class="hljs-number">1</span> <span class="hljs-comment">#Python不支持++运算符</span>print(n)<span class="hljs-keyword">if</span> n == <span class="hljs-number">5</span> :<span class="hljs-keyword">break</span></code></pre><h3 id="continue"><a class="markdownIt-Anchor" href="#continue"></a> continue</h3><p>在循环中通过<code>continue</code>跳过本次循环。</p><pre class="highlight"><code class="python">n=<span class="hljs-number">0</span><span class="hljs-keyword">while</span> n &lt; <span class="hljs-number">10</span> :    <span class="hljs-keyword">if</span> n == <span class="hljs-number">5</span> :        <span class="hljs-keyword">continue</span>    n += <span class="hljs-number">1</span> <span class="hljs-comment">#Python不支持++运算符</span>    print(n)</code></pre><h2 id="with语句"><a class="markdownIt-Anchor" href="#with语句"></a> with语句</h2><p>任何对象，只要正确实现了上下文管理，就可以用于with语句。<br>实现上下文管理是通过<code>__enter__</code>和<code>__exit__</code>这两个方法实现的。典型的使用场景<a href="/2018/08/20/python/Python3%20IO编程(v3.7)">IO编程</a>open()方法</p><pre class="highlight"><code class="python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseWith</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__enter__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__exit__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">pass</span>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">pass</span><span class="hljs-comment">#使用with语句        </span><span class="hljs-keyword">with</span> UserWith() <span class="hljs-keyword">as</span> uw:    uw.func()</code></pre><blockquote><p>实现上下文方法比较繁琐，Python提供<code>contextlib</code>标准库提供了更简便的写法。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-keyword">from</span> contextlib <span class="hljs-keyword">import</span> contextmanager<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UseWith</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-meta">@contextmanager    </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_func</span><span class="hljs-params">()</span>:</span>    q = UseWith()    <span class="hljs-keyword">yield</span> q        <span class="hljs-keyword">with</span> create_func() <span class="hljs-keyword">as</span> cf:    cf.func()</code></pre><p><code>@contextmanager</code>这个decorator接受一个<code>generator</code>，用<code>yield</code>语句把<code>with ... as var</code>把变量输出出去，然后，with语句。</p><h2 id="切片"><a class="markdownIt-Anchor" href="#切片"></a> 切片</h2><p>切片的作用是对于列表、元组以及字符串截取的高阶操作，实现快速截取元素。其表示形式为：<code>[开始索引:结束索引(不包括此索引):间隔索引]</code></p><p>以上面列表colors为例：</p><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-string">'red'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">#截取索引为1到索引4的元素（不包括4）</span>[<span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'pink'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-number">1</span>:] <span class="hljs-comment">#冒号后无值表示从指定索引开始截取到最后</span>[<span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>colors[:<span class="hljs-number">2</span>] <span class="hljs-comment">#同理，冒号前无值表示从索引0开始截取到指定索引</span>[<span class="hljs-string">'red'</span>, <span class="hljs-string">'black'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>colors[<span class="hljs-number">-2</span>:] <span class="hljs-comment">#同列表索引读取一样切片也支持负数</span>[<span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>colors[:] <span class="hljs-comment">#空切片表示完整复制一个列表</span>[<span class="hljs-string">'red'</span>, <span class="hljs-string">'black'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'pink'</span>, <span class="hljs-string">'yellow'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>colors[:<span class="hljs-number">5</span>:<span class="hljs-number">2</span>] <span class="hljs-comment">#两个冒号表示每隔多少切片一次</span>[<span class="hljs-string">'red'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'yellow'</span>]</code></pre><h2 id="列表生成式"><a class="markdownIt-Anchor" href="#列表生成式"></a> 列表生成式</h2><p>列表生成式是Python内置的可用来生成list的生成式。</p><ul><li>生成最简单的集合</li></ul><pre class="highlight"><code class="python"><span class="hljs-meta">&gt;&gt;&gt; </span>list(range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>))</code></pre><ul><li>生成特殊值的集合(如偶数集合)</li></ul><p><code>方法一：</code> for循环</p><pre class="highlight"><code class="python">L = []<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>) :<span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> :L.append(n)print(L)结果：[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]</code></pre><p><code>方法二：</code> 列表生成式</p><pre class="highlight"><code class="python">L = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]print(L)结果：[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]</code></pre><blockquote><p>通过上面代码结果显而易见，列表表达式更加简洁。同时列表表达式还支持多个变量，嵌套循环等。</p></blockquote><pre class="highlight"><code class="python"><span class="hljs-comment">#嵌套循环</span><span class="hljs-meta">&gt;&gt;&gt; </span>[m + n <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-string">'ABC'</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-string">'123'</span>][<span class="hljs-string">'A1'</span>, <span class="hljs-string">'A2'</span>, <span class="hljs-string">'A3'</span>, <span class="hljs-string">'B1'</span>, <span class="hljs-string">'B2'</span>, <span class="hljs-string">'B3'</span>, <span class="hljs-string">'C1'</span>, <span class="hljs-string">'C2'</span>, <span class="hljs-string">'C3'</span>]<span class="hljs-comment">#多变量(以前面字典scores为例）</span><span class="hljs-meta">&gt;&gt;&gt; </span>[k + <span class="hljs-string">'='</span> + str(v) <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> scores.items()] <span class="hljs-comment">#因为字典值为int不能与字符串相加所以用str()函数转换为字符串</span>[<span class="hljs-string">'Math=95'</span>, <span class="hljs-string">'Chi=98'</span>, <span class="hljs-string">'Eng=92'</span>] <span class="hljs-comment"># 把list中字母转小写</span><span class="hljs-meta">&gt;&gt;&gt; </span>L = [chr(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(ord(<span class="hljs-string">'A'</span>),ord(<span class="hljs-string">'Z'</span>))][<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span>, <span class="hljs-string">'E'</span>, <span class="hljs-string">'F'</span>, <span class="hljs-string">'G'</span>, <span class="hljs-string">'H'</span>, <span class="hljs-string">'I'</span>, <span class="hljs-string">'J'</span>, <span class="hljs-string">'K'</span>, <span class="hljs-string">'L'</span>, <span class="hljs-string">'M'</span>, <span class="hljs-string">'N'</span>, <span class="hljs-string">'O'</span>, <span class="hljs-string">'P'</span>, <span class="hljs-string">'Q'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'S'</span>, <span class="hljs-string">'T'</span>, <span class="hljs-string">'U'</span>, <span class="hljs-string">'V'</span>, <span class="hljs-string">'W'</span>, <span class="hljs-string">'X'</span>, <span class="hljs-string">'Y'</span>]<span class="hljs-meta">&gt;&gt;&gt; </span>[x.lower() <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> L][<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'g'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'j'</span>, <span class="hljs-string">'k'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'m'</span>, <span class="hljs-string">'n'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'p'</span>, <span class="hljs-string">'q'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'s'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'u'</span>, <span class="hljs-string">'v'</span>, <span class="hljs-string">'w'</span>, <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Python3 </tag>
            
            <tag> Python3学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倒鸭子</title>
      <link href="2018/07/23/blog/%E5%80%92%E9%B8%AD%E5%AD%90/"/>
      <url>2018/07/23/blog/%E5%80%92%E9%B8%AD%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>2011年很火的一个小视频倒鸭子，当时项目经理希望我们把这个视频用HTML5技术实现出来。当时，HTML5技术还没有现在这么成熟，团队成员更是没有人会。就在这种情况下，我们各种学习，搜集资料，最终用了两个星期实现了这个动画的全部内容，最近无意间看见了这个小项目，把它拿出来放到我的博客里，也算是保存一下吧。</p><iframe src="/backDuck/" frameborder="0" scrolling="no" width="700px" height="460px"></iframe><p>现在公司由于项目不紧张，领导想让我们研究一下区块链相关技术。最终选择我在内三个人来研究，没有要求时间限制，本来接到这个任务的我是很兴奋的，因为之前对区块链和比特币什么的都只是概念性的了解，没有什么深入体会，并且感觉未来这方面技术还是比较有发展的，所以对此兴致勃勃。作为这个任务的负责人，我也就把这个任务研究进程做了一些分配，可总事与愿违。事情开展没几天，我发现一个其中一个人对此毫无兴趣可研，更是动摇军心，大言不惭的说“我认为这么几个人做不出来”。我认为这就跟战争年代还没打就投降汉奸没什么区别，后来领导知道这件事后，就把他派去做别的事情了。另一个开始比较认真，满腔热血，可是后来也不知道碰到了什么问题，说搞不懂，直接放弃不弄了。我跟他交流过几次，始终没搞明白，他到底哪块卡住了。研究一个问题，不就是因为不懂吗，懂了还研究个 pì 呀!</p><p>我个人并不是对什么年代的人有什么歧视，可是最近遇到的几个X零后表示完全懵逼，最后送上勉励的一句话：</p><h3>“身体力行，敢为天下先！”</h3>]]></content>
      
      
      <categories>
          
          <category> 自娱自乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>徒步水泉沟峡谷</title>
      <link href="2018/07/16/blog/%E5%BE%92%E6%AD%A5%E6%B0%B4%E6%B3%89%E6%B2%9F%E5%B3%A1%E8%B0%B7/"/>
      <url>2018/07/16/blog/%E5%BE%92%E6%AD%A5%E6%B0%B4%E6%B3%89%E6%B2%9F%E5%B3%A1%E8%B0%B7/</url>
      
        <content type="html"><![CDATA[<p>上周六公司组织了一次团建活动，参加前的我原本是抗拒的，因为对行程表示不理解，早饭没有;午饭自助烧烤（DIY）;晚饭没有。行程又紧张，好多同事都借机请假躲避了。原则上来说我对这种行为是不耻的，此种行为让我感觉这种人不合群，不喜欢与这种人共事，但对于这次我表示理解。</p><p>以往公司团建基本上都是安排两天，放松开心的活动，所以大多数人带着一点不情愿开始了此次行程。周六早晨6点多就起床洗漱，8点半到公司集合坐大巴车，慢长的路途借游戏来消磨时间，由于郊区4G信号比较差，玩了一会儿就开始睡觉，直到到达目的地。</p><p>绿水青山环绕，蓝天白云相伴，给人心情还是不错的。到了目的地后开始分队、队长、队服、队名、队标、口号等等，常规团建操作没什么特殊，接下来游戏放松时间（也可以说是整人时间）,惩罚措施：</p><blockquote><p>1、被惩罚人唱一句带“爱”字的情歌，但爱后面不能有“情”字，所有惩罚人不能唱重复的歌曲。</p></blockquote><p><code>赵某某：</code>　我爱你，爱着你，就像老鼠爱大米。<br><code>钱某某：</code>　爱你不是两三天…。<br><code>孙某某：</code>　爱你一万年，爱你经得起考验。<br><code>周某某：</code>　死了都要爱，不淋漓尽致不痛快。<br>.<br>.<br>.<br>.<br><strong>压轴大戏</strong><br><code>吴某总：</code>　你问我爱你有多深，我爱你有几分。（此歌之前是某同事推荐的，总有种被套路了感觉。）</p><p>接下来，欢乐时间到。。。</p><blockquote><p>2、全部惩罚人演唱完后，所有被惩罚人把自己唱的那句歌的“爱”字换成“弄”字，再唱一遍。</p></blockquote><p>游戏完毕，四小队排成一纵队，徒手翻越野长城，也不知道具体叫什么名字，爬长城前还要爬一座小山，才能到长城。</p><img src="/2018/07/16/blog/%E5%BE%92%E6%AD%A5%E6%B0%B4%E6%B3%89%E6%B2%9F%E5%B3%A1%E8%B0%B7/IMG_20180714_123701.jpg" width="490px" alt="野长城"><span class="image-caption">野长城</span><p>登上长城，各种拍照。</p><img src="/2018/07/16/blog/%E5%BE%92%E6%AD%A5%E6%B0%B4%E6%B3%89%E6%B2%9F%E5%B3%A1%E8%B0%B7/IMG_20180714_124755.jpg" width="490px" alt="登上长城"><span class="image-caption">登上长城</span><p>烽火台瞭望。</p><img src="/2018/07/16/blog/%E5%BE%92%E6%AD%A5%E6%B0%B4%E6%B3%89%E6%B2%9F%E5%B3%A1%E8%B0%B7/IMG_20180714_125157.jpg" width="490px" alt="烽火台"><span class="image-caption">烽火台</span><p>下长城，有一部电影叫《垂直极限》，有点类似吧。从这一点我确实认同了一件事，长城从项目角度来说是个彻头彻尾的失败工程，抛开它没有挡住北方骑马民族的入侵不说，单就这段险峻的路程，守城兵还没来到支援可能就已经累摊在路上了。当然从文化角度来说，它确实是承载中华民族辉煌文化的瑰宝，不得不叹服古人的伟大！</p><img src="/2018/07/16/blog/%E5%BE%92%E6%AD%A5%E6%B0%B4%E6%B3%89%E6%B2%9F%E5%B3%A1%E8%B0%B7/IMG_20180714_130052.jpg" width="490px" alt="垂直极限"><span class="image-caption">垂直极限</span><p>历经两三个小时，我们终于到达上午的目的地，自助烧烤农家院。好吃是别想了，反正是熟的能吃，还有就是管饱。</p><p>吃饱喝足后就开始了下午的活动，相比上午而言，确是轻松了许多。小桥流水，峡谷穿行，体验初级户外徒步。教练说这其实连初级都算不上，最多算个体验级，像灵山一些地方才是真正星级的户外旅行，貌似每年都会有驴友遇险。</p><img src="/2018/07/16/blog/%E5%BE%92%E6%AD%A5%E6%B0%B4%E6%B3%89%E6%B2%9F%E5%B3%A1%E8%B0%B7/IMG_20180714_164110.jpg" width="490px" alt="户外徒步"><span class="image-caption">户外徒步</span><p>途中有团队游戏，有互帮互助，有“湿”身落水……。到达终点后，天色已渐昏暗。领导讲话总结一天行程结束！</p><img src="/2018/07/16/blog/%E5%BE%92%E6%AD%A5%E6%B0%B4%E6%B3%89%E6%B2%9F%E5%B3%A1%E8%B0%B7/IMG_20180714_182527.jpg" width="490px" alt="黄昏时分"><span class="image-caption">黄昏时分</span><p>一个团队就应该是拧成一团才能叫作团队，团建我感觉是增强团队融合比较好的方式，至少我感觉对我来说有些收获，以往见面都不说话的同事也有了改善。对此种现象在现在已是普遍存在，甚至连十几二十人小公司，同事间都互不交流，跟路人无异。可叹人性为何变得如此冷漠！</p>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 徒步 </tag>
            
            <tag> 野长城 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全站启用HTTPS</title>
      <link href="2018/07/05/tech_stack/%E5%85%A8%E7%AB%99%E5%90%AF%E7%94%A8HTTPS/"/>
      <url>2018/07/05/tech_stack/%E5%85%A8%E7%AB%99%E5%90%AF%E7%94%A8HTTPS/</url>
      
        <content type="html"><![CDATA[<p>关于启用https原本早就应该实施，只是由于服务器一直不固定的原因，也就推迟了下来。前一段时间赶上京东云打1折，就买了一台，顺便把博客就挪了过来。就在昨天历时半个多月的备案也下来了，整个过程比较顺利，至此整个博客就算迁移成功了，在此记录一下启用HTTPS的方法。</p><span id="more"></span><p>本站采用的是Let’s Encrypt免费证书，安装过程比较简单：</p><h3 id="配置nginx配置文件"><a class="markdownIt-Anchor" href="#配置nginx配置文件"></a> 配置nginx配置文件</h3><pre class="highlight"><code class="nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">server_name</span>  www.fcwalkers.com fcwalkers.com blog.fcwalkers.com;        ...省略&#125;</code></pre><p><strong>注意server_name配上你想要配置的域名,否则certbot不会检查nginx配置文件并自动配置。</strong></p><h3 id="选择服务器系统"><a class="markdownIt-Anchor" href="#选择服务器系统"></a> 选择服务器系统</h3><p>打开<a href="https://certbot.eff.org/">Certbot</a>网站，选择使用软件以及服务器系统，此处以nginx和centOS7为例：</p><ul><li>安装相关依赖</li></ul><pre class="highlight"><code class="bash">$ yum -y install yum-utils$ yum-config-manager --<span class="hljs-built_in">enable</span> rhui-REGION-rhel-server-extras rhui-REGION-rhel-server-optional</code></pre><ul><li>安装Certbot工具</li></ul><pre class="highlight"><code class="bash">$ sudo yum install python2-certbot-nginx</code></pre><ul><li>生成证书</li></ul><pre class="highlight"><code class="bash">sudo certbot --nginx</code></pre><p><strong>如果是第一次安装会提示输入邮箱为了接收过期等信息，如果前面server_name配置了域名此时就会让你选择给那个域名配置证书(多个域名空格分割)，否则直接生成证书。</strong></p><p>至此https就配置完成了，打开nginx配置文件会发现多了如下配置：</p><pre class="highlight"><code class="nginx"><span class="hljs-section">server</span> &#123;<span class="hljs-comment"># https配置</span><span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2; <span class="hljs-comment"># managed by Certbot</span><span class="hljs-attribute">ssl_certificate</span> /etc/letsencrypt/live/www.fcwalkers.com/fullchain.pem; <span class="hljs-comment"># managed by Certbot</span><span class="hljs-attribute">ssl_certificate_key</span> /etc/letsencrypt/live/www.fcwalkers.com/privkey.pem; <span class="hljs-comment"># managed by Certbot</span><span class="hljs-attribute">include</span> /etc/letsencrypt/options-ssl-nginx.conf; <span class="hljs-comment"># managed by Certbot</span><span class="hljs-attribute">ssl_dhparam</span> /etc/letsencrypt/ssl-dhparams.pem; <span class="hljs-comment"># managed by Certbot</span>&#125;</code></pre><p><strong>注意上面http2是开启http2协议,具有更快的HTTPS传输性能，所以建议开启（默认不开启）</strong></p><pre class="highlight"><code class="nginx"><span class="hljs-section">server</span> &#123;<span class="hljs-comment"># http 301重定向</span><span class="hljs-attribute">if</span> (<span class="hljs-variable">$host</span> = www.fcwalkers.com) &#123;   <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;&#125; <span class="hljs-comment"># managed by Certbot</span><span class="hljs-attribute">if</span> (<span class="hljs-variable">$host</span> = blog.fcwalkers.com) &#123;   <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;&#125; <span class="hljs-comment"># managed by Certbot</span><span class="hljs-attribute">if</span> (<span class="hljs-variable">$host</span> = fcwalkers.com) &#123;   <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;&#125; <span class="hljs-comment"># managed by Certbot</span><span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;&#125;</code></pre><p>上面301重定向也可采用通用配置：</p><pre class="highlight"><code class="nginx"><span class="hljs-comment"># Redirect non-https traffic to https</span><span class="hljs-attribute">if</span> (<span class="hljs-variable">$scheme</span> != <span class="hljs-string">"https"</span>) &#123;  <span class="hljs-attribute">return</span> <span class="hljs-number">301</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;&#125; <span class="hljs-comment"># managed by Certbot</span></code></pre><h3 id="证书更新"><a class="markdownIt-Anchor" href="#证书更新"></a> 证书更新</h3><p>Let’s Encrypt 证书的有效期是90天，因此需要设置自动化脚本定期更新证书。</p><p>使用crond服务定时执行更新操作,执行<code>crontab -e</code>命令，将下面内容复制后保存退出：</p><pre class="highlight"><code class="bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">"0 0,12 * * * root python -c 'import random; import time; time.sleep(random.random() * 3600)' &amp;&amp; certbot renew -q"</span> | sudo tee -a /etc/crontab &gt; /dev/null</code></pre><p>更多crond服务说明参考<a href="/2017/12/11/Linux/%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%E8%B0%83%E5%BA%A6/">例行性工作调度</a>笔记。</p><p>配置完后重启nginx　执行<code>nginx -s reload</code>即可。</p><h3 id="其它问题"><a class="markdownIt-Anchor" href="#其它问题"></a> 其它问题</h3><ul><li><p>Mixed Content</p><p>站点启用https后原有引用http的链接都会报错</p><blockquote><p>Mixed Content: The page at ‘<a href="https://xifengxx.github.io/web-demo/imooc/index.html">https://xifengxx.github.io/web-demo/imooc/index.html</a>’ was loaded over HTTPS, but requested an insecure resource ‘<a href="http://player.youku.com/embed/XMTU4MTY4OTg5Mg==">http://player.youku.com/embed/XMTU4MTY4OTg5Mg==</a>’. This request has been blocked; the content must be served over HTTPS.</p></blockquote><p>大致意思就是页面中混合使用了https和http链接，解决方法就是在页面的head中添加一个<code>meta</code>:</p><pre class="highlight"><code class="js">&lt;meta http-equiv=<span class="hljs-string">"Content-Security-Policy"</span> content=<span class="hljs-string">"upgrade-insecure-requests"</span>&gt;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS </tag>
            
            <tag> SSL/TLS </tag>
            
            <tag> Let’s Encrypt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS cursor</title>
      <link href="2018/06/13/tech_stack/CSS%20cursor/"/>
      <url>2018/06/13/tech_stack/CSS%20cursor/</url>
      
        <content type="html"><![CDATA[<p>折腾就是我，我就是爱折腾，最近又双叒叕觉得网站排版不太好看，接下来都懂得，折腾！折腾的好处就是忘记的东东可以捡起来，不会的东东可以学出来。</p><p>对于排版暂时还没计划去改，也就只能在元素和图片上动文章了。翻来覆去决定体验一次青春的赶脚，就是现在这个黑板了[笑哭]！当最后感觉样式差不多了，想在鼠标变成一个粉笔这样感觉更贴切,可是就这么个小样式也弄了好久才弄出来，记录一下用法，以免以后再忘。</p><span id="more"></span><pre class="highlight"><code class="css">语法：<span class="hljs-selector-tag">cursor</span><span class="hljs-selector-pseudo">:url('')</span> | <span class="hljs-selector-tag">default</span> | <span class="hljs-selector-tag">auto</span> | 可能值</code></pre><p>一般用法就不说了，这里主要记录一下自定义url情况：</p><p><code>图片尺寸</code> : 建议尺寸　32×32　其它尺寸没试过<br><code>图片格式</code> : 建议　.ico  其它格式也可以不过兼容性可能差些</p><p>素材准备好了，具体用法如下：</p><pre class="highlight"><code class="css"><span class="hljs-selector-tag">cursor</span>: <span class="hljs-selector-tag">url</span>('图片路径'),<span class="hljs-selector-tag">default</span>;注意：后面<span class="hljs-selector-tag">default</span>非常重要，之前一直没加结果<span class="hljs-selector-tag">chrome</span>浏览器一直报<span class="hljs-selector-tag">ivalid</span> <span class="hljs-selector-tag">property</span> <span class="hljs-selector-tag">value</span>。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小米耍猴第8季</title>
      <link href="2018/06/05/blog/%E5%B0%8F%E7%B1%B3%E8%80%8D%E7%8C%B4%E7%AC%AC8%E5%AD%A3/"/>
      <url>2018/06/05/blog/%E5%B0%8F%E7%B1%B3%E8%80%8D%E7%8C%B4%E7%AC%AC8%E5%AD%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>没错，是我，就是我，就是那只在抢小米的猴!<br>——　风尘</p></blockquote><span id="more"></span><p>在此之前我仅感受过春运时期12306那种点击的无力感，那种就像便秘的时候有劲没处使的赶脚！就算如此，人家最终还能“出来”不是。</p><p>在我看来今年算是是手机的大年吧，之所以这么说，是因为今年的手机集体剪了齐刘海。。。恰巧我用了两年多的三星note5也该到了光荣退休的年纪，所以就到处搜索攻略研究了一下今年新品手机。其实我一直喜欢的机型是三星note8　双曲面系列，那种感觉让无力抗拒，经过双手掏兜这个动作后也就放弃了。。。年初那段时间vivo x21、oppo r15率先出场了，不出意外刘海妹登场了，但vivo的骁龙660 CPU实在是提不起兴趣，最关键的还那么贵，还不如去年给女票买的小米6吸引我。对于华为手机不知道为什么，我始终看不出它的美在哪里，所以直接忽略了。无意中发现了一加手机这个品牌，之前真心没听过，网上查了一番居然2014年就有了这个品牌，瞬间觉得我是火星来的。一加6从配置到外观都是我比较满意的，唯一问题就是价格感觉略高（当然跟小米比）。于是乎在仔细斟酌和女票的强烈推荐下，终于走上了一条不归路。</p><p>从发布惯例的4初到现在2个多月的煎熬等等终于发布了，发布会直播的2个小时我一直在看，当小米8的配置售价一出后，有些兴奋也有一些失望。单看售价确实让人疯狂，唯一3千以下超配手机，但是就想弱弱的问一句为啥没有8G版。虽然和自己的理想机型还差点，但也算是比较满意了。晚上18点开售，我兴奋的打开官网，点击预售按钮，结果提示我人数太多排队中…大约1分钟左右排除超时…什么鬼xxoo?!(*233＆＃‧。<br>我继续点预售再一次排队中…又过了大约1分钟提示售罄晚上24点再次预售…</p><p>鉴于之前的经验，在快到24点前我准备了两台手机一台电脑同时登陆多个账号抢，结果万幸…依旧没没抢到。<br>期间又抢了两次，去过万达小米之家都买不到，连预订的机会都不给。这就是传说的中备货充足，这次真真体会到了耍猴模式。买个手机买的好心累，小米你样做真的好吗，你已经耍了米粉们8年了（虽然我不是米粉，才是第一次被耍），你靠耍猴模式耍的都快上市了，还不能有诚意一回吗？</p><h4 id="尾声"><a class="markdownIt-Anchor" href="#尾声"></a> 尾声</h4><hr><p>原谅我又一次低俗的举例形容，一句话总结米粉不容易，且行且珍惜！再次声明我真不是一个米粉！！！我只是一个米粉的临时工！！！<br>气愤之下准备放弃了，最后看看了配置，看看了钱包，我决定要锻炼一下自己的意志…<br>祈祷下个猴年马月到来前我能买到吧！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 手机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不以成败论英雄</title>
      <link href="2018/06/01/blog/%E4%B8%8D%E4%BB%A5%E6%88%90%E8%B4%A5%E8%AE%BA%E8%8B%B1%E9%9B%84/"/>
      <url>2018/06/01/blog/%E4%B8%8D%E4%BB%A5%E6%88%90%E8%B4%A5%E8%AE%BA%E8%8B%B1%E9%9B%84/</url>
      
        <content type="html"><![CDATA[<p><img src="/2018/06/01/blog/%E4%B8%8D%E4%BB%A5%E6%88%90%E8%B4%A5%E8%AE%BA%E8%8B%B1%E9%9B%84/QQ20180601-154620@2x.png" alt="不以成败论英雄"><span class="image-caption">不以成败论英雄</span></p><span id="more"></span><p>6.1儿童节快乐！到了这个与儿童越来越远的年纪，也许只能穿着开裆裤上街才能找到一丝儿童节的感觉吧。。。</p><p>年少时期盼长大，长大后还想还童，彼此羡慕着别人，失去着自己！功成名就、马齿徒增、是是非非，无时无刻得不在前行的道路烦扰着。</p><p>51分8篮板8助攻，是的他就是4次MVP，8进总决赛，3次总冠军，3次FMVP……，G1折翼的天之骄子！虽然05年左右就已知道了他的存在。但是真正关注他并路转粉还是在2010-2011赛季的热火，华丽的空接，凶残的扣篮，开阔的视野，精准自带模式的传球，还有那恐怖的死亡之瞪。当然不仅仅这些，最让我欣赏的是他那独有的领袖气质和良好品格，这在利欲熏心NBA更是难能可贵。即便注定又是失败的一季，也要安之若素，处之泰然！</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迟来的驾照</title>
      <link href="2018/05/24/blog/%E8%BF%9F%E6%9D%A5%E7%9A%84%E9%A9%BE%E7%85%A7/"/>
      <url>2018/05/24/blog/%E8%BF%9F%E6%9D%A5%E7%9A%84%E9%A9%BE%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<p>对于开车这件事儿，貌似没有其他人那么强烈的欲望，所以一拖再拖的到了现在才提上日程。具体萌生出想法是去年冬天，也不知道因为什么，还是受什么刺激，突然想开车了。终于磨了大半年的时间开始行动了。</p><p>之前一直的想法是，自己又没有车，考了也没什么用。包括身边好多朋友，驾驶证都快换终身了，除了驾校学习，还没摸过车。也许我就是看到了这种情况，一直提不起去学的兴趣。现在想想还有点小小的后悔，为什么不早点去考呢。之前无论从学费，还是难易程度都比现在好很多。身边的人十之八九都考了好几年了，而我还是一个预备新手。。。</p><span id="more"></span><p>伴随着欲望的愈加强烈，终于在5号上午开启了我的学车之旅：</p><hr><ul><li><code>2018年5月5日</code>　咨询报名资费一气呵成</li><li><code>2018年5月25日</code>　经过几个星期的法规学习参加了科目一考试（雄心壮志的100分，结果得了94。。。大写的“囧”）</li></ul><hr><p>科一考完后的一个星期驾校打来电话帮我约科目二练车,原本报名时候选的车型是宝来(据说比其它车型好一些)。可能由于车少人多原因,推荐我换成了伊兰特。为了尽早学习拿到驾照，也就同意了变更。</p><hr><ul><li><code>2018年6月9日</code>　科目二模拟课，感觉像是来打游戏的，不过通过老师的讲课还是从中学到了一些东西。</li><li><code>2018年6月10日</code> 第一次上车，坐在车上练了差不多半个小时的换档和打方向盘，然后开始练习带速行驶、曲线、直角、换档道路行驶。整体感觉有些生疏，主要是教练总在身旁喊太紧张了。。。</li><li><code>2018年6月17日</code>　将近6个小时的学习，侧方停车、倒库入库、坡起，科目二所有项目全都学完了，腰酸背痛，腿脚抽筋。早上5点多出门，不到5分钟就开始下大雨（瓢泼大雨）。找个早餐铺躲了会儿雨，雨小了点后，接着往车站走，一不留神踩进了一个小水坑，鞋子湿了一半。到了车站后等车时突然间海浪漫身飞来，我急忙转身才堪堪躲避一点，从头到脚无一幸免，只看见一辆轿车飞驰而去。。。（你大爷的）</li><li><code>2018年6月24日</code>　学车以来第一个酷暑，橙色高温预警，热！考试前倒数第二次课，所有项目综合练习了几遍，感觉有点难，考场车太多两个小时就练了两圈。</li><li><code>2018年6月28日</code>  科目二学习最后一课，这教练我已无力吐槽，教的太不认真了，不懂的问题问他不说，做错了就开始说你不按他教的做。。。原本想考试前一天到考场好好练习一天，所以预约考试时间特意往后了一天，结果得知不能练了。中间隔了两天考试，也不知道会不会有影响，一切只能听天由命了。</li><li><code>2018年7月3日</code>　科目二考试，手抖、脚抖、各种问题。已挂！</li><li><code>2018年7月11日</code>　科三考前集训，天气大到暴雨，今天外路跑的时间挺长，比较有感觉。明天考试多了一些成功率。</li><li><code>2018年7月12日</code>　早上7点到了科三备考大厅，登记摄像后，等候叫名字考试。本以为会很靠后的，因为约考的时候已经排到400多号了，没想到第一批就叫到我了28号车，有一点小紧张(灯光模拟出了点小差错，自己及时纠正过来，监考也没说啥)，不过整体挺顺利90分一次通过。跟我同车考试的也是灯光模拟出了问题，直接开始第二次机会考试，途中有点小问题，不过也过了。下周考重新考科二了，希望顺利通过吧！</li><li><code>2018年7月28日</code>　第二次科目二考试考前训练，三个人一个车6个小时集训，看着时间挺长，其实最终每人只练了一圈。由于之前有事耽搁了，所以距上次科二考试差不多快二十天了，第一圈练习完全不在状态，每一项都出错。后来才一点点找回感觉，但还是有些小问题。依旧感觉练习时间太少，只能尽人事，听天命了！</li><li><code>2018年7月29日</code>　科目二第二次考试日，可能这一次运气终于落在我头上了，遇到的几个教练都很好，而且很仔细的给我们讲一些注意事项，让我对考试多了一些信心。准备充足果然能够打胜仗，神态自若，气定神闲。一气呵成的操作，顺利通过，100分。</li><li><code>2018年7月30号</code>　由于周末不能考科三理论，所以只能周一上午再来考了，整体和科一没多大区别。94分，竟然和科一一样的分数，也算是比较有意义。宣誓、领证、以及最后一课…</li></ul><hr><p>考驾照前说时间最少也得两三个月，当时感觉时间好长好麻烦啊。可真到考完回头看看的时候，感觉整个考驾照过程很短，很仓促，感觉还没准备好就要考试了。俗话说没有教不会的学生，只有不会教的老师。最后还是要吐槽一下教练，考试前关键点啥都不说，问也不好好回答，结果科目二考试前各种懵逼，连最基本的刷身份证位置都不知道，本来就紧张，结果也就显而易见了。再说科三考试，也是差不多的情况就学完了，就连考试路线都不好好带着练，要不是考前集训换了个教练（这个教练人特别好，教的也非常仔细，名字忘记了），我竟然不知道考试有两条路随机选的。。。结果第二天考试恰恰走了我不知道那条路，也恰好前一天练了好几次，万幸的通过了。虽然我知道事情不能总找客观原因，可是遇到这样的教练谁能不郁闷呢！</p><p>至此历时两个多月的学车经历就告一段落了，期间有苦亦有甜，苦的是凌晨5点的起床和炎炎的烈日;甜的是拿到成果后的喜悦。终于可以自由的驾驶了～</p><p>本文完！</p>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汽车 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圈圈</title>
      <link href="2018/05/03/blog/%E5%9C%88%E5%9C%88/"/>
      <url>2018/05/03/blog/%E5%9C%88%E5%9C%88/</url>
      
        <content type="html"><![CDATA[<p>圈圈是一只被粗心的主人忘记了问出生日期的小泰迪，也是一只坚强的与病魔抗争过小英雄。　　<br>圈圈是一只长23高13厘米的呆萌型男，圈圈更是一只集智慧、乖巧等等优点于一身的小伙伴。　　<br>圈圈的名字源于它那一身金灿灿的毛发，是它的主人穷尽词汇，浪费了不少脑细胞得来的。</p><span id="more"></span><p>眨眼间，从出生两个多月后来到主人身边已经一个月零两天了。聪明的圈圈已经学会了上厕所、坐下、握手和卖萌。圈圈喜欢粘着主人要抱抱，圈圈也会乖巧在家等待主人的归来。虽然圈圈还是不能听懂很多命令，但它正在努力的去理解！虽然圈圈的主人在一个没有计划的下午冲动的把它带回家，但他(她）一直在努力的做的更好，对这个新到来的伙伴负责。因为这是他（她）的第一只自己的宠物，并且他（她）也很爱它。</p><p>忘了说，圈圈的生辰被它的糊涂主人定为了腊月初八！</p><p>圈圈欢迎你的到来～</p><hr><p>我们不是一名铲屎官，我们只是它的搬运工！</p><p>——　圈圈的主人</p><hr>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 狗狗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>全文检索Sphinx—多索引配置文件</title>
      <link href="2018/04/18/tech_stack/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2Sphinx%E4%B9%8B%E7%B4%A2%E5%BC%95%E7%8B%AC%E7%AB%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>2018/04/18/tech_stack/%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2Sphinx%E4%B9%8B%E7%B4%A2%E5%BC%95%E7%8B%AC%E7%AB%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>Sphinx是一个基于SQL的全文检索引擎，可以结合MySQL,PostgreSQL做全文搜索.</p></blockquote><p>开发过程中,可能涉及公共配置和多个索引配置,如果配置在一个文件中将导致文件庞大,难于维护所以考虑拆分配置文件,场景如下:</p><span id="more"></span><h3 id="公共索引配置"><a class="markdownIt-Anchor" href="#公共索引配置"></a> 公共索引配置</h3><p>建立公共索引配置文件(sphinx-base.conf,包括数据源、索引、索引查询等配置)　如下：</p><pre class="highlight"><code class>source main_src&#123;    type            = mysql    sql_host        = localhost    sql_user        = 数据库用户名    sql_pass        = 数据库密码    sql_db          = 数据库名    sql_port        = 3306    # 数据库端口(可选)，默认3306    sql_query_pre   = SET NAMES utf8 #数据库编码&#125;indexer&#123;    mem_limit       = 256M&#125;searchd&#123;    listen          = 9312    listen          = 9306:mysql41    mysql_version_string    = 5.0.37    log         = /usr/local/sphinx/var/log/searchd.log    query_log       = /usr/local/sphinx/var/log/query.log    read_timeout        = 5    max_children        = 30    pid_file        = /usr/local/sphinx/var/log/searchd.pid    seamless_rotate = 1    preopen_indexes = 1    unlink_old      = 1    workers         = threads # for RT to work    binlog_path     = /usr/local/sphinx/var/data&#125;</code></pre><h3 id="索引一"><a class="markdownIt-Anchor" href="#索引一"></a> 索引一</h3><p>建立博客文章表索引(sphinx-article.conf)如下:</p><pre class="highlight"><code class>source article_src:main_src&#123;    sql_query_pre           = SET NAMES utf8    #初始化索引记数表    sql_query_pre           = REPLACE INTO yy_sphinx_counter SELECT 1,MAX(id) from yy_article    #分步查询    sql_query_range         = SELECT MIN(id),MAX(id) FROM yy_article    sql_range_step          = 1000    sql_query               = \    SELECT  \    a.id,  a.titile,  a.thumbnail,  a.page_view,  a.privacy,  a.type,  a.gmt_create, a.create_by, \    a.destination_id, a.destination_tag_id,  b.name destinaiton_name,  c.name destination_tag_name, d.content \        FROM yy_article a \        LEFT JOIN yy_destination b ON a.destination_id = b.id \            LEFT JOIN yy_destination_tag c ON a.destination_tag_id = c.id \            LEFT JOIN yy_article_content d ON a.id = d.article_id \    WHERE a.is_deleted = 0 AND a.audit_status = 1 and a.id &gt;= $start and a.id &lt;= $end    sql_attr_string        = gmt_create    sql_attr_string        = destinaiton_name     sql_attr_string        = destination_tag_name    sql_attr_string        = thumbnail     sql_attr_uint          = page_view    sql_attr_uint          = type    sql_attr_bigint        = create_by    sql_attr_bigint        = destination_id    sql_attr_bigint        = destination_tag_id   # 被索引字段    sql_field_string     = titile    sql_field_string     = privacy     sql_field_string     = content &#125;#增量数据源source article_delta_src : article_src&#123;    sql_query_pre           = REPLACE INTO yy_sphinx_counter SELECT 1,MAX(id) from yy_article    sql_query_pre           = SET NAMES utf8    #分步查询    sql_query_range     = SELECT  (    SELECT max_doc_id    FROM yy_sphinx_counter    WHERE id = 1),  (SELECT max(id)   FROM yy_article)&#125;index article&#123;    source            = article_src    path              = /usr/local/sphinx/var/data/article_index    # 索引最小前缀(0表示任意字符)    min_infix_len     = 0    # 最小索引字符数(1表示每个字符都索引)    min_word_len      = 1    # 中文编码    charset_table     = 0..9, U+27, U+41..U+5a-&gt;U+61..U+7a,  U+61..U+7a, \U+aa, U+b5, U+ba, \U+c0..U+d6-&gt;U+e0..U+f6,  U+d8..U+de-&gt;U+f8..U+fe,  U+df..U+f6, \U+f8..U+ff,  U+100..U+12f/2,  U+130-&gt;U+69, \U+131,  U+132..U+137/2,  U+138, \U+139..U+148/2,  U+149,  U+14a..U+177/2, \U+178-&gt;U+ff,  U+179..U+17e/2,  U+17f..U+180, \U+181-&gt;U+253,  U+182..U+185/2,  U+186-&gt;U+254, \U+187..U+188/2,  U+189..U+18a-&gt;U+256..U+257,  U+18b..U+18c/2, \U+18d,  U+18e-&gt;U+1dd,  U+18f-&gt;U+259, \U+190-&gt;U+25b,  U+191..U+192/2,  U+193-&gt;U+260, \U+194-&gt;U+263,  U+195,  U+196-&gt;U+269, \U+197-&gt;U+268,  U+198..U+199/2,  U+19a..U+19b, \U+19c-&gt;U+26f,  U+19d-&gt;U+272,  U+19e, \U+19f-&gt;U+275,  U+1a0..U+1a5/2,  U+1a6-&gt;U+280, \U+1a7..U+1a8/2,  U+1a9-&gt;U+283,  U+1aa..U+1ab, \U+1ac..U+1ad/2,  U+1ae-&gt;U+288,  U+1af..U+1b0/2, \U+1b1..U+1b2-&gt;U+28a..U+28b,  U+1b3..U+1b6/2,  U+1b7-&gt;U+292, \U+1b8..U+1b9/2,  U+1ba..U+1bb,  U+1bc..U+1bd/2, \U+1be..U+1c3,  U+1c4-&gt;U+1c6,  U+1c5..U+1c6/2, \U+1c7-&gt;U+1c9,  U+1c8..U+1c9/2,  U+1ca-&gt;U+1cc, \U+1cb..U+1dc/2,  U+1dd,  U+1de..U+1ef/2, \U+1f0,  U+1f1-&gt;U+1f3,  U+1f2..U+1f5/2, \U+1f6-&gt;U+195,  U+1f7-&gt;U+1bf,  U+1f8..U+21f/2, \U+220-&gt;U+19e,  U+221,  U+222..U+233/2, \U+234..U+23a,  U+23b..U+23c/2,  U+23d-&gt;U+19a, \U+23e..U+240,  U+241-&gt;U+294,  U+250..U+2c1, \U+2c6..U+2d1,  U+2e0..U+2e4,  U+2ee, \U+1e96..U+1e9b,  U+1ea0..U+1ef9/2,  U+3005..U+3006, \U+3031..U+3035,  U+303b..U+303c,  U+3041..U+3096, \U+309d..U+309f,  U+30a1..U+30fa,  U+30fc..U+30ff, \U+31f0..U+31ff, U+F900-&gt;U+8C48, U+F901-&gt;U+66F4, \U+F902-&gt;U+8ECA, U+F903-&gt;U+8CC8, U+F904-&gt;U+6ED1, \U+F905-&gt;U+4E32, U+F906-&gt;U+53E5, U+F907-&gt;U+9F9C, \U+F908-&gt;U+9F9C, U+F909-&gt;U+5951, U+F90A-&gt;U+91D1, \U+F90B-&gt;U+5587, U+F90C-&gt;U+5948, U+F90D-&gt;U+61F6, \U+F90E-&gt;U+7669, U+F90F-&gt;U+7F85, U+F910-&gt;U+863F, \U+F911-&gt;U+87BA, U+F912-&gt;U+88F8, U+F913-&gt;U+908F, \U+F914-&gt;U+6A02, U+F915-&gt;U+6D1B, U+F916-&gt;U+70D9, \U+F917-&gt;U+73DE, U+F918-&gt;U+843D, U+F919-&gt;U+916A, \U+F91A-&gt;U+99F1, U+F91B-&gt;U+4E82, U+F91C-&gt;U+5375, \U+F91D-&gt;U+6B04, U+F91E-&gt;U+721B, U+F91F-&gt;U+862D, \U+F920-&gt;U+9E1E, U+F921-&gt;U+5D50, U+F922-&gt;U+6FEB, \U+F923-&gt;U+85CD, U+F924-&gt;U+8964, U+F925-&gt;U+62C9, \U+F926-&gt;U+81D8, U+F927-&gt;U+881F, U+F928-&gt;U+5ECA, \U+F929-&gt;U+6717, U+F92A-&gt;U+6D6A, U+F92B-&gt;U+72FC, \U+F92C-&gt;U+90CE, U+F92D-&gt;U+4F86, U+F92E-&gt;U+51B7, \U+F92F-&gt;U+52DE, U+F930-&gt;U+64C4, U+F931-&gt;U+6AD3, \U+F932-&gt;U+7210, U+F933-&gt;U+76E7, U+F934-&gt;U+8001, \U+F935-&gt;U+8606, U+F936-&gt;U+865C, U+F937-&gt;U+8DEF, \U+F938-&gt;U+9732, U+F939-&gt;U+9B6F, U+F93A-&gt;U+9DFA, \U+F93B-&gt;U+788C, U+F93C-&gt;U+797F, U+F93D-&gt;U+7DA0, \U+F93E-&gt;U+83C9, U+F93F-&gt;U+9304, U+F940-&gt;U+9E7F, \U+F941-&gt;U+8AD6, U+F942-&gt;U+58DF, U+F943-&gt;U+5F04, \U+F944-&gt;U+7C60, U+F945-&gt;U+807E, U+F946-&gt;U+7262, \U+F947-&gt;U+78CA, U+F948-&gt;U+8CC2, U+F949-&gt;U+96F7, \U+F94A-&gt;U+58D8, U+F94B-&gt;U+5C62, U+F94C-&gt;U+6A13, \U+F94D-&gt;U+6DDA, U+F94E-&gt;U+6F0F, U+F94F-&gt;U+7D2F, \U+F950-&gt;U+7E37, U+F951-&gt;U+964B, U+F952-&gt;U+52D2, \U+F953-&gt;U+808B, U+F954-&gt;U+51DC, U+F955-&gt;U+51CC, \U+F956-&gt;U+7A1C, U+F957-&gt;U+7DBE, U+F958-&gt;U+83F1, \U+F959-&gt;U+9675, U+F95A-&gt;U+8B80, U+F95B-&gt;U+62CF, \U+F95C-&gt;U+6A02, U+F95D-&gt;U+8AFE, U+F95E-&gt;U+4E39, \U+F95F-&gt;U+5BE7, U+F960-&gt;U+6012, U+F961-&gt;U+7387, \U+F962-&gt;U+7570, U+F963-&gt;U+5317, U+F964-&gt;U+78FB, \U+F965-&gt;U+4FBF, U+F966-&gt;U+5FA9, U+F967-&gt;U+4E0D, \U+F968-&gt;U+6CCC, U+F969-&gt;U+6578, U+F96A-&gt;U+7D22, \U+F96B-&gt;U+53C3, U+F96C-&gt;U+585E, U+F96D-&gt;U+7701, \U+F96E-&gt;U+8449, U+F96F-&gt;U+8AAA, U+F970-&gt;U+6BBA, \U+F971-&gt;U+8FB0, U+F972-&gt;U+6C88, U+F973-&gt;U+62FE, \U+F974-&gt;U+82E5, U+F975-&gt;U+63A0, U+F976-&gt;U+7565, \U+F977-&gt;U+4EAE, U+F978-&gt;U+5169, U+F979-&gt;U+51C9, \U+F97A-&gt;U+6881, U+F97B-&gt;U+7CE7, U+F97C-&gt;U+826F, \U+F97D-&gt;U+8AD2, U+F97E-&gt;U+91CF, U+F97F-&gt;U+52F5, \U+F980-&gt;U+5442, U+F981-&gt;U+5973, U+F982-&gt;U+5EEC, \U+F983-&gt;U+65C5, U+F984-&gt;U+6FFE, U+F985-&gt;U+792A, \U+F986-&gt;U+95AD, U+F987-&gt;U+9A6A, U+F988-&gt;U+9E97, \U+F989-&gt;U+9ECE, U+F98A-&gt;U+529B, U+F98B-&gt;U+66C6, \U+F98C-&gt;U+6B77, U+F98D-&gt;U+8F62, U+F98E-&gt;U+5E74, \U+F98F-&gt;U+6190, U+F990-&gt;U+6200, U+F991-&gt;U+649A, \U+F992-&gt;U+6F23, U+F993-&gt;U+7149, U+F994-&gt;U+7489, \U+F995-&gt;U+79CA, U+F996-&gt;U+7DF4, U+F997-&gt;U+806F, \U+F998-&gt;U+8F26, U+F999-&gt;U+84EE, U+F99A-&gt;U+9023, \U+F99B-&gt;U+934A, U+F99C-&gt;U+5217, U+F99D-&gt;U+52A3, \U+F99E-&gt;U+54BD, U+F99F-&gt;U+70C8, U+F9A0-&gt;U+88C2, \U+F9A1-&gt;U+8AAA, U+F9A2-&gt;U+5EC9, U+F9A3-&gt;U+5FF5, \U+F9A4-&gt;U+637B, U+F9A5-&gt;U+6BAE, U+F9A6-&gt;U+7C3E, \U+F9A7-&gt;U+7375, U+F9A8-&gt;U+4EE4, U+F9A9-&gt;U+56F9, \U+F9AA-&gt;U+5BE7, U+F9AB-&gt;U+5DBA, U+F9AC-&gt;U+601C, \U+F9AD-&gt;U+73B2, U+F9AE-&gt;U+7469, U+F9AF-&gt;U+7F9A, \U+F9B0-&gt;U+8046, U+F9B1-&gt;U+9234, U+F9B2-&gt;U+96F6, \U+F9B3-&gt;U+9748, U+F9B4-&gt;U+9818, U+F9B5-&gt;U+4F8B, \U+F9B6-&gt;U+79AE, U+F9B7-&gt;U+91B4, U+F9B8-&gt;U+96B8, \U+F9B9-&gt;U+60E1, U+F9BA-&gt;U+4E86, U+F9BB-&gt;U+50DA, \U+F9BC-&gt;U+5BEE, U+F9BD-&gt;U+5C3F, U+F9BE-&gt;U+6599, \U+F9BF-&gt;U+6A02, U+F9C0-&gt;U+71CE, U+F9C1-&gt;U+7642, \U+F9C2-&gt;U+84FC, U+F9C3-&gt;U+907C, U+F9C4-&gt;U+9F8D, \U+F9C5-&gt;U+6688, U+F9C6-&gt;U+962E, U+F9C7-&gt;U+5289, \U+F9C8-&gt;U+677B, U+F9C9-&gt;U+67F3, U+F9CA-&gt;U+6D41, \U+F9CB-&gt;U+6E9C, U+F9CC-&gt;U+7409, U+F9CD-&gt;U+7559, \U+F9CE-&gt;U+786B, U+F9CF-&gt;U+7D10, U+F9D0-&gt;U+985E, \U+F9D1-&gt;U+516D, U+F9D2-&gt;U+622E, U+F9D3-&gt;U+9678, \U+F9D4-&gt;U+502B, U+F9D5-&gt;U+5D19, U+F9D6-&gt;U+6DEA, \U+F9D7-&gt;U+8F2A, U+F9D8-&gt;U+5F8B, U+F9D9-&gt;U+6144, \U+F9DA-&gt;U+6817, U+F9DB-&gt;U+7387, U+F9DC-&gt;U+9686, \U+F9DD-&gt;U+5229, U+F9DE-&gt;U+540F, U+F9DF-&gt;U+5C65, \U+F9E0-&gt;U+6613, U+F9E1-&gt;U+674E, U+F9E2-&gt;U+68A8, \U+F9E3-&gt;U+6CE5, U+F9E4-&gt;U+7406, U+F9E5-&gt;U+75E2, \U+F9E6-&gt;U+7F79, U+F9E7-&gt;U+88CF, U+F9E8-&gt;U+88E1, \U+F9E9-&gt;U+91CC, U+F9EA-&gt;U+96E2, U+F9EB-&gt;U+533F, \U+F9EC-&gt;U+6EBA, U+F9ED-&gt;U+541D, U+F9EE-&gt;U+71D0, \U+F9EF-&gt;U+7498, U+F9F0-&gt;U+85FA, U+F9F1-&gt;U+96A3, \U+F9F2-&gt;U+9C57, U+F9F3-&gt;U+9E9F, U+F9F4-&gt;U+6797, \U+F9F5-&gt;U+6DCB, U+F9F6-&gt;U+81E8, U+F9F7-&gt;U+7ACB, \U+F9F8-&gt;U+7B20, U+F9F9-&gt;U+7C92, U+F9FA-&gt;U+72C0, \U+F9FB-&gt;U+7099, U+F9FC-&gt;U+8B58, U+F9FD-&gt;U+4EC0, \U+F9FE-&gt;U+8336, U+F9FF-&gt;U+523A, U+FA00-&gt;U+5207, \U+FA01-&gt;U+5EA6, U+FA02-&gt;U+62D3, U+FA03-&gt;U+7CD6, \U+FA04-&gt;U+5B85, U+FA05-&gt;U+6D1E, U+FA06-&gt;U+66B4, \U+FA07-&gt;U+8F3B, U+FA08-&gt;U+884C, U+FA09-&gt;U+964D, \U+FA0A-&gt;U+898B, U+FA0B-&gt;U+5ED3, U+FA0C-&gt;U+5140, \U+FA0D-&gt;U+55C0, U+FA10-&gt;U+585A, U+FA12-&gt;U+6674, \U+FA15-&gt;U+51DE, U+FA16-&gt;U+732A, U+FA17-&gt;U+76CA, \U+FA18-&gt;U+793C, U+FA19-&gt;U+795E, U+FA1A-&gt;U+7965, \U+FA1B-&gt;U+798F, U+FA1C-&gt;U+9756, U+FA1D-&gt;U+7CBE, \U+FA1E-&gt;U+7FBD, U+FA20-&gt;U+8612, U+FA22-&gt;U+8AF8, \U+FA25-&gt;U+9038, U+FA26-&gt;U+90FD, U+FA2A-&gt;U+98EF, \U+FA2B-&gt;U+98FC, U+FA2C-&gt;U+9928, U+FA2D-&gt;U+9DB4, \U+FA30-&gt;U+4FAE, U+FA31-&gt;U+50E7, U+FA32-&gt;U+514D, \U+FA33-&gt;U+52C9, U+FA34-&gt;U+52E4, U+FA35-&gt;U+5351, \U+FA36-&gt;U+559D, U+FA37-&gt;U+5606, U+FA38-&gt;U+5668, \U+FA39-&gt;U+5840, U+FA3A-&gt;U+58A8, U+FA3B-&gt;U+5C64, \U+FA3C-&gt;U+5C6E, U+FA3D-&gt;U+6094, U+FA3E-&gt;U+6168, \U+FA3F-&gt;U+618E, U+FA40-&gt;U+61F2, U+FA41-&gt;U+654F, \U+FA42-&gt;U+65E2, U+FA43-&gt;U+6691, U+FA44-&gt;U+6885, \U+FA45-&gt;U+6D77, U+FA46-&gt;U+6E1A, U+FA47-&gt;U+6F22, \U+FA48-&gt;U+716E, U+FA49-&gt;U+722B, U+FA4A-&gt;U+7422, \U+FA4B-&gt;U+7891, U+FA4C-&gt;U+793E, U+FA4D-&gt;U+7949, \U+FA4E-&gt;U+7948, U+FA4F-&gt;U+7950, U+FA50-&gt;U+7956, \U+FA51-&gt;U+795D, U+FA52-&gt;U+798D, U+FA53-&gt;U+798E, \U+FA54-&gt;U+7A40, U+FA55-&gt;U+7A81, U+FA56-&gt;U+7BC0, \U+FA57-&gt;U+7DF4, U+FA58-&gt;U+7E09, U+FA59-&gt;U+7E41, \U+FA5A-&gt;U+7F72, U+FA5B-&gt;U+8005, U+FA5C-&gt;U+81ED, \U+FA5D-&gt;U+8279, U+FA5E-&gt;U+8279, U+FA5F-&gt;U+8457, \U+FA60-&gt;U+8910, U+FA61-&gt;U+8996, U+FA62-&gt;U+8B01, \U+FA63-&gt;U+8B39, U+FA64-&gt;U+8CD3, U+FA65-&gt;U+8D08, \U+FA66-&gt;U+8FB6, U+FA67-&gt;U+9038, U+FA68-&gt;U+96E3, \U+FA69-&gt;U+97FF, U+FA6A-&gt;U+983B, U+FA70-&gt;U+4E26, \U+FA71-&gt;U+51B5, U+FA72-&gt;U+5168, U+FA73-&gt;U+4F80, \U+FA74-&gt;U+5145, U+FA75-&gt;U+5180, U+FA76-&gt;U+52C7, \U+FA77-&gt;U+52FA, U+FA78-&gt;U+559D, U+FA79-&gt;U+5555, \U+FA7A-&gt;U+5599, U+FA7B-&gt;U+55E2, U+FA7C-&gt;U+585A, \U+FA7D-&gt;U+58B3, U+FA7E-&gt;U+5944, U+FA7F-&gt;U+5954, \U+FA80-&gt;U+5A62, U+FA81-&gt;U+5B28, U+FA82-&gt;U+5ED2, \U+FA83-&gt;U+5ED9, U+FA84-&gt;U+5F69, U+FA85-&gt;U+5FAD, \U+FA86-&gt;U+60D8, U+FA87-&gt;U+614E, U+FA88-&gt;U+6108, \U+FA89-&gt;U+618E, U+FA8A-&gt;U+6160, U+FA8B-&gt;U+61F2, \U+FA8C-&gt;U+6234, U+FA8D-&gt;U+63C4, U+FA8E-&gt;U+641C, \U+FA8F-&gt;U+6452, U+FA90-&gt;U+6556, U+FA91-&gt;U+6674, \U+FA92-&gt;U+6717, U+FA93-&gt;U+671B, U+FA94-&gt;U+6756, \U+FA95-&gt;U+6B79, U+FA96-&gt;U+6BBA, U+FA97-&gt;U+6D41, \U+FA98-&gt;U+6EDB, U+FA99-&gt;U+6ECB, U+FA9A-&gt;U+6F22, \U+FA9B-&gt;U+701E, U+FA9C-&gt;U+716E, U+FA9D-&gt;U+77A7, \U+FA9E-&gt;U+7235, U+FA9F-&gt;U+72AF, U+FAA0-&gt;U+732A, \U+FAA1-&gt;U+7471, U+FAA2-&gt;U+7506, U+FAA3-&gt;U+753B, \U+FAA4-&gt;U+761D, U+FAA5-&gt;U+761F, U+FAA6-&gt;U+76CA, \U+FAA7-&gt;U+76DB, U+FAA8-&gt;U+76F4, U+FAA9-&gt;U+774A, \U+FAAA-&gt;U+7740, U+FAAB-&gt;U+78CC, U+FAAC-&gt;U+7AB1, \U+FAAD-&gt;U+7BC0, U+FAAE-&gt;U+7C7B, U+FAAF-&gt;U+7D5B, \U+FAB0-&gt;U+7DF4, U+FAB1-&gt;U+7F3E, U+FAB2-&gt;U+8005, \U+FAB3-&gt;U+8352, U+FAB4-&gt;U+83EF, U+FAB5-&gt;U+8779, \U+FAB6-&gt;U+8941, U+FAB7-&gt;U+8986, U+FAB8-&gt;U+8996, \U+FAB9-&gt;U+8ABF, U+FABA-&gt;U+8AF8, U+FABB-&gt;U+8ACB, \U+FABC-&gt;U+8B01, U+FABD-&gt;U+8AFE, U+FABE-&gt;U+8AED, \U+FABF-&gt;U+8B39, U+FAC0-&gt;U+8B8A, U+FAC1-&gt;U+8D08, \U+FAC2-&gt;U+8F38, U+FAC3-&gt;U+9072, U+FAC4-&gt;U+9199, \U+FAC5-&gt;U+9276, U+FAC6-&gt;U+967C, U+FAC7-&gt;U+96E3, \U+FAC8-&gt;U+9756, U+FAC9-&gt;U+97DB, U+FACA-&gt;U+97FF, \U+FACB-&gt;U+980B, U+FACC-&gt;U+983B, U+FACD-&gt;U+9B12, \U+FACE-&gt;U+9F9C, U+FACF-&gt;U+2284A, U+FAD0-&gt;U+22844, \U+FAD1-&gt;U+233D5, U+FAD2-&gt;U+3B9D, U+FAD3-&gt;U+4018, \U+FAD4-&gt;U+4039, U+FAD5-&gt;U+25249, U+FAD6-&gt;U+25CD0, \U+FAD7-&gt;U+27ED3, U+FAD8-&gt;U+9F43, U+FAD9-&gt;U+9F8E, \U+2F800-&gt;U+4E3D, U+2F801-&gt;U+4E38, U+2F802-&gt;U+4E41, \U+2F803-&gt;U+20122, U+2F804-&gt;U+4F60, U+2F805-&gt;U+4FAE, \U+2F806-&gt;U+4FBB, U+2F807-&gt;U+5002, U+2F808-&gt;U+507A, \U+2F809-&gt;U+5099, U+2F80A-&gt;U+50E7, U+2F80B-&gt;U+50CF, \U+2F80C-&gt;U+349E, U+2F80D-&gt;U+2063A, U+2F80E-&gt;U+514D, \U+2F80F-&gt;U+5154, U+2F810-&gt;U+5164, U+2F811-&gt;U+5177, \U+2F812-&gt;U+2051C, U+2F813-&gt;U+34B9, U+2F814-&gt;U+5167, \U+2F815-&gt;U+518D, U+2F816-&gt;U+2054B, U+2F817-&gt;U+5197, \U+2F818-&gt;U+51A4, U+2F819-&gt;U+4ECC, U+2F81A-&gt;U+51AC, \U+2F81B-&gt;U+51B5, U+2F81C-&gt;U+291DF, U+2F81D-&gt;U+51F5, \U+2F81E-&gt;U+5203, U+2F81F-&gt;U+34DF, U+2F820-&gt;U+523B, \U+2F821-&gt;U+5246, U+2F822-&gt;U+5272, U+2F823-&gt;U+5277, \U+2F824-&gt;U+3515, U+2F825-&gt;U+52C7, U+2F826-&gt;U+52C9, \U+2F827-&gt;U+52E4, U+2F828-&gt;U+52FA, U+2F829-&gt;U+5305, \U+2F82A-&gt;U+5306, U+2F82B-&gt;U+5317, U+2F82C-&gt;U+5349, \U+2F82D-&gt;U+5351, U+2F82E-&gt;U+535A, U+2F82F-&gt;U+5373, \U+2F830-&gt;U+537D, U+2F831-&gt;U+537F, U+2F832-&gt;U+537F, \U+2F833-&gt;U+537F, U+2F834-&gt;U+20A2C, U+2F835-&gt;U+7070, \U+2F836-&gt;U+53CA, U+2F837-&gt;U+53DF, U+2F838-&gt;U+20B63, \U+2F839-&gt;U+53EB, U+2F83A-&gt;U+53F1, U+2F83B-&gt;U+5406, \U+2F83C-&gt;U+549E, U+2F83D-&gt;U+5438, U+2F83E-&gt;U+5448, \U+2F83F-&gt;U+5468, U+2F840-&gt;U+54A2, U+2F841-&gt;U+54F6, \U+2F842-&gt;U+5510, U+2F843-&gt;U+5553, U+2F844-&gt;U+5563, \U+2F845-&gt;U+5584, U+2F846-&gt;U+5584, U+2F847-&gt;U+5599, \U+2F848-&gt;U+55AB, U+2F849-&gt;U+55B3, U+2F84A-&gt;U+55C2, \U+2F84B-&gt;U+5716, U+2F84C-&gt;U+5606, U+2F84D-&gt;U+5717, \U+2F84E-&gt;U+5651, U+2F84F-&gt;U+5674, U+2F850-&gt;U+5207, \U+2F851-&gt;U+58EE, U+2F852-&gt;U+57CE, U+2F853-&gt;U+57F4, \U+2F854-&gt;U+580D, U+2F855-&gt;U+578B, U+2F856-&gt;U+5832, \U+2F857-&gt;U+5831, U+2F858-&gt;U+58AC, U+2F859-&gt;U+214E4, \U+2F85A-&gt;U+58F2, U+2F85B-&gt;U+58F7, U+2F85C-&gt;U+5906, \U+2F85D-&gt;U+591A, U+2F85E-&gt;U+5922, U+2F85F-&gt;U+5962, \U+2F860-&gt;U+216A8, U+2F861-&gt;U+216EA, U+2F862-&gt;U+59EC, \U+2F863-&gt;U+5A1B, U+2F864-&gt;U+5A27, U+2F865-&gt;U+59D8, \U+2F866-&gt;U+5A66, U+2F867-&gt;U+36EE, U+2F868-&gt;U+36FC, \U+2F869-&gt;U+5B08, U+2F86A-&gt;U+5B3E, U+2F86B-&gt;U+5B3E, \U+2F86C-&gt;U+219C8, U+2F86D-&gt;U+5BC3, U+2F86E-&gt;U+5BD8, \U+2F86F-&gt;U+5BE7, U+2F870-&gt;U+5BF3, U+2F871-&gt;U+21B18, \U+2F872-&gt;U+5BFF, U+2F873-&gt;U+5C06, U+2F874-&gt;U+5F53, \U+2F875-&gt;U+5C22, U+2F876-&gt;U+3781, U+2F877-&gt;U+5C60, \U+2F878-&gt;U+5C6E, U+2F879-&gt;U+5CC0, U+2F87A-&gt;U+5C8D, \U+2F87B-&gt;U+21DE4, U+2F87C-&gt;U+5D43, U+2F87D-&gt;U+21DE6, \U+2F87E-&gt;U+5D6E, U+2F87F-&gt;U+5D6B, U+2F880-&gt;U+5D7C, \U+2F881-&gt;U+5DE1, U+2F882-&gt;U+5DE2, U+2F883-&gt;U+382F, \U+2F884-&gt;U+5DFD, U+2F885-&gt;U+5E28, U+2F886-&gt;U+5E3D, \U+2F887-&gt;U+5E69, U+2F888-&gt;U+3862, U+2F889-&gt;U+22183, \U+2F88A-&gt;U+387C, U+2F88B-&gt;U+5EB0, U+2F88C-&gt;U+5EB3, \U+2F88D-&gt;U+5EB6, U+2F88E-&gt;U+5ECA, U+2F88F-&gt;U+2A392, \U+2F890-&gt;U+5EFE, U+2F891-&gt;U+22331, U+2F892-&gt;U+22331, \U+2F893-&gt;U+8201, U+2F894-&gt;U+5F22, U+2F895-&gt;U+5F22, \U+2F896-&gt;U+38C7, U+2F897-&gt;U+232B8, U+2F898-&gt;U+261DA, \U+2F899-&gt;U+5F62, U+2F89A-&gt;U+5F6B, U+2F89B-&gt;U+38E3, \U+2F89C-&gt;U+5F9A, U+2F89D-&gt;U+5FCD, U+2F89E-&gt;U+5FD7, \U+2F89F-&gt;U+5FF9, U+2F8A0-&gt;U+6081, U+2F8A1-&gt;U+393A, \U+2F8A2-&gt;U+391C, U+2F8A3-&gt;U+6094, U+2F8A4-&gt;U+226D4, \U+2F8A5-&gt;U+60C7, U+2F8A6-&gt;U+6148, U+2F8A7-&gt;U+614C, \U+2F8A8-&gt;U+614E, U+2F8A9-&gt;U+614C, U+2F8AA-&gt;U+617A, \U+2F8AB-&gt;U+618E, U+2F8AC-&gt;U+61B2, U+2F8AD-&gt;U+61A4, \U+2F8AE-&gt;U+61AF, U+2F8AF-&gt;U+61DE, U+2F8B0-&gt;U+61F2, \U+2F8B1-&gt;U+61F6, U+2F8B2-&gt;U+6210, U+2F8B3-&gt;U+621B, \U+2F8B4-&gt;U+625D, U+2F8B5-&gt;U+62B1, U+2F8B6-&gt;U+62D4, \U+2F8B7-&gt;U+6350, U+2F8B8-&gt;U+22B0C, U+2F8B9-&gt;U+633D, \U+2F8BA-&gt;U+62FC, U+2F8BB-&gt;U+6368, U+2F8BC-&gt;U+6383, \U+2F8BD-&gt;U+63E4, U+2F8BE-&gt;U+22BF1, U+2F8BF-&gt;U+6422, \U+2F8C0-&gt;U+63C5, U+2F8C1-&gt;U+63A9, U+2F8C2-&gt;U+3A2E, \U+2F8C3-&gt;U+6469, U+2F8C4-&gt;U+647E, U+2F8C5-&gt;U+649D, \U+2F8C6-&gt;U+6477, U+2F8C7-&gt;U+3A6C, U+2F8C8-&gt;U+654F, \U+2F8C9-&gt;U+656C, U+2F8CA-&gt;U+2300A, U+2F8CB-&gt;U+65E3, \U+2F8CC-&gt;U+66F8, U+2F8CD-&gt;U+6649, U+2F8CE-&gt;U+3B19, \U+2F8CF-&gt;U+6691, U+2F8D0-&gt;U+3B08, U+2F8D1-&gt;U+3AE4, \U+2F8D2-&gt;U+5192, U+2F8D3-&gt;U+5195, U+2F8D4-&gt;U+6700, \U+2F8D5-&gt;U+669C, U+2F8D6-&gt;U+80AD, U+2F8D7-&gt;U+43D9, \U+2F8D8-&gt;U+6717, U+2F8D9-&gt;U+671B, U+2F8DA-&gt;U+6721, \U+2F8DB-&gt;U+675E, U+2F8DC-&gt;U+6753, U+2F8DD-&gt;U+233C3, \U+2F8DE-&gt;U+3B49, U+2F8DF-&gt;U+67FA, U+2F8E0-&gt;U+6785, \U+2F8E1-&gt;U+6852, U+2F8E2-&gt;U+6885, U+2F8E3-&gt;U+2346D, \U+2F8E4-&gt;U+688E, U+2F8E5-&gt;U+681F, U+2F8E6-&gt;U+6914, \U+2F8E7-&gt;U+3B9D, U+2F8E8-&gt;U+6942, U+2F8E9-&gt;U+69A3, \U+2F8EA-&gt;U+69EA, U+2F8EB-&gt;U+6AA8, U+2F8EC-&gt;U+236A3, \U+2F8ED-&gt;U+6ADB, U+2F8EE-&gt;U+3C18, U+2F8EF-&gt;U+6B21, \U+2F8F0-&gt;U+238A7, U+2F8F1-&gt;U+6B54, U+2F8F2-&gt;U+3C4E, \U+2F8F3-&gt;U+6B72, U+2F8F4-&gt;U+6B9F, U+2F8F5-&gt;U+6BBA, \U+2F8F6-&gt;U+6BBB, U+2F8F7-&gt;U+23A8D, U+2F8F8-&gt;U+21D0B, \U+2F8F9-&gt;U+23AFA, U+2F8FA-&gt;U+6C4E, U+2F8FB-&gt;U+23CBC, \U+2F8FC-&gt;U+6CBF, U+2F8FD-&gt;U+6CCD, U+2F8FE-&gt;U+6C67, \U+2F8FF-&gt;U+6D16, U+2F900-&gt;U+6D3E, U+2F901-&gt;U+6D77, \U+2F902-&gt;U+6D41, U+2F903-&gt;U+6D69, U+2F904-&gt;U+6D78, \U+2F905-&gt;U+6D85, U+2F906-&gt;U+23D1E, U+2F907-&gt;U+6D34, \U+2F908-&gt;U+6E2F, U+2F909-&gt;U+6E6E, U+2F90A-&gt;U+3D33, \U+2F90B-&gt;U+6ECB, U+2F90C-&gt;U+6EC7, U+2F90D-&gt;U+23ED1, \U+2F90E-&gt;U+6DF9, U+2F90F-&gt;U+6F6E, U+2F910-&gt;U+23F5E, \U+2F911-&gt;U+23F8E, U+2F912-&gt;U+6FC6, U+2F913-&gt;U+7039, \U+2F914-&gt;U+701E, U+2F915-&gt;U+701B, U+2F916-&gt;U+3D96, \U+2F917-&gt;U+704A, U+2F918-&gt;U+707D, U+2F919-&gt;U+7077, \U+2F91A-&gt;U+70AD, U+2F91B-&gt;U+20525, U+2F91C-&gt;U+7145, \U+2F91D-&gt;U+24263, U+2F91E-&gt;U+719C, U+2F91F-&gt;U+243AB, \U+2F920-&gt;U+7228, U+2F921-&gt;U+7235, U+2F922-&gt;U+7250, \U+2F923-&gt;U+24608, U+2F924-&gt;U+7280, U+2F925-&gt;U+7295, \U+2F926-&gt;U+24735, U+2F927-&gt;U+24814, U+2F928-&gt;U+737A, \U+2F929-&gt;U+738B, U+2F92A-&gt;U+3EAC, U+2F92B-&gt;U+73A5, \U+2F92C-&gt;U+3EB8, U+2F92D-&gt;U+3EB8, U+2F92E-&gt;U+7447, \U+2F92F-&gt;U+745C, U+2F930-&gt;U+7471, U+2F931-&gt;U+7485, \U+2F932-&gt;U+74CA, U+2F933-&gt;U+3F1B, U+2F934-&gt;U+7524, \U+2F935-&gt;U+24C36, U+2F936-&gt;U+753E, U+2F937-&gt;U+24C92, \U+2F938-&gt;U+7570, U+2F939-&gt;U+2219F, U+2F93A-&gt;U+7610, \U+2F93B-&gt;U+24FA1, U+2F93C-&gt;U+24FB8, U+2F93D-&gt;U+25044, \U+2F93E-&gt;U+3FFC, U+2F93F-&gt;U+4008, U+2F940-&gt;U+76F4, \U+2F941-&gt;U+250F3, U+2F942-&gt;U+250F2, U+2F943-&gt;U+25119, \U+2F944-&gt;U+25133, U+2F945-&gt;U+771E, U+2F946-&gt;U+771F, \U+2F947-&gt;U+771F, U+2F948-&gt;U+774A, U+2F949-&gt;U+4039, \U+2F94A-&gt;U+778B, U+2F94B-&gt;U+4046, U+2F94C-&gt;U+4096, \U+2F94D-&gt;U+2541D, U+2F94E-&gt;U+784E, U+2F94F-&gt;U+788C, \U+2F950-&gt;U+78CC, U+2F951-&gt;U+40E3, U+2F952-&gt;U+25626, \U+2F953-&gt;U+7956, U+2F954-&gt;U+2569A, U+2F955-&gt;U+256C5, \U+2F956-&gt;U+798F, U+2F957-&gt;U+79EB, U+2F958-&gt;U+412F, \U+2F959-&gt;U+7A40, U+2F95A-&gt;U+7A4A, U+2F95B-&gt;U+7A4F, \U+2F95C-&gt;U+2597C, U+2F95D-&gt;U+25AA7, U+2F95E-&gt;U+25AA7, \U+2F95F-&gt;U+7AEE, U+2F960-&gt;U+4202, U+2F961-&gt;U+25BAB, \U+2F962-&gt;U+7BC6, U+2F963-&gt;U+7BC9, U+2F964-&gt;U+4227, \U+2F965-&gt;U+25C80, U+2F966-&gt;U+7CD2, U+2F967-&gt;U+42A0, \U+2F968-&gt;U+7CE8, U+2F969-&gt;U+7CE3, U+2F96A-&gt;U+7D00, \U+2F96B-&gt;U+25F86, U+2F96C-&gt;U+7D63, U+2F96D-&gt;U+4301, \U+2F96E-&gt;U+7DC7, U+2F96F-&gt;U+7E02, U+2F970-&gt;U+7E45, \U+2F971-&gt;U+4334, U+2F972-&gt;U+26228, U+2F973-&gt;U+26247, \U+2F974-&gt;U+4359, U+2F975-&gt;U+262D9, U+2F976-&gt;U+7F7A, \U+2F977-&gt;U+2633E, U+2F978-&gt;U+7F95, U+2F979-&gt;U+7FFA, \U+2F97A-&gt;U+8005, U+2F97B-&gt;U+264DA, U+2F97C-&gt;U+26523, \U+2F97D-&gt;U+8060, U+2F97E-&gt;U+265A8, U+2F97F-&gt;U+8070, \U+2F980-&gt;U+2335F, U+2F981-&gt;U+43D5, U+2F982-&gt;U+80B2, \U+2F983-&gt;U+8103, U+2F984-&gt;U+440B, U+2F985-&gt;U+813E, \U+2F986-&gt;U+5AB5, U+2F987-&gt;U+267A7, U+2F988-&gt;U+267B5, \U+2F989-&gt;U+23393, U+2F98A-&gt;U+2339C, U+2F98B-&gt;U+8201, \U+2F98C-&gt;U+8204, U+2F98D-&gt;U+8F9E, U+2F98E-&gt;U+446B, \U+2F98F-&gt;U+8291, U+2F990-&gt;U+828B, U+2F991-&gt;U+829D, \U+2F992-&gt;U+52B3, U+2F993-&gt;U+82B1, U+2F994-&gt;U+82B3, \U+2F995-&gt;U+82BD, U+2F996-&gt;U+82E6, U+2F997-&gt;U+26B3C, \U+2F998-&gt;U+82E5, U+2F999-&gt;U+831D, U+2F99A-&gt;U+8363, \U+2F99B-&gt;U+83AD, U+2F99C-&gt;U+8323, U+2F99D-&gt;U+83BD, \U+2F99E-&gt;U+83E7, U+2F99F-&gt;U+8457, U+2F9A0-&gt;U+8353, \U+2F9A1-&gt;U+83CA, U+2F9A2-&gt;U+83CC, U+2F9A3-&gt;U+83DC, \U+2F9A4-&gt;U+26C36, U+2F9A5-&gt;U+26D6B, U+2F9A6-&gt;U+26CD5, \U+2F9A7-&gt;U+452B, U+2F9A8-&gt;U+84F1, U+2F9A9-&gt;U+84F3, \U+2F9AA-&gt;U+8516, U+2F9AB-&gt;U+273CA, U+2F9AC-&gt;U+8564, \U+2F9AD-&gt;U+26F2C, U+2F9AE-&gt;U+455D, U+2F9AF-&gt;U+4561, \U+2F9B0-&gt;U+26FB1, U+2F9B1-&gt;U+270D2, U+2F9B2-&gt;U+456B, \U+2F9B3-&gt;U+8650, U+2F9B4-&gt;U+865C, U+2F9B5-&gt;U+8667, \U+2F9B6-&gt;U+8669, U+2F9B7-&gt;U+86A9, U+2F9B8-&gt;U+8688, \U+2F9B9-&gt;U+870E, U+2F9BA-&gt;U+86E2, U+2F9BB-&gt;U+8779, \U+2F9BC-&gt;U+8728, U+2F9BD-&gt;U+876B, U+2F9BE-&gt;U+8786, \U+2F9BF-&gt;U+45D7, U+2F9C0-&gt;U+87E1, U+2F9C1-&gt;U+8801, \U+2F9C2-&gt;U+45F9, U+2F9C3-&gt;U+8860, U+2F9C4-&gt;U+8863, \U+2F9C5-&gt;U+27667, U+2F9C6-&gt;U+88D7, U+2F9C7-&gt;U+88DE, \U+2F9C8-&gt;U+4635, U+2F9C9-&gt;U+88FA, U+2F9CA-&gt;U+34BB, \U+2F9CB-&gt;U+278AE, U+2F9CC-&gt;U+27966, U+2F9CD-&gt;U+46BE, \U+2F9CE-&gt;U+46C7, U+2F9CF-&gt;U+8AA0, U+2F9D0-&gt;U+8AED, \U+2F9D1-&gt;U+8B8A, U+2F9D2-&gt;U+8C55, U+2F9D3-&gt;U+27CA8, \U+2F9D4-&gt;U+8CAB, U+2F9D5-&gt;U+8CC1, U+2F9D6-&gt;U+8D1B, \U+2F9D7-&gt;U+8D77, U+2F9D8-&gt;U+27F2F, U+2F9D9-&gt;U+20804, \U+2F9DA-&gt;U+8DCB, U+2F9DB-&gt;U+8DBC, U+2F9DC-&gt;U+8DF0, \U+2F9DD-&gt;U+208DE, U+2F9DE-&gt;U+8ED4, U+2F9DF-&gt;U+8F38, \U+2F9E0-&gt;U+285D2, U+2F9E1-&gt;U+285ED, U+2F9E2-&gt;U+9094, \U+2F9E3-&gt;U+90F1, U+2F9E4-&gt;U+9111, U+2F9E5-&gt;U+2872E, \U+2F9E6-&gt;U+911B, U+2F9E7-&gt;U+9238, U+2F9E8-&gt;U+92D7, \U+2F9E9-&gt;U+92D8, U+2F9EA-&gt;U+927C, U+2F9EB-&gt;U+93F9, \U+2F9EC-&gt;U+9415, U+2F9ED-&gt;U+28BFA, U+2F9EE-&gt;U+958B, \U+2F9EF-&gt;U+4995, U+2F9F0-&gt;U+95B7, U+2F9F1-&gt;U+28D77, \U+2F9F2-&gt;U+49E6, U+2F9F3-&gt;U+96C3, U+2F9F4-&gt;U+5DB2, \U+2F9F5-&gt;U+9723, U+2F9F6-&gt;U+29145, U+2F9F7-&gt;U+2921A, \U+2F9F8-&gt;U+4A6E, U+2F9F9-&gt;U+4A76, U+2F9FA-&gt;U+97E0, \U+2F9FB-&gt;U+2940A, U+2F9FC-&gt;U+4AB2, U+2F9FD-&gt;U+29496, \U+2F9FE-&gt;U+980B, U+2F9FF-&gt;U+980B, U+2FA00-&gt;U+9829, \U+2FA01-&gt;U+295B6, U+2FA02-&gt;U+98E2, U+2FA03-&gt;U+4B33, \U+2FA04-&gt;U+9929, U+2FA05-&gt;U+99A7, U+2FA06-&gt;U+99C2, \U+2FA07-&gt;U+99FE, U+2FA08-&gt;U+4BCE, U+2FA09-&gt;U+29B30, \U+2FA0A-&gt;U+9B12, U+2FA0B-&gt;U+9C40, U+2FA0C-&gt;U+9CFD, \U+2FA0D-&gt;U+4CCE, U+2FA0E-&gt;U+4CED, U+2FA0F-&gt;U+9D67, \U+2FA10-&gt;U+2A0CE, U+2FA11-&gt;U+4CF8, U+2FA12-&gt;U+2A105, \U+2FA13-&gt;U+2A20E, U+2FA14-&gt;U+2A291, U+2FA15-&gt;U+9EBB, \U+2FA16-&gt;U+4D56, U+2FA17-&gt;U+9EF9, U+2FA18-&gt;U+9EFE, \U+2FA19-&gt;U+9F05, U+2FA1A-&gt;U+9F0F, U+2FA1B-&gt;U+9F16, \U+2FA1C-&gt;U+9F3B, U+2FA1D-&gt;U+2A600, U+2F00-&gt;U+4E00, \U+2F01-&gt;U+4E28, U+2F02-&gt;U+4E36, U+2F03-&gt;U+4E3F, \U+2F04-&gt;U+4E59, U+2F05-&gt;U+4E85, U+2F06-&gt;U+4E8C, \U+2F07-&gt;U+4EA0, U+2F08-&gt;U+4EBA, U+2F09-&gt;U+513F, \U+2F0A-&gt;U+5165, U+2F0B-&gt;U+516B, U+2F0C-&gt;U+5182, \U+2F0D-&gt;U+5196, U+2F0E-&gt;U+51AB, U+2F0F-&gt;U+51E0, \U+2F10-&gt;U+51F5, U+2F11-&gt;U+5200, U+2F12-&gt;U+529B, \U+2F13-&gt;U+52F9, U+2F14-&gt;U+5315, U+2F15-&gt;U+531A, \U+2F16-&gt;U+5338, U+2F17-&gt;U+5341, U+2F18-&gt;U+535C, \U+2F19-&gt;U+5369, U+2F1A-&gt;U+5382, U+2F1B-&gt;U+53B6, \U+2F1C-&gt;U+53C8, U+2F1D-&gt;U+53E3, U+2F1E-&gt;U+56D7, \U+2F1F-&gt;U+571F, U+2F20-&gt;U+58EB, U+2F21-&gt;U+5902, \U+2F22-&gt;U+590A, U+2F23-&gt;U+5915, U+2F24-&gt;U+5927, \U+2F25-&gt;U+5973, U+2F26-&gt;U+5B50, U+2F27-&gt;U+5B80, \U+2F28-&gt;U+5BF8, U+2F29-&gt;U+5C0F, U+2F2A-&gt;U+5C22, \U+2F2B-&gt;U+5C38, U+2F2C-&gt;U+5C6E, U+2F2D-&gt;U+5C71, \U+2F2E-&gt;U+5DDB, U+2F2F-&gt;U+5DE5, U+2F30-&gt;U+5DF1, \U+2F31-&gt;U+5DFE, U+2F32-&gt;U+5E72, U+2F33-&gt;U+5E7A, \U+2F34-&gt;U+5E7F, U+2F35-&gt;U+5EF4, U+2F36-&gt;U+5EFE, \U+2F37-&gt;U+5F0B, U+2F38-&gt;U+5F13, U+2F39-&gt;U+5F50, \U+2F3A-&gt;U+5F61, U+2F3B-&gt;U+5F73, U+2F3C-&gt;U+5FC3, \U+2F3D-&gt;U+6208, U+2F3E-&gt;U+6236, U+2F3F-&gt;U+624B, \U+2F40-&gt;U+652F, U+2F41-&gt;U+6534, U+2F42-&gt;U+6587, \U+2F43-&gt;U+6597, U+2F44-&gt;U+65A4, U+2F45-&gt;U+65B9, \U+2F46-&gt;U+65E0, U+2F47-&gt;U+65E5, U+2F48-&gt;U+66F0, \U+2F49-&gt;U+6708, U+2F4A-&gt;U+6728, U+2F4B-&gt;U+6B20, \U+2F4C-&gt;U+6B62, U+2F4D-&gt;U+6B79, U+2F4E-&gt;U+6BB3, \U+2F4F-&gt;U+6BCB, U+2F50-&gt;U+6BD4, U+2F51-&gt;U+6BDB, \U+2F52-&gt;U+6C0F, U+2F53-&gt;U+6C14, U+2F54-&gt;U+6C34, \U+2F55-&gt;U+706B, U+2F56-&gt;U+722A, U+2F57-&gt;U+7236, \U+2F58-&gt;U+723B, U+2F59-&gt;U+723F, U+2F5A-&gt;U+7247, \U+2F5B-&gt;U+7259, U+2F5C-&gt;U+725B, U+2F5D-&gt;U+72AC, \U+2F5E-&gt;U+7384, U+2F5F-&gt;U+7389, U+2F60-&gt;U+74DC, \U+2F61-&gt;U+74E6, U+2F62-&gt;U+7518, U+2F63-&gt;U+751F, \U+2F64-&gt;U+7528, U+2F65-&gt;U+7530, U+2F66-&gt;U+758B, \U+2F67-&gt;U+7592, U+2F68-&gt;U+7676, U+2F69-&gt;U+767D, \U+2F6A-&gt;U+76AE, U+2F6B-&gt;U+76BF, U+2F6C-&gt;U+76EE, \U+2F6D-&gt;U+77DB, U+2F6E-&gt;U+77E2, U+2F6F-&gt;U+77F3, \U+2F70-&gt;U+793A, U+2F71-&gt;U+79B8, U+2F72-&gt;U+79BE, \U+2F73-&gt;U+7A74, U+2F74-&gt;U+7ACB, U+2F75-&gt;U+7AF9, \U+2F76-&gt;U+7C73, U+2F77-&gt;U+7CF8, U+2F78-&gt;U+7F36, \U+2F79-&gt;U+7F51, U+2F7A-&gt;U+7F8A, U+2F7B-&gt;U+7FBD, \U+2F7C-&gt;U+8001, U+2F7D-&gt;U+800C, U+2F7E-&gt;U+8012, \U+2F7F-&gt;U+8033, U+2F80-&gt;U+807F, U+2F81-&gt;U+8089, \U+2F82-&gt;U+81E3, U+2F83-&gt;U+81EA, U+2F84-&gt;U+81F3, \U+2F85-&gt;U+81FC, U+2F86-&gt;U+820C, U+2F87-&gt;U+821B, \U+2F88-&gt;U+821F, U+2F89-&gt;U+826E, U+2F8A-&gt;U+8272, \U+2F8B-&gt;U+8278, U+2F8C-&gt;U+864D, U+2F8D-&gt;U+866B, \U+2F8E-&gt;U+8840, U+2F8F-&gt;U+884C, U+2F90-&gt;U+8863, \U+2F91-&gt;U+897E, U+2F92-&gt;U+898B, U+2F93-&gt;U+89D2, \U+2F94-&gt;U+8A00, U+2F95-&gt;U+8C37, U+2F96-&gt;U+8C46, \U+2F97-&gt;U+8C55, U+2F98-&gt;U+8C78, U+2F99-&gt;U+8C9D, \U+2F9A-&gt;U+8D64, U+2F9B-&gt;U+8D70, U+2F9C-&gt;U+8DB3, \U+2F9D-&gt;U+8EAB, U+2F9E-&gt;U+8ECA, U+2F9F-&gt;U+8F9B, \U+2FA0-&gt;U+8FB0, U+2FA1-&gt;U+8FB5, U+2FA2-&gt;U+9091, \U+2FA3-&gt;U+9149, U+2FA4-&gt;U+91C6, U+2FA5-&gt;U+91CC, \U+2FA6-&gt;U+91D1, U+2FA7-&gt;U+9577, U+2FA8-&gt;U+9580, \U+2FA9-&gt;U+961C, U+2FAA-&gt;U+96B6, U+2FAB-&gt;U+96B9, \U+2FAC-&gt;U+96E8, U+2FAD-&gt;U+9751, U+2FAE-&gt;U+975E, \U+2FAF-&gt;U+9762, U+2FB0-&gt;U+9769, U+2FB1-&gt;U+97CB, \U+2FB2-&gt;U+97ED, U+2FB3-&gt;U+97F3, U+2FB4-&gt;U+9801, \U+2FB5-&gt;U+98A8, U+2FB6-&gt;U+98DB, U+2FB7-&gt;U+98DF, \U+2FB8-&gt;U+9996, U+2FB9-&gt;U+9999, U+2FBA-&gt;U+99AC, \U+2FBB-&gt;U+9AA8, U+2FBC-&gt;U+9AD8, U+2FBD-&gt;U+9ADF, \U+2FBE-&gt;U+9B25, U+2FBF-&gt;U+9B2F, U+2FC0-&gt;U+9B32, \U+2FC1-&gt;U+9B3C, U+2FC2-&gt;U+9B5A, U+2FC3-&gt;U+9CE5, \U+2FC4-&gt;U+9E75, U+2FC5-&gt;U+9E7F, U+2FC6-&gt;U+9EA5, \U+2FC7-&gt;U+9EBB, U+2FC8-&gt;U+9EC3, U+2FC9-&gt;U+9ECD, \U+2FCA-&gt;U+9ED1, U+2FCB-&gt;U+9EF9, U+2FCC-&gt;U+9EFD, \U+2FCD-&gt;U+9F0E, U+2FCE-&gt;U+9F13, U+2FCF-&gt;U+9F20, \U+2FD0-&gt;U+9F3B, U+2FD1-&gt;U+9F4A, U+2FD2-&gt;U+9F52, \U+2FD3-&gt;U+9F8D, U+2FD4-&gt;U+9F9C, U+2FD5-&gt;U+9FA0, \U+3042-&gt;U+3041, U+3044-&gt;U+3043, U+3046-&gt;U+3045, \U+3048-&gt;U+3047, U+304A-&gt;U+3049, U+304C-&gt;U+304B, \U+304E-&gt;U+304D, U+3050-&gt;U+304F, U+3052-&gt;U+3051, \U+3054-&gt;U+3053, U+3056-&gt;U+3055, U+3058-&gt;U+3057, \U+305A-&gt;U+3059, U+305C-&gt;U+305B, U+305E-&gt;U+305D, \U+3060-&gt;U+305F, U+3062-&gt;U+3061, U+3064-&gt;U+3063, \U+3065-&gt;U+3063, U+3067-&gt;U+3066, U+3069-&gt;U+3068, \U+3070-&gt;U+306F, U+3071-&gt;U+306F, U+3073-&gt;U+3072, \U+3074-&gt;U+3072, U+3076-&gt;U+3075, U+3077-&gt;U+3075, \U+3079-&gt;U+3078, U+307A-&gt;U+3078, U+307C-&gt;U+307B, \U+307D-&gt;U+307B, U+3084-&gt;U+3083, U+3086-&gt;U+3085, \U+3088-&gt;U+3087, U+308F-&gt;U+308E, U+3094-&gt;U+3046, \U+3095-&gt;U+304B, U+3096-&gt;U+3051, U+30A2-&gt;U+30A1, \U+30A4-&gt;U+30A3, U+30A6-&gt;U+30A5, U+30A8-&gt;U+30A7, \U+30AA-&gt;U+30A9, U+30AC-&gt;U+30AB, U+30AE-&gt;U+30AD, \U+30B0-&gt;U+30AF, U+30B2-&gt;U+30B1, U+30B4-&gt;U+30B3, \U+30B6-&gt;U+30B5, U+30B8-&gt;U+30B7, U+30BA-&gt;U+30B9, \U+30BC-&gt;U+30BB, U+30BE-&gt;U+30BD, U+30C0-&gt;U+30BF, \U+30C2-&gt;U+30C1, U+30C5-&gt;U+30C4, U+30C7-&gt;U+30C6, \U+30C9-&gt;U+30C8, U+30D0-&gt;U+30CF, U+30D1-&gt;U+30CF, \U+30D3-&gt;U+30D2, U+30D4-&gt;U+30D2, U+30D6-&gt;U+30D5, \U+30D7-&gt;U+30D5, U+30D9-&gt;U+30D8, U+30DA-&gt;U+30D8, \U+30DC-&gt;U+30DB, U+30DD-&gt;U+30DB, U+30E4-&gt;U+30E3, \U+30E6-&gt;U+30E5, U+30E8-&gt;U+30E7, U+30EF-&gt;U+30EE, \U+30F4-&gt;U+30A6, U+30AB-&gt;U+30F5, U+30B1-&gt;U+30F6, \U+30F7-&gt;U+30EF, U+30F8-&gt;U+30F0, U+30F9-&gt;U+30F1, \U+30FA-&gt;U+30F2, U+30AF-&gt;U+31F0, U+30B7-&gt;U+31F1, \U+30B9-&gt;U+31F2, U+30C8-&gt;U+31F3, U+30CC-&gt;U+31F4, \U+30CF-&gt;U+31F5, U+30D2-&gt;U+31F6, U+30D5-&gt;U+31F7, \U+30D8-&gt;U+31F8, U+30DB-&gt;U+31F9, U+30E0-&gt;U+31FA, \U+30E9-&gt;U+31FB, U+30EA-&gt;U+31FC, U+30EB-&gt;U+31FD, \U+30EC-&gt;U+31FE, U+30ED-&gt;U+31FF, U+FF66-&gt;U+30F2, \U+FF67-&gt;U+30A1, U+FF68-&gt;U+30A3, U+FF69-&gt;U+30A5, \U+FF6A-&gt;U+30A7, U+FF6B-&gt;U+30A9, U+FF6C-&gt;U+30E3, \U+FF6D-&gt;U+30E5, U+FF6E-&gt;U+30E7, U+FF6F-&gt;U+30C3, \U+FF71-&gt;U+30A1, U+FF72-&gt;U+30A3, U+FF73-&gt;U+30A5, \U+FF74-&gt;U+30A7, U+FF75-&gt;U+30A9, U+FF76-&gt;U+30AB, \U+FF77-&gt;U+30AD, U+FF78-&gt;U+30AF, U+FF79-&gt;U+30B1, \U+FF7A-&gt;U+30B3, U+FF7B-&gt;U+30B5, U+FF7C-&gt;U+30B7, \U+FF7D-&gt;U+30B9, U+FF7E-&gt;U+30BB, U+FF7F-&gt;U+30BD, \U+FF80-&gt;U+30BF, U+FF81-&gt;U+30C1, U+FF82-&gt;U+30C3, \U+FF83-&gt;U+30C6, U+FF84-&gt;U+30C8, U+FF85-&gt;U+30CA, \U+FF86-&gt;U+30CB, U+FF87-&gt;U+30CC, U+FF88-&gt;U+30CD, \U+FF89-&gt;U+30CE, U+FF8A-&gt;U+30CF, U+FF8B-&gt;U+30D2, \U+FF8C-&gt;U+30D5, U+FF8D-&gt;U+30D8, U+FF8E-&gt;U+30DB, \U+FF8F-&gt;U+30DE, U+FF90-&gt;U+30DF, U+FF91-&gt;U+30E0, \U+FF92-&gt;U+30E1, U+FF93-&gt;U+30E2, U+FF94-&gt;U+30E3, \U+FF95-&gt;U+30E5, U+FF96-&gt;U+30E7, U+FF97-&gt;U+30E9, \U+FF98-&gt;U+30EA, U+FF99-&gt;U+30EB, U+FF9A-&gt;U+30EC, \U+FF9B-&gt;U+30ED, U+FF9C-&gt;U+30EF, U+FF9D-&gt;U+30F3, \U+FFA0-&gt;U+3164, U+FFA1-&gt;U+3131, U+FFA2-&gt;U+3132, \U+FFA3-&gt;U+3133, U+FFA4-&gt;U+3134, U+FFA5-&gt;U+3135, \U+FFA6-&gt;U+3136, U+FFA7-&gt;U+3137, U+FFA8-&gt;U+3138, \U+FFA9-&gt;U+3139, U+FFAA-&gt;U+313A, U+FFAB-&gt;U+313B, \U+FFAC-&gt;U+313C, U+FFAD-&gt;U+313D, U+FFAE-&gt;U+313E, \U+FFAF-&gt;U+313F, U+FFB0-&gt;U+3140, U+FFB1-&gt;U+3141, \U+FFB2-&gt;U+3142, U+FFB3-&gt;U+3143, U+FFB4-&gt;U+3144, \U+FFB5-&gt;U+3145, U+FFB6-&gt;U+3146, U+FFB7-&gt;U+3147, \U+FFB8-&gt;U+3148, U+FFB9-&gt;U+3149, U+FFBA-&gt;U+314A, \U+FFBB-&gt;U+314B, U+FFBC-&gt;U+314C, U+FFBD-&gt;U+314D, \U+FFBE-&gt;U+314E, U+FFC2-&gt;U+314F, U+FFC3-&gt;U+3150, \U+FFC4-&gt;U+3151, U+FFC5-&gt;U+3152, U+FFC6-&gt;U+3153, \U+FFC7-&gt;U+3154, U+FFCA-&gt;U+3155, U+FFCB-&gt;U+3156, \U+FFCC-&gt;U+3157, U+FFCD-&gt;U+3158, U+FFCE-&gt;U+3159, \U+FFCF-&gt;U+315A, U+FFD2-&gt;U+315B, U+FFD3-&gt;U+315C, \U+FFD4-&gt;U+315D, U+FFD5-&gt;U+315E, U+FFD6-&gt;U+315F, \U+FFD7-&gt;U+3160, U+FFDA-&gt;U+3161, U+FFDB-&gt;U+3162, \U+FFDC-&gt;U+3163, U+3131-&gt;U+1100, U+3132-&gt;U+1101, \U+3133-&gt;U+11AA, U+3134-&gt;U+1102, U+3135-&gt;U+11AC, \U+3136-&gt;U+11AD, U+3137-&gt;U+1103, U+3138-&gt;U+1104, \U+3139-&gt;U+1105, U+313A-&gt;U+11B0, U+313B-&gt;U+11B1, \U+313C-&gt;U+11B2, U+313D-&gt;U+11B3, U+313E-&gt;U+11B4, \U+313F-&gt;U+11B5, U+3140-&gt;U+111A, U+3141-&gt;U+1106, \U+3142-&gt;U+1107, U+3143-&gt;U+1108, U+3144-&gt;U+1121, \U+3145-&gt;U+1109, U+3146-&gt;U+110A, U+3147-&gt;U+110B, \U+3148-&gt;U+110C, U+3149-&gt;U+110D, U+314A-&gt;U+110E, \U+314B-&gt;U+110F, U+314C-&gt;U+1110, U+314D-&gt;U+1111, \U+314E-&gt;U+1112, U+314F-&gt;U+1161, U+3150-&gt;U+1162, \U+3151-&gt;U+1163, U+3152-&gt;U+1164, U+3153-&gt;U+1165, \U+3154-&gt;U+1166, U+3155-&gt;U+1167, U+3156-&gt;U+1168, \U+3157-&gt;U+1169, U+3158-&gt;U+116A, U+3159-&gt;U+116B, \U+315A-&gt;U+116C, U+315B-&gt;U+116D, U+315C-&gt;U+116E, \U+315D-&gt;U+116F, U+315E-&gt;U+1170, U+315F-&gt;U+1171, \U+3160-&gt;U+1172, U+3161-&gt;U+1173, U+3162-&gt;U+1174, \U+3163-&gt;U+1175, U+3165-&gt;U+1114, U+3166-&gt;U+1115, \U+3167-&gt;U+11C7, U+3168-&gt;U+11C8, U+3169-&gt;U+11CC, \U+316A-&gt;U+11CE, U+316B-&gt;U+11D3, U+316C-&gt;U+11D7, \U+316D-&gt;U+11D9, U+316E-&gt;U+111C, U+316F-&gt;U+11DD, \U+3170-&gt;U+11DF, U+3171-&gt;U+111D, U+3172-&gt;U+111E, \U+3173-&gt;U+1120, U+3174-&gt;U+1122, U+3175-&gt;U+1123, \U+3176-&gt;U+1127, U+3177-&gt;U+1129, U+3178-&gt;U+112B, \U+3179-&gt;U+112C, U+317A-&gt;U+112D, U+317B-&gt;U+112E, \U+317C-&gt;U+112F, U+317D-&gt;U+1132, U+317E-&gt;U+1136, \U+317F-&gt;U+1140, U+3180-&gt;U+1147, U+3181-&gt;U+114C, \U+3182-&gt;U+11F1, U+3183-&gt;U+11F2, U+3184-&gt;U+1157, \U+3185-&gt;U+1158, U+3186-&gt;U+1159, U+3187-&gt;U+1184, \U+3188-&gt;U+1185, U+3189-&gt;U+1188, U+318A-&gt;U+1191, \U+318B-&gt;U+1192, U+318C-&gt;U+1194, U+318D-&gt;U+119E, \U+318E-&gt;U+11A1, U+A490-&gt;U+A408, U+A491-&gt;U+A1B9, \U+4E00..U+9FBB, U+3400..U+4DB5, U+20000..U+2A6D6, \U+FA0E, U+FA0F, U+FA11, \U+FA13, U+FA14, U+FA1F, \U+FA21, U+FA23, U+FA24, \U+FA27, U+FA28, U+FA29, \U+3105..U+312C, U+31A0..U+31B7, U+3041, \U+3043, U+3045, U+3047, \U+3049, U+304B, U+304D, \U+304F, U+3051, U+3053, \U+3055, U+3057, U+3059, \U+305B, U+305D, U+305F, \U+3061, U+3063, U+3066, \U+3068, U+306A..U+306F, U+3072, \U+3075, U+3078, U+307B, \U+307E..U+3083, U+3085, U+3087, \U+3089..U+308E, U+3090..U+3093, U+30A1, \U+30A3, U+30A5, U+30A7, \U+30A9, U+30AD, U+30AF, \U+30B3, U+30B5, U+30BB, \U+30BD, U+30BF, U+30C1, \U+30C3, U+30C4, U+30C6, \U+30CA, U+30CB, U+30CD, \U+30CE, U+30DE, U+30DF, \U+30E1, U+30E2, U+30E3, \U+30E5, U+30E7, U+30EE, \U+30F0..U+30F3, U+30F5, U+30F6, \U+31F0, U+31F1, U+31F2, \U+31F3, U+31F4, U+31F5, \U+31F6, U+31F7, U+31F8, \U+31F9, U+31FA, U+31FB, \U+31FC, U+31FD, U+31FE, \U+31FF, U+AC00..U+D7A3, U+1100..U+1159&#125;#文章增量索引(用于增量更新索引)index article_detal : article&#123;    source      = article_delta_src    path        = /usr/local/sphinx/var/data/article_detal&#125;</code></pre><h3 id="索引二"><a class="markdownIt-Anchor" href="#索引二"></a> 索引二:</h3><p>建立博客论坛文章索引(sphinx-social-article.conf,此处省略格式同上)</p><h3 id="建立sphinxconf配置文件"><a class="markdownIt-Anchor" href="#建立sphinxconf配置文件"></a> 建立sphinx.conf配置文件</h3><p>注意:<strong>#!/bin/bash</strong> 很重要</p><pre class="highlight"><code class>#!/bin/bash path=/usr/local/sphinx/etc#引入所有索引文件/bin/cat $path/sphinx-base.conf $path/sphinx-article.conf $path/sphinx-social-article.conf</code></pre><blockquote><p>此时,配置工作就已经完成,可以启动sphinx服务,并生成索引文件了.</p></blockquote><h3 id="自动索引"><a class="markdownIt-Anchor" href="#自动索引"></a> 自动索引</h3><p>用<a href="/2017/12/11/Linux/%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%E8%B0%83%E5%BA%A6">cron定时任务</a>实现自动索引.</p><p><code>建立索引更新脚本</code>: start_index.sh</p><pre class="highlight"><code class>#!/bin/shindex=/usr/local/sphinx/bin/indexer#建立索引echo -e &quot;\n\n\n[`date`]建立索引-------------&gt;$1&quot;;$index --rotate $1#pat=detal#echo $1|grep -e $pat &gt; /dev/nullif [ $# -eq 2 ]; then    echo -e &quot;[`date`]$1合并增量索引-------------&gt;$2&quot;    $index --merge $2 $1 --rotatefi</code></pre><p><code>设置cron定时任务</code>: crontab -e</p><pre class="highlight"><code class>#sphinx article索引*/1 * * * * /usr/local/sphinx/etc/start_index.sh article_detal article &gt;&gt; /root/sphinx/log/detal.log 2&gt;&amp;1 #增量索引* 2 * * * /usr/local/sphinx/etc/start_index.sh article &gt;&gt; /root/sphinx/log/all.log 2&gt;&amp;1 #全量索引#sphinx social_article索引*/1 * * * * /usr/local/sphinx/etc/start_index.sh social_article_detal social_article &gt;&gt; /root/sphinx/log/detal.log 2&gt;&amp;1 #增量索引* 2 * * * /usr/local/sphinx/etc/start_index.sh social_article &gt;&gt; /root/sphinx/log/all.log 2&gt;&amp;1 #全量索引```---参考资料:官方文档:[http://sphinxsearch.com/](http://sphinxsearch.com/)中文资料:* [Sphinx 配置文件全解析](http://www.cnblogs.com/yjf512/p/3598332.html)* [Sphinx 命令行工具](https://blog.csdn.net/huanghuitan/article/details/60133114)---</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 全文检索 </tag>
            
            <tag> Sphinx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIT学习笔记</title>
      <link href="2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="工作区和暂存区"><a class="markdownIt-Anchor" href="#工作区和暂存区"></a> 工作区和暂存区</h2><blockquote><p>git和其它版本控制系统,如SVN的一个不同之处就是有暂存区的概念</p><p><code>工作区</code>:就是电脑能看到的仓库文件夹目录.</p><p><code>版本库</code>:工作区内的隐藏目录.git,这个不算工作区,而是git的版本库.</p><p>GIT版本库里存了很多东西,其中最重要的就是stage(或者叫index)的暂存区,还有GIT为我们自动创建的第一个分支master,以及一个指向master的指针HEAD.</p><p>实际上git add就是把所有修改放到暂存区,git commit是把暂缓区的修改提交到分支.</p><p><strong>因此,修改一个文件后必须要添加(git add)到暂存区,才能提交(git commit)到分支,否则提交无效</strong></p></blockquote><h2 id="第一次安装设置"><a class="markdownIt-Anchor" href="#第一次安装设置"></a> 第一次安装设置</h2><pre class="highlight"><code class="bash"><span class="hljs-comment">#因为git是分布式,这些就是你在提交commit时的签名。(--global全局设置,不加则设置当前版本库)</span>$ git config [--global] user.name <span class="hljs-string">"Your Name"</span>$ git config [--global] user.email <span class="hljs-string">"email@example.com"</span></code></pre><h2 id="创建版本仓库"><a class="markdownIt-Anchor" href="#创建版本仓库"></a> 创建版本仓库</h2><pre class="highlight"><code class="bash">$ git init [--bare] <span class="hljs-comment"># 创建版本仓库 (--bare 目地是创建一个裸仓库，作为远程仓库使用)</span>$ git add [-p|-u|-A]［&lt;path&gt;,...] <span class="hljs-comment"># 添加文件到版本仓库</span>| -------- | ----------------------------------------------------------------------------------------| &lt;path&gt;   | 添加&lt;path&gt;路径中修改的文件（不包括删除文件）或新增加文件到暂存区| -u       | 添加&lt;path&gt;路径中所有已修改的文件（不包括新增加文件）到暂存区，可省略&lt;path&gt;表示当前目录| -A       | 添加&lt;path&gt;路径中所有已修改的文件（包括删除文件和新增文件）到暂存区，可省略&lt;path&gt;表示当前目录| -p       | 通过补丁块拣选方式选择要添加到暂存区的内容（? 键查看相关文档）| -------- | ----------------------------------------------------------------------------------------$ git add -p <span class="hljs-comment"># 通过补丁块的方式选择要添加到暂存区的内容（ ? 查看快捷键文档）</span>$ git commit -m <span class="hljs-string">'提交说明信息'</span> <span class="hljs-comment"># 提交版本</span>$ git commit [-v] <span class="hljs-comment"># 提交版本,启动编辑器编写注释(-v显示详细变更信息)</span>$ git commit -a <span class="hljs-comment"># 提交版本,跳过使用暂存区(不用 git add)</span></code></pre><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/QQ20171117-115013@2x.png" alt="版本库"><span class="image-caption">版本库</span></p><h2 id="版本管理"><a class="markdownIt-Anchor" href="#版本管理"></a> 版本管理</h2><h3 id="文件状态"><a class="markdownIt-Anchor" href="#文件状态"></a> 文件状态</h3><pre class="highlight"><code class="bash">$ git status (-s/--short) <span class="hljs-comment">#查看版本库状态以及文件修改状态(-s 显示简单信息)</span>1.未修改状态:nothing to commit,working tree clean2.修改后文件已在缓存区:Changes to be commited3.新增文件状态:Untracked files4.修改后文件未在缓存区:Changes not staged <span class="hljs-keyword">for</span> commit3与4状态区别在于3无法用git commit –am命令将文件添加到本地仓库</code></pre><h3 id="git-status-s符号意义"><a class="markdownIt-Anchor" href="#git-status-s符号意义"></a> git status -s符号意义</h3><blockquote><p>?? 新添加的未跟踪文件前面</p><p>A 新添加到暂存区中的文件</p><p>M 修改过的文件(出现在右边的,表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区)</p></blockquote><h3 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h3><blockquote><p>和<code>SVN</code>不一样,<code>GIT</code>每个提交版本的commit id不是1,2,3…的数字而是一个SHA1计算出来的十六进制数字.因为GIT是分布式控制系统,如果用1,2,3…数字表示多人协作会重复.</p></blockquote><pre class="highlight"><code class="bash">HEAD <span class="hljs-comment">#表示最新提交的版本</span>HEAD^ <span class="hljs-comment">#表示上一个提交版本</span>HEAD~100 <span class="hljs-comment">#表示往上100个版本(~ 代替多个 ^)</span><span class="hljs-comment">#git reset 版本号</span>$ git reset (--mixed) HEAD^ <span class="hljs-comment">#回退到上个版本,缓存区和你指定的提交同步，但工作目录不受影响(--mixed是默认选项,可以不加)</span>$ git reset --soft HEAD^ <span class="hljs-comment">#回退到上个版本,缓存区和工作区都不受影响</span>$ git reset --hard HEAD^ <span class="hljs-comment">#回退到上个版本,缓存区和工作目录都同步到你指定的提交(危险指令)</span></code></pre><blockquote><p>git reset 后面如果是版本号不用写全,只写前几位就可以了.GIT版本回退非常快,因为GIT在内部有个指向当前版本的HEAD指针,当回退版本时GIT仅仅是把HEAD从指向当前版本改为指向回退版本(如下图),顺便把工作区更新了.</p></blockquote><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/QQ20171117-112922@2x.png" alt="当前版本"><span class="image-caption">当前版本</span></p><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/QQ20171117-112940@2x.png" alt="版本回退"><span class="image-caption">版本回退</span></p><blockquote><p>由于git log仅显示从当前版本到历史版本的纪录,如果回退了某个版本,又想还原到最新版本，可以使用<code>git reflog</code>查看commitId然后回退到指定版本。<br>因为，git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录。</p></blockquote><h3 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h3><pre class="highlight"><code class="bash">$ git commit --amend <span class="hljs-comment"># 撤消上次文件提交的修改,重新提交（--amend选项仅针对当前版本未push情况有效）</span>$ git reset HEAD 文件名 <span class="hljs-comment"># 撤销暂存区文件修改(HEAD表示撤销到最新版本)</span>$ git checkout -- 文件名 <span class="hljs-comment"># 撤销工作区文件的修改(如果没有--应变成了切换分支的命令)</span>$ git restore [--staged] 文件名 <span class="hljs-comment"># 撤销工作区文件的修改（同上），--staged 选项表示撤销暂存区的修改相当于 git reset 操作。</span></code></pre><blockquote><p>已经推送到远程仓库的撤销，需要使用<code>git push --force</code> 强制推送（危险操作慎用）</p></blockquote><h3 id="修改提交"><a class="markdownIt-Anchor" href="#修改提交"></a> 修改提交</h3><ul><li>拆分当前提交</li></ul><pre class="highlight"><code class="bash"><span class="hljs-comment"># 重置到上一次提交</span>$ git reset HEAD^<span class="hljs-comment"># 拣选补丁块</span>$ git add -p<span class="hljs-comment"># 对拣选出的补丁块进行提交</span>$ git add -u$ git commit</code></pre><p>如果要拆分的提交，不同的实现逻辑耦合在一起，难以通过补丁块拣选（<code>git add -p</code>）的方式修改提交，此时可以直接编辑文件，删除要剥离出此次提交的修改，然后执行下面命令：</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 追加提交剥离后的修改</span>$ git commit -a --amend<span class="hljs-comment"># 还原上次提交前文件的修改</span>$ git checkout HEAD@&#123;1&#125; -- .<span class="hljs-comment"># 提交文件</span>$ git commit</code></pre><ul><li>拆分历史提交</li></ul><pre class="highlight"><code class="bash"><span class="hljs-comment"># 先对历史提交进行变基</span>$ git rebase -i commitId^<span class="hljs-comment"># 在打开的编辑器(如 vi 编辑器)中修改关键字 pick 为 edit</span>-----------------------------------------pick commitId 要拆分的提交pick ...   其他参与变基的提交-----------------------------------------||VV-----------------------------------------edit commitId 要拆分的提交pick ...   其他参与变基的提交-----------------------------------------<span class="hljs-comment"># 保存文件退出，变基开始</span><span class="hljs-comment"># 首先会在 commitId 处停下来，此时要拆分的提交成为当前提交。后续按照 "拆分当前提交" 进行操作。</span><span class="hljs-comment"># 最后拆分结束后再执行下面命令，完成变基。</span>$ git rebase --<span class="hljs-built_in">continue</span></code></pre><ul><li>修改历史提交</li></ul><p>当想要修改一次历史提交内容时，通过<code>fixup</code> 和变基操作即可实现，步骤如下：</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 直接在当前工作区进行修改，然后提交(-m 选项可以修改历史提交信息)</span>$ git commit -a --fixup commitId [-m]<span class="hljs-comment"># 此时提交历史会增加一个 "fixup!" ,此时可以通过变基 --autosquash 选项对修改进行合并</span>$ git rebase -i -autosquash commitId^<span class="hljs-comment"># git 会在编辑器内对提交进行自动排序，修改关键字 fixup 为 squash</span>-----------------------------------------pick commitId 最近一次的提交fixup commitId fixup 的提交pick ...   其他参与变基的提交-----------------------------------------||VV-----------------------------------------pick commitId 最近一次的提交squash commitId fixup 的提交pick ...   其他参与变基的提交-----------------------------------------<span class="hljs-comment"># 保存文件退出，变基开始</span><span class="hljs-comment"># 自动打开保存消息，保存退出，历史修改成功</span></code></pre><h3 id="删除文件"><a class="markdownIt-Anchor" href="#删除文件"></a> 删除文件</h3><pre class="highlight"><code class="bash">$ git rm　[--cached] 文件名 <span class="hljs-comment">#从版本库中删除文件(--cached从缓存区中移除到工作区)</span>$ git clean [-fd] <span class="hljs-comment"># 清空未跟踪文件(-f 强制清空 -d 递归文件夹清空)</span></code></pre><blockquote><p>GIT删除(git rm)文件后,直接提交(git commit)即可,不需要再添加到暂存区(git add).<br>如果不小心删错了,可以直接撤销修改(git checkout – 文件名)<br>如果文件已经提交到版本库,那么永远不用担心误删,但只能恢复到最新版本库,最新修改将丢失.</p></blockquote><h3 id="文件移动"><a class="markdownIt-Anchor" href="#文件移动"></a> 文件移动</h3><pre class="highlight"><code class="bash">$ git mv file_from file_to <span class="hljs-comment">#重命名文件</span>实际相当于运行下面三个命令$ mv file_from file_to$ git rm file_from$ git add file_to</code></pre><h2 id="远程仓库a-nameh2_remote_orgina"><a class="markdownIt-Anchor" href="#远程仓库a-nameh2_remote_orgina"></a> 远程仓库<a name="h2_remote_orgin"></a></h2><pre class="highlight"><code class="bash">$ git remote add origin 远程仓库地址 <span class="hljs-comment">#关联远程仓库(origin是git远程仓库的默认名,可以修改)</span>$ git push <span class="hljs-comment">#本地内容推送到远程仓库</span></code></pre><blockquote><p>关联后第一次推送仓库的所有内容使用命令:git push -u origin master<br>此后,每次推送本地修改内容可以使用命令:git push origin master</p></blockquote><pre class="highlight"><code class="bash">$ git <span class="hljs-built_in">clone</span> [-b 分支名] 远程仓库地址 <span class="hljs-comment">#克隆远程仓库到本地(-b指定分支)</span>$ git fetch 远程仓库名 <span class="hljs-comment">#从服务器上抓取本地没有的数据，它并不会修改工作目录中的内容, 它只会获取数据然后让你自己合并.</span>$ git pull (--allow-unrelated-histories) <span class="hljs-comment">#从服务器抓取分支数据并然后尝试合并.</span></code></pre><blockquote><p>由于git pull命令经常让人困惑,所以通常单独显式地使用 git fetch 与git merge 命令会更好一些。使用git fetch命令后会返回一个FETCH_HEAD，可以使用git log -p FETCH_HEAD查看详情。</p></blockquote><pre class="highlight"><code class="bash">$ git remote <span class="hljs-comment">#显示远程仓库名</span>$ git ls-remote <span class="hljs-comment">#显示远程引用完整列表</span>$ git remote show [remote-name] <span class="hljs-comment">#查看远程仓库更多信息</span>$ git remote -v <span class="hljs-comment">#显示远程仓库信息</span>origin  git@github.com:WindusL/LearningNotes.git (fetch)origin  git@github.com:WindusL/LearningNotes.git (push)</code></pre><blockquote><p>上面显示了可以抓取和推送的origin地址。如果没有推送权限就看不到push的地址。</p></blockquote><pre class="highlight"><code class="bash">$ git remote rename [oldname] [newname] <span class="hljs-comment">#对远程仓库的简写名称重命名指令</span>$ git remote rm [remote-name] <span class="hljs-comment">#对远程仓库的简写名称进行移除的命令</span></code></pre><h2 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h2><blockquote><p>Git里默认有一个主分支master，其中HEAD严格来说指向的不是提交，而是当前分支，分支才指向提交。</p></blockquote><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/QQ20171118223701.png" alt="指向图"><span class="image-caption">指向图</span></p><blockquote><p>Git创建一个分支只是增加一个指针，然后将HEAD指向新的分支 ，表示在当前分支，工作区的文件没有任何变化。</p></blockquote><pre class="highlight"><code class="bash">$ git branch 分支名 <span class="hljs-comment">#创建分支</span>$ git checkout 分支名 <span class="hljs-comment">#切换分支</span><span class="hljs-comment">#上面两个命令相当于</span>$ git checkout -b 分支名 <span class="hljs-comment">#创建并切换分支(加上-b表示先创建后切换)</span>$ git checkout -b 分支名 远程分支名 <span class="hljs-comment"># 拉取远程分支到本地分支((加上-b表示先创建后切换)</span>$ git branch (-a/r) <span class="hljs-comment">#列出所有本地分支(-a 包括远程分支,-r仅列出远程分支)</span>$ git branch [-v|-vv] <span class="hljs-comment">#查看每个分支最后一次的提交(-vv选项会列表更多信息)</span>$ git branch -d 分支名 <span class="hljs-comment">#删除已合并本地分支</span>$ git branch -D 分支名 <span class="hljs-comment">#强制删除分支(包括未合并的分支)</span>$ git branch [-m|-M] 旧分支名 新分支名 <span class="hljs-comment"># 分支重命名（-M强制生命名）</span>$ git merge 分支名 <span class="hljs-comment">#合并指定分支到当前分支</span>$ git switch [分支名|-] <span class="hljs-comment"># 切换分支，- 表示切换到上一个分支</span>$ git swtitch -c 分支名 <span class="hljs-comment"># 创建一个新分支并切换到该分支</span>$ git switch --detach commitId <span class="hljs-comment"># 切换一个提交到游离状态</span><span class="hljs-comment"># 分支添加注释(注意，这个注释是本地存储的。它不能被推送，因为它存储在.git/config中)</span>$ git config branch.hexo.description 注释内容<span class="hljs-comment"># 修改分支注释</span>$ git branch --edit-description</code></pre><h3 id="重命名远程分支推荐做法"><a class="markdownIt-Anchor" href="#重命名远程分支推荐做法"></a> 重命名远程分支推荐做法:</h3><p>1、删除远程分支</p><p>2、push本地新分支名到远程</p><pre class="highlight"><code class="bash">$ git branch --merged|--no-merged <span class="hljs-comment">#查看已（未）合并的分支</span></code></pre><h3 id="删除选程分支"><a class="markdownIt-Anchor" href="#删除选程分支"></a> 删除选程分支</h3><pre class="highlight"><code class="bash">git branch -dr 分支名　<span class="hljs-comment"># (-r删除远程分支)</span>git push [远程名] :[分支名]</code></pre><h3 id="分支合并忽略指定文件方法"><a class="markdownIt-Anchor" href="#分支合并忽略指定文件方法"></a> 分支合并忽略指定文件方法</h3><pre class="highlight"><code class>第一步：自定义merge driver$ git config --global merge.ours.driver true第二步：在被合并分支下把忽略文件(如test.json)写入项目根目录.gitattributes文件，并提交$ git checkout dev$ echo 'test.json merge=ours' &gt;&gt; .gitattributes  $ git add .gitattributes  $ git commit -m 'chore: Preserve email.json during merges' 第三步：回到要合并分支执行合并操作$ git checkout master$ git merge dev </code></pre><h3 id="分支-变基"><a class="markdownIt-Anchor" href="#分支-变基"></a> 分支-变基</h3><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/basic-rebase-1.png" alt="分叉的提交历史"><span class="image-caption">分叉的提交历史</span></p><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/basic-rebase-2.png" alt="merge 后的提交历史"><span class="image-caption">merge 后的提交历史</span></p><p>分支合并会产生记录,如果想不产生这些记录就可以使用分支变基后再合并.</p><pre class="highlight"><code class="bash">$ git rebase 分支名 <span class="hljs-comment">#把当前分支变基到指定分支</span><span class="hljs-comment">#第一步：切换到要变基的分支进行变基</span>$ git checkout experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged <span class="hljs-built_in">command</span></code></pre><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/basic-rebase-3.png" alt="变基后的提交历史"><span class="image-caption">变基后的提交历史</span></p><pre class="highlight"><code class="bash"><span class="hljs-comment">#第二步：回到合并分支进行合并</span>$ git checkout master$ git merge experiment</code></pre><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/basic-rebase-4.png" alt="变基后合并的提交历史"><span class="image-caption">变基后合并的提交历史</span></p><blockquote><p>变基注意事项:<br>只在从未推送至共用仓库的提交上执行变基命令。如果真的在远程仓库进行了变基产生了混乱，可以使用 git pull --rebase 命令将分支变基到远程仓库再进行合并。</p></blockquote><p>变基的另一种场景是，假如从 <code>master</code> 分支创建一个新的分支<code>server</code>，提交了 <code>C3</code> 和 <code>C4</code>。 然后从 <code>C3</code> 上创建了分支 <code>client</code>，为客户端添加了一些功能，提交了 <code>C8</code> 和 <code>C9</code>。 最后，回到 <code>server</code> 分支，又提交了 <code>C10</code>。</p><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/interesting-rebase-1.png" alt="变基前提交历史"><span class="image-caption">变基前提交历史</span></p><p>此时希望将 <code>client</code> 中的修改合并到<code>master</code>分支并发布，但暂时并不想合并 <code>server</code> 中的修改， 因为它们还需要经过更全面的测试。</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 使用 --onto 选项：取出 client 分支，找出它与 server 分支分歧之后的补丁，然后把这些补丁在 master 分支上重放一遍。</span>git rebase --onto master server client</code></pre><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/interesting-rebase-2.png" alt="变基后提交历史"><span class="image-caption">变基后提交历史</span></p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 切换到 master 分支</span>git checkout master <span class="hljs-comment"># 合并 bug 分支</span>git merge client</code></pre><p><img src="/2018/03/29/GIT/GIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/interesting-rebase-3.png" alt="合并后提交历史"><span class="image-caption">合并后提交历史</span></p><h2 id="分支管理策略"><a class="markdownIt-Anchor" href="#分支管理策略"></a> 分支管理策略</h2><blockquote><p>通常，合并分支，如果可能Git会用Fast Forward模式，但这种模式下，删除分支后，会丢掉分支信息。<br>如果强制禁用Fast Forward模式，Git会在merge时生成一个新的commit，这样从分支历史上就可以看出分支信息。</p></blockquote><pre class="highlight"><code class="bash">$ git merge --no-ff -m 注释 分支名 <span class="hljs-comment">#合并分支(--no-ff表示禁用Fast Forward模式，因为要生成一个新的commit所以要加上-m注释参数)</span></code></pre><h3 id="bug分支"><a class="markdownIt-Anchor" href="#bug分支"></a> Bug分支</h3><blockquote><p>当一个分支的工作还没有做完，不能提交，而此时又要及时做其它工作时，可以先把工作区储藏起来,创建bug分支(命名:fixbug-issueId)。</p></blockquote><pre class="highlight"><code class="bash">$ git stash <span class="hljs-comment">#储藏工作区(储藏后再用git status查看就是干净的, 除非是没有被git管理的文件)</span>$ git stash save (--keep-index|-u|--patch)注释 <span class="hljs-comment">#储藏工作区并添加注释</span>(--keep-index <span class="hljs-comment">#不储藏任何通过 git add 命令已暂存的;</span>-u <span class="hljs-comment">#储藏任何创建的未跟踪文件</span>--patch <span class="hljs-comment">#不会储藏所有修改过的任何东西，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中。</span>)$ git stash list <span class="hljs-comment">#查看stash列表</span>$ git stash apply <span class="hljs-comment">#恢复stash，但stash不删除</span>$ git stash pop <span class="hljs-comment">#恢复stash，同时删除stash</span>$ git stash drop <span class="hljs-comment">#移除stash (会删除储存所有修改,谨慎使用)</span>$ git stash show (-p/--patch) <span class="hljs-comment">#查看stash(详细)修改</span></code></pre><blockquote><p>如果多次执行stash后，恢复stash就加上stash名，如：git stash pop/apply stash@{0}<br>默认情况,stash不会存储Untracked files.如果想要存储,要先git add添加到版本库或者使用git stash -u选项,如下:</p></blockquote><pre class="highlight"><code class="bash">git stash -u (--include-untracked) <span class="hljs-comment"># 存储工作空间包括Untracked files</span></code></pre><h3 id="feature分支"><a class="markdownIt-Anchor" href="#feature分支"></a> Feature分支</h3><blockquote><p>开发新功能时最好创建一个新的分支(命名:feature-x)。</p></blockquote><h3 id="预发布分支"><a class="markdownIt-Anchor" href="#预发布分支"></a> 预发布分支</h3><blockquote><p>发布正式版本之前（即合并到 Master 分支之前），我们可能需要有一个预发布的版本进行测试(命名:release-版本号)。</p></blockquote><h3 id="推送分支a-hrefh2_remote_orgin同远程仓库a"><a class="markdownIt-Anchor" href="#推送分支a-hrefh2_remote_orgin同远程仓库a"></a> 推送分支(<a href="#h2_remote_orgin">同远程仓库</a>)</h3><pre class="highlight"><code class="bash">$ git push origin 分支名 <span class="hljs-comment">#推送分支到远程仓库</span></code></pre><h3 id="跟踪分支"><a class="markdownIt-Anchor" href="#跟踪分支"></a> 跟踪分支</h3><blockquote><p>从一个远程分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。 <br>跟踪分支是与远程分支有直接关系的本地分支,Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p></blockquote><pre class="highlight"><code class="bash"><span class="hljs-comment">#设置跟踪分支(将本地分支与远程库分支时行连接。)</span>$ git branch --<span class="hljs-built_in">set</span>-upstream origin 分支名 <span class="hljs-comment">#最新版本已被废弃</span><span class="hljs-comment">#最新版本命令</span>$ git branch --<span class="hljs-built_in">set</span>-upstream-to=origin/&lt;branch&gt; 分支名 (可简写为 -u)<span class="hljs-comment">#取消跟踪远程分支</span>$ git branch --<span class="hljs-built_in">unset</span>-upstream 分支名</code></pre><h3 id="多人协作"><a class="markdownIt-Anchor" href="#多人协作"></a> 多人协作</h3><blockquote><p>当从远程仓库克隆时，Git自动把本地master分支和远程分支对应起来。并且远程分为默认名是origin。</p></blockquote><p>多人协作的工作模式：<br>1.试图推送分支。<br>2.推送失败则要先抓取远程分支，试图合并。<br>3.合并有冲突，则解决冲突，并在本地提交。<br>4.没有冲突或解决掉了冲突，再推送到远程分支。</p><h2 id="标签管理"><a class="markdownIt-Anchor" href="#标签管理"></a> 标签管理</h2><blockquote><p>发布新版本时，通常在版本库打一个标签，来确定打标签时刻的版本。将来无论什么时候，取某个标签的版本就是那个打标签时候的历史版本。所以，标签也相当于版本库的一个快照。<br>Git标签虽然是版本库的快照，但其实就是一个指向commit的指针（与分支类似，但分支可以移动，但标签不能移动）。所以，创建标签也是瞬间完成的。</p></blockquote><pre class="highlight"><code class="bash">$ git tag <span class="hljs-comment">#查看所有标签</span>$ git tag -l <span class="hljs-comment"># 用特定的搜索模式列出符合条件的标签</span><span class="hljs-comment">#指搜索1.4.2系统标签</span>$ git tag -l <span class="hljs-string">'v1.4.2.*'</span>v1.4.2.1v1.4.2.2v1.4.2.3v1.4.2.4$ git tag 标签名 <span class="hljs-comment">#打标签(轻量标签，指向提交对象的引用)</span>$ git tag 标签名 commitId <span class="hljs-comment">#给指定commit打标签</span>$ git tag -a 标签名 -m 注释 commitId <span class="hljs-comment">#创建带有说明的标签(附注标签，仓库中的一个独立对象，一般建议打附注标签)</span>$ git tag -n&lt;num&gt; <span class="hljs-comment">#显示&lt;num&gt;行标签显示注释</span>$ git tag -n2v1.4.2.1　注释内容v1.4.2.2　注释内容v1.4.2.3v1.4.2.4$ git tag -d 标签名 <span class="hljs-comment">#删除标签</span></code></pre><blockquote><p>还可以通过-s用私钥签名一个标签,采用PGP签名必须先安装gpg</p></blockquote><pre class="highlight"><code class="bash">$ git tag -s 标签名 -m 注释 commitId</code></pre><h3 id="推送远程标签"><a class="markdownIt-Anchor" href="#推送远程标签"></a> 推送远程标签</h3><pre class="highlight"><code class="bash">$ git push origin 标签名 <span class="hljs-comment">#推送指定标签到远程仓库</span>$ git push origin --tags <span class="hljs-comment">#推送全部尚未推送到远程仓库的标签</span></code></pre><h3 id="删除远程标签"><a class="markdownIt-Anchor" href="#删除远程标签"></a> 删除远程标签</h3><pre class="highlight"><code class="bash">$ git tag -d 标签名 <span class="hljs-comment">#先删除本地标签</span>$ git push origin :refs/tags/标签名 <span class="hljs-comment">#然后删除远程标签</span></code></pre><h3 id="检出标签"><a class="markdownIt-Anchor" href="#检出标签"></a> 检出标签</h3><pre class="highlight"><code class="bash"><span class="hljs-comment">#在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。</span><span class="hljs-comment">#如果你想要工作目录与仓库中特定的标签版本完全一样，可以使在特定的标签上创建一个新分支：</span>语法:git checkout -b [branchname] [tagname]</code></pre><h2 id="子模块"><a class="markdownIt-Anchor" href="#子模块"></a> 子模块</h2><p>当项目中使用第三方或独立开发的代码库时，可以通过<code>Git</code>子模块来解决。子模块允许你将一个Git仓库作了另一个Git仓库的子目录并保持提交的独立。</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 添加指定远程仓为子模块</span>git submodule add &lt;仓库URL&gt; [可选&lt;子模块目录名&gt;]</code></pre><p>添加子模块后,会在项目根目录出现一个<code>.gitmodules</code>文件,内容如下:</p><pre class="highlight"><code class="bash">$ cat .gitmodules[submodule <span class="hljs-string">"XXX"</span>]path = DbConnectorurl = https://github.com/XXX/XXX</code></pre><p>虽然子模块是仓库中的子目录,但当不在子模块目录中时,Git不会跟踪它的内容,而是将它看成作仓库中的一个特殊提交。</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 设设使用diff、status等命时显示子模块的摘要内容</span>git config status.submodulesummary 1<span class="hljs-comment"># 查看子模块的差异输出</span>git diff --submoudle</code></pre><p>克隆含有子模块的库时，默认会包含子模块目录，但目录中是空的。可以通过两种方式加载子模块：</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 方法一：--recursive 选项</span>git <span class="hljs-built_in">clone</span> --recursive &lt;仓库URL&gt; <span class="hljs-comment"># 方法二：</span>git submodule init <span class="hljs-comment"># 初始化本地配置文件</span>git submodule update <span class="hljs-comment"># 克隆子模块</span></code></pre><p>当项目中仅仅是使用子模块，而不修改子模块的前提下，可以通过两种方式拉取最新子模块：</p><pre class="highlight"><code class="bash">方法一：    git submodule update --remote [可选&lt;子模块名字&gt;]    方法二：    进入子模块目录通过git fetch 和 git merge命令</code></pre><p>子模块更新默认拉取<code>master</code>分支，可以通过配置<code>.gitmodules</code>或<code>.git/config</code>文件修改拉取的分支：</p><pre class="highlight"><code class="bash">git config [可选&lt;-f .gitmodules&gt;] submodule.&lt;子模块名&gt;.branch &lt;分支名&gt;<span class="hljs-comment"># 如果不加 -f .gitmodules 选项，那么配置不会写入.gitmodules中，那么它只会为你做修改</span>，其他人不会接收到相应的改变。</code></pre><p>从子模块仓库中抓取修改时，<code>Git</code>将会获得这些改动并更新子目录中的文件，但是会将子仓库留在一个称作 “游离的 HEAD” 的状态。 这意味着没有本地工作分支（例如 “master”）跟踪改动, 所以你做的任何改动都不会被跟踪。为了将子模块设置得更容易进入并修改，需要进入每个子模块并检出其相应的工作分支，然后通过<code>--merge</code>选项将改动合并到分支。</p><pre class="highlight"><code class="bash">git submodule update --remote --merge<span class="hljs-comment"># 如果忘记加　--merge　选项，Git 会将子模块更新为服务器上的状态。并且会将项目重置为一个游离的 HEAD 状态。此时只需重新检出工作分支，并手动合并改动即可。</span></code></pre><p>在主项目中提交并推送，而不推送子模块上的改动，其他人检出时因为无法获取相应依赖而出现问题。所以在推送主项目时增加<code>--recurse-submodules=checked</code>参数来检查，如果子模块改动没有推送则主项目<code>push</code>将失败。</p><pre class="highlight"><code class="bash">$ git push --recurse-submodules=checkThe following submodule paths contain changes that cannot be found on any remote:        XXX    Please trygit push --recurse-submodules=on-demandor <span class="hljs-built_in">cd</span> to the path and usegit pushto push them to a remote.<span class="hljs-comment"># 根据提示信息可以通过 --recurse-submodules=on-demand 选项，或进入子模块目录进行 push 两种方法进行推送子模块。</span></code></pre><p>在主项目中可以使用<code>foreach</code>子模块遍历命来批量处理子模块，如批量切换分支：</p><pre class="highlight"><code class="bash">$ git submodule foreach <span class="hljs-string">'git stash'</span>$ git submodule foreach <span class="hljs-string">'git checkout -b 分支名'</span></code></pre><p>如果项目内有一些文件在子目录中，想要将其转换为一个子模块。可以如下做：</p><pre class="highlight"><code class="bash">$ git rm -r &lt;目录名&gt;$ git submodule add &lt;模块仓库URL&gt;<span class="hljs-comment"># 注意，切记不要使用 rm 删除目录，否则添加子模块时会报错。</span><span class="hljs-comment"># 添加子模块提示已存在时，但工作空间内不存在此目录时，可能是之前子模块删除不彻底。可以检查`.git/modules`目录是否存在模块，将其删除。</span></code></pre><p>此外，当创建一个新分支，在其中添加一个子模块，之后切换到没有该子模块的分支上时，仍然会有一个还未跟踪的子模块目录。可以选则删除那个目录，但当切换那个回含有子模块的分支后，需要重新运行<code>submodule update --init</code>来建立和填充。</p><h2 id="git工具"><a class="markdownIt-Anchor" href="#git工具"></a> GIT工具</h2><h3 id="日志"><a class="markdownIt-Anchor" href="#日志"></a> 日志</h3><pre class="highlight"><code class="bash">$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span> <span class="hljs-comment">#显示在每个提交(commit)中哪些文件被修改了</span>$ git <span class="hljs-built_in">log</span> -p <span class="hljs-comment">#显示每次提交的内容差异</span>$ git <span class="hljs-built_in">log</span> -n <span class="hljs-comment">#显示最近几条日志</span>$ git <span class="hljs-built_in">log</span> --pretty=oneline|format$ git <span class="hljs-built_in">log</span> --graph <span class="hljs-comment">#展示分支、合并历史</span>$ git <span class="hljs-built_in">log</span> --author <span class="hljs-comment">#仅显示指定作者相关的提交。</span>$ git <span class="hljs-built_in">log</span> --committer <span class="hljs-comment">#仅显示指定提交者相关的提交。</span>$ git <span class="hljs-built_in">log</span> --grep <span class="hljs-comment">#仅显示含指定关键字的提交</span>$ git <span class="hljs-built_in">log</span> 文件名 <span class="hljs-comment">#仅显示指定文件提交历史</span></code></pre><h3 id="日志搜索"><a class="markdownIt-Anchor" href="#日志搜索"></a> 日志搜索</h3><pre class="highlight"><code class="bash">git <span class="hljs-built_in">log</span>-S 字符串 <span class="hljs-comment">#显示新增和删除该字符串的提交</span>-G 相对于-S更精准,使用正则表达式搜索-L 展示代码中一行或者一个函数的历史<span class="hljs-comment">#找到 ZLIB_BUF_MAX 常量是什么时候引入的</span>$ git <span class="hljs-built_in">log</span> -SZLIB_BUF_MAX --onelinee01503b zlib: allow feeding more than 4GB <span class="hljs-keyword">in</span> one goef49a7a zlib: zlib can only process 4GB at a time<span class="hljs-comment">#查看 zlib.c 文件中`git_deflate_bound` 函数的每一次变更</span>$ git <span class="hljs-built_in">log</span> -L :git_deflate_bound:zlib.c</code></pre><h3 id="提交区间"><a class="markdownIt-Anchor" href="#提交区间"></a> 提交区间</h3><pre class="highlight"><code class="bash">1. 双点语法(..)$ git <span class="hljs-built_in">log</span> master..dev <span class="hljs-comment">#比对dev还没提交到master分支的记录</span>$ git <span class="hljs-built_in">log</span> origin/master..HEAD <span class="hljs-comment">#输出在你当前分支中而不在远程 origin 中的提交(如果留空了其中的一边， Git 会默认为 HEAD)</span>2. 多点语法(^ 或 --not)$ git <span class="hljs-built_in">log</span> refA refB ^refC <span class="hljs-comment">#查看所有被 refA 或 refB 包含的但是不被 refC 包含的提交</span>$ git <span class="hljs-built_in">log</span> refA refB --not refC3. 三点语法(...)语法可以选择出被两个引用中的一个包含但又不被两者同时包含的提交$ git <span class="hljs-built_in">log</span> master...experiment <span class="hljs-comment">#看 master 或者 experiment 中包含的但不是两者共有的提交</span>$ git <span class="hljs-built_in">log</span> --left-right master...experiment(--left-right显示是哪边分支的提交 <span class="hljs-string">"&gt;"</span> 或 <span class="hljs-string">"&lt;"</span>)</code></pre><h3 id="git-show"><a class="markdownIt-Anchor" href="#git-show"></a> git show</h3><p>显示标签、commitId等对象的信息</p><pre class="highlight"><code class="bash">git show 标签名 <span class="hljs-comment">#查看标签信息</span>git show (--<span class="hljs-built_in">stat</span>) commitId <span class="hljs-comment">#查看指定提交的详细信息(--stat只查看变动文件)</span></code></pre><h3 id="比较-git-diff"><a class="markdownIt-Anchor" href="#比较-git-diff"></a> 比较 git diff</h3><pre class="highlight"><code class="bash">git diff &lt;filename&gt;<span class="hljs-comment">#比较工作区与暂存区的差异  </span>git diff --cached (&lt;commitId&gt;) &lt;filename&gt; <span class="hljs-comment">#比较暂存区与上次(/指定commitId)提交的差异</span>git diff HEAD/commitId &lt;filename&gt; <span class="hljs-comment">#比较工作区与(上次/指定commitId)提交的差异</span>git diff commitId commitId <span class="hljs-comment">#比较Git仓库任意两次 commit 之间的差别</span>git diff --<span class="hljs-built_in">stat</span> <span class="hljs-comment">#比较统计(如几处删除,几处增加等等)</span>git diff 本地分支 origin/远程分支 <span class="hljs-comment">#与远程库比对(比对前需先执行git fetch)</span></code></pre><h3 id="交互式暂存"><a class="markdownIt-Anchor" href="#交互式暂存"></a> 交互式暂存</h3><p>修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交.</p><pre class="highlight"><code class="bash">$ git add -i <span class="hljs-comment">#进入交互终端</span>$ git add -p(--patch) <span class="hljs-comment">#Git暂存文件的特定部分(文件中做了两处修改，但只想要暂存其中的一个)</span></code></pre><h3 id="清理-git-clean"><a class="markdownIt-Anchor" href="#清理-git-clean"></a> 清理 git clean</h3><p>需要谨慎地使用这个命令，因为它被设计为从工作目录中移除没有忽略的未跟踪文件(任何与 .gitiignore 或其他忽略文件中的模式匹配的文件都不会被移除),可能无法再找回.</p><pre class="highlight"><code class="bash">git clean -f 表示强制清理-d 后面接要清理的目录-n 演习删除,显示将要删除的内容-x 完全干净删除</code></pre><h3 id="搜索-git-grep"><a class="markdownIt-Anchor" href="#搜索-git-grep"></a> 搜索 git grep</h3><p>从提交历史或者工作目录中查找一个字符串或者正则表达式.</p><pre class="highlight"><code class="bash">git grep-n 输出内容所在文件的行号 --count 输出内容所在文件的数量</code></pre><h3 id="忽略文件"><a class="markdownIt-Anchor" href="#忽略文件"></a> 忽略文件</h3><p>一般情况,可以使用.gitignore文件添加忽略文件.如果当前文件是已经commit ,push到远程仓库后了，.gitignore里面再配置是不起作用了.此时解决办法有两种:</p><p>一种方法是移除文件跟踪,然后将文件添加到.gitignore文件中去(此种方法对其他人影响较大).<br>另一种方法是仅在自己本地忽略:</p><pre class="highlight"><code class="bash">$ git update-index --assume-unchanged 文件名 <span class="hljs-comment">#忽略文件</span>$ git update-index --no-assume-unchanged 文件名 <span class="hljs-comment">#取消忽略文件</span>$ git ls-files -v | grep ^h｜^S\&lt;space&gt; <span class="hljs-comment">#显示本地（--assume-unchanged|--skip-worktree）忽略文件列表(&lt;space&gt; 是表示空格)</span><span class="hljs-comment"># 通过awk实现批量文件操作</span>$ git status | grep <span class="hljs-string">'modified'</span> | awk <span class="hljs-string">'&#123;print $2&#125;'</span> |xargs git update-index --assume-unchanged <span class="hljs-comment">#指添加忽略文件</span>$ git ls-files -v | grep <span class="hljs-string">'^h'</span> | awk <span class="hljs-string">'&#123;print $2&#125;'</span> |xargs git update-index --no-assume-unchanged <span class="hljs-comment">#批量取消忽略文件</span>更多信息使用 --<span class="hljs-built_in">help</span> 自行查阅</code></pre><blockquote><p>–assume-unchanged与–skip-worktree 的区别<br>前者 忽略更改文件,当索引中文件条目变化时则失效（即，此文件变化自上游）<br>后者 忽略更改文件,索引中文件条目变化仍起作用(直至此索引被放弃)</p></blockquote><h3 id="命令自动补全"><a class="markdownIt-Anchor" href="#命令自动补全"></a> 命令自动补全</h3><ul><li>第一步 下载git官方提供的自动补全git-completion.bash脚本到自己的家目录并重命名为.git-completion.bash</li></ul><pre class="highlight"><code class="bash">curl https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash -o ~/.git-completion.bash</code></pre><ul><li>第二步 将下载的脚本添加到~/.bash_profile文件</li></ul><pre class="highlight"><code class="bash"><span class="hljs-keyword">if</span> [ -f ~/.git-completion.bash ]; <span class="hljs-keyword">then</span> . ~/.git-completion.bash <span class="hljs-keyword">fi</span> <span class="hljs-comment"># . 符号可以换成source</span></code></pre><ul><li>第三步 编译~/.bash_profile使其立即生效</li></ul><pre class="highlight"><code class="bash"><span class="hljs-built_in">source</span> ~/.bash_profile</code></pre><h2 id="常见问题"><a class="markdownIt-Anchor" href="#常见问题"></a> 常见问题</h2><h3 id="中文文件名编码问题"><a class="markdownIt-Anchor" href="#中文文件名编码问题"></a> 中文文件名编码问题</h3><p>在默认设置下，中文文件名在工作区状态输出，中文名不能正确显示，而是显示为八进制的字符编码。</p><pre class="highlight"><code class>#解决方法：git config --global core.quotepath false</code></pre><h3 id="httphttps方式免密操作"><a class="markdownIt-Anchor" href="#httphttps方式免密操作"></a> HTTP/HTTPS方式免密操作</h3><p>通常ssh方式可以通过ssh密钥方法免密，HTTP方式需要通过GIT自带凭证系统来实现</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 配置存储模式</span>git config --global credential.helper 模式</code></pre><ul><li><p><code>cache</code> 模式会将凭证存放在内存中一段时间。 密码永远不会被存储在磁盘中，并且在15分钟后从内存中清除。</p></li><li><p><code>store</code> 模式会将凭证用明文的形式存放在磁盘中，并且永不过期。存放位置为home目录下的<code>.git-credentials</code>文件中。</p></li><li><p><code>osxkeychain</code> 模式会将凭证缓存到你系统用户的钥匙串中。 这种方式将凭证存放在磁盘中，并且永不过期，但是是被加密的，这种加密方式与存放 HTTPS 凭证以及 Safari 的自动填写是相同的，此种模式只有mac系统中才能使用。</p></li><li><p><code>winstore</code> 辅助工具 和上面的 <code>osxkeychain</code> 十分类似，但是是使用 <code>Windows Credential Store</code> 来控制敏感信息，需要在Windows系统中<a href="https://gitcredentialstore.codeplex.com">下载</a>安装。</p></li></ul><h3 id="换行符问题"><a class="markdownIt-Anchor" href="#换行符问题"></a> 换行符问题</h3><p>由于不同系统的换行符不相同，所以导致git比较文件时混乱，可以通过设置<code>core.autocrlf</code>和<code>core.safecrlf</code>来解决此问题。</p><p><code>core.autocrlf</code>选项:</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 提交时转换为LF，检出时转换为CRLF</span>git config --global core.autocrlf <span class="hljs-literal">true</span>   <span class="hljs-comment"># 提交时转换为LF，检出时不转换</span>git config --global core.autocrlf input   <span class="hljs-comment"># 提交检出均不转换</span>git config --global core.autocrlf <span class="hljs-literal">false</span></code></pre><p><code>core.safecrlf</code>选项:</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 拒绝提交包含混合换行符的文件</span>git config --global core.safecrlf <span class="hljs-literal">true</span>   <span class="hljs-comment"># 允许提交包含混合换行符的文件</span>git config --global core.safecrlf <span class="hljs-literal">false</span>   <span class="hljs-comment"># 提交包含混合换行符的文件时给出警告</span>git config --global core.safecrlf warn</code></pre><h3 id="文件名大小写问题"><a class="markdownIt-Anchor" href="#文件名大小写问题"></a> 文件名大小写问题</h3><p>Git 默认对文件名大小写不敏感，导致更改文件名为小写或大写后，使用<code>git status</code>无法发现修改，可以使用<code>core.ignorecase</code>配置是否忽略大小写敏感。</p><pre class="highlight"><code class="git">git config --global core.ignorecase false</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> GIT </tag>
            
            <tag> GIT学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim编辑器</title>
      <link href="2018/03/27/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8/"/>
      <url>2018/03/27/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="vi编辑器的模式"><a class="markdownIt-Anchor" href="#vi编辑器的模式"></a> vi编辑器的模式</h2><h3 id="一般指令模式"><a class="markdownIt-Anchor" href="#一般指令模式"></a> 一般指令模式</h3><p>用vi 打开一个文件就直接进入一般指令模式,在一般指令模式中可以进行删除、复制、贴上等等的动作.</p><span id="more"></span><ul><li>移动光标方法</li></ul><hr><table><thead><tr><th style="text-align:center">按键</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">h（←）</td><td>向左移动一个字符</td></tr><tr><td style="text-align:center">j（↓）</td><td>向下移动一个字符</td></tr><tr><td style="text-align:center">k（↑）</td><td>向上移动一个字符</td></tr><tr><td style="text-align:center">l（→）</td><td>向右移动一个字符</td></tr><tr><td style="text-align:center">Ctrl+f</td><td>屏幕向下移动一页[PageDown]</td></tr><tr><td style="text-align:center">Ctrl+b</td><td>屏幕向上移动一页[PageUp]</td></tr><tr><td style="text-align:center">Ctrl+d</td><td>屏幕向下移动半页</td></tr><tr><td style="text-align:center">Ctrl+u</td><td>屏幕向上移动半页</td></tr><tr><td style="text-align:center">+</td><td>光标移动到非空白字符的下一行</td></tr><tr><td style="text-align:center">-</td><td>光标移动到非空白字符的上一行</td></tr><tr><td style="text-align:center">n<space></space></td><td>按下数字再按空格键向后移动n个字符</td></tr><tr><td style="text-align:center">0</td><td>移动到当前行最前字符处</td></tr><tr><td style="text-align:center">$</td><td>移动到当前行最后字符处</td></tr><tr><td style="text-align:center">H</td><td>移动到屏幕最上行</td></tr><tr><td style="text-align:center">M</td><td>移动到屏幕中央一行</td></tr><tr><td style="text-align:center">L</td><td>移动到屏幕最下行</td></tr><tr><td style="text-align:center">G</td><td>移动到文件最后一行</td></tr><tr><td style="text-align:center">nG</td><td>移动到第n行</td></tr><tr><td style="text-align:center">gg</td><td>移动到文件第一行(相当于1G)</td></tr><tr><td style="text-align:center">n[Enter]</td><td>向下移动n行</td></tr></tbody></table><ul><li>搜寻与取代</li></ul><hr><table><thead><tr><th style="text-align:center">按键</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">/word</td><td>向下搜索字符串</td></tr><tr><td style="text-align:center">?word</td><td>向上搜索字符串</td></tr><tr><td style="text-align:center">n</td><td>重复上面搜索动作</td></tr><tr><td style="text-align:center">N</td><td>反向重复上面搜索动作</td></tr><tr><td style="text-align:center">:n1,n2s/word1/word2/g</td><td>在n1到n2行之间寻找word1字符串,  并将该字符串取代为word2(n2可以换成$  表示到最后一行)</td></tr><tr><td style="text-align:center">:n1,n2s/word1/word2/gc</td><td>与上面区别在于替换前加入提示(c–&gt;confirm)</td></tr></tbody></table><ul><li>删除/复制/粘贴</li></ul><hr><table><thead><tr><th style="text-align:center">按键</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">x,X</td><td>x向后删除(剪切)一个字符;X向前删除(剪切)一个字符</td></tr><tr><td style="text-align:center">nx/X</td><td>连续向后 / 向前删除(剪切)n个字符</td></tr><tr><td style="text-align:center">dd</td><td>删除(剪切)当前行</td></tr><tr><td style="text-align:center">ndd</td><td>向下删除(剪切)n行</td></tr><tr><td style="text-align:center">d1G</td><td>删除(剪切)光标所在行到第一行的所有数据</td></tr><tr><td style="text-align:center">dG</td><td>删除(剪切)光标所在行到最后一行的所有数据</td></tr><tr><td style="text-align:center">d$</td><td>删除(剪切)该行光标所在行到最后一个字符</td></tr><tr><td style="text-align:center">d0</td><td>删除(剪切)该行光标所在行到第一个字符</td></tr><tr><td style="text-align:center">yy</td><td>复制光标所在行</td></tr><tr><td style="text-align:center">nyy</td><td>向下复制n行</td></tr><tr><td style="text-align:center">y1G</td><td>复制光标所在行到第一行的所有数据</td></tr><tr><td style="text-align:center">yG</td><td>复制光标所在行到最后一行的所有数据</td></tr><tr><td style="text-align:center">y0</td><td>复制该行光标所在行到最后一个字符</td></tr><tr><td style="text-align:center">y$</td><td>复制该行光标所在行到第一个字符</td></tr><tr><td style="text-align:center">p,P</td><td>p已复制数据在光标下一行粘贴;P已复制数据在光标上一行粘贴</td></tr><tr><td style="text-align:center">J</td><td>光标所在行与下一行合并成一行</td></tr><tr><td style="text-align:center">c</td><td>重复删除多个数据</td></tr><tr><td style="text-align:center">u</td><td>复原前一个动作</td></tr><tr><td style="text-align:center">Ctrl+r</td><td>还原u命令之前动作</td></tr><tr><td style="text-align:center">.</td><td>重复上一个动作</td></tr></tbody></table><h3 id="编辑模式"><a class="markdownIt-Anchor" href="#编辑模式"></a> 编辑模式</h3><p>一般指令模式下,按<code>i</code>、<code>I</code>、<code>o</code>、<code>O</code>、<code>a</code>、<code>A</code>、<code>r</code>、<code>R</code>等任意一个字母后进入编辑模式. <strong>按<code>Esc</code>返回一般模式.</strong></p><table><thead><tr><th style="text-align:center">按键</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">i,I</td><td>进入插入模式（Insert mode）： i 为“从目前光标所在处插入”， I 为“在目前所在行的第一个非空白字符处开始插入”。</td></tr><tr><td style="text-align:center">a,A</td><td>进入插入模式（Insert mode）：a 为“从目前光标所在的下一个字符处开始插入”， A 为“从光标所在行的最后一个字符处开始插入”。</td></tr><tr><td style="text-align:center">o,O</td><td>进入插入模式（Insert mode）：这是英文字母 o 的大小写。o 为“在目前光标所在的下一行处插入新的一行”； O 为在目前光标所在处的上一行插入新的一行！</td></tr><tr><td style="text-align:center">r,R</td><td>进入取代模式（Replace mode）：r只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，  直到按下 ESC 为止；</td></tr></tbody></table><h3 id="命令行模式"><a class="markdownIt-Anchor" href="#命令行模式"></a> 命令行模式</h3><p>一般模式下输入<code>/</code>、<code>?</code>、<code>:</code>任意一个符号即可进入到引模式. <strong>按<code>Esc</code>返回一般模式.</strong></p><table><thead><tr><th style="text-align:center">按键</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">:w</td><td>将编辑数据写入文件</td></tr><tr><td style="text-align:center">:w!</td><td>将编辑文件强制写入文件(具体与权限有关)</td></tr><tr><td style="text-align:center">:q</td><td>离开vim</td></tr><tr><td style="text-align:center">:q!</td><td>不存储编辑数据,强制离开vim</td></tr><tr><td style="text-align:center">:wq</td><td>保存编辑数据并离开vim</td></tr><tr><td style="text-align:center">ZZ</td><td>大写Z,若文件没有修改则不存储离开;若文件有修改,则存储后离开</td></tr><tr><td style="text-align:center">:w [filename]</td><td>将编辑数据存储为另一个新文件</td></tr><tr><td style="text-align:center">:r [filename]</td><td>在编辑数据中读入另一个文件的数据.亦将filename文件内容加到光标所在行的后面.</td></tr><tr><td style="text-align:center">:n1,n2 w [filename]</td><td>将n1到n2行的数据存储为另一个新文件</td></tr><tr><td style="text-align:center">:! command</td><td>暂时离开vim到命令行执行commd命令</td></tr><tr><td style="text-align:center">:set</td><td>vim环境变更指令.如: :set nu显示行号; :set nonu取消行号</td></tr></tbody></table><blockquote><p>一般指令模式可与编辑模式及命令行界面切换， 但编辑模式与命令行界面之间不可相互切换.</p></blockquote><h2 id="vim-暂存盘"><a class="markdownIt-Anchor" href="#vim-暂存盘"></a> vim 暂存盘</h2><p>在使用vim编辑器时,vim会在与被编辑文件目录创建一个名为<strong>filename.swap</strong>的暂存文件,你对编辑的文件所有动作都会记录到这个文件内.如果vim的文件被不正常中断,导致暂存盘无法借由正常流程结束,所以暂存盘就不会消失.再次打开此文件时,vim会主动判断这个文件可能有的问题:</p><ul><li><p>可能其它人或程序在同时编辑这个文件<br>由于 Linux 是多用户多任务的环境，因此很可能有很多人同时在编辑同一个文件。如果在多人共同编辑的情况下， 万一大家同时储存，那么这个文件的内容将会变的乱七八糟！为了避免这个问题，因此 vim 会出现这个警告窗口！</p></li><li><p>在上次vim编辑过程中可能由于未知原因导致vim中断</p></li></ul><p>在发现暂存盘后,会出现警告信息页面,有六个按钮可供操作,说明如下:</p><ul><li>（O）pen Read-Only 打开此文件成为只读文件，可以用在你只是想要查阅该文件内容并不想要进行编辑行为时。</li><li>（E）dit anyway：还是用正常的方式打开你要编辑的那个文件， 并不会载入暂存盘的内容。不过很容易出现两个使用者互相改变对方的文件等问题！</li><li>（R）ecover：就是载入暂存盘的内容，用在你要救回之前未储存的工作。 不过当你救回来并且储存离开 vim 后，还是要手动自行删除那个暂存盘喔！</li><li>（D）elete it：你确定那个暂存盘是无用的！那么打开文件前会先将这个暂存盘删除！ 这个动作其实是比较常做的！因为你可能不确定这个暂存盘是怎么来的，所以就删除掉他吧！</li><li>（Q）uit：按下 q 就离开 vim ，不会进行任何动作回到命令提示字符。</li><li>（A）bort：忽略这个编辑行为，与 quit 非常类似！ 也会送你回到命令提示字符！</li></ul><h2 id="区块选择"><a class="markdownIt-Anchor" href="#区块选择"></a> 区块选择</h2><p>按键意义:</p><table><thead><tr><th style="text-align:center">按键</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">v</td><td>字符选择，会将光标经过的地方反白选择</td></tr><tr><td style="text-align:center">V</td><td>行选择，会将光标经过的行反白选择</td></tr><tr><td style="text-align:center">Ctrl+v</td><td>矩形选择，可以用矩形的方式选择数据(可以配合Ctrl+d、I、A、y、p、d等快捷键进行编辑)</td></tr><tr><td style="text-align:center">y</td><td>将选中地方复制起来</td></tr><tr><td style="text-align:center">p</td><td>将刚刚复制的区块，在光标所在处贴上</td></tr><tr><td style="text-align:center">d</td><td>将选中地方删除</td></tr></tbody></table><h2 id="多文件编辑"><a class="markdownIt-Anchor" href="#多文件编辑"></a> 多文件编辑</h2><p>vim后面接多个文件名打开多个文件,此时多个文件内可以各种模式内的命令.</p><p><code>如从一个文件内yy(复制)到另一个文件内pp(粘贴)</code></p><table><thead><tr><th style="text-align:center">按键</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">:n</td><td>编辑上一个文件</td></tr><tr><td style="text-align:center">:N</td><td>编辑下一个文件</td></tr><tr><td style="text-align:center">:files</td><td>列出目前vim打开的所有文件列表</td></tr></tbody></table><h2 id="多窗口"><a class="markdownIt-Anchor" href="#多窗口"></a> 多窗口</h2><p><code>:sp &#123;filename&#125;</code></p><table><thead><tr><th style="text-align:center">按键</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">:sp [filename]</td><td>横向打开一个新窗口，如果有加 filename， 表示在新窗口打开一个新文件，否则表示两个窗口为同一个文件内容（同步显示）</td></tr><tr><td style="text-align:center">:vsp [filename]</td><td>纵向打开一个新窗口，其它同上</td></tr><tr><td style="text-align:center">Ctrl+w+j(↓)</td><td>按键的按法是：先按下 [ctrl] 不放， 再按下 w 后放开所有的按键，然后再按下 j （或向下方向键或连按Ctrl+w），则光标可移动到下方的窗口。其它方向按键参考上面<strong>移动光标方法</strong>按键.</td></tr><tr><td style="text-align:center">Ctrl+w+q</td><td>相当于:q离开</td></tr></tbody></table><h2 id="dos与linxu断行字符"><a class="markdownIt-Anchor" href="#dos与linxu断行字符"></a> DOS与Linxu断行字符</h2><p>在 Linux 下面的指令在开始执行时，他的判断依据是 “Enter”，而 Linux 的 Enter 为 LF 符号， 不过，由于 DOS 的断行符号是 CRLF ，也就是多了一个 ^M 的符号出来， 在这样的情况下，如果是一个 shell script 的程序文件，将可能造成“程序无法执行”的状态～ 因为他会误判程序所下达的指令内容.</p><p>解决方法是通过指令将文件转换成Linux字符即可:</p><pre class="highlight"><code class>$ dos2unix [-kn] file [newfile]$ unix2dos [-kn] file [newfile]选项与参数：-k  ：保留该文件原本的 mtime 时间格式 （不更新文件上次内容经过修订的时间）-n  ：保留原本的旧文件，将转换后的内容输出到新文件，如： dos2unix -n old new#例一:将文件转换成dos断行符$ ll man_db.conf-rw-r--r--. 1 root root 5171 Jun 10  2014 man_db.conf$ unix2dos -k man_db.confunix2dos: converting file man_db.conf to DOS format ...# 屏幕会显示上述的讯息，说明断行转为 DOS 格式了！$ ll man_db.conf-rw-r--r--. 1 dmtsai dmtsai 5302 Jun 10  2014 man_db.conf# 断行字符多了 ^M ，所以容量增加了！#例二:将文件转换成Linux断行符,并保留新文件$ dos2unix -k -n man_db.conf man_db.conf.linuxdos2unix: converting file man_db.conf to file man_db.conf.linux in Unix format ...$ ll man_db.conf*-rw-r--r--. 1 dmtsai dmtsai 5302 Jun 10  2014 man_db.conf-rw-r--r--. 1 dmtsai dmtsai 5171 Jun 10  2014 man_db.conf.linux$ file man_db.conf*man_db.conf:       ASCII text, with CRLF line terminators  # 很清楚说明是 CRLF 断行！</code></pre><h2 id="语系编码转换"><a class="markdownIt-Anchor" href="#语系编码转换"></a> 语系编码转换</h2><pre class="highlight"><code class>$ iconv --list$ iconv -f 原本编码 -t 新编码 filename [-o newfile]选项与参数：--list ：列出 iconv 支持的语系数据-f     ：from ，亦即来源之意，后接原本的编码格式；-t     ：to ，亦即后来的新编码要是什么格式；-o file：如果要保留原本的文件，那么使用 -o 新文件名，可以创建新编码文件。#可以用file查看文件编码</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux正则与文件格式化</title>
      <link href="2018/03/21/Linux/Linux%E6%AD%A3%E5%88%99%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/"/>
      <url>2018/03/21/Linux/Linux%E6%AD%A3%E5%88%99%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="基础正则表达式"><a class="markdownIt-Anchor" href="#基础正则表达式"></a> 基础正则表达式</h2><p>基础正则字符包括:<code>^</code> <code>$</code> <code>.</code> <code>\</code> <code>*</code> <code>[]</code> <code>[n1-n2]</code> <code>[^]</code> <code>\&#123;n,m\&#125;</code></p><h3 id="语系对正则表达式的影响"><a class="markdownIt-Anchor" href="#语系对正则表达式的影响"></a> 语系对正则表达式的影响</h3><p>由于不同语系的编码数据并不相同，所以就会造成数据撷取结果的差异。</p><span id="more"></span><pre class="highlight"><code class>C和zh_TW.big5语系下,英文大小写的编码顺序:LANG=C     时：0 1 2 3 4 ... A B C D ... Z a b c d ...zLANG=zh_TW 时：0 1 2 3 4 ... a A b B c C d D ... z Z# C语系$ ll -d /etc/[^a-z]* # 正确显示# zh_TW.big5语系(测试zh_CN.UTF-8语系可以正确显示)$ ll -d /etc/[^a-z]* # 显示混乱</code></pre><blockquote><p>上面由于C语系字母是连续的所以正则表达式可以进行匹配,而zh_CN.UTF-8语系字母是非连续排列所以找不到该文件.<strong>由于一般正则表达式，使用的是相容于 POSIX 的标准，因此就使用“ C ”这个语系,所以通常使用正则将系统语系设置成C后使用.</strong></p></blockquote><pre class="highlight"><code class># 搜寻特定字符串(-v表示反向)$ grep -n (-v) 'the' regular_express.txt # 利用中括号[]搜寻集合字符$ grep -n 't[ae]st' regular_express.txt$ grep -n '[^a-z]oo' regular_express.txt$ grep -n '[0-9]' regular_express.txt#如上考虑到语系的影响可以使用特殊符号代替连续编码(&quot; - &quot;)$ grep -n '[^[:lower:]]oo' regular_express.txt$ grep -n '[[:digit:]]' regular_express.txt</code></pre><blockquote><p>为了要避免这样编码所造成的英文与数字的撷取问题,所以可以使用特殊符号代替</p></blockquote><table><thead><tr><th style="text-align:center">特殊符号</th><th style="text-align:center">代表意义</th></tr></thead><tbody><tr><td style="text-align:center">[:alnum:]</td><td style="text-align:center">代表英文大小写字符及数字，亦即 0-9, A-Z, a-z</td></tr><tr><td style="text-align:center">[:alpha:]</td><td style="text-align:center">代表任何英文大小写字符，亦即 A-Z, a-z</td></tr><tr><td style="text-align:center">[:blank:]</td><td style="text-align:center">代表空白键与 [Tab] 按键两者</td></tr><tr><td style="text-align:center">[:cntrl:]</td><td style="text-align:center">代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del… 等等</td></tr><tr><td style="text-align:center">[:digit:]</td><td style="text-align:center">代表数字而已，亦即 0-9</td></tr><tr><td style="text-align:center">[:graph:]</td><td style="text-align:center">除了空白字符 （空白键与 [Tab] 按键） 外的其他所有按键</td></tr><tr><td style="text-align:center">[:lower:]</td><td style="text-align:center">代表小写字符，亦即 a-z</td></tr><tr><td style="text-align:center">[:print:]</td><td style="text-align:center">代表任何可以被打印出来的字符</td></tr><tr><td style="text-align:center">[:punct:]</td><td style="text-align:center">代表标点符号 （punctuation symbol），亦即：&quot; ’ ? ! ; : # $…</td></tr><tr><td style="text-align:center">[:upper:]</td><td style="text-align:center">代表大写字符，亦即 A-Z</td></tr><tr><td style="text-align:center">[:space:]</td><td style="text-align:center">任何会产生空白的字符，包括空白键, [Tab], CR 等等</td></tr><tr><td style="text-align:center">[:xdigit:]</td><td style="text-align:center">代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字符</td></tr></tbody></table><h2 id="延伸正则表达式"><a class="markdownIt-Anchor" href="#延伸正则表达式"></a> 延伸正则表达式</h2><p><a href="/2018/03/06/Linux/Linux%E7%9A%84Bash/#grep">grep</a> 默认仅支持基础正则表达式，如果要使用延伸型正则表达式，你可以使用 grep -E ， 不过更建议直接使用 egrep</p><pre class="highlight"><code class>#去除空白行与首先为#的行列(需要使用管线命令来搜寻两次)grep -v '^$' | grep -v '^#' regular_express.txt#使用延伸正则表达式(延伸型正则表达式可以通过群组功能“ | ”来进行一次搜寻！)egrep -v '^$|^#' regular_express.txt</code></pre><p>延伸正则字符包括:<code>+</code> <code>?</code> <code>|</code> <code>()</code> <code>()+</code></p><h2 id="sed-工具"><a class="markdownIt-Anchor" href="#sed-工具"></a> sed 工具</h2><p>sed 本身也是一个管线命令，而且 sed 还可以将数据进行取代、删除、新增、撷取特定行等等的功能。</p><pre class="highlight"><code class>[dmtsai@study ~]$ sed [-nefr] [动作]选项与参数：-n  ：使用安静（silent）模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。      但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行（或者动作）才会被列出来。-e  ：直接在命令行界面上进行 sed 的动作编辑；-f  ：直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作；-r  ：sed 的动作支持的是延伸型正则表达式的语法。（默认是基础正则表达式语法）-i  ：直接修改读取的文件内容，而不是由屏幕输出。动作说明：  [n1[,n2]]functionn1, n2 ：不见得会存在，一般代表“选择进行动作的行数”，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则“ 10,20[动作行为] ”function 有下面这些：a   ：新增， a 的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）～c   ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d   ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i   ：插入， i 的后面可以接字串，而这些字串会在新的一行出现（目前的上一行）；p   ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s   ：取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配正则表达式！</code></pre><ul><li><p>以行为单位的功能</p><pre class="highlight"><code class># 将/etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除！$ nl /etc/passwd | sed '2,5d'1 root:x:0:0:root:/root:/bin/bash6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown.....（后面省略）.....# 承上，在第二行后（亦即是加在第三行）加上“drink tea?”字样！$ nl /etc/passwd | sed '2a drink tea' 1  root:x:0:0:root:/root:/bin/bash 2  bin:x:1:1:bin:/bin:/sbin/nologindrink tea 3  daemon:x:2:2:daemon:/sbin:/sbin/nologin.....（后面省略）.....</code></pre></li><li><p>部分数据的搜索与取代功能<br><code>sed 's/要被取代的字串(或正则)/新的字串/g'</code><br>如果想用以行为单位取代<br><code>sed 'n1,n2s/要被取代的字串(或正则)/新的字串/g'</code></p></li><li><p>直接修改文件内容（危险动作）<br>-i 选项可以让 sed 直接去修改后面接的文件内容而不是由屏幕输出！</p><pre class="highlight"><code class>#用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !$ sed -i 's/\.$/\!/g' regular_express.txt#利用 sed 直接在 regular_express.txt 最后一行加入“# This is a test”$ sed -i '$a # This is a test' regular_express.txt# 由于 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增！</code></pre></li></ul><h2 id="文件格式化处理"><a class="markdownIt-Anchor" href="#文件格式化处理"></a> 文件格式化处理</h2><h3 id="格式化打印"><a class="markdownIt-Anchor" href="#格式化打印"></a> 格式化打印</h3><pre class="highlight"><code class>printf '打印格式' 实际内容选项与参数：关于格式方面的几个特殊样式：       \a    警告声音输出       \b    倒退键（backspace）       \f    清除屏幕 （form feed）       \n    输出新的一行       \r    亦即 Enter 按键       \t    水平的 [tab] 按键       \v    垂直的 [tab] 按键       \xNN  NN 为两位数的数字，可以转换数字成为字符。关于 C 程序语言内，常见的变量格式       %ns   那个 n 是数字， s 代表 string ，亦即多少个字符；       %ni   那个 n 是数字， i 代表 integer ，亦即多少整数码数；       %N.nf 那个 n 与 N 都是数字， f 代表 floating （浮点），如果有小数码数， 假设我共要十个位数，但小数点有两位，即为 %10.2f ！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux的Bash</title>
      <link href="2018/03/06/Linux/Linux%E7%9A%84Bash/"/>
      <url>2018/03/06/Linux/Linux%E7%9A%84Bash/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="shell"><a class="markdownIt-Anchor" href="#shell"></a> Shell</h2><p>/etc/shells记录系统所有shell</p><h2 id="bash-shell-功能"><a class="markdownIt-Anchor" href="#bash-shell-功能"></a> Bash shell 功能</h2><h3 id="命令编修能力"><a class="markdownIt-Anchor" href="#命令编修能力"></a> 命令编修能力</h3><blockquote><p>默认指令记忆功能可以达到1000个<br>记录位置~/.bash_history(当前指令用户指令在内存中,登出后才记录到文件此内)</p></blockquote><ul><li>命令与文件实例功能(tab补全)</li><li>命令别名设置功能</li><li>工作控制/前景背景控制</li><li>程序化脚本shell script</li><li>万用字符(*)</li></ul><span id="more"></span><h3 id="type指令"><a class="markdownIt-Anchor" href="#type指令"></a> type指令</h3><p>type 这个指令我们可以知道每个指令是否为 bash 的内置指令。 此外，type只能查找可执行文件.</p><pre class="highlight"><code class>[dmtsai@study ~]$ type [-tpa] name选项与参数：    ：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令-t  ：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义：      file    ：表示为外部指令；      alias   ：表示该指令为命令别名所设置的名称；      builtin ：表示该指令为 bash 内置的指令功能；-p  ：如果后面接的 name 为外部指令时，才会显示完整文件名；-a  ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias</code></pre><h3 id="快速编辑"><a class="markdownIt-Anchor" href="#快速编辑"></a> 快速编辑</h3><ul><li><p>反斜杠( \ )<br>命令输入太长需要换行,利用反斜杠( \ )[Enter]开启下一行,而不执行命令.<br><strong>注意: [Enter] 按键是紧接着反斜线 （ \ ）</strong></p></li><li><p>快捷键</p></li></ul><table><tr><th>组合键</th><th>功能与示范</th></tr><tr><td>[ctrl]+u/[ctrl]+k</td><td>分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k） </td></tr><tr><td>[ctrl]+a/[ctrl]+e</td><td>分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e） </td></tr><tr><td>Ctrl + C</td><td>终止目前命令</td></tr><tr><td>Ctrl + D</td><td>输入结束(EOF),例如:邮件结束的时候</td></tr><tr><td>Ctrl + M</td><td>就是Enter</td></tr><tr><td>Ctrl + S</td><td>暂停屏幕输出</td></tr><tr><td>Ctrl + Q</td><td>恢复屏幕输出</td></tr><tr><td>Ctrl + U</td><td>在提示字符下，将整列命令删除</td></tr><tr><td>Ctrl + Z</td><td>“暂停”目前的命令 配合fg/bg/jobs命令使用</td></tr></table><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><h4 id="echo-指令"><a class="markdownIt-Anchor" href="#echo-指令"></a> echo 指令</h4><p>显示变量内容,&quot;-e&quot;选项可以格式化打印内容</p><pre class="highlight"><code class>[dmtsai@study ~]$ echo $PATH</code></pre><h4 id="变量设置规则"><a class="markdownIt-Anchor" href="#变量设置规则"></a> 变量设置规则</h4><ol><li><p>变量与变量内容以一个&quot;=&quot;来连接.<br><code>myname=Windus</code></p></li><li><p>等号两边不能直接接空白符.</p><pre class="highlight"><code class>#错误myname= Windusmyname=Windus L</code></pre></li><li><p>变量内容若有空白符可使用双引号或单引号将变量内容结合起来.</p><pre class="highlight"><code class>#双引号内特殊字符可保持原本特性,如:&quot;$&quot;等var=&quot;lang is $LANG&quot;echo $var --&gt; lang is UTF8#单引号内的特殊字符仅为一般字符(纯文本)var='lang is $LANG'echo $var --&gt; lang is $LANG</code></pre></li><li><p>变量名称只能是英文字母与数字,但开头字符不能是数字.</p></li><li><p>可用跳脱字符&quot; \ &quot;,将特殊符号变成一般符号。(如： [Enter], $, , 空白字符等）</p><p><code>myname=Windus\ L</code></p></li><li><p>在一串指令的执行中，还需要借由其他额外的指令所提供的信息时，可以使用反单引号“<code>指令</code>”或 “$（指令）</p><pre class="highlight"><code class>version=$（uname -r）echo $version --&gt; 3.10.0-229.el7.x86_64</code></pre></li><li><p>若该变量为扩增变量内容时，则可用 “$变量名称” 或 ${变量} 累加内容</p><pre class="highlight"><code class>PATH=&quot;$PATH&quot;:/home/bin或PATH=$&#123;PATH&#125;:/home/bin</code></pre></li><li><p>若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量<br><code>export PATH</code></p></li><li><p>通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断 （纯粹依照使用者兴趣与嗜好,在 Linux 默认的情况中，使用{大写的字母}来设置的变量一般为系统内定需要的变量）</p></li><li><p>取消变量用unset<br><code>unset myname</code></p></li></ol><h4 id="环境变量"><a class="markdownIt-Anchor" href="#环境变量"></a> 环境变量</h4><ul><li><p>env命令<br>查看所有环境变量</p><ul><li><p>HOME 使用者主文件夹变量, ~就会读取此变量</p></li><li><p>SHELL 目前环境使用的SHELL程序(Linux默认:/bin/bash)</p></li><li><p>HISTSIZE 历史命令记录笔数</p></li><li><p>MAIL 当前用户邮箱文件</p></li><li><p>PATH 可执行文件搜寻的路径(目录与目录中间:分隔).由于搜寻顺序依据PATH变量内目录顺序,所以目录顺序也是重要的.</p></li><li><p>LANG 语系数据</p></li><li><p>RANDOM 随机数变量(/dev/random),内容介于0~32767之间.</p><pre class="highlight"><code class>#想要获取指定范围内的数,使用delcare声名数值类型[dmtsai@study ~]$ declare -i number=$RANDOM*10/32768 ; echo $number8   &lt;== 此时会随机取出 0~9 之间的数值喔！</code></pre></li></ul></li><li><p>set命令<br>查看所有变量(含环境变量与自定变量)</p><ul><li><p>PS1 提示字符的设置</p><pre class="highlight"><code class>\d ：可显示出“星期 月 日”的日期格式，如：&quot;Mon Feb 2&quot;\H ：完整的主机名称。举例来说，鸟哥的练习机为“study.centos.vbird”\h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为“study”后面省略\t ：显示时间，为 24 小时格式的“HH:MM:SS”\T ：显示时间，为 12 小时格式的“HH:MM:SS”\A ：显示时间，为 24 小时格式的“HH:MM”\@ ：显示时间，为 12 小时格式的“am/pm”样式\u ：目前使用者的帐号名称，如“dmtsai”；\v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46（1）-release，仅取“4.2”显示\w ：完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以 ~ 取代；\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。\# ：下达的第几个指令。\$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ </code></pre></li><li><p>$ 本shell的PID<br><code>echo $$</code></p></li><li><p>? 上个指令的回传值<br>执行某些指令时， 这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令， 则会回传一个 0 值,如果执行过程发生错误,就会传回错误代码.一般以非0代码取代.</p></li></ul></li><li><p>export命令<br>当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是一个称为程序识别码，被称为 PID 的就是。 接下来你在这个 bash 下面所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了.<br><img src="/2018/03/06/Linux/Linux%E7%9A%84Bash/QQ20180307-115110@2x.png" alt="程序相关性示意图"><span class="image-caption">程序相关性示意图</span></p><p>子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自订变量.所以你在原本 bash 的自订变量在进入了子程序后就会消失不见， 一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！<br>此时,把自定变量变成环境变量就变得很有必要了:<br><code>export 变量名称</code></p></li></ul><p>如果export后面不加变量名称,就会将系统所有变量列出来,等同于set命令.</p><h4 id="语系变量"><a class="markdownIt-Anchor" href="#语系变量"></a> 语系变量</h4><ul><li><p>查看Linux支持的语系</p><pre class="highlight"><code class>[dmtsai@study ~]$ locale -a....（前面省略）....zh_TWzh_TW.big5     &lt;==大五码的中文编码zh_TW.euctwzh_TW.utf8     &lt;==万国码的中文编码zu_ZAzu_ZA.iso88591zu_ZA.utf8</code></pre></li><li><p>修改Linux语系</p><pre class="highlight"><code class>locale  &lt;==后面不加任何选项与参数即可！LANG=en_US                   &lt;==主语言的环境LC_CTYPE=&quot;en_US&quot;             &lt;==字符（文字）辨识的编码LC_NUMERIC=&quot;en_US&quot;           &lt;==数字系统的显示讯息LC_TIME=&quot;en_US&quot;              &lt;==时间系统的显示数据LC_COLLATE=&quot;en_US&quot;           &lt;==字串的比较与排序等LC_MONETARY=&quot;en_US&quot;          &lt;==币值格式的显示等LC_MESSAGES=&quot;en_US&quot;          &lt;==讯息显示的内容，如功能表、错误讯息等LC_ALL=                      &lt;==整体语系的环境....（后面省略）....</code></pre><p>可以逐一设置每个与语系有关的变量数据,可也以直接设置LANG或LC_ALL(其它语系变量会被这两个变量所取代).</p><p>系统默认语系文件是: <strong>/etc/locale.conf</strong></p></li></ul><h4 id="变量范围"><a class="markdownIt-Anchor" href="#变量范围"></a> 变量范围</h4><p>环境变量可以被子程序引用的原理:</p><ol><li>当启动一个shell,系统会分配一个记忆区给shell使用,使此内存内的变量,即环境变量可让子程序使用.</li><li>若父程序用export功能,将自定变量内容写到上述内存区块当中(环境变量).</li><li>当载入另一个shell时(亦启动一个子程序,离开原本父程序),子程序可以将父shell的环境变量所在记忆区导入自己的环境变量区块当中.</li></ol><h4 id="变量键盘读取阵列与宣告"><a class="markdownIt-Anchor" href="#变量键盘读取阵列与宣告"></a> 变量键盘读取/阵列与宣告</h4><ul><li><p>read命令<br>程序执行的过程当中，会等待使用者输入 “yes/no” 之类的讯息,和使用者对谈时使用此命令.</p><pre class="highlight"><code class>[dmtsai@study ~]$ read [-pt] variable选项与参数：-p  ：后面可以接提示字符！-t  ：后面可以接等待的“秒数！”这个比较有趣～不会一直等待使用者啦！</code></pre></li><li><p>declare/typeset<br>declare 或 typeset 是一样的功能，就是在“宣告变量的类型.</p><pre class="highlight"><code class>[dmtsai@study ~]$ declare [-aixr] variable选项与参数：-a  ：将后面名为 variable 的变量定义成为阵列 （array） 类型-i  ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型-x  ：用法与 export 一样，就是将后面的 variable 变成环境变量；-r  ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset-p : 仅列出变量类型范例一：让变量 sum 进行 100+300+50 的加总结果[dmtsai@study ~]$ sum=100+300+50[dmtsai@study ~]$ echo $&#123;sum&#125;100+300+50  &lt;==咦！怎么没有帮我计算加总？因为这是文字体态的变量属性啊！[dmtsai@study ~]$ declare -i sum=100+300+50[dmtsai@study ~]$ echo $&#123;sum&#125;450         &lt;==瞭乎？？</code></pre></li></ul><blockquote><p>注意: bash环境下,变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。 所以上述第一个执行的结果才会出现那个情况的；<br>bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0；</p></blockquote><h4 id="变量内容删除取代替换"><a class="markdownIt-Anchor" href="#变量内容删除取代替换"></a> 变量内容删除/取代/替换</h4><hr><p>暂时跳过</p><hr><h3 id="系统限制关系-ulimit"><a class="markdownIt-Anchor" href="#系统限制关系-ulimit"></a> 系统限制关系 ulimit</h3><pre class="highlight"><code class>[dmtsai@study ~]$ ulimit [-SHacdfltu] [配额]选项与参数：-H  ：hard limit ，严格的设置，必定不能超过这个设置的数值；-S  ：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。      在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 80 而 hard       设置为 100，那么你可以使用到 90 （因为没有超过 100），但介于 80~100 之间时，      系统会有警告讯息通知你！-a  ：后面不接任何选项与参数，可列出所有的限制额度；-c  ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用），      这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量。-f  ：此 shell 可以创建的最大文件大小（一般可能设置为 2GB）单位为 KBytes-d  ：程序可使用的最大断裂内存（segment）容量；-l  ：可用于锁定 （lock） 的内存量-t  ：可使用的最大 CPU 时间 （单位为秒）-u  ：单一使用者可以使用的最大程序（process）数量。-n &lt;文件数目&gt;：指定同一时间最多可开启的文件数；</code></pre><h3 id="命令别名与历史命令"><a class="markdownIt-Anchor" href="#命令别名与历史命令"></a> 命令别名与历史命令</h3><h4 id="别名设置-alias-unalias"><a class="markdownIt-Anchor" href="#别名设置-alias-unalias"></a> 别名设置 alias / unalias</h4><pre class="highlight"><code class>#设置别名[dmtsai@study ~]$ alias lm='ls -al | more#取消别名[dmtsai@study ~]$ unalias lm</code></pre><blockquote><p>设置别名,在机器重启后将丢失,如果想永久存在,需要写在~/.bash_profile文件内</p></blockquote><h4 id="历史命令-history"><a class="markdownIt-Anchor" href="#历史命令-history"></a> 历史命令 history</h4><p>历史命令记录在~/.bash_history文件中,记录的数量由HISTFILESIZE环境变量决定.</p><pre class="highlight"><code class>[dmtsai@study ~]$ history [-raw] histfiles选项与参数：n   ：数字，意思是“要列出最近的 n 笔命令列表”的意思！-c  ：将目前的 shell 中的所有 history 内容全部消除-a  ：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ，      则默认写入 ~/.bash_history-r  ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中；-w  ：将目前的 history 记忆内容写入 histfiles 中！</code></pre><ul><li><p>历史命令的使用:</p><pre class="highlight"><code class>[dmtsai@study ~]$ !选项与参数：number  ：执行第几笔指令的意思；command ：由最近的指令向前搜寻“指令串开头为 command”的那个指令，并执行；!!      ：就是执行上一个指令（相当于按↑按键后，按 Enter）</code></pre></li><li><p>同一帐号同时多次登陆的history写入问题</p><p>因为这些 bash 在同时以同一个身份登陆， 因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到登出时才会更新记录文件，所以，最后登出的那个 bash 才会是最后写入的数据。如此一来其他 bash 的指令操作就不会被记录下来了 （其实有被记录，只是被后来的最后一个 bash 所覆盖更新了） 。</p></li><li><p>历史命令时间问题<br>历史命令还有一个问题，那就是无法记录指令下达的时间。由于这 1000 笔历史命令是依序记录的， 但是并没有记录时间，所以在查询方面会有一些不方便。其实可以通过~/.bash_logout 来进行 history 的记录，并加上 date 来增加时间参数.</p></li></ul><h2 id="bash-shell操作环境"><a class="markdownIt-Anchor" href="#bash-shell操作环境"></a> Bash Shell操作环境</h2><h3 id="bash-进站欢迎信息-etcissue-etcmotd"><a class="markdownIt-Anchor" href="#bash-进站欢迎信息-etcissue-etcmotd"></a> Bash 进站欢迎信息 /etc/issue  /etc/motd</h3><pre class="highlight"><code class>issue 内的各代码意义:\d 本地端时间的日期；\l 显示第几个终端机接口；\m 显示硬件的等级 （i386/i486/i586/i686...）；\n 显示主机的网络名称；\O 显示 domain name；\r 操作系统的版本 （相当于 uname -r）\t 显示本地端时间的时间；\S 操作系统的名称；\v 操作系统的版本</code></pre><blockquote><p>当我们使用 telnet 连接到主机时，主机的登陆画面就会显示 /etc/issue.net 而不是 /etc/issue<br>/etc/motd 里面显示的则是文字信息</p></blockquote><h3 id="bash环境配置文件"><a class="markdownIt-Anchor" href="#bash环境配置文件"></a> bash环境配置文件</h3><h4 id="login与non-login-shell"><a class="markdownIt-Anchor" href="#login与non-login-shell"></a> login与non-login Shell</h4><ul><li><p>login shell：取得 bash 时需要完整的登陆流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登陆，需要输入使用者的帐号与密码，此时取得的 bash 就称为“ login shell ”</p></li><li><p>non-login shell：取得 bash 接口的方法不需要重复登陆的举动，举例来说，（1）你以 X window 登陆 Linux 后， 再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入帐号与密码，那个 bash 的环境就称为 non-login shell了。（2）你在原本的 bash 环境下再次下达 bash 这个指令，同样的也没有输入帐号密码， 那第二个 bash （子程序） 也是 non-login shell 。</p></li></ul><blockquote><p>这两个Shell，读取的配置文件数据并不一样.</p></blockquote><h4 id="etcprofile-login-shell读取"><a class="markdownIt-Anchor" href="#etcprofile-login-shell读取"></a> /etc/profile (login Shell读取)</h4><p>这个配置文件可以利用使用者的识别码 （UID） 来决定很多重要的变量数据， 也是每个使用者登陆取得 bash 时一定会读取的配置文件.所以设置全局环境就要改这个文件!</p><pre class="highlight"><code class>主要变量:PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；MAIL：依据帐号设置好使用者的 mailbox 到 /var/spool/mail/帐号名；USER：根据使用者的帐号设置此一变量内容；HOSTNAME：依据主机的 hostname 指令决定此一变量内容；HISTSIZE：历史命令记录笔数。CentOS 7.x 设置为 1000 ；umask：包括 root 默认为 022 而一般用户为 002 等！</code></pre><blockquote><p>/etc/profile 还会调用外部的设置数据,主要有如下:</p></blockquote><ul><li><p>/etc/profile.d/*.sh<br>“这个目录内的众多文件！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使用者能够具有 r 的权限， 那么该文件就会被 /etc/profile 调用进来。在 CentOS 7.x 中，这个目录下面的文件规范了 bash 操作接口的颜色、 语系、ll 与 ls 指令的命令别名、vi 的命令别名、which 的命令别名等等。如果你需要帮所有使用者设置一些共享的命令别名时， 可以在这个目录下面自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可！</p></li><li><p>/etc/locale.conf<br>这个文件是由 /etc/profile.d/lang.sh 调用进来的！这也是我们决定 bash 默认使用何种语系的重要配置文件！ 文件里最重要的就是 LANG/LC_ALL 这些个变量的设置！</p></li><li><p>/usr/share/bash-completion/completions/*<br>这个目录下除前面谈过 [tab] 命令补齐、文件名补齐之外，还可以进行指令的选项/参数补齐功能！那就是从这个目录里面找到相对应的指令来处理的！ 其实这个目录下面的内容是由 /etc/profile.d/bash_completion.sh 这个文件载入的啦！</p></li></ul><h4 id="~bash_profile-login-shell读取"><a class="markdownIt-Anchor" href="#~bash_profile-login-shell读取"></a> ~/.bash_profile (login Shell读取)</h4><p>bash 在读完了整体环境设置的 /etc/profile 并借此调用其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：</p><pre class="highlight"><code class>1. ~/.bash_profile2. ~/.bash_login3. ~/.profile</code></pre><p>其实 bash 的 login shell 设置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 ~/.bash_profile 存在，那么其他两个文件不论有无存在，都不会被读取。 如果 ~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思。 会有这么多的文件，其实是因应其他 shell 转换过来的使用者的习惯而已。</p><p><img src="/2018/03/06/Linux/Linux%E7%9A%84Bash/QQ20180315-174127@2x.png" alt="shell 读取流程"><span class="image-caption">shell 读取流程</span></p><h4 id="source-读入环境配置文件指令"><a class="markdownIt-Anchor" href="#source-读入环境配置文件指令"></a> source 读入环境配置文件指令</h4><p>由于 /etc/profile 与 ~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以， 如果你将自己的偏好设置写入上述的文件后，通常都是得登出再登陆后，该设置才会生效。利用这个指令可以直接生效!</p><pre class="highlight"><code class>[dmtsai@study ~]$ source 配置文件文件名范例：将主文件夹的 ~/.bashrc 的设置读入目前的 bash 环境中[dmtsai@study ~]$ source ~/.bashrc  &lt;==下面这两个指令是一样的！[dmtsai@study ~]$  .  ~/.bashrc</code></pre><h4 id="~bashrc-non-login-shell-读取"><a class="markdownIt-Anchor" href="#~bashrc-non-login-shell-读取"></a> ~/.bashrc （non-login shell 读取）</h4><p>CentOS 7.x 还会主动的调用 /etc/bashrc 这个文件</p><pre class="highlight"><code class>/etc/bashrc文件记录内容1. 依据不同的 UID 规范出 umask 的值；2. 依据不同的 UID 规范出提示字符 （就是 PS1 变量）；3. 调用 /etc/profile.d/*.sh 的设置</code></pre><blockquote><p>/etc/bashrc文件是Red Hat系统特有的,如果此文件丢失,可以复制 /etc/skel/.bashrc 到你的主文件夹.</p></blockquote><h3 id="终端机环境设置-stty-set"><a class="markdownIt-Anchor" href="#终端机环境设置-stty-set"></a> 终端机环境设置 stty , set</h3><h4 id="stty命令"><a class="markdownIt-Anchor" href="#stty命令"></a> stty命令</h4><p>查阅目前的一些按键内容</p><pre class="highlight"><code class>[dmtsai@study ~]$ stty [-a]选项与参数：-a  ：将目前所有的 stty 参数列出来；#列出所有的按键与按键内容[dmtsai@study ~]$ stty -aspeed 38400 baud; rows 20; columns 90; line = 0;intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;flush = ^O; min = 1; time = 0;....（以下省略）....#设置按键[dmtsai@study ~]$ stty erase ^h意义:intr  : 送出一个 interrupt （中断） 的讯号给目前正在 执行的程序 （就是终止啰！）；quit  : 送出一个 quit 的讯号给目前正在执行的程序；erase : 向后删除字符，kill  : 删除在目前命令行上的所有文字；eof   : End of file 的意思，代表“结束输入”。start : 在某个程序停止后，重新启动他的 outputstop  : 停止目前屏幕的输出；susp  : 送出一个 terminal stop 的讯号给正在 run 的程序。</code></pre><h4 id="set命令"><a class="markdownIt-Anchor" href="#set命令"></a> set命令</h4><hr><p>暂无</p><hr><h3 id="万用字符与特殊符号"><a class="markdownIt-Anchor" href="#万用字符与特殊符号"></a> 万用字符与特殊符号</h3><p>万用字符:</p><pre class="highlight"><code class>*代表“ 0 个到无穷多个”任意字符?代表“一定有一个”任意字符[]同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”[-]若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！[^]若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</code></pre><p>特殊字符:</p><pre class="highlight"><code class>#注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行\跳脱符号：将“特殊字符或万用字符”还原成一般字符|管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；;连续指令下达分隔符号：连续性命令的界定 （注意:与管线命令并不相同）~使用者的主文件夹$取用变量前置字符：亦即是变量之前需要加的变量取代值&amp;工作控制 （job control）：将指令变成背景下工作!逻辑运算意义上的“非” not 的意思！/目录符号：路径分隔的符号&gt;, &gt;&gt;数据流重导向：输出导向，分别是“取代”与“累加”&lt;, &lt;&lt;数据流重导向：输入导向 ''单引号，不具有变量置换的功能 （$ 变为纯文本）&quot;&quot;具有变量置换的功能！ （$ 可保留相关功能）``两个“ ` ”中间为可以先执行的指令，亦可使用 $（ ）()在中间为子 shell 的起始与结束&#123;&#125;在中间为命令区块的组合！</code></pre><h2 id="数据流重导向"><a class="markdownIt-Anchor" href="#数据流重导向"></a> 数据流重导向</h2><h3 id="数据流输入输出"><a class="markdownIt-Anchor" href="#数据流输入输出"></a> 数据流输入/输出</h3><p><em><strong>标准输出</strong></em>:指的是“指令执行所回传的正确的讯息”<br><em><strong>标准错误输出</strong></em>:“ 指令执行失败后，所回传的错误讯息”</p><blockquote><p>标准输入　　（stdin） ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；<br>标准输出　　（stdout）：代码为 1 ，使用 &gt; 或 &gt;&gt; ；<br>标准错误输出（stderr）：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</p></blockquote><h4 id="devnull-垃圾桶黑洞设备与特殊写法"><a class="markdownIt-Anchor" href="#devnull-垃圾桶黑洞设备与特殊写法"></a> /dev/null 垃圾桶黑洞设备与特殊写法</h4><p>/dev/null 可以吃掉任何导向这个设备的信息</p><h4 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2&gt;&amp; | &amp;&gt;</h4><pre><code>```#将指令的数据全部写入名为 list 的文件中(包括错误信息)[dmtsai@study ~]$ find /home -name .bashrc &gt; list 2&gt;&amp;1    [dmtsai@study ~]$ find /home -name .bashrc &amp;&gt; list        ```</code></pre><h4 id="标准输入"><a class="markdownIt-Anchor" href="#标准输入"></a> 标准输入</h4><pre class="highlight"><code class>#利用 cat 指令来创建一个文件的简单流程[dmtsai@study ~]$ cat &gt; catfiletestingcat file test&lt;==这里按下 [ctrl]+d 来离开[dmtsai@study ~]$ cat catfiletestingcat file test#用 stdin 取代键盘的输入以创建新文件的简单流程[dmtsai@study ~]$ cat &gt; catfile &lt; ~/.bashrc[dmtsai@study ~]$ ll catfile ~/.bashrc# 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！-rw-r--r--. 1 dmtsai dmtsai 231 Mar  6 06:06 /home/dmtsai/.bashrc-rw-rw-r--. 1 dmtsai dmtsai 231 Jul  9 18:58 catfile#用 cat 直接将输入的讯息输出到 catfile 中， 且当由键盘输入 eof 时，该次输入就结束[dmtsai@study ~]$ cat &gt; catfile &lt;&lt; &quot;eof&quot;&gt; This is a test.&gt; OK now stop&gt; eof  &lt;==输入这关键字，立刻就结束而不需要输入 [ctrl]+d[dmtsai@study ~]$ cat catfileThis is a test.OK now stop     &lt;==只有这两行，不会存在关键字那一行！</code></pre><h3 id="命令执行的判断依据"><a class="markdownIt-Anchor" href="#命令执行的判断依据"></a> 命令执行的判断依据 ;  &amp;&amp;  ||</h3><h4 id="不考虑指令相关性的连续指令下达-cmdcmd"><a class="markdownIt-Anchor" href="#不考虑指令相关性的连续指令下达-cmdcmd"></a> 不考虑指令相关性的连续指令下达 cmd;cmd</h4><pre class="highlight"><code class>[root@study ~]# sync; sync; shutdown -h now</code></pre><h4 id="指令回传值-与-或"><a class="markdownIt-Anchor" href="#指令回传值-与-或"></a> $? （指令回传值） 与 &amp;&amp; 或 ||</h4><p>若前一个指令执行的结果为正确，在 Linux 下面会回传一个 $? = 0 的值</p><table><tr><th>指令</th><th>说明</th></tr><tr><td>cmd1 && cmd2</td><td>1. 若 cmd1 执行完毕且正确执行（$?=0），则开始执行 cmd2。<br>  2. 若 cmd1 执行完毕且为错误 （$?≠0），则 cmd2 不执行。</td></tr><tr><td>cmd1 || cmd2</td><td>1. 若 cmd1 执行完毕且正确执行（$?=0），则 cmd2 不执行。<br>  2. 若 cmd1 执行完毕且为错误 （$?≠0），则开始执行 cmd2。</td></tr></table><pre class="highlight"><code class>[dmtsai@study ~]$ ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe</code></pre><p>Linux 下面的指令都是由左往右执行,上面执行结果:<br><em>情况一:</em><br>（1）若 /tmp/abc 不存在故回传 $?≠0，则<br>（2）因为 || 遇到非为 0 的 $? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc 会成功进行，所以回传 $?=0<br>（3）因为 &amp;&amp; 遇到 $?=0 故会执行 touch /tmp/abc/hehe，最终 hehe 就被创建了；</p><p><em>情况二:</em><br>（1）若 /tmp/abc 存在故回传 $?=0，则<br>（2）因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故<br>（3）因为 &amp;&amp; 遇到 $?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。</p><p><img src="/2018/03/06/Linux/Linux%E7%9A%84Bash/QQ20180316-134233@2x.png" alt="指令执行关系示意图"><span class="image-caption">指令执行关系示意图</span></p><pre class="highlight"><code class>ls /tmp/vbirding || echo &quot;not exist&quot; &amp;&amp; echo &quot;exist”#返回结果:not existexist</code></pre><blockquote><p>由于指令是一个接着一个去执行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错(如上面例子).<br>一般来说，假设判断式有三个，也就是：<br>command1 &amp;&amp; command2 || command3</p></blockquote><h2 id="管线命令pipe"><a class="markdownIt-Anchor" href="#管线命令pipe"></a> 管线命令(pipe)</h2><p><strong>管线命令使用的是“ | ”这个界定符号！ 另外，管线命令与“连续下达命令”是不一样！</strong><br><strong>管线命令“ | ”仅能处理经由前面一个指令传来的正确信息，也就是 standard output 的信息，对于 stdandard error 并没有直接处理的能力.</strong><br><strong>每个管线后面接的第一个数据必定是“指令”喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以是为“管线命令”</strong></p><h3 id="撷取命令-cut-grep"><a class="markdownIt-Anchor" href="#撷取命令-cut-grep"></a> 撷取命令 cut grep</h3><h4 id="cut"><a class="markdownIt-Anchor" href="#cut"></a> cut</h4><p>将一段讯息的某一段给他“切”出来～ 处理的讯息是以“行”为单位</p><pre class="highlight"><code class>[dmtsai@study ~]$ cut -d'分隔字符' -f fields &lt;==用于有特定分隔字符[dmtsai@study ~]$ cut -c 字符区间            &lt;==用于排列整齐的讯息选项与参数：-d  ：后面接分隔字符。与 -f 一起使用；-f  ：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；-c  ：以字符 （characters） 的单位取出固定字符区间；[dmtsai@study ~]$ echo $&#123;PATH&#125; | cut -d ':' -f 5 #显示切割后的第5个[dmtsai@study ~]$ echo $&#123;PATH&#125; | cut -d ':' -f 3,5 #显示切割后的3-5个[dmtsai@study ~]$ echo $&#123;PATH&#125; | cut -d ':' -f 3- #显示切割后的3到最后一个#将 export 输出的讯息，取得第 12 字符以后的所有字串[dmtsai@study ~]$ exportdeclare -x HISTCONTROL=&quot;ignoredups&quot;declare -x HISTSIZE=&quot;1000&quot;declare -x HOME=&quot;/home/dmtsai&quot;declare -x HOSTNAME=&quot;study.centos.vbird&quot;.....（其他省略）.....# 注意看，每个数据都是排列整齐的输出！如果我们不想要“ declare -x ”时，就得这么做：[dmtsai@study ~]$ export | cut -c 12-HISTCONTROL=&quot;ignoredups&quot;HISTSIZE=&quot;1000&quot;HOME=&quot;/home/dmtsai&quot;HOSTNAME=&quot;study.centos.vbird&quot;.....（其他省略）.....</code></pre><h4 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> grep</h4><pre class="highlight"><code class>[dmtsai@study ~]$ grep [-acinv] [--color=auto] '搜寻字串' filename选项与参数：-a ：将 binary 文件以 text 文件的方式搜寻数据-c ：计算找到 '搜寻字串' 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 '搜寻字串' 内容的那一行！--color=auto ：可以将找到的关键字部分加上颜色的显示喔！-A : 后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；-B : 后面可加数字，为 before 的意思，除了列出该行外，前面的 n 行也列出来；</code></pre><h3 id="排序命令-sort-wc-uniq"><a class="markdownIt-Anchor" href="#排序命令-sort-wc-uniq"></a> 排序命令 sort wc uniq</h3><h4 id="sort"><a class="markdownIt-Anchor" href="#sort"></a> sort</h4><pre class="highlight"><code class>[dmtsai@study ~]$ sort [-fbMnrtuk] [file or stdin]选项与参数：-f  ：忽略大小写的差异，例如 A 与 a 视为编码相同；-b  ：忽略最前面的空白字符部分；-M  ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；-n  ：使用“纯数字”进行排序（默认是以文字体态来排序的）；-r  ：反向排序；-u  ：就是 uniq ，相同的数据中，仅出现一行代表；-t  ：分隔符号，默认是用 [tab] 键来分隔；-k  ：以那个区间 （field） 来进行排序的意思#/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？[dmtsai@study ~]$ cat /etc/passwd | sort -t ':' -k 3root:x:0:0:root:/root:/bin/bashdmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bashalex:x:1001:1002::/home/alex:/bin/basharod:x:1002:1003::/home/arod:/bin/bash# 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～# 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：# cat /etc/passwd | sort -t ':' -k 3 -n# 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</code></pre><h4 id="uniq"><a class="markdownIt-Anchor" href="#uniq"></a> uniq</h4><p>重复的数据仅列出一个显示</p><pre class="highlight"><code class>[dmtsai@study ~]$ uniq [-ic]选项与参数：-i  ：忽略大小写字符的不同；-c  ：进行计数#使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；[dmtsai@study ~]$ last | cut -d ' ' -f1 | sort | uniq#承上,继续显示每个帐号登录次数[dmtsai@study ~]$ last | cut -d ' ' -f1 | sort | uniq -c      1      6 （unknown     47 dmtsai      4 reboot      7 root      1 wtmp</code></pre><h4 id="wc"><a class="markdownIt-Anchor" href="#wc"></a> wc</h4><pre class="highlight"><code class>[dmtsai@study ~]$ wc [-lwm]选项与参数：-l  ：仅列出行；-w  ：仅列出多少字（英文单字）；-m  ：多少字符；#/etc/man_db.conf 里面到底有多少相关字、行、字符数？[dmtsai@study ~]$ cat /etc/man_db.conf | wc    131     723    5171# 输出的三个数字中，分别代表： “行、字数、字符数</code></pre><h3 id="双重导向tee"><a class="markdownIt-Anchor" href="#双重导向tee"></a> 双重导向tee</h3><p>可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理.<br><img src="/2018/03/06/Linux/Linux%E7%9A%84Bash/QQ20180319-161532@2x.png" alt="tee工作流程示意图"><span class="image-caption">tee工作流程示意图</span></p><pre class="highlight"><code class>[dmtsai@study ~]$ tee [-a] file选项与参数：-a  ：以累加 （append） 的方式，将数据加入 file 当中！[dmtsai@study ~]$ ls -l /home | tee ~/homefile | more# 将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！[dmtsai@study ~]$ ls -l / | tee -a ~/homefile | more# 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。</code></pre><h3 id="字符转换命令-tr-col-join-paste-expand"><a class="markdownIt-Anchor" href="#字符转换命令-tr-col-join-paste-expand"></a> 字符转换命令 tr, col, join, paste, expand</h3><h4 id="tr"><a class="markdownIt-Anchor" href="#tr"></a> tr</h4><p>tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！</p><pre class="highlight"><code class>[dmtsai@study ~]$ tr [-ds] SET1 ...选项与参数：-d  ：删除讯息当中的 SET1 这个字串；-s  ：取代掉重复的字符！#将 last 输出的讯息中，所有的小写变成大写字符：[dmtsai@study ~]$ last | tr '[a-z]' '[A-Z]'# 不加单引号也是可以执行的，如：“ last | tr [a-z] [A-Z] ”#将 /etc/passwd 输出的讯息中，将冒号 （:） 删除[dmtsai@study ~]$ cat /etc/passwd | tr -d ':'</code></pre><h4 id="col"><a class="markdownIt-Anchor" href="#col"></a> col</h4><p>用来简单的处理将 [tab] 按键取代成为空白键.(***还有其它用途???***)</p><pre class="highlight"><code class>[dmtsai@study ~]$ col [-xb]选项与参数：-x  ：将 tab 键转换成对等的空白键#利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白[dmtsai@study ~]$ cat -A /etc/man_db.conf  &lt;==此时会看到很多 ^I 的符号，那就是 tab[dmtsai@study ~]$ cat /etc/man_db.conf | col -x | cat -A | more</code></pre><h3 id="分区命令-split"><a class="markdownIt-Anchor" href="#分区命令-split"></a> 分区命令 split</h3><p>如果有文件太大，导致一些携带式设备无法复制的问题，split 可以将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了</p><pre class="highlight"><code class>[dmtsai@study ~]$ split [-bl] file PREFIX选项与参数：-b  ：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；-l  ：以行数来进行分区。PREFIX ：代表前置字符的意思，可作为分区文件的前导文字。</code></pre><p><code>范例一</code>：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？</p><pre class="highlight"><code class>[dmtsai@study ~]$ cd /tmp; split -b 300k /etc/services services[dmtsai@study tmp]$ ll -k services*-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul  9 22:52 servicesaa-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul  9 22:52 servicesab-rw-rw-r--. 1 dmtsai dmtsai  55893 Jul  9 22:52 servicesac# 那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa, xxxab, xxxac 等方式来创建小文件的！</code></pre><p><code>“范例二</code>：如何将上面的三个小文件合成一个文件，文件名为 servicesback</p><pre class="highlight"><code class>#用数据流重导向合成文件[dmtsai@study tmp]$ cat services* &gt;&gt; servicesback</code></pre><p><code>范例三</code>：使用 ls -al / 输出的信息中，每十行记录成一个文件</p><pre class="highlight"><code class>[dmtsai@study tmp]$ ls -al / | split -l 10 - lsroot[dmtsai@study tmp]$ wc -l lsroot*  10 lsrootaa  10 lsrootab   4 lsrootac  24 total# 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</code></pre><h3 id="参数代换-xargs后面貌似不能用alias"><a class="markdownIt-Anchor" href="#参数代换-xargs后面貌似不能用alias"></a> 参数代换 xargs(后面貌似不能用alias)</h3><pre class="highlight"><code class>[dmtsai@study ~]$ xargs [-0epn] command选项与参数：-0  ：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数      可以将他还原成一般字符。这个参数可以用于特殊状态！-e  ：这个是 EOF （end of file） 的意思。后面可以接一个字符串，当 xargs 分析到这个字串时，就会停止继续工作！-p  ：在执行每个指令的 argument 时，都会询问使用者的意思；-n  ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！</code></pre><p><code>范例一</code>：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来.</p><pre class="highlight"><code class>[dmtsai@study ~]$ id rootuid=0（root） gid=0（root） groups=0（root）   # 这个 id 指令可以查询使用者的 UID/GID 等信息[dmtsai@study ~]$ id $(cut -d ':' -f 1 /etc/passwd | head -n 3)# 虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！# 所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！[dmtsai@study ~]$ cut -d ':' -f 1 /etc/passwd | head -n 3 | iduid=1000 (dmtsai) gid=1000 (dmtsai) groups=1000 (dmtsai),10(wheel)# 因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！[dmtsai@study ~]$ cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs id# 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但id 就接受 1 个参数！[dmtsai@study ~]$ cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -n 1 iduid=0（root） gid=0（root） groups=0（root）uid=1（bin） gid=1（bin） groups=1（bin）uid=2（daemon） gid=2（daemon） groups=2（daemon）# 通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</code></pre><p><code>范例二</code>：同上，但是每次执行 id 时，都要询问使用者是否动作？</p><pre class="highlight"><code class>[dmtsai@study ~]$ cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -p -n 1 idid root ?...yuid=0（root） gid=0（root） groups=0（root）id bin ?...y.....（下面省略）.....# 呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</code></pre><p><code>范例三</code>：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串</p><pre class="highlight"><code class>[dmtsai@study ~]$ cut -d ':' -f 1 /etc/passwd | xargs -e'sync' -n 1 id# 仔细与上面的案例做比较。也同时注意，那个 -e'sync' 是连在一起的，中间没有空白键。# 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e'sync' 后，则分析到 sync 这个字串时，# 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</code></pre><p><em><strong>很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！</strong></em></p><p><code>范例四</code>：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性</p><pre class="highlight"><code class>[dmtsai@study ~]$ find /usr/sbin -perm /7000 | xargs ls -l-rwx--s--x. 1 root lock      11208 Jun 10  2014 /usr/sbin/lockdev-rwsr-xr-x. 1 root root     113400 Mar  6 12:17 /usr/sbin/mount.nfs-rwxr-sr-x. 1 root root      11208 Mar  6 11:05 /usr/sbin/netreport.....（下面省略）.....# 也可以使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！</code></pre><h3 id="减号-的用途"><a class="markdownIt-Anchor" href="#减号-的用途"></a> 减号 &quot; - &quot; 的用途</h3><p>管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 “-” 来替代.</p><pre class="highlight"><code class>[root@study ~]# mkdir /tmp/homeback[root@study ~]# tar -cvf - /home | tar -xvf - -C /tmp/homeback</code></pre><blockquote><p>上面这个例子是：“将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - ”。后面的这个 - 则是取用前一个指令的 stdout， 因此，我们就不需要使用 filename 了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件压缩/打包/备份</title>
      <link href="2018/03/02/Linux/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9:%E6%89%93%E5%8C%85:%E5%A4%87%E4%BB%BD/"/>
      <url>2018/03/02/Linux/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9:%E6%89%93%E5%8C%85:%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="压缩文件的技术"><a class="markdownIt-Anchor" href="#压缩文件的技术"></a> 压缩文件的技术</h2><p>压缩文件简单原理:目前我们使用的计算机系统中都是使用所谓的 Bytes 单位来计量的！不过，事实上，计算机最小的计量单位应该是 bits 才对啊。此外，我们也知道 1 Byte = 8 bits 。但是如果今天我们只是记忆一个数字，亦即是 1 这个数字呢?由于我们记录数字是 1 ，考虑计算机所谓的二进制喔，如此一来， 1 会在最右边占据 1 个 bit ，而其他的 7 个 bits 将会自动的被填上 0 啰！你看看，其实在这样的例子中，那 7 个 bits 应该是“空的”才对！不过，为了要满足目前我们的操作系统数据的存取，所以就会将该数据转为 Byte 的型态来记录了！而一些聪明的计算机工程师就利用一些复杂的计算方式， 将这些没有使用到的空间“丢”出来，以让文件占用的空间变小！这就是压缩的技术啦！</p><span id="more"></span><p>另外一种压缩技术也很有趣，他是将重复的数据进行统计记录的。举例来说，如果你的数据为“111…”共有100个1时， 那么压缩技术会记录为“100个1”而不是真的有100个1的位存在！<br>简单的说，你可以将他想成，其实文件里面有相当多的“空间”存在，并不是完全填满的， 而“压缩”的技术就是将这些“空间”填满，以让整个文件占用的容量下降！ 不过，这些“压缩过的文件”并无法直接被我们的操作系统所使用的，因此， 若要使用这些被压缩过的文件数据，则必须将他“还原”回来未压缩前的模样， 那就是所谓的“解压缩</p><h2 id="常见的压缩指令"><a class="markdownIt-Anchor" href="#常见的压缩指令"></a> 常见的压缩指令</h2><blockquote><p>*.Z         compress 程序压缩的文件；<br>*.zip       zip 程序压缩的文件；<br>*.gz        gzip 程序压缩的文件；<br>*.bz2       bzip2 程序压缩的文件；<br>*.xz        xz 程序压缩的文件；<br>*.tar       tar 程序打包的数据，并没有压缩过；<br>*.tar.gz    tar 程序打包的文件，其中并且经过 gzip 的压缩<br>*.tar.bz2   tar 程序打包的文件，其中并且经过 bzip2 的压缩<br>*.tar.xz    tar 程序打包的文件，其中并且经过 xz 的压缩</p></blockquote><ul><li>gzip, zcat/zmore/zless/zgrep<br>gzip是目前应用最广的压缩指令,后缀为*.gz<br>如果压缩的文件是文本文件,压缩后可以使用zcat相关指令读取出来.</li></ul><pre class="highlight"><code class>[dmtsai@study ~]$ gzip [-cdtv#] 文件名选项与参数：-c  ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；-d  ：解压缩的参数；-t  ：可以用来检验一个压缩文件的一致性～看看文件有无错误；-v  ：可以显示出原文件/压缩文件的压缩比等信息；-#  ：#为数字的意思，代表压缩等级，-1最快，但是压缩比最差、-9最慢，但是压缩比最好！默认是 -6</code></pre><p>gzip压缩默认会删除原文件,如果想保留原文件可以使用如下命令:</p><pre class="highlight"><code class>[dmtsai@study tmp]$ gzip -9 -c services &gt; services.gz-c 选项打印出文件到屏幕,然后使用 &gt; 重定向</code></pre><p>找出压缩文件中的关键字命令:</p><pre class="highlight"><code class>[dmtsai@study tmp]$ zgrep -n 'http' services.gz14:#       http://www.iana.org/assignments/port-numbers89:http            80/tcp          www www-http    # WorldWideWeb HTTP90:http            80/udp          www www-http    # HyperText Transfer Protocol.....（下面省略）.....</code></pre><ul><li>bzip2, bzcat/bzmore/bzless/bzgrep<br>与gzip用法类似,比gzip压缩比更好<br>后缀为*.bz2</li></ul><pre class="highlight"><code class>[dmtsai@study ~]$ bzip2 [-cdkzv#] 文件名选项与参数：-c  ：将压缩的过程产生的数据输出到屏幕上！-d  ：解压缩的参数-k  ：保留原始文件，而不会删除原始的文件喔！-z  ：压缩的参数 （默认值，可以不加）-v  ：可以显示出原文件/压缩文件的压缩比等信息；-#  ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！</code></pre><ul><li>xz, xzcat/xzmore/xzless/xzgrep<br>与gzip,bzip2用法类似,比bzip2压缩比更好<br>后缀为*.xz</li></ul><pre class="highlight"><code class>[dmtsai@study ~]$ xz [-dtlkc#] 文件名选项与参数：-d  ：就是解压缩啊！-t  ：测试压缩文件的完整性，看有没有错误-l  ：列出压缩文件的相关信息-k  ：保留原本的文件不删除～-c  ：同样的，就是将数据由屏幕上输出的意思！-#  ：同样的，也有较佳的压缩比的意思！”</code></pre><h2 id="打包文件"><a class="markdownIt-Anchor" href="#打包文件"></a> 打包文件</h2><p>虽然 gzip, bzip2, xz 也能够针对目录来进行压缩，不过， 这两个指令对目录的压缩指的是“将目录内的所有文件 “分别” 进行压缩”的动作！而不像在 Windows 的系统，可以使用类似 WinRAR 这一类的压缩软件来将好多数据“包成一个文件”的样式。</p><h3 id="tar命令常用选项"><a class="markdownIt-Anchor" href="#tar命令常用选项"></a> tar命令常用选项</h3><pre class="highlight"><code class>[dmtsai@study ~]$ tar [-z|-j|-J][cv][-f 待创建的新文件名] filename... &lt;==打包与压缩[dmtsai@study ~]$ tar [-z|-j|-J][tv] [-f 既有的 tar文件名]     &lt;==察看文件名[dmtsai@study ~]$ tar [-z|-j|-J] [xv] [-f 既有的 tar文件名][-C 目录]   &lt;==解压缩选项与参数：-c  ：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）-t  ：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；-x  ：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开      特别留意的是， -c, -t, -x 不可同时出现在一串命令行中。-z  ：通过 gzip  的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz-j  ：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2-J  ：通过 xz    的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz      特别留意， -z, -j, -J 不可以同时出现在一串命令行中-v  ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！-f filename：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）-C 目录    ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。其他后续练习会使用到的选项介绍：-p（小写） ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件-P（大写） ：保留绝对路径，亦即允许备份数据中含有根目录存在之意；--exclude=FILE：在压缩的过程中，不要将 FILE 打包！</code></pre><h3 id="tar备份"><a class="markdownIt-Anchor" href="#tar备份"></a> tar备份</h3><pre class="highlight"><code class>[dmtsai@study ~]$ su -  # 因为备份 /etc 需要 root 的权限，否则会出现一堆错误[root@study ~]# time tar -zpcv -f /root/etc.tar.gz /etctar: Removing leading `/' from member names  &lt;==注意这个警告讯息/etc/....（中间省略）..../etc/hostname#多了time会显示程序运行时间#加上&quot;-p&quot;选项原因是为了保存原本文件的权限和属性</code></pre><p><em>tar备份默认是没有根目录的,那为什么要拿掉根目录呢？主要是为了安全！我们使用 tar 备份的数据可能会需要解压缩回来使用， 在 tar 所记录的文件名 （就是我们刚刚使用 tar -jtvf 所察看到的文件名） 那就是解压缩后的实际文件名。 如果拿掉了根目录，假设你将备份数据在 /tmp 解开，那么解压缩的文件名就会变成“/tmp/etc/xxx”。 但“如果没有拿掉根目录，解压缩后的文件名就会是绝对路径， 亦即解压缩后的数据一定会被放置到 /etc/xxx 去！”如此一来，你的原本的 /etc/ 下面的数据， 就会被备份数据所覆盖过去了！如果想保存根目录可以使用-P选项</em></p><h3 id="解压tar包内单一文件"><a class="markdownIt-Anchor" href="#解压tar包内单一文件"></a> 解压tar包内单一文件</h3><pre class="highlight"><code class># 1. 先找到我们要的文件名，假设解开 shadow 文件好了：[root@study ~]# tar -jtv -f /root/etc.tar.bz2 | grep 'shadow'---------- root/root       721 2015-06-17 00:20 etc/gshadow---------- root/root      1183 2015-06-17 00:20 etc/shadow----------- root/root      1210 2015-06-17 00:20 etc/shadow  &lt;==这是我们要的！---------- root/root       707 2015-06-17 00:20 etc/gshadow-# 2. 将该文件解开！语法与实际作法如下：[root@study ~]# tar -jxv -f 打包档.tar.bz2 待解开文件名[root@study ~]# tar -jxv -f /root/etc.tar.bz2 etc/shadowetc/shadow[root@study ~]# ll etctotal 4----------. 1 root root 1210 Jun 17 00:20 shadow# 很有趣！此时只会解开一个文件而已！不过，重点是那个文件名！你要找到正确的文件名。# 在本例中，你不能写成 /etc/shadow ！因为记录在 etc.tar.bz2 内的并没有 / 之故！</code></pre><h3 id="tarfile与tarball"><a class="markdownIt-Anchor" href="#tarfile与tarball"></a> tarfile与tarball</h3><p>使用tar打包的文件称为tarfile<br>如果打包文件同时使用压缩则称为tarball.</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式语法</title>
      <link href="2018/01/10/tech_stack/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/"/>
      <url>2018/01/10/tech_stack/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="元字符"><a class="markdownIt-Anchor" href="#元字符"></a> 元字符</h2><table style><tr><th>代码</th><th>说明</th></tr><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></table><h2 id="字符转义"><a class="markdownIt-Anchor" href="#字符转义"></a> 字符转义</h2><p>如果想查找元字符本身的话,就需要将字符转义 如:\* \.</p><h2 id="重复"><a class="markdownIt-Anchor" href="#重复"></a> 重复</h2><table style><tr><th>代码</th><th>说明</th></tr><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></table><h2 id="字符类"><a class="markdownIt-Anchor" href="#字符类"></a> 字符类</h2><p>要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有预定义元字符的字符集合(比如元音字母a,e,i,o,u),应该怎么办？</p><pre class="highlight"><code class>- [aeiou] 匹配元音字母- [0-9] 匹配数字范围0-9(与\d含义一致)- [a-z0-9A-Z_] 匹配字母数字下划线(只考虑英文时,与\w含义一致)</code></pre><p><code>案例1:</code><br>匹配几种电话号码:<br>(010)88886666，或022-22334455，或02912345678</p><pre class="highlight"><code class>\(?0\d&#123;2&#125;[) -]?\d&#123;8&#125;</code></pre><h2 id="分枝条件"><a class="markdownIt-Anchor" href="#分枝条件"></a> 分枝条件</h2><blockquote><p><strong>分枝条件</strong>指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。</p></blockquote><p>观察<code>案例1</code>表达式,发现其匹配存有以下缺陷:<br>能够同时匹配010)12345678或(022-87654321这种不正确的格式.因此,解决这种问题要使用分枝条件,如下:</p><pre class="highlight"><code class>- 0\d&#123;2&#125;-\d&#123;8&#125;|0\d&#123;3&#125;-\d&#123;7&#125;  这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)  - \(0\d&#123;2&#125;\)[- ]?\d&#123;8&#125;|0\d&#123;2&#125;[- ]?\d&#123;8&#125;  这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。  - \d&#123;5&#125;-\d&#123;4&#125;|\d&#123;5&#125;  这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。</code></pre><p><em><strong>注意:</strong></em> 用分枝条件时，要注意各个条件的顺序,上面例子如果改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是<strong>匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了</strong>。</p><h2 id="分组"><a class="markdownIt-Anchor" href="#分组"></a> 分组</h2><p>当想要重复多个字符时,可以使用小括号来指定子表达式(也叫做,分组),然后可以指定子表达式的重复次数.<br><code>案例2</code><br>匹配ip地址:</p><pre class="highlight"><code class>- (\d&#123;1,3&#125;\.)&#123;3&#125;\d&#123;1,3&#125; 简单的ip地址匹配,缺陷是会匹配到256.300.888.999这种不可能存在的IP地址- ((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)精确匹配ip地址,由于正则不支持算术比较,所以只能使用冗长的分组和分枝条件</code></pre><h2 id="反义"><a class="markdownIt-Anchor" href="#反义"></a> 反义</h2><blockquote><p>有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到<strong>反义</strong></p></blockquote><table style><tr><th>代码</th><th>说明</th></tr><tr><td>\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></table><h2 id="后向引用"><a class="markdownIt-Anchor" href="#后向引用"></a> 后向引用</h2><blockquote><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p></blockquote><p><strong>后向引用</strong>用于<strong>重复搜索</strong>前面某个分组匹配的文本。例如，\1代表分组1匹配的文本.<br><code>案例3</code><br>匹配重复的单词</p><pre class="highlight"><code class>- \b(\w+)\b\s+\1\b 匹配go go或kitty kitty这类单词(\1代表第一个分组)</code></pre><p><em><strong>组名也可以自定义,语法如下:</strong></em><br>(?&lt;name&gt;exp)<br>案例3变形如下:</p><pre class="highlight"><code class>- \b(?&lt;Word&gt;\w+)\b\s+\k&lt;Word&gt;\b注意:\k&lt;name&gt;表示使用定义的别名后向引用其它用法总结:</code></pre><table style><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr><tr><td rowspan="3">捕获</td><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td>(?&lt;name&gt;exp)</td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)</td></tr><tr><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号(一般用于只验证规则,不需要捕获内容)</td></tr><tr><td rowspan="2">零宽断言</td><td>(?=exp)</td><td>匹配exp前面的位置</td></tr><tr><td>(?<=exp)< td><td>匹配exp后面的位置</td></=exp)<></td></tr><tr>   <td rowspan="2">负向零宽断言</td><td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td></tr><tr><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td></tr><tr><td>注释</td><td>(?#comment)</td><td>此类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></table>`案例4`匹配以 ing 结尾的单词前面的部分(除 ing 以外部分)<pre class="highlight"><code class>going\w+(?=ing) 零宽断言go</code></pre><h2 id="贪婪与懒惰"><a class="markdownIt-Anchor" href="#贪婪与懒惰"></a> 贪婪与懒惰</h2><blockquote><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符.如:<br><em><em>a.<em>b</em></em>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为</em><em>贪婪匹配</em>*。<br>相反,有时需要尽可能少的匹配,称为<strong>懒惰匹配</strong>,语法是在表达式之后加一个?.同上面表达式变成懒惰匹配 : <strong>a.*?b</strong></p></blockquote><table style><tr><th>代码/语法</th><th>说明</th></tr><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr></table><h2 id="修饰符标记"><a class="markdownIt-Anchor" href="#修饰符标记"></a> 修饰符(标记)</h2><p>正则表达式的标记用于指定额外的匹配策略。标记不写在正则表达式里，标记位于表达式之外。</p><p><code>格式：/pattern/flags</code></p><table><tr><th style="width: 150px;">修饰符</th><th>说明</th></tr><tr><td>i</td><td>(ignore)忽略大小写。</td></tr><tr><td>g</td><td>全局匹配。默认正则过程中字符串从左到右匹配，找到第一个符合条件的即匹配成功。使用该修饰符，查找所有匹配项。</td></tr><tr><td>m</td><td>多行模式，边界字符 `^` 和 `$` 匹配每一行的开头和结尾，而不是整个字符串的开头和结尾。</td></tr><tr><td>s</td><td>`“.”`表达式包含换行符`“\n”`。默认情况下的`"."` 是 匹配除换行符 `"\n"` 之外的任何字符，加上 `s` 修饰符之后包含换行符 `"\n"`。</td></tr><tr><td>u</td><td>完整的 unicode 支持。默认正则不支持四个字节的 UTF-16 编码，会将其识别为两个字符。该修饰符将会正确识别为一个字符，建议汉字匹配都加上该修饰符。</td></tr><tr><td>y</td><td>（sticky）“粘连”修饰符，与`g`类似也是全局匹配，不同之处在于，`g`修饰符只要剩余位置中存在匹配就可，而`y`修饰符确保匹配必须从剩余的第一个位置开始。有些实现需要与`g`一起使用才可全局匹配。</td></tr></table><pre class="highlight"><code class="regex"># u 修饰符/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true/^\uD83D/u.test('\uD83D\uDC2A') // false/^\uD83D/.test('\uD83D\uDC2A') // true# y 修饰符字符串：a_a_a_a_aa_a_a_正则：/a_/gy匹配结果：a_a_a_a_</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>例行性工作调度</title>
      <link href="2017/12/11/Linux/%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%E8%B0%83%E5%BA%A6/"/>
      <url>2017/12/11/Linux/%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="循环性执行的例行性工作调度"><a class="markdownIt-Anchor" href="#循环性执行的例行性工作调度"></a> 循环性执行的例行性工作调度</h2><p>循环执行的例行性工作调度由cron(crond)服务 控制.Lnux上有非常多的例行性工作,因此这个服务是默认启动的.</p><ul><li>使用者的设置</li></ul><pre class="highlight"><code class>/etc/cron.allow 允许使用crontab的用户/etc/cron.deny 不允许使用crontab的用户allow优先级优于deny</code></pre><span id="more"></span><blockquote><p>当用户使用crontab指令创建工作调度之后,该项工作被纪录到/var/spool/cron里,而且是以账号作为判别的.如:用Windus使用后会纪录到/var/spool/cron/Windus<code>注意:不要使用vim编辑该文件,可能由于输入法错误导致无法执行cron</code><br>另外,cron执行的每一项任务都纪录到/var/log/cron中.</p></blockquote><pre class="highlight"><code class>[root@study ~]# crontab [-u username] [-l|-e|-r]选项与参数：-u  ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作调度；-e  ：编辑 crontab 的工作内容-l  ：查阅 crontab 的工作内容-r  ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。</code></pre><h3 id="字段意义"><a class="markdownIt-Anchor" href="#字段意义"></a> 字段意义</h3><p><strong>每项工作格式都有六个字段,意义为:</strong></p><table><thead><tr><th>代表意义</th><th style="text-align:center">分</th><th style="text-align:center">时</th><th style="text-align:center">日期</th><th style="text-align:center">月</th><th style="text-align:center">周</th><th style="text-align:center">指令</th></tr></thead><tbody><tr><td>数字范围</td><td style="text-align:center">0~59</td><td style="text-align:center">0~23</td><td style="text-align:center">1~31</td><td style="text-align:center">1~12</td><td style="text-align:center">0~7</td><td style="text-align:center">执行指令</td></tr></tbody></table><p><code>注意:周指令0和7都代表星期天</code></p><table style="width:100%;margin-top:-500px;"><thead><tr><th colspan="2" style="text-align:center;">特殊字符</th></tr></thead><tr><th style="text-align:center;width:60px;">字符</th><th style="text-align:center">意义</th></tr><tr><th>\*(星号)</th><td>代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 * ， 就代表着“不论何月、何日的礼拜几的 12:00 都执行后续指令”的意思！</td></tr><tr><th>,(逗号)</th><td>代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是：0 3,6 * * * command时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！</td></tr><tr><th>-(减号)</th><td>代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作：20 8-12 * * * command仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！</td></tr><tr><th>/n(斜线)</th><td>那个 n 代表数字，亦即是“每隔 n 单位间隔”的意思，例如每五分钟进行一次，则：*/5 * * * * command 用 * 与 /5 来搭配，也可以写成 0-59/5 ，相同意思!</td></tr></table> <ul><li>crond服务读取配置文件位置</li></ul><pre class="highlight"><code class>- /etc/crontab- /etc/cron.d/*- /var/spool/cron/*前两个跟系统有关的配置文件,后一个跟用户有关</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘与文件管理</title>
      <link href="2017/09/29/Linux/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>2017/09/29/Linux/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="ext2文件系统"><a class="markdownIt-Anchor" href="#ext2文件系统"></a> EXT2文件系统</h2><p><img src="/2017/09/29/Linux/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/QQ20180117-095156@2x.png" alt="ext2文件系统示意图"><span class="image-caption">ext2文件系统示意图</span></p><span id="more"></span><h3 id="data-block-用来放置文件内容数据的地方在ext2文件系统中支持block大小有1k-2k-4k"><a class="markdownIt-Anchor" href="#data-block-用来放置文件内容数据的地方在ext2文件系统中支持block大小有1k-2k-4k"></a> data block 用来放置文件内容数据的地方.在EXT2文件系统中支持block大小有1k 2k 4k.</h3><blockquote><p>每个block大小在与数量在格式化完成后就确定,不能再改变了.(<strong>除非格式化或使用resize2fs等指令变更文件系统大小</strong>)<br>每个block最多只能放一个文件<br>如果文件大于block大小,那文件会占用多个block<br>如果文件大小小于block,那么剩余容量就不能再使用了(磁盘空间会浪费).</p></blockquote><h3 id="inode-table"><a class="markdownIt-Anchor" href="#inode-table"></a> inode table</h3><ul><li>记录内容:</li></ul><blockquote><p>该文件的存取模式（read/write/excute）<br>该文件的拥有者与群组（owner/group）<br>该文件的容量<br>该文件创建或状态改变的时间（ctime）<br>最近一次的读取时间（atime）<br>最近修改的时间（mtime）<br>定义文件特性的旗标（flag），如 SetUID…<br>该文件真正内容的指向 （pointer）<br>不记录文件名(文件名记录在block上)</p></blockquote><ul><li>特点:</li></ul><blockquote><p>每个 inode 大小均固定为 128 Bytes（新的 ext4 与 xfs 可设置到 256 Bytes）<br>每个文件都仅会占用一个 inode 而已<br>承上，因此文件系统能够创建的文件数量与 inode 的数量有关<br>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用者是否符合，若符合才能够开始实际读取 block 的内容。</p></blockquote><p><img src="/2017/09/29/Linux/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/QQ20180109-160713@2x.png" alt="inode结构示意图"><span class="image-caption">inode结构示意图</span></p><p><em><strong>inode要记录的数据特别多,而只有128Bytes.inode记录一个block号码要4Byte,所以大文件一个inode肯定是不够用的.为此,inode记录block号码区域定义了12个直接,一个间接,一个双间接,一个三间接记录区.</strong></em></p><blockquote><p>如上图,最左边为 inode 本身 （128 Bytes），里面有 12 个直接指向 block 号码的对照，这 12 笔记录就能够直接取得 block 号码啦！ 至于所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果文件太大时， 就会使用间接的 block 来记录号码。如上图 7.1.4 当中间接只是拿一个 block 来记录额外的号码而已。 同理，如果文件持续长大，那么就会利用所谓的双间接，第一个 block 仅再指出下一个记录号码的 block 在哪里， 实际记录的在第二个 block 当中。依此类推，三间接就是利用第三层 block 来记录号码啦！</p></blockquote><pre class="highlight"><code class>inode指定block大小计算(block为1k):- 12 个直接指向： 12*1K=12K  由于是直接,12所以总共可以记录12笔- 1  个间接： 256*1K=256K  每笔 block 号码的记录会花去 4Bytes，因此 1K 的大小能够记录 256 笔记录- 1  个双间接: 256*256*1K=2562K  第一层 block 会指定256个第二层,每个第二层可以指定 256个号码- 1  个三间接： 256*256*256*1K=2563K  第一层 block 会指定256个第二层,每个第二层可以指定256个第三层，每个第三层可以指定 256 个号码得到:12 + 256 + 256*256 + 256*256*256 （K） = 16GB上面方法不能用在2k及4k block大小计算中,因为大于2k block将会受到EXT2文件系统本身的限制,所以计算结果会不太符合之故.</code></pre><h3 id="super-block-记录整个文件系统信息没有它就没有文件系统"><a class="markdownIt-Anchor" href="#super-block-记录整个文件系统信息没有它就没有文件系统"></a> super block 记录整个文件系统信息,没有它就没有文件系统</h3><ul><li>记录信息</li></ul><blockquote><p>block 与 inode 的总量<br>未使用与已使用的 inode / block 数量<br>block 与 inode 的大小（block为1,2,4K,inode为 128Bytes或 256Bytes）<br>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 （fsck） 的时间等文件系统的相关信息<br>一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1</p></blockquote><p><em>superblock大小为1024Bytes,文件系统除了第一个block group含有superblock以外,后续的block group都不一定含有supperblock,若含有则是对第一个block group的备份.</em></p><h3 id="block-bitmap-区块对照表"><a class="markdownIt-Anchor" href="#block-bitmap-区块对照表"></a> block bitmap (区块对照表)</h3><p>文件修改时,记录block是否被占用.</p><h3 id="inode-bitmap-inode对照表"><a class="markdownIt-Anchor" href="#inode-bitmap-inode对照表"></a> inode bitmap (inode对照表)</h3><p>与block bitmap功能类似,记录inode占用情况.</p><h3 id="filesystem-description-文件系统描述说明"><a class="markdownIt-Anchor" href="#filesystem-description-文件系统描述说明"></a> Filesystem Description （文件系统描述说明）</h3><p>这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 （superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间。</p><h4 id="dumpe2fs-查询-ext-家族-superblock-信息的指令"><a class="markdownIt-Anchor" href="#dumpe2fs-查询-ext-家族-superblock-信息的指令"></a> dumpe2fs 查询 Ext 家族 superblock 信息的指令</h4><blockquote><p>由于目前centos7以xfs为默认文件系统,所以这个指令无法使用.</p></blockquote><pre class="highlight"><code class>[root@study ~]# dumpe2fs [-bh] 设备文件名选项与参数：-b ：列出保留为坏轨的部分（一般用不到吧！？）-h ：仅列出 superblock 的数据，不会列出其他的区段内容！ </code></pre><hr><h3 id="目录树的操作"><a class="markdownIt-Anchor" href="#目录树的操作"></a> 目录树的操作</h3><p>由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的 inode 号码，此时就能够得到根目录的 inode 内容，并依据该 inode 读取根目录的 block 内的文件名数据，再一层一层的往下读到正确的文件名。</p><ul><li>读取步骤</li></ul><pre class="highlight"><code class>[root@study ~]# ll -di / /etc /etc/passwd  128 dr-xr-xr-x.  17 root root 4096 May  4 17:56 /33595521 drwxr-xr-x. 131 root root 8192 Jun 17 00:20 /etc36628004 -rw-r--r--.   1 root root 2092 Jun 17 00:20 /etc/passwd</code></pre><ol><li><p>/ 的 inode：<br>通过挂载点的信息找到 inode 号码为 128 的根目录 inode，且 inode 规范的权限让我们可以读取该 block 的内容（有 r 与 x） ；</p></li><li><p>/ 的 block：<br>经过上个步骤取得 block 的号码，并找到该内容有 etc/ 目录的 inode 号码 （33595521）；</p></li><li><p>etc/ 的 inode：<br>读取 33595521 号 inode 得知 dmtsai 具有 r 与 x 的权限，因此可以读取 etc/ 的 block 内容；</p></li><li><p>etc/ 的 block：<br>经过上个步骤取得 block 号码，并找到该内容有 passwd 文件的 inode 号码 （36628004）；</p></li><li><p>passwd 的 inode：<br>读取 36628004 号 inode 得知 dmtsai 具有 r 的权限，因此可以读取 passwd 的 block 内容;</p></li><li><p>passwd 的 block：<br>最后将该 block 内容的数据读出来。</p></li></ol><ul><li>写步骤</li></ul><ol><li>先确定使用者对于欲新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增；</li><li>根据 inode bitmap 找到没有使用的 inode 号码，并将新文件的权限/属性写入；</li><li>根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode 的 block 指向数据；</li><li>将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap，并更新 superblock 的内容。</li></ol><h3 id="日志式文件系统"><a class="markdownIt-Anchor" href="#日志式文件系统"></a> 日志式文件系统</h3><p>由于各种情况,可能造成数据发生问题,导致写入数据只有inode/block,而缺失bitmap,此时发生metadata与实际数据存放区产生不一致的情况.<br>在早期的 Ext2 文件系统中，如果发生这个问题， 那么系统在重新开机的时候，就会借由 Superblock 当中记录的 valid bit （是否有挂载） 与 filesystem state （clean 与否） 等状态来判断是否强制进行数据一致性的检查！若有需要检查时则以 e2fsck 这支程序来进行的。<br>因为要针对metadata区域和实际数据存放区域进行比对,所以非常耗时.<br>为了避免上述问题的发生,应运而生了日志文件系统,具体执行步骤:</p><ol><li>预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息；</li><li>实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据；</li><li>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。</li></ol><p><em>在这样的程序当中，万一数据的纪录过程当中发生了问题，那么我们的系统只要去检查日志记录区块， 就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整块 filesystem 去检查， 这样就可以达到快速修复 filesystem 的能力</em></p><h2 id="xfs文件系统"><a class="markdownIt-Anchor" href="#xfs文件系统"></a> XFS文件系统</h2><p><em>EXT文件系统目前对于格式化处理,采用预先规划出inode/block/meta data等数据,未来系统可以直接使用,由于现在硬盘越来越大,所以格式化越来越慢.因此,从centos7.x开始文件系统已默认更换成XFS这个比较适合大容量磁盘与巨型文件,性能较佳的文件系统了.</em></p><hr><p>基本止,xfs就是一个日志文件系统,最早之前它就是被开发来用于大容量磁盘以及高性能文件系统之用.Ext4几乎所有的功能xfs都具备.<br>xfs文件系统在数据分布上,主要规划三个部分:一个数据区(data section),一个文件系统活动登录区(log section),一个实时运行区(realtime section).</p><h3 id="数据区data-section"><a class="markdownIt-Anchor" href="#数据区data-section"></a> 数据区(data section)</h3><p>基本上,数据区和Ext文件系统一样,包括inode/data block/superblock等数据,都放在这个区块.这个数据区与Ext家族的block group类似,也是分为多个存储区群组(allocation groups)来分别放置文件系统所要的数据.每个存储区群组都包含了(1)整个文件系统的superblock(2)剩余空间管理机制(3)inode的分配与追踪.此外，inode与 block 都是系统需要用到时， 这才动态配置产生，所以格式化动作超级快！</p><blockquote><p>另外，与 ext 家族不同的是， xfs 的 block 与 inode 有多种不同的容量可供设置，block 容量可由 512Bytes ~ 64K 调配，不过，Linux 的环境下， 由于内存控制的关系 （分页档 pagesize 的容量之故），因此最高可以使用的 block 大小为 4K 而已！（尝试格式化 block 成为 16K 是没问题的，不过，Linux 核心不给挂载！ 所以格式化完成后也无法使用啦！） 至于 inode 容量可由 256Bytes 到 2M 这么大！不过，大概还是保留 256Bytes 的默认值就很够用了！</p></blockquote><h3 id="文件系统活动登录区log-section"><a class="markdownIt-Anchor" href="#文件系统活动登录区log-section"></a> 文件系统活动登录区(log section)</h3><p>这个区域主要用来被记录文件系统的变化,其实有点像日志区.</p><h3 id="实时运行区realtime-section"><a class="markdownIt-Anchor" href="#实时运行区realtime-section"></a> 实时运行区(realtime section)</h3><p>当有文件被创建时,xfs会在这个区域找一个到数个extent区块,将文件放置在这个区块内,等分配完毕后再写入data section的inode与block中去.<br>这个extent区块大小要在格式化时候指定,最小值4K,最大可到1G.<br>一般非磁盘阵列的磁盘默认64K,而具有磁盘阵列的情况下,则建议extent设置为与stripe一样大较佳.</p><pre class="highlight"><code class>xfs文件系统的描述数据观察:#找出系统 /boot 这个挂载点下面的文件系统的 superblock 纪录 [root@study ~]# df -T /bootFilesystem   Type 1K-blocks   Used Available Use% Mounted on/dev/vda2     xfs    1038336 133704    904632  13% /boot[root@study ~]# xfs_info /dev/vda2 </code></pre><ul><li>df命令<br>列出文件系统的整体磁盘使用量</li></ul><pre class="highlight"><code class>[root@study ~]# df [-ahikHTm] [目录或文件名]选项与参数：-a  ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k  ：以 KBytes 的容量显示各文件系统；-m  ：以 MBytes 的容量显示各文件系统；-h  ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H  ：以 M=1000K 取代 M=1024K 的进位方式；-T  ：连同该 partition 的 filesystem 名称 （例如 xfs） 也列出；-i  ：不用磁盘容量，而以 inode 的数量来显示</code></pre><ul><li>du命令<br>评估文件系统的磁盘使用量（常用在推估目录所占容量）</li></ul><pre class="highlight"><code class>[root@study ~]# du [-ahskm] 文件或目录名称选项与参数：-a  ：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已。-h  ：以人们较易读的容量格式 （G/M） 显示；-s  ：列出总量而已，而不列出每个各别的目录占用容量；-S  ：不包括子目录下的总计，与 -s 有点差别。-k  ：以 KBytes 列出容量显示；-m  ：以 MBytes 列出容量显示；</code></pre><p><em>df 主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在 Superblock 内的信息， 所以这个指令显示结果的速度非常的快速.</em><br><em>du 这个指令其实会直接到文件系统内去搜寻所有的文件数据，这个指令的会执行一小段时间！</em></p><ul><li>Hard Link （实体链接, 硬式链接或实际链接）<br>由于每个文件都占用一个inode,文件内容由inode记录指向,想要读取文件必须经过目录记录的文件名来指向到正确的inode号码才能读取.也就是说,其实文件名只与目录有关,但是文件内容则与inode有关.<br>如果有多个文件名对应一个inode,那就是实体链接的由来.<br><strong>限制:</strong></li></ul><blockquote><ul><li>不能跨FileSystem</li><li>不能link目录</li></ul></blockquote><p><em>如果hard link到链接到目录时,链接的数据需要连同被链接目录下面的所有数据都创建链接，举例来说，如果你要将 /etc 使用实体链接创建一个 /etc_hd 的目录时，那么在 /etc_hd 下面的所有文件名同时都与 /etc 下面的文件名要创建 hard link 的，而不是仅链接到 /etc_hd 与 /etc 而已。 并且，未来如果需要在 /etc_hd 下面创建新文件时，连带的， /etc 下面的数据又得要创建一次 hard link ，因此造成环境相当大的复杂度.所以啰，目前 hard link 对于目录暂时还是不支持的啊！</em></p><ul><li>Symbolic Link(符号链接)<br>Symbolic link 就是在创建一个独立的文件，而这个文件会让数据的读取指向他 link 的那个文件的文件名！由于只是利用文件来做为指向的动作， 所以，当来源文件被删除之后，symbolic link 的文件会“开不了”， 会一直说“无法打开某文件！”。实际上就是找不到原始“文件名”而已啦！</li></ul><pre class="highlight"><code class>[root@study ~]# ln -s /etc/crontab crontab2[root@study ~]# ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10  2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root  12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab</code></pre><p>上面结果我们可以知道两个文件指向不同的 inode 号码，当然就是两个独立的文件存在！ 而且链接文件的重要内容就是他会写上目标文件的“文件名”， 你可以发现为什么上表中链接文件的大小为 12 Bytes 呢？ 因为箭头（–&gt;）右边的文件名“/etc/crontab”总共有 12 个英文，每个英文占用 1 个 Bytes ，所以文件大小就是 12Bytes了！</p><ul><li>ln命令</li></ul><pre class="highlight"><code class>[root@study ~]# ln [-sf] 来源文件 目标文件选项与参数：-s  ：如果不加任何参数就进行链接，那就是hard link，至于 -s 就是symbolic link-f  ：如果 目标文件 存在时，就主动的将目标文件直接移除后再创建！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件与目录管理</title>
      <link href="2017/09/13/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
      <url>2017/09/13/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="目录相关操作"><a class="markdownIt-Anchor" href="#目录相关操作"></a> 目录相关操作</h2><blockquote><p>.         代表此层目录<br>…        代表上一层目录</p></blockquote><ul><li><pre><code>    代表前一个工作目录  </code></pre></li></ul><p>~         代表“目前使用者身份”所在的主文件夹<br>~account  代表 account 这个使用者的主文件夹（account是个帐号名称）</p><span id="more"></span><h3 id="pwd命令"><a class="markdownIt-Anchor" href="#pwd命令"></a> pwd命令</h3><pre class="highlight"><code class="bash"><span class="hljs-comment">#显示所在目录</span>root@study ~]<span class="hljs-comment"># pwd [-P]</span>-P  ：显示出确实的路径，而非使用链接 （link） 路径。[root@study mail]<span class="hljs-comment"># ls -ld /var/mail</span>lrwxrwxrwx. 1 root root 10 May  4 17:51 /var/mail -&gt; spool/mail[root@study ~]<span class="hljs-comment"># cd /var/mail   </span>[root@study mail]<span class="hljs-comment"># pwd</span>/var/mail         &lt;==列出目前的工作目录[root@study mail]<span class="hljs-comment"># pwd -P</span>/var/spool/mail   </code></pre><h3 id="mkdir-创建目录"><a class="markdownIt-Anchor" href="#mkdir-创建目录"></a> mkdir  创建目录</h3><pre class="highlight"><code class="bash">root@study ~]<span class="hljs-comment"># mkdir [-p] 目录名</span>-p : 创建层级目录mkdir -p /home/windus/<span class="hljs-built_in">test</span>/linux</code></pre><h3 id="ls命令"><a class="markdownIt-Anchor" href="#ls命令"></a> ls命令</h3><pre class="highlight"><code class="bash">选项与参数：-a  ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）-A  ：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录-d  ：仅列出目录本身，而不是列出目录内的文件数据（常用）-f  ：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）-F  ：根据文件、目录等信息，给予附加数据结构，例如：      *:代表可可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；-h  ：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；-i  ：列出 inode 号码，inode 的意义下一章将会介绍；-l  ：长数据串行出，包含文件的属性与权限等等数据；（常用）字段说明:1.文件属性：drwxr-xr-x2.文件硬链接数量 33.所有者：user4.所属用户组：group5.文件大小：102 byte6.修改时间：Mar11　22:567.文件名：Filename-n  ：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）-r  ：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；-R  ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；-S  ：以文件大小大小排序，而不是用文件名排序；-t  ：依时间排序，而不是用文件名。--color=never  ：不要依据文件特性给予颜色显示；--color=always ：显示颜色--color=auto   ：让系统自行依据设置来判断是否给予颜色--full-time    ：以完整时间模式 （包含年、月、日、时、分） 输出--time=&#123;atime,ctime&#125; ：输出 access 时间或改变权限属性时间 （ctime）而非内容变更时间 （modification time）</code></pre><h3 id="cp命令"><a class="markdownIt-Anchor" href="#cp命令"></a> cp命令</h3><pre class="highlight"><code class>选项与参数:-a  ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；（常用）-d  ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；-i  ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）-l  ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；-p  ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；-r  ：递回持续复制，用于目录的复制行为；（常用）-s  ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；-u  ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。</code></pre><h3 id="rmdir命令"><a class="markdownIt-Anchor" href="#rmdir命令"></a> rmdir命令</h3><pre class="highlight"><code class>root@study ~]# rmdir [-p] 目录名称选项与参数：-p ：连同“上层”“空的”目录也一起删除</code></pre><h3 id="rm命令"><a class="markdownIt-Anchor" href="#rm命令"></a> rm命令</h3><blockquote><p>1.在指令前加上反斜线，可以忽略掉 alias 的指定选项喔！<strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></strong><br>2.删除一个带有 - 开头的文件。（因为“－”是选项,所以系统误判了！</p></blockquote><pre class="highlight"><code class>#错误[root@study tmp]# rm -aaa-rm: invalid option -- 'a‘#正确 rm --help查找[root@study tmp]# rm ./-aaa-[root@study tmp]# rm -- -aaa- </code></pre><h3 id="mv命令"><a class="markdownIt-Anchor" href="#mv命令"></a> mv命令</h3><pre class="highlight"><code class>选项与参数：-f  ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i  ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！-u  ：若目标文件已经存在，且 source 比较新，才会更新 （update）</code></pre><blockquote><p>特殊用处:<br>1.文件更名(类似命令rename)<br>2.可同时移动多个文件到同一目录</p></blockquote><h3 id="rename命令"><a class="markdownIt-Anchor" href="#rename命令"></a> rename命令</h3><pre class="highlight"><code class>参数:原字符串：将文件名需要替换的字符串；   目标字符串：将文件名中含有的原字符替换成目标字符串； 文件：指定要改变文件名的文件列表#[root@study tmp]# rename .htm .html *.htm</code></pre><h3 id="basename"><a class="markdownIt-Anchor" href="#basename"></a> basename</h3><p>获取文件/目录名</p><pre class="highlight"><code class>选项:-a, --multiple       support multiple arguments and treat each as a NAME-s, --suffix=SUFFIX  remove a trailing SUFFIX-z, --zero           separate output with NUL rather than newline  #例子basename /usr/bin/sort          -&gt; &quot;sort&quot;basename include/stdio.h .h     -&gt; &quot;stdio&quot;basename -s .h include/stdio.h  -&gt; &quot;stdio&quot;basename -a any/str1 any/str2   -&gt; &quot;str1&quot; followed by &quot;str2&quot;</code></pre><h3 id="dirname"><a class="markdownIt-Anchor" href="#dirname"></a> dirname</h3><pre class="highlight"><code class>#例子dirname /usr/bin/          -&gt; &quot;/usr&quot;dirname dir1/str dir2/str  -&gt; &quot;dir1&quot; followed by &quot;dir2&quot;dirname stdio.h            -&gt; &quot;.&quot;</code></pre><h2 id="文件内容审阅"><a class="markdownIt-Anchor" href="#文件内容审阅"></a> 文件内容审阅</h2><h3 id="cat命令"><a class="markdownIt-Anchor" href="#cat命令"></a> cat命令</h3><p><em>由第一行开始显示内容(与tac相反)</em></p><pre class="highlight"><code class>选项与参数：-A  ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；-b  ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E  ：将结尾的断行字符 $ 显示出来；-n  ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；-T  ：将 [tab] 按键以 ^I 显示出来；-v  ：列出一些看不出来的特殊字符</code></pre><h3 id="nl指令"><a class="markdownIt-Anchor" href="#nl指令"></a> nl指令</h3><p><em>添加行号打印,默认不打印空行行号.“其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能呢。</em></p><pre class="highlight"><code class>nl [选项]... [文件]...-b  ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；-n  ：列出行号表示的方法，主要有三种：-n ln ：行号在萤幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；-w  ：行号栏位的占用的位数。(与-n ln 或 -n rz配合使用)-p 在逻辑定界符处不重新开始计算。$ nl -n ln -w 3 test.txt</code></pre><h3 id="可翻页检视-more-less"><a class="markdownIt-Anchor" href="#可翻页检视-more-less"></a> 可翻页检视 more / less</h3><p><em>两者区别在于前者不能向前翻页(管线操作),后者可以向前翻页并支持更多其它操作</em></p><h3 id="数据撷取"><a class="markdownIt-Anchor" href="#数据撷取"></a> 数据撷取</h3><ul><li>head 撷取前面几行</li><li>tail 取出后几行,默认10行<br><em><strong>注意:当用-f |grep 选项时,默认会有缓存区不能及时显示可加–line-buffered</strong></em></li></ul><pre class="highlight"><code class>例题：假如我想要显示 /etc/man_db.conf 的第 11 到第 20 行呢？head -n 20 /etc/man_db.conf | tail -n 10 </code></pre><h3 id="非纯文本文件-od"><a class="markdownIt-Anchor" href="#非纯文本文件-od"></a> 非纯文本文件　od</h3><pre class="highlight"><code class>选项或参数：-t  ：后面可以接各种“类型 （TYPE）”的输出，例如：      a       ：利用默认的字符来输出；      c       ：使用 ASCII 字符来输出      d[size] ：利用十进制（decimal）来输出数据，每个整数占用 size Bytes ；      f[size] ：利用浮点数值（floating）来输出数据，每个数占用 size Bytes ；      o[size] ：利用八进位（octal）来输出数据，每个整数占用 size Bytes ；      x[size] ：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes ；</code></pre><blockquote><p>如果对纯文本文件使用这个指令，你甚至可以发现到 ASCII 与字符的对照表！<br>例题：想要立刻找到 password 这几个字的 ASCII 对照，该如何通过 od 来判断？<br>答：<br>echo password | od -t oCc</p></blockquote><h3 id="文件时间"><a class="markdownIt-Anchor" href="#文件时间"></a> 文件时间</h3><ul><li>modification time （mtime）：<br>当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！</li><li>status time （ctime）：<br>当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。</li><li>access time （atime）：<br>当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。</li></ul><h3 id="修改文件时间-touch命令"><a class="markdownIt-Anchor" href="#修改文件时间-touch命令"></a> 修改文件时间 touch命令</h3><pre class="highlight"><code class>选项与参数：-a  ：仅修订 access time；-c  ：仅修改文件的时间，若该文件不存在则不创建新文件；-d  ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;-m  ：仅修改 mtime ；-t  ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]. </code></pre><p><em>该命令也可用来新建文件</em></p><h3 id="file命令"><a class="markdownIt-Anchor" href="#file命令"></a> file命令</h3><p><em>查看某个文件的基本数据类型,如:ASCII/data文件/binary文件等等信息,也可用来判断tar包文件是用哪种压缩功能打包的.</em></p><p>##文件与文件夹权限<br><em>在Linux传统的Ext2/Ext3/Ext4文件系统下，我们还可以设置其他的系统隐藏属性， 这部份可使用 chattr 来设置，而以 lsattr 来查看，最重要的属性就是可以设置其不可修改的特性！让连文件的拥有者都不能进行修改！ 这个属性可是相当重要的，尤其是在安全机制上面 （security）！比较可惜的是，在 CentOS 7.x 当中利用 xfs 作为默认文件系统， 但是 xfs 就没有支持所有的 chattr 的参数了！仅有部份参数还有支持而已！</em></p><h3 id="文件默认权限-umask"><a class="markdownIt-Anchor" href="#文件默认权限-umask"></a> 文件默认权限 umask</h3><p><em><strong>umask 的分数指的是“该默认值需要减掉的权限！</strong></em></p><ul><li><p>若使用者创建为“文件”则默认“没有可执行（ x ）权限”，亦即只有 rw 这两个项目，也就是最大为 666 分，默认权限如下：-rw-rw-rw-</p></li><li><p>若使用者创建为“目录”，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为 777 分，默认权限如下：drwxrwxrwx</p></li></ul><pre class="highlight"><code class>[root@study ~]# umask0022             &lt;==与一般权限有关的是后面三个数字！[root@study ~]# umask -Su=rwx,g=rx,o=rx  [root@study ~]# umask 022 &lt;==设置默认权限</code></pre><h3 id="文件隐藏属性-chattr"><a class="markdownIt-Anchor" href="#文件隐藏属性-chattr"></a> 文件隐藏属性 chattr</h3><p><em>chattr指令只能在Ext2/Ext3/Ext4的 Linux 传统文件系统上面完整生效， 其他的文件系统可能就无法完整的支持这个指令了，例如 xfs 仅支持部份参数而已</em></p><pre class="highlight"><code class>[root@study ~]# chattr [+-=][ASacdistu] 文件或目录名称选项与参数：+   ：增加某一个特殊参数，其他原本存在参数则不动。-   ：移除某一个特殊参数，其他原本存在参数则不动。=   ：设置一定，且仅有后面接的参数A  ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改，     可避免 I/O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）S  ：一般文件是非同步写入磁盘的（原理请参考前一章sync的说明），如果加上 S 这个属性时，当你进行任何文件的修改，该更动会“同步”写入磁盘中。a  ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性c  ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩，     但是在储存的时候，将会先进行压缩后再储存（看来对于大文件似乎蛮有用的！）d  ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份i  ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！    对于系统安全性有相当大的助益！只有 root 能设置此属性s  ：当文件设置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间，     所以如果误删了，完全无法救回来了喔！u  ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中，     可以使用来救援该文件喔！注意1：属性设置常见的是 a 与 i 的设置值，而且很多设置值必须要身为 root 才能设置注意2：xfs 文件系统仅支持 AadiS 而已</code></pre><h3 id="显示文件隐藏属性-lsattr"><a class="markdownIt-Anchor" href="#显示文件隐藏属性-lsattr"></a> 显示文件隐藏属性 lsattr</h3><pre class="highlight"><code class>root@study ~]# lsattr [-adR] 文件或目录选项与参数：“-a ：将隐藏文件的属性也秀出来；-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；-R ：连同子目录的数据也一并列出来！ [root@study tmp]# chattr +aiS attrtest[root@study tmp]# lsattr attrtest--S-ia---------- attrtest</code></pre><h3 id="文件特殊权限"><a class="markdownIt-Anchor" href="#文件特殊权限"></a> 文件特殊权限</h3><h4 id="set-uid-suid权限"><a class="markdownIt-Anchor" href="#set-uid-suid权限"></a> Set UID -&gt; SUID权限</h4><pre class="highlight"><code class="bash">[root@study ~]<span class="hljs-comment"># ls -l /usr/bin/passwd</span>-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /usr/bin/</code></pre><blockquote><p>注意:上面passwd指令,一般账号没有写入权限,为什么一般账号还能修改密码呢?<br>这就是USID的功能了（注意拥有者的“s”）:<br>1、dmtsai 对于 /usr/bin/passwd 这个程序来说是<strong>具有 x 权限</strong>的，表示 dmtsai 能执行 passwd；<br>2、passwd 的拥有者是 root 这个帐号；<br>3、dmtsai 执行 passwd 的过程中，会“暂时”获得 root 的权限；<br>4、/etc/shadow 就可以被 dmtsai 所执行的 passwd 所修改。<br>如果一般用户用cat去读取/etc/shadow时,会提示权限不够,因为cat指令没有SUID权限。<strong>另外SUID只对二进制程序有用,不能用于shell脚本。</strong></p></blockquote><h4 id="set-gid-sgid权限"><a class="markdownIt-Anchor" href="#set-gid-sgid权限"></a> Set GID -&gt; SGID权限</h4><p><em>与SUID类似，当s标志在文件群组的x位置时，则称为SGID</em></p><pre class="highlight"><code class>[root@study ~]# ll /usr/bin/locate /var/lib/mlocate/mlocate.db-rwx--s--x. 1 root slocate   40496 Jun 10  2014 /usr/bin/locate-rw-r-----. 1 root slocate 2349055 Jun 15 03:44 /var/lib/mlocate/mlocate.db</code></pre><blockquote><p>使用 dmtsai 这个帐号去执行 locate 时，那 dmtsai 将会取得 slocate 群组的支持， 因此就能够去读取 mlocate.db 啦</p></blockquote><p>除了 binary program 之外，事实上 SGID 也能够用在目录上，这也是非常常见的一种用途！ 当一个目录设置了 SGID 的权限后，他将具有如下的功能：</p><ul><li>使用者若对于此目录具有 r 与 x 的权限时，该使用者能够进入此目录；</li><li>使用者在此目录下的有效群组（effective group）将会变成该目录的群组；</li><li>用途：若使用者在此目录下具有 w 的权限（可以新建文件），则使用者所创建的新文件，该新文件的群组与此目录的群组相同。</li></ul><h4 id="sticky-bit-sbit权限"><a class="markdownIt-Anchor" href="#sticky-bit-sbit权限"></a> Sticky Bit -&gt; SBIT权限</h4><p>*目前这个权限仅针对目录有效，对于文件已经没有效果了。在others上的t标识</p><ul><li>当使用者对于此目录具有 w, x 权限，亦即具有写入的权限时；</li><li>当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件<br>如:/tmp 本身的权限是“drwxrwxrwt”， 在这样的权限内容下，任何人都可以在 /tmp 内新增、修改文件，但仅有该文件/目录创建者与 root 能够删除自己的目录或文件。</li></ul><h4 id="suidsgidsbit-权限设置"><a class="markdownIt-Anchor" href="#suidsgidsbit-权限设置"></a> SUID/SGID/SBIT 权限设置</h4><p><em><strong>SUID : 4 SGID : 2 SBIT : 1</strong></em><br>在数字权限前面加上一个数字就表示几个特殊权限了.</p><blockquote><p>假设要将一个文件权限改为“-rwsr-xr-x”时，由于 s 在使用者权限中，所以是 SUID ，因此， 在原先的 755 之前还要加上 4 ，也就是：“ chmod 4755 filename ”来设置！此外，还有大 S 与大 T 的产生喔！参考下面的范例啦！</p></blockquote><pre class="highlight"><code class="bash">[root@study tmp]<span class="hljs-comment"># chmod 7666 test; ls -l test &lt;==具有空的 SUID/SGID 权限</span>-rwSrwSrwT 1 root root 0 Jun 16 02:53 <span class="hljs-built_in">test</span></code></pre><p><em>注意:上面大写SST,因为特殊权限要求必须有执行权限(上面是666),所以权限不能启作用为空权限</em></p><p><em><strong>除了数字方法外,也可以通过符号来处理.其中 SUID 为 u+s ，而 SGID 为 g+s ，SBIT 则是 o+t</strong></em></p><pre class="highlight"><code class="bash"> <span class="hljs-comment">#设置权限成为 -rws--x--x 的模样：</span>[root@study tmp]<span class="hljs-comment"># chmod u=rwxs,go=x test; ls -l test</span>-rws--x--x 1 root root 0 Jun 16 02:53 <span class="hljs-built_in">test</span> <span class="hljs-comment">#承上，加上 SGID 与 SBIT 在上述的文件权限中！</span>[root@study tmp]<span class="hljs-comment"># chmod g+s,o+t test; ls -l test</span>-rws--s--t 1 root root 0 Jun 16 02:53 <span class="hljs-built_in">test</span></code></pre><h2 id="指令与文件的搜寻"><a class="markdownIt-Anchor" href="#指令与文件的搜寻"></a> 指令与文件的搜寻</h2><h3 id="指令文件名搜寻"><a class="markdownIt-Anchor" href="#指令文件名搜寻"></a> 指令文件名搜寻</h3><h4 id="which-寻找可执行文件"><a class="markdownIt-Anchor" href="#which-寻找可执行文件"></a> which (寻找&quot;可执行文件&quot;)</h4><p><em>默认查找PATH内所规范的目录第一个被找到的执行文件</em></p><pre class="highlight"><code class>选项参数:-a 将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称root@study ~]# which history/usr/bin/which: no history in （/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin）</code></pre><blockquote><p>因为history是bash内置命令所以不能用which查找，可以通过type命令查看。^<strong>[详见bash章节]</strong></p></blockquote><h3 id="文件文件名搜寻"><a class="markdownIt-Anchor" href="#文件文件名搜寻"></a> 文件文件名搜寻</h3><h4 id="whereis-由一些特定的目录中寻找文件文件名"><a class="markdownIt-Anchor" href="#whereis-由一些特定的目录中寻找文件文件名"></a> whereis (由一些特定的目录中寻找文件文件名)</h4><pre class="highlight"><code class>[root@study ~]# whereis [-bmsu] 文件或目录名选项与参数：-l    :可以列出 whereis 会去查询的几个主要目录而已-b    :只找 binary 格式的文件-m    :只找在说明文档 manual 路径下的文件-s    :只找 source 来源文件-u    :搜寻不在上述三个项目当中的其他特殊文件</code></pre><h4 id="locate-updatedb"><a class="markdownIt-Anchor" href="#locate-updatedb"></a> locate / updatedb</h4><p><em>locate寻找的数据是由/var/lib/mlocate里面的数据搜索到的,所以不用搜索硬盘,速度快。但由于数据库默认每天创建一次，所以新建的文件可能搜索不到，或者已删除文件还能搜索到</em></p><pre class="highlight"><code class>[root@study ~]# locate [-ir] keyword选项与参数：-i  ：忽略大小写的差异；-c  ：不输出文件名，仅计算找到的文件数量-l  ：仅输出几行的意思，例如输出五行则是 -l 5-S  ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等-r  ：后面可接正则表达式的显示方式 </code></pre><blockquote><p>想要实时搜索就要手动更新数据库：updatedb<br>*updatedb：根据 /etc/updatedb.conf 的设置去搜寻系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件；<br>*locate：依据 /var/lib/mlocate 内的数据库记载，找出使用者输入的关键字文件名。<br>*因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！</p></blockquote><h4 id="find"><a class="markdownIt-Anchor" href="#find"></a> find</h4><pre class="highlight"><code class>[root@study ~]# find [PATH] [option] [action]选项与参数：1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明   -mtime  n ：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件；   -mtime +n ：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名；   -mtime -n ：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。   -newer file ：file 为一个存在的文件，列出比 file 还要新的文件文件名    2. 与使用者或群组名称有关的参数：   -uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在/etc/passwd 里面与帐号名称对应的数字。   -gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在/etc/group   -user name ：name 为使用者帐号名称！例如 dmtsai    -group name：name 为群组名称喔，例如 users ；   -nouser    ：寻找文件的拥有者不存在 /etc/passwd 的人！   -nogroup   ：寻找文件的拥有群组不存在于 /etc/group 的文件！                当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者，                这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。3. 与文件权限及名称有关的参数：-name filename ：搜寻文件名称为 filename 的文件；   -size [+-]SIZE ：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有：c: 代表 Byte， k: 代表 1024Bytes。所以，要找比50KB还要大的文件，就是“ -size +50k”   -type TYPE ：搜寻文件的类型为 TYPE 的，   类型主要有：   一般正规文件（f）,    设备文件（b, c）,     目录（d）,     链接文件（l）,      socket（s）,      及 FIFO（p） 等属性。  -perm mode ：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！   -perm -mode ：搜寻文件权限“必须要全部囊括 mode 的权“限”的文件。   -perm /mode : 任何权限位 mode 被设置了的文件。举例：[root@study ~]# find / -perm +7000 *所谓的 7000 就是 ---s--s--t ，那么只要含有 s 或 t 的就列出，所以当然要使用 /7000，*使用 -7000 表示要同时含有 ---s--s--t 的所有三个权限。而只需要任意一个，就是 /7000 ～瞭乎？(旧版是：-perm +7000已经被/7000替换)4. 额外可进行的动作：-exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。-print ：将结果打印到屏幕上，这个动作是默认动作！[root@study ~]# find / -name &quot;passwd&quot; -exec ls -l &#123;&#125; \;</code></pre><p><em><strong>-exec 后面不支持别名所以上面使用 ls -l<br>{} 代表的是“由find找到的内容”<br>由于find命令是硬盘搜索，所以速度会相对很慢</strong></em></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>详见bash章节 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件目录权限</title>
      <link href="2017/09/12/Linux/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90/"/>
      <url>2017/09/12/Linux/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="文件属性"><a class="markdownIt-Anchor" href="#文件属性"></a> 文件属性</h2><p><img src="/2017/09/12/Linux/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90/QQ20170911-172829@2x.png" alt="执行命令"><span class="image-caption">执行命令</span></p><span id="more"></span><ul><li>第一栏代表文件类型与权限</li></ul><blockquote><p><strong>列表第一个字符意义:</strong><br>当为[ d ]则是目录，例如上表文件名为“.config”的那一行；<br>当为[ - ]则是文件，例如上表第三行；<br>若是[ l ]则表示为链接文件（link file）；<br>若是[ b ]则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；<br>若是[ c ]则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。</p></blockquote><ul><li>第二栏表示有多少文件名链接到此节点上</li><li>第三栏表示这个文件“拥有者账号”</li><li>第四栏表示这个文件所属群组</li><li>第五栏表示这个文件大小，默认单位Bytes</li><li>第六栏表示文件的创建日期或修改日期</li><li>第七栏为文件名</li></ul><h2 id="改变文件属性与权限"><a class="markdownIt-Anchor" href="#改变文件属性与权限"></a> 改变文件属性与权限</h2><ul><li>改变文件群组</li></ul><blockquote><p>chgrp [-R] 群组名 文件或目录</p></blockquote><ul><li>改变文件拥有者</li></ul><blockquote><p>chown [-R] 账号名:群组名 文件或目录</p></blockquote><ul><li><p>改变权限<br><em>数字类型改变文件权限</em></p><blockquote><p>r:4 w:2 o:1<br>chmod [-R] 权限和 文件/文件夹</p></blockquote><p><em>符号类型改变文件权限</em></p><blockquote><p>user:u group:g others:o all:a<br>+加入权限 -去除权限 =设置权限<br>写法:<br>chmod [-R] u=rwx,g=rw,o=rw 文件/文件夹</p></blockquote></li></ul><h2 id="linux目录配置"><a class="markdownIt-Anchor" href="#linux目录配置"></a> Linux目录配置</h2><p><img src="/2017/09/12/Linux/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90/QQ20170912-092638@2x.png" alt="Linux目录"><span class="image-caption">Linux目录</span></p><h3 id="hfs要求必须存在的目录"><a class="markdownIt-Anchor" href="#hfs要求必须存在的目录"></a> HFS要求必须存在的目录</h3><ol><li><p><strong>/bin</strong> 放置的是单人维护模式下还能够被操作的命令。主要有：cat、chmod、chown、date、mv、mkdir、cp、bash等常用指令。</p></li><li><p><strong>/boot</strong> 此目录主要放置在开机会使用的文件,包括Linux核心文件以及开机菜单与开机所需要的配置文件等等。</p></li><li><p><strong>/dev</strong> Linux上,任何设置与周边设置都以文件形态存在于这个目录。通过读取这个目录下的文件，就等于存取这个设备。比较重要的文件有：/dev/null,/dev/zero,/dev/tty等等。</p></li><li><p><strong>/etc</strong> 系统主要配置文件几乎都放在这个目录内,例如人员账号密码档、各种服务启动档等等。一般来说这个目录文件可以让一般用户查阅，但是只有root用户可以修改。<em><strong>FHS建议不要放置可可执行文件(binary)在这个目录中。</strong></em> 比较重要的文件有：/etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue</p><blockquote><p>/etc/opt(必要) 这个目录放置第三方软件/opt的相关配置文件。</p></blockquote></li><li><p><strong>/lib</strong> 放置的是开机时会用到的函数库,以及在/bin或/sbin下指令会调用的函数库.</p><blockquote><p><strong>/lib/modules</strong> (必要) 这个目录放置可抽换式的核心模块(驱动程序)</p></blockquote></li><li><p><strong>/media</strong> 放置可移除设置。包括：软盘、光盘、DVD等等设置都暂时挂载于此。常见的文件名有：/media/floppy, /media/cdrom等等。</p></li><li><p><strong>/mnt</strong> 如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</p></li><li><p><strong>/opt</strong> 第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的distribution提供的），那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！</p></li><li><p><strong>/run</strong> 早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！</p></li><li><p><strong>/sbin</strong> 放在/sbin下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</p></li><li><p><strong>/srv</strong> srv可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。</p></li><li><p><strong>/tmp</strong> 这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！</p></li><li><p><strong>/usr</strong> 第二层FHS设置,见后续…</p></li><li><p><strong>/var</strong> 第二层FHS设置,见后续…</p></li></ol><h3 id="hfs要求可以存在的目录"><a class="markdownIt-Anchor" href="#hfs要求可以存在的目录"></a> HFS要求可以存在的目录</h3><ol><li><strong>/home</strong> 这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来</li></ol><pre><code>&gt; ~：代表目前这个使用者的主文件夹  </code></pre><p>~dmtsai ：则代表 dmtsai 的主文件夹！</p><ol start="2"><li><strong>/lib&lt;qual&gt;</strong> 用来存放与 /lib 不同的格式的二进制函数库，例如支持 64 位的 /lib64 函数库等</li><li><strong>/root</strong> 系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中。</li></ol><hr><p>事实上FHS针对根目录定义的标准仅有上面这些,不过Linux还有许多目录需要了解一下.下面几个目录也非常重要:</p><hr><ol><li><strong>/lost+found</strong> 这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！</li><li><strong>/proc</strong> 这个目录本身是一个虚拟目录.它放置 的数据都是在内存中.例如系统核心、行程信息、周边设备状态以及网络状态等等。因为这个目录数据都在内存当中，所以本身不占任何磁盘空间。比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。</li><li><strong>/sys</strong> 这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！</li></ol><h3 id="usr目录"><a class="markdownIt-Anchor" href="#usr目录"></a> /usr目录</h3><blockquote><p><strong>/usr</strong> 目录是Unix Software Resource的缩写， 也就是“Unix操作系统软件资源”所放置的目录，而不是使用者的数据啦！这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。</p></blockquote><h4 id="fhs要求必须存在的目录"><a class="markdownIt-Anchor" href="#fhs要求必须存在的目录"></a> FHS要求必须存在的目录</h4><pre><code>- **/usr/bin** 所有一般用户使用的指令都放在这里! 目前CentOS7已经将全部指令放置于此,而使用链接文件的方式将 **/bin** 链接至此! 也就是说 **/bin** 与 **/usr/bin** 是一模一样了! 另外,FHS要求在此目录下不应该有子目录!- **/usr/lib** 基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！- **/usr/local** 系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)建议安装到此目录,这样会比较方便管理. 举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录喔！- **/usr/sbin** 非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon）啰！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的。- **/usr/share** 主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文字文件嘛！  &gt;常见的还有这些次目录：    **/usr/share/man** 线上说明文档    **/usr/share/doc** 软件杂项文件说明    **/usr/share/zoneinfo** 与时区有关的时区文件</code></pre><h4 id="fhs建议可以存在的目录"><a class="markdownIt-Anchor" href="#fhs建议可以存在的目录"></a> FHS建议可以存在的目录</h4><pre><code>-  **/usr/games** 与游戏比较相关的数据放置处- **/usr/include** c/c++等程序语言的文件开始（header）与包含档（include）放置处，当我们以tarball方式 （*.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！- **/usr/libexec** 某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。- **/usr/lib\&lt;qual&gt; 与 /lib\&lt;qual&gt;/功能相同，因此目前 /lib&lt;qual&gt; 就是链接到此目录中- **/usr/src** 一般源代码建议放在这里, src有source的意思. 至于核心源代码建议放到 **/usr/src/linux** 目录下.</code></pre><h3 id="var目录"><a class="markdownIt-Anchor" href="#var目录"></a> /var目录</h3><blockquote><p>如果 <strong>/usr</strong> 是安装时会占用较大硬盘容量的目录，那么 <strong>/var</strong> 就是在系统运行后才会渐渐占用硬盘容量的目录。 因为 <strong>/var</strong> 目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如MySQL数据库的文件等等</p></blockquote><ul><li>FHS要求必须存在的目录<ul><li><strong>/var/cache</strong> 应用程序运行中会产生的一些暂存盘</li><li><strong>/var/lib</strong> 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！</li><li><strong>/var/lock</strong> 某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 <em>/run/lock</em> 中</li><li><strong>/var/log</strong> 重要到不行！这是登录文件放置的目录！里面比较重要的文件如 <strong>/var/log/messages</strong> ,  <strong>/var/log/wtmp</strong>（记录登陆者的信息）等。</li><li><strong>/var/mail</strong> 放置个人电子邮件信箱的目录，不过这个目录也被放置到 <strong>/var/spool/mail/</strong> 目录中！ 通常这两个目录是互为链接文件啦！</li><li><strong>/var/run</strong> 某些程序或者服务启动后, 会将它们的PID放置在这个目录下! 与 <strong>/run</strong> 相同，这个目录链接到 <strong>/run</strong> 去了！</li><li><strong>/var/spool</strong> 这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到/var/spool/cron/目录中！</li></ul></li></ul><h2 id="centos观察"><a class="markdownIt-Anchor" href="#centos观察"></a> CentOS观察</h2><ul><li>uname</li></ul><pre class="highlight"><code class="Linux">[dmtsai@study ~]$ uname -r   # 查看核心版本3.10.0-229.el7.x86_64[dmtsai@study ~]$ uname -m   # 查看操作系统的位版本x86_64</code></pre><ul><li>lsb_release指令已经不是默认安装软件了.使用前需要安装</li></ul><pre class="highlight"><code class="Linux">[root@study ~]# dnf install redhat-lsb[root@study ~]# lsb_release -aLSB Version::core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarchDistributor ID:CentOSDescription:CentOS Linux release 7.3.1611 (Core)Release:7.3.1611Codename:Core</code></pre><ul><li>/etc/*</li></ul><pre class="highlight"><code class>[root@study ~]# cat /etc/issueCentOS release 5.5 (Final)Kernel r on an m[root@study ~]# cat /etc/redhat-release</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开关机</title>
      <link href="2017/09/11/Linux/%E5%BC%80%E5%85%B3%E6%9C%BA/"/>
      <url>2017/09/11/Linux/%E5%BC%80%E5%85%B3%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="重要热键"><a class="markdownIt-Anchor" href="#重要热键"></a> 重要热键</h2><blockquote><p>Tab 自动补全<br>Ctrl+C 中断目前程序<br>Ctrl+d 键盘输入结束<br>Shift+Page [Up][Down] 上下翻页<br>[Ctrl] + [Alt] + [F1]~[F6]的组合按钮 终端切换</p></blockquote><span id="more"></span><h2 id="开关机"><a class="markdownIt-Anchor" href="#开关机"></a> 开关机</h2><ul><li>shutdown [-krhc] [时间] [警告讯息]　<em>关机命令</em></li></ul><blockquote><p>-k     ： 不要真的关机，只是发送警告讯息出去！<br>-r     ： 在将系统的服务停掉之后就重新开机（常用）<br>-h     ： 将系统的服务停掉后，立即关机。 （常用）<br>-c     ： 取消已经在进行的 shutdown 指令内容。<br>时间   ： 指定系统关机的时间！时间的范例下面会说明。若没有这个项目，则默认 1 分钟后自动进行。</p></blockquote><ul><li>reboot　<em>重新开机命令</em></li></ul><blockquote><p>sync;reboot<br>实际开关机命令默认都会执行sync命令,但为了保险起见还是手动执行一下此命令。</p></blockquote><ul><li>实际使用关机管理工具<br>systemctl  [指令]<br>　<em>上面提到的开关机命令实际都是调用此命令执行开关机</em></li></ul><blockquote><p>halt       进入系统停止的模式，屏幕可能会保留一些讯息，这与你的电源管理模式有关<br>poweroff   进入系统关机模式，直接关机没有提供电力喔！<br>reboot     直接重新开机<br>suspend    进入休眠模式<br>[root@study ~]# systemctl reboot    # 系统重新开机<br>[root@study ~]# systemctl poweroff  # 系统关机</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> Linux学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记——深入React组件(v15.5)</title>
      <link href="2017/05/04/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5React%E7%BB%84%E4%BB%B6(v15.5)/"/>
      <url>2017/05/04/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5React%E7%BB%84%E4%BB%B6(v15.5)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>组件让UI独立，可重复利用，并且单独解决每块问题。React.Component是由React提供的。</p><p>React.Component是一个抽象的基类，因此它很少的被直接使用。反而，你会用一个有代表性的子类，并且至少定义一个render()方法。</p><span id="more"></span><p>使用JavaScript定义一个简单的类组件：</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;  &#125;&#125;</code></pre><p>如果你没有使用ES6，你需要使用react-create-class模块创建。可以参考React中不使用ES6。</p><h3 id="组件生命周期"><a class="markdownIt-Anchor" href="#组件生命周期"></a> 组件生命周期</h3><p>每个组件都有几个生命周期，你可重写它们并在特定时间，它们会被执行。前缀是will的方法会在行为发生前被调用;前缀为did的方法会在行为发生后被调用。</p><h4 id="mounting"><a class="markdownIt-Anchor" href="#mounting"></a> Mounting</h4><p>当一个组件实例被创建并且插入到DOM时，这些方法被调用：</p><blockquote><p>constructor()<br>componentWillMount()<br>render()<br>componentDidMount()</p></blockquote><h4 id="updating"><a class="markdownIt-Anchor" href="#updating"></a> Updating</h4><p>可能由props或state引发的更新。当组件被重新渲染时，这些方法被调用：</p><blockquote><p>componentWillReceiveProps()<br>shouldComponentUpdate()<br>componentWillUpdate()<br>render()<br>componentDidUpdate()</p></blockquote><h4 id="unmounting"><a class="markdownIt-Anchor" href="#unmounting"></a> Unmounting</h4><p>当组件被移出DOM时，这个方法被调用：</p><blockquote><p>componentWillUnmount()</p></blockquote><h4 id="其它api"><a class="markdownIt-Anchor" href="#其它api"></a> 其它API</h4><p>每个组件也提供一些其它API。</p><blockquote><p>setState()<br>forceUpdate()</p></blockquote><h3 id="类属性"><a class="markdownIt-Anchor" href="#类属性"></a> 类属性</h3><blockquote><p>defaultProps<br>displayName</p></blockquote><h4 id="实例属性"><a class="markdownIt-Anchor" href="#实例属性"></a> 实例属性</h4><blockquote><p>props<br>state</p></blockquote><h3 id="方法使用说明"><a class="markdownIt-Anchor" href="#方法使用说明"></a> 方法使用说明</h3><h4 id="render"><a class="markdownIt-Anchor" href="#render"></a> render()</h4><p>这个方法是必须存在的方法。</p><p>当被调用时，它会检查props和state，并且返回单一的React元素。这个元素可以是一个本地DOM组件，如&lt;div /&gt;，也可以是一个自定义的合成组件。</p><p>你也可以返回null或者false，表示你不想要任何渲染。当返回的是null或者false时，ReactDOM.findDOMNode(this)返回的是null。</p><p>这个方法是纯粹的，也就是说它不能更新state，每次调用返回相同的结果，并且它不直接与浏览器交互。</p><p>注意：如果shouldComponentUpdate()方法返回false，render()不会被调用。</p><h4 id="constructor"><a class="markdownIt-Anchor" href="#constructor"></a> constructor()</h4><p>构造函数是初始化state的正确位置。如果你不需要初始化state并且也不绑定方法，那就不需要实现构造函数。</p><pre class="highlight"><code class="jsx"><span class="hljs-keyword">constructor</span>(props) &#123;  <span class="hljs-keyword">super</span>(props);  <span class="hljs-keyword">this</span>.state = &#123;    <span class="hljs-attr">color</span>: props.initialColor  &#125;;&#125;</code></pre><h4 id="componentwillupdate"><a class="markdownIt-Anchor" href="#componentwillupdate"></a> componentWillUpdate()</h4><p>这个方法在mounting发生前调用，并且在render()方法之前调用。因此，在这个方法设置state同步，不会触发重新渲染。避免了任副作用和订阅。</p><p>这仅仅是 服务器渲染时调用的生命周期的钩子。一般推荐使用constructor()代替。</p><h4 id="componentdidmount"><a class="markdownIt-Anchor" href="#componentdidmount"></a> componentDidMount()</h4><p>这个方法mounting发生后调用。在这个方法设置state会触发重新渲染。可以在这里初始化必要的DOM，如果需要加载远程数据，这里是发起请求的好地方。</p><h4 id="componentwillreceiveprops"><a class="markdownIt-Anchor" href="#componentwillreceiveprops"></a> componentWillReceiveProps()</h4><p>这个方法在一个已加载的组件接收新prop前调用。在这个方法里可以使用setState()比较this.props和nextProps。</p><p>注意：即使props没有改变，React也可能调用这个方法。因此，请确保比较当前值和即将改变的值。</p><p>在mounting期间初始化props，React不会调用这个方法。它只在组件props被更新时调用。调用setState()通常不会触发此方法。</p><h4 id="shouldcomponentupdate"><a class="markdownIt-Anchor" href="#shouldcomponentupdate"></a> shouldComponentUpdate()</h4><p>此方法默认行为是，当state改变时组件重新渲染。</p><p>当props或state 被接收到时，这个方法将在render()之前调用。当初始化渲染和使用forceUpdate()方法时，此方法不被调用。</p><p>此方法返回false时，并不能阻止子组件由于state改变后重新渲染。</p><p>目前，此方法返回false时componentWillUpdate()、render() 和 componentDidUpdate()方法不会被调用。注意，这在将来可能只是一个提示，而不是严格的指令，也就是说即使该方法返回false，仍然会重新渲染组件。</p><h4 id="componentwillupdate-2"><a class="markdownIt-Anchor" href="#componentwillupdate-2"></a> componentWillUpdate()</h4><p>此方法被调用在prop和state被接收后组件渲染前，组件初始化渲染不调用此方法。</p><p><strong>注意</strong>：</p><p>1、你不能在这个方法中调用this.setState()，如果你想在props变化后更新state请使用componentWillReceiveProps()代替。</p><p>2、如果shouldComponentUpdate()方法返回false，此方法不会被调用。</p><h4 id="componentdidupdate"><a class="markdownIt-Anchor" href="#componentdidupdate"></a> componentDidUpdate()</h4><p>这个方法在updating发生后立即调用，并且在组件初始化渲染时也不调用。</p><p>在组件更新后，在这个方法中操作DOM是个很好的机会。这也是一个做网络请求的好地方。</p><p>注意：如果shouldComponentUpdate()方法返回false，此方法不会被调用。</p><h4 id="componentwillunmount"><a class="markdownIt-Anchor" href="#componentwillunmount"></a> componentWillUnmount()</h4><p>此方法会在组件被卸载和销毁之前立即调用。在这个方法可以执行必要的清理工作。如：无效的定时器、取消网络请求或者清理componentDidMount()创建的DOM元素。</p><h4 id="forceupdate"><a class="markdownIt-Anchor" href="#forceupdate"></a> forceUpdate()</h4><p>默认情况下，当组件的state或props改变时就会重新渲染。如果你的render()方法需要依赖一此其它数据，你可以通过调用forceUpdate()方法告诉React组件需要重新渲染。</p><p>调用forceUpdate()，会引起render()直接调用，而跳过shouldComponentUpdate()。但是它会正常触发每一个子组件的生命周期方法。</p><p>通常应该避免使用此方法。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJs </tag>
            
            <tag> HTML </tag>
            
            <tag> React学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记——使用PropTypes类型检查(v15.5)</title>
      <link href="2017/05/03/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8PropTypes%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5(v15.5)/"/>
      <url>2017/05/03/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8PropTypes%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5(v15.5)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>React v15.5中React.PropTypes已经被废弃了，建议使用prop-types库代替。</p><p>随着应用的增长，可能遇到越来越多的类型检查方面的bug，对于一些应用，你可以使用JavaScript的扩展如：flow、typescript来检查你整个应用。但是，对于React来说，即使你不使用这些，其也内置了一些类型检查能力。要使用类型检查作用于组件，你可以指定一个特殊的属性proptypes：</p><span id="more"></span><pre class="highlight"><code class="jsx"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>    );  &#125;&#125;Greeting.propTypes = &#123;  <span class="hljs-attr">name</span>: PropTypes.string&#125;;</code></pre><p>下面是React对不同类型检查的示例：</p><pre class="highlight"><code class="jsx"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;MyComponent.propTypes = &#123;  <span class="hljs-comment">// You can declare that a prop is a specific JS primitive. By default, these</span>  <span class="hljs-comment">// are all optional.</span>  optionalArray: PropTypes.array,  <span class="hljs-attr">optionalBool</span>: PropTypes.bool,  <span class="hljs-attr">optionalFunc</span>: PropTypes.func,  <span class="hljs-attr">optionalNumber</span>: PropTypes.number,  <span class="hljs-attr">optionalObject</span>: PropTypes.object,  <span class="hljs-attr">optionalString</span>: PropTypes.string,  <span class="hljs-attr">optionalSymbol</span>: PropTypes.symbol,  <span class="hljs-comment">// Anything that can be rendered: numbers, strings, elements or an array</span>  <span class="hljs-comment">// (or fragment) containing these types.</span>  optionalNode: PropTypes.node,  <span class="hljs-comment">// A React element.</span>  optionalElement: PropTypes.element,  <span class="hljs-comment">// You can also declare that a prop is an instance of a class. This uses</span>  <span class="hljs-comment">// JS's instanceof operator.</span>  optionalMessage: PropTypes.instanceOf(Message),  <span class="hljs-comment">// You can ensure that your prop is limited to specific values by treating</span>  <span class="hljs-comment">// it as an enum.</span>  optionalEnum: PropTypes.oneOf([<span class="hljs-string">'News'</span>, <span class="hljs-string">'Photos'</span>]),  <span class="hljs-comment">// An object that could be one of many types</span>  optionalUnion: PropTypes.oneOfType([    PropTypes.string,    PropTypes.number,    PropTypes.instanceOf(Message)  ]),  <span class="hljs-comment">// An array of a certain type</span>  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),  <span class="hljs-comment">// An object with property values of a certain type</span>  optionalObjectOf: PropTypes.objectOf(PropTypes.number),  <span class="hljs-comment">// An object taking on a particular shape</span>  optionalObjectWithShape: PropTypes.shape(&#123;    <span class="hljs-attr">color</span>: PropTypes.string,    <span class="hljs-attr">fontSize</span>: PropTypes.number  &#125;),  <span class="hljs-comment">// You can chain any of the above with `isRequired` to make sure a warning</span>  <span class="hljs-comment">// is shown if the prop isn't provided.</span>  requiredFunc: PropTypes.func.isRequired,  <span class="hljs-comment">// A value of any data type</span>  requiredAny: PropTypes.any.isRequired,  <span class="hljs-comment">// You can also specify a custom validator. It should return an Error</span>  <span class="hljs-comment">// object if the validation fails. Don't `console.warn` or throw, as this</span>  <span class="hljs-comment">// won't work inside `oneOfType`.</span>  customProp: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props, propName, componentName</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/matchme/</span>.test(props[propName])) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(        <span class="hljs-string">'Invalid prop `'</span> + propName + <span class="hljs-string">'` supplied to'</span> +        <span class="hljs-string">' `'</span> + componentName + <span class="hljs-string">'`. Validation failed.'</span>      );    &#125;  &#125;,  <span class="hljs-comment">// You can also supply a custom validator to `arrayOf` and `objectOf`.</span>  <span class="hljs-comment">// It should return an Error object if the validation fails. The validator</span>  <span class="hljs-comment">// will be called for each key in the array or object. The first two</span>  <span class="hljs-comment">// arguments of the validator are the array or object itself, and the</span>  <span class="hljs-comment">// current item's key.</span>  customArrayProp: PropTypes.arrayOf(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">propValue, key, componentName, location, propFullName</span>) </span>&#123;    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/matchme/</span>.test(propValue[key])) &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(        <span class="hljs-string">'Invalid prop `'</span> + propFullName + <span class="hljs-string">'` supplied to'</span> +        <span class="hljs-string">' `'</span> + componentName + <span class="hljs-string">'`. Validation failed.'</span>      );    &#125;  &#125;)&#125;;</code></pre><p>需要一个子元素</p><p>使用Proptypes.element，你可以指定只有一个子元素可以被传入组件中。</p><pre class="highlight"><code class="jsx"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">'prop-types'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-comment">// This must be exactly one element or it will warn.</span>    <span class="hljs-keyword">const</span> children = <span class="hljs-keyword">this</span>.props.children;    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        &#123;children&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>    );  &#125;&#125;MyComponent.propTypes = &#123;  <span class="hljs-attr">children</span>: PropTypes.element.isRequired&#125;;</code></pre><h3 id="prop默认值"><a class="markdownIt-Anchor" href="#prop默认值"></a> prop默认值</h3><p>你可以通过指定一个特殊的属性defaultProps，来设定prop的默认值。</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Greeting</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>    );  &#125;&#125;<span class="hljs-comment">// Specifies the default values for props:</span>Greeting.defaultProps = &#123;  <span class="hljs-attr">name</span>: <span class="hljs-string">'Stranger'</span>&#125;;<span class="hljs-comment">// Renders "Hello, Stranger":</span>ReactDOM.render(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Greeting</span> /&gt;</span>,  document.getElementById('example'));</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJs </tag>
            
            <tag> HTML </tag>
            
            <tag> React学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记——引用和DOM(v15.5)</title>
      <link href="2017/05/03/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%95%E7%94%A8%E5%92%8CDOM(v15.5)/"/>
      <url>2017/05/03/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%95%E7%94%A8%E5%92%8CDOM(v15.5)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>在典型的React数据流中，props是父组件与子组件交互的唯一方式。想要修改子组件的，你需要重新渲染父组件的props。然而，有一些种情况是你需要在典型数据流的外面立即修改子组件。要修改的子组件可以是React组件的实例或者是一个DOM元素。对于这两种情况，React 提供了一个解决方案。</p><span id="more"></span><h3 id="何时使用refs"><a class="markdownIt-Anchor" href="#何时使用refs"></a> 何时使用Refs</h3><blockquote><p>1、管理焦点、选中或者是媒体重放。<br>2、触发命令动画。<br>3、与第三方DOM库集成。</p></blockquote><h3 id="避免在可声明的事物上使用refs"><a class="markdownIt-Anchor" href="#避免在可声明的事物上使用refs"></a> 避免在可声明的事物上使用refs。</h3><p>例如：不在Dialog组件上暴露open()和close()方法，而是传递一个isOpen属性。</p><h3 id="在dom元素上添加一个ref"><a class="markdownIt-Anchor" href="#在dom元素上添加一个ref"></a> 在DOM元素上添加一个ref</h3><p>React支持在任何组件上添加一个特殊的属性。ref属性接收一个回调函数，并且这个函数在组件mounted和unmounted时会立即执行。</p><p>当ref属性被用在一个HTML元素上时，ref回调函数接收的是基础的DOM元素作为它的参数。</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.focus = <span class="hljs-keyword">this</span>.focus.bind(<span class="hljs-keyword">this</span>);  &#125;  focus() &#123;    <span class="hljs-comment">// 明确文本框使用的原始DOM　API focus</span>    <span class="hljs-keyword">this</span>.textInput.focus();  &#125;  render() &#123;    <span class="hljs-comment">// ref回调函数存储文本框DOM</span>    <span class="hljs-comment">// element in an instance field (for example, this.textInput).</span>    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;input          type="text"          ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;        &lt;input          type="button"          value="Focus the text input"          onClick=&#123;this.focus&#125;        /&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><p>当组件mounts时，React会调用ref回调函数，并向其传入DOM元素;当组件unmounts时，React调用ref回调函数，并向其传入null。</p><p>使用ref回调函数为类设置一个属性，访问DOM元素是一种常见的方式。首先的方法就是向上面一样在ref回调函数中设置一个属性。有一个更简单的写法是：ref={input =&gt; this.textInput = input}</p><h3 id="在类的组件上添加一个ref"><a class="markdownIt-Anchor" href="#在类的组件上添加一个ref"></a> 在类的组件上添加一个ref</h3><p>当ref属性被添加到一个以类方式定义的组件上时，它的回调函数接收的是已mount组件的实例作为实例。例如：想要模拟组件在mount后直接被点击：</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoFocusTextInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  componentDidMount() &#123;    <span class="hljs-keyword">this</span>.textInput.focus();  &#125;  render() &#123;    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomTextInput</span>        <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;(input)</span> =&gt;</span> &#123; this.textInput = input; &#125;&#125; /&gt;    );  &#125;&#125;</span></code></pre><p><strong>注意</strong>：只有组件以类的方式定义才有效。</p><h3 id="refs和函数式组件"><a class="markdownIt-Anchor" href="#refs和函数式组件"></a> Refs和函数式组件</h3><p>不能在函数式组件上使用ref属性，因为函数式组件没有实例</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyFunctionalComponent</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> &lt;input /&gt;;&#125;class Parent extends React.Component &#123;  render() &#123;    // This will *not* work!    return (      &lt;MyFunctionalComponent        ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;    );  &#125;&#125;</code></pre><p>如果你需要使用它，你应该将组件转换为类，就像你需要使用生命周期或者状态时候一样。</p><p>但是，你可以在函数式组件内部使用ref属性，只要是DOM元素或类组件上就可以。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CustomTextInput</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-comment">// textInput must be declared here so the ref callback can refer to it</span>  <span class="hljs-keyword">let</span> textInput = <span class="hljs-literal">null</span>;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleClick</span>(<span class="hljs-params"></span>) </span>&#123;    textInput.focus();  &#125;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;input        type="text"        ref=&#123;(input) =&gt; &#123; textInput = input; &#125;&#125; /&gt;      &lt;input        type="button"        value="Focus the text input"        onClick=&#123;handleClick&#125;      /&gt;    &lt;/div&gt;  );  &#125;</code></pre><h3 id="暴露dom-refs到父组件"><a class="markdownIt-Anchor" href="#暴露dom-refs到父组件"></a> 暴露DOM Refs到父组件</h3><p>在极少的情况下，你可能想要在一个父组件中接收子组件的DOM节点。这种做法通常是不推荐的，但是对于触发焦点和测试DOM的大小或位置，它偶尔也是有用的。</p><p>虽然，可以在子组件上添加一个ref属性，但这不理想的解决方案，你只会得到一个组件的实例，而不是组件的DOM节点。此外，这也不会在函数式组件上工作。</p><p>相反，在这种情况下，我们希望暴露一个特殊的prop在子组件上。子组件接收一个任意名字的函数作为prop，并且在一DOM节点上加上一个ref属性。这让父组件通过中间件传递ref回调函数到子组件的DOM节点上。</p><p>它在类组件和函数式组件上都可以工作。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CustomTextInput</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;input ref=&#123;props.inputRef&#125; /&gt;    &lt;/div&gt;  );&#125;class Parent extends React.Component &#123;  render() &#123;    return (      &lt;CustomTextInput        inputRef=&#123;el =&gt; this.inputElement = el&#125;      /&gt;    );  &#125;&#125;</code></pre><p>在上面的例子中，结果this.inputElement在Parent组件中被设置为CustomTextInput组件input元素相应的DOM节点。</p><p>这种模式的好处是，它可以纵向深入使用。例如：Parent组件不需要DOM节点，但是另一个组件渲染Parent组件的需要DOM节点（我们叫它GrandParent），我们可以在GrandParent组件中传递inputRef到Parent组件，并且让Parent组件向下传递它到CustomTextInput组件。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CustomTextInput</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &lt;input ref=&#123;props.inputRef&#125; /&gt;    &lt;/div&gt;  );&#125;function Parent(props) &#123;  return (    &lt;div&gt;      My input: &lt;CustomTextInput inputRef=&#123;props.inputRef&#125; /&gt;    &lt;/div&gt;  );&#125;class Grandparent extends React.Component &#123;  render() &#123;    return (      &lt;Parent        inputRef=&#123;el =&gt; this.inputElement = el&#125;      /&gt;    );  &#125;&#125;</code></pre><p>注意，如果此种方法需要在子组件中添加代码，如果你对子组件没有绝对的控制权，那么你只能使用findDOMNode()，但是它是不被鼓励使用的。</p><h3 id="不要过渡使用refs"><a class="markdownIt-Anchor" href="#不要过渡使用refs"></a> 不要过渡使用Refs</h3><p>你可能倾向使用ref来解决问题应用中的问题，如果是这种情况，请花费一些时间考虑一下，状态应该在组件的层次结构什么位置。通常，拥有该状态的适当位置应该是更高层级的组件上。参考状态提升示例。</p><h3 id="旧版api字符串refs"><a class="markdownIt-Anchor" href="#旧版api字符串refs"></a> 旧版API：字符串Refs</h3><p>如果你之前使用过React，你可能会熟悉一个较旧的API,其中ref属性是一个字符串，如像&quot;textInput&quot;,DOM节点被这样访问this.refs.textInput。我们建议不这样使用。因为字符串引用有一些被认为是遗留的问题，并且可能在未来的一个版本中被删除。如果你目前正在使用this.refs.textInput访问refs,我们建议你使用回调模式。</p><p><strong>注意</strong></p><p>如果ref回调被定义为内联函数，它将在更新期间被调用两次，第一次调用传入null,第二次调用传入DOM 元素。这是因为函数的新实例是通过每次渲染创建的，因此React需要清除旧的引用并设置新的引用。你可以通过将ref回调定义为类上的绑定方法来避免这种情况，但请注意，在大多数情况下它不重要。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJs </tag>
            
            <tag> HTML </tag>
            
            <tag> React学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记——深入理解JSX(v15.5)</title>
      <link href="2017/05/02/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSX(v15.5)/"/>
      <url>2017/05/02/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JSX(v15.5)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>从根本上讲，React语法仅仅是React.createElement(component, props, …children)方法的语法糖。</p><pre class="highlight"><code class="jsx"><span class="hljs-comment">//JSX代码</span>&lt;MyButton color=<span class="hljs-string">"blue"</span> shadowSize=&#123;<span class="hljs-number">2</span>&#125;&gt;  Click Me&lt;<span class="hljs-regexp">/MyButton&gt;/</span><span class="hljs-regexp">/编译后：React.createElement(  MyButton,  &#123;color: 'blue', shadowSize: 2&#125;,  'Click Me')如果标签没有子元素，可以使用闭口标签。/</span><span class="hljs-regexp">/JSX代码&lt;div className="sidebar" /</span>&gt;<span class="hljs-comment">//编译后</span>React.createElement(  <span class="hljs-string">'div'</span>,  &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">'sidebar'</span>&#125;,  <span class="hljs-literal">null</span>)</code></pre><span id="more"></span><h3 id="指定react元素类型"><a class="markdownIt-Anchor" href="#指定react元素类型"></a> 指定React元素类型</h3><h4 id="react必须在作用域里"><a class="markdownIt-Anchor" href="#react必须在作用域里"></a> react必须在作用域里</h4><p>由于JSX编译后调用的是React.createElement方法，因此React库必须始终在JSX代码作用域中。</p><pre class="highlight"><code class="jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> CustomButton <span class="hljs-keyword">from</span> <span class="hljs-string">'./CustomButton'</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WarningButton</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// return React.createElement(CustomButton, &#123;color: 'red'&#125;, null);</span>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomButton</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span> /&gt;</span>;&#125;</span></code></pre><p>如果不使用JavaScript打包工具并且已经使用&lt;script&gt;标签引入React。它就已经在全局作用域中了。</p><h4 id="jsx类型使用点表达式"><a class="markdownIt-Anchor" href="#jsx类型使用点表达式"></a> JSX类型使用点表达式</h4><p>你也可以在JSX中使用点表达式引用组件。如果有一个模块导出很多组件的时候，这是很方便的。例如：MyComponents.DatePicker是一个组件，你可以直接在JSX中使用它：</p><pre class="highlight"><code class="jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">const</span> MyComponents = &#123;  <span class="hljs-attr">DatePicker</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DatePicker</span>(<span class="hljs-params">props</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Imagine a &#123;props.color&#125; datepicker here.<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BlueDatePicker</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponents.DatePicker</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"blue"</span> /&gt;</span>;&#125;</span></code></pre><h4 id="用户定义组件必须大写"><a class="markdownIt-Anchor" href="#用户定义组件必须大写"></a> 用户定义组件必须大写</h4><p>当一个元素以小写字母开始，它指的就是一个内建组件，如：&lt;div&gt;或者&lt;span&gt;，结果就会将’div’或’span’被传入React.createElement方法。而大写字母开始的组件如<Foo>会编译成React.createElement(Foo)，并且它符合一个组件的定义。</Foo></p><p>我们推荐使用大写字母定义一个组件。如果你有一个组件是使用小写字母开始，在JSX中使用它前把它赋值给一个大写变量。</p><p>例如，下面代码不会如期运行：</p><pre class="highlight"><code class="jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-comment">// 错误！这是一个组件应该产首字母大写</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-comment">// 正确! 这使用的是&lt;div&gt;标签，因为它是一个有效的HTML标签</span>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello &#123;props.toWhat&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">HelloWorld</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// 错误! Reac认为 &lt;hello /&gt; 是一个HTML标签，因为它首字母是小写</span>  <span class="hljs-keyword">return</span> &lt;hello toWhat="World" /&gt;;&#125;修复这些问题，重命名hello为Hello，并且在涉及到它的地方使用&lt;Hello/&gt;：import React from 'react';// Correct! This is a component and should be capitalized:function Hello(props) &#123;  // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag:  return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123;  // Correct! React knows &lt;Hello /&gt; is a component because it's capitalized.  return &lt;Hello toWhat="World" /&gt;;&#125;</code></pre><h4 id="运行时选择类型"><a class="markdownIt-Anchor" href="#运行时选择类型"></a> 运行时选择类型</h4><p>你不能使用普通表达式作为React元素的类型。如果你想使用普通表达式表明元素的类型，首先将其赋值给一个大写变量。这种情况经常出现在你想依据prop渲染不同组件的时候。</p><pre class="highlight"><code class="jsx"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> &#123; PhotoStory, VideoStory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./stories'</span>;<span class="hljs-keyword">const</span> components = &#123;  <span class="hljs-attr">photo</span>: PhotoStory,  <span class="hljs-attr">video</span>: VideoStory&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Story</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-comment">// 错误! JSX 类型不能使用表达式</span>  <span class="hljs-keyword">return</span> &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;&#125;修复这个，首先将其赋值给一个大写变量：import React from 'react';import &#123; PhotoStory, VideoStory &#125; from './stories';const components = &#123;  photo: PhotoStory,  video: VideoStory&#125;;function Story(props) &#123;  // 正确! JSX 类型可以使用一个大写变量代替.  const SpecificStory = components[props.storyType];  return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125;</code></pre><h3 id="jsx的props"><a class="markdownIt-Anchor" href="#jsx的props"></a> JSX的Props</h3><h4 id="javascript表达式作为-props"><a class="markdownIt-Anchor" href="#javascript表达式作为-props"></a> JavaScript表达式作为 Props</h4><p>你可以通过{}传递任何表达式作为prop。例如：</p><pre class="highlight"><code class="jsx">&lt;MyComponent foo=&#123;<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span>&#125; /&gt;</code></pre><p>if表达式和for循环在JavaScript中不是表达式，因此不能直接在JSX中使用。你可以把它们放在周围代码中：</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberDescriber</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">let</span> description;  <span class="hljs-keyword">if</span> (props.number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;    description = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>even<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span></span>;  &#125; <span class="hljs-keyword">else</span> &#123;    description = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">i</span>&gt;</span>odd<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span>;  &#125;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;props.number&#125; is an &#123;description&#125; number<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;&#125;</code></pre><h3 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h3><p>你可以传递一个字符串作为prop。这两个JSX表达式是等价的：</p><pre class="highlight"><code class="jsx">&lt;MyComponent message=<span class="hljs-string">"hello world"</span> /&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&#123;</span>'<span class="hljs-attr">hello</span> <span class="hljs-attr">world</span>'&#125; /&gt;</span></span></code></pre><p>当你传递一个字符串时，它的值是未转义的HTML。这两个表达式是等价的：</p><pre class="highlight"><code class="jsx">&lt;MyComponent message=<span class="hljs-string">"&amp;lt;3"</span> /&gt;&lt;MyComponent message=&#123;'&lt;3'&#125; /&gt;</code></pre><h4 id="props默认值true"><a class="markdownIt-Anchor" href="#props默认值true"></a> Props默认值true</h4><p>如果你传递一个没有值的prop，它默认传递的是true。这两个表达式是等价的：</p><pre class="highlight"><code class="jsx">&lt;MyTextBox autocomplete /&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyTextBox</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">&#123;true&#125;</span> /&gt;</span></span></code></pre><p>一般来说，不建议使用默认值，因为ES6的语法中对象简写{foo}等价于{foo:foo}而不是{foo:true}，所以这样写容易混淆。只有这个行为和HTML行相同的时候才能这么使用。</p><h4 id="扩展属性"><a class="markdownIt-Anchor" href="#扩展属性"></a> 扩展属性</h4><p>如果你已经有一个props的对象，并且希望这个props传递给JSX中。可以使用…作为扩展运算符传递整个props对象。下面两个组件是相等的：</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App1</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> &lt;Greeting firstName="Ben" lastName="Hector" /&gt;;&#125;function App2() &#123;  const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;;  return &lt;Greeting &#123;...props&#125; /&gt;;&#125;</code></pre><p>当你创建通用的容器时，扩展属性是很有用的。然而，它也能使你的代码产品混乱，它很容易使组件产生很多无关紧要的props。我们建议很少使用这个语法。</p><h3 id="jsx子元素"><a class="markdownIt-Anchor" href="#jsx子元素"></a> JSX子元素</h3><p>在JSX表达式中包含一个开始标签和一个结束标签，标签中内容通过一个特殊的prop：props.children传递。有几种不同方法传递子元素</p><h4 id="字符串-2"><a class="markdownIt-Anchor" href="#字符串-2"></a> 字符串</h4><p>你可以在开始和结束标签之间放一字符串，这样props.children的值就是一个字符串。这对于很多内置的HTML元素来说是很有用的：</p><pre class="highlight"><code class="jsx">&lt;MyComponent&gt;Hello world!<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">MyComponent</span>&gt;</span></span></code></pre><h4 id="jsx子元素-2"><a class="markdownIt-Anchor" href="#jsx子元素-2"></a> JSX子元素</h4><p>你可以提供更多的JSX元素作为子元素，这对于显示嵌套组件是很有用的：</p><pre class="highlight"><code class="jsx">&lt;MyContainer&gt;  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyFirstComponent</span> /&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">MySecondComponent</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">MyContainer</span>&gt;</span></span></code></pre><p>你可以混合不同类型的子元素，因此你可以使用字符串在JSX子元素中，这是另一种方式的JSX，看起来就像HTML，所以这既是有效的JSX，也是有效的HTML：</p><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  Here is a list:  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>一个React组件不能同时返回多个React元素，但是一个JSX表达式可以有多个子元素。因此，如果你想要一个组件呈现多个事情的时候，你可以像上面一样将它包裹在一个div里。</p><h4 id="javascript表达式作为子元素"><a class="markdownIt-Anchor" href="#javascript表达式作为子元素"></a> JavaScript表达式作为子元素</h4><p>你可以通过{}传递任何JavaScript表达式作为子元素。例如：这些表达式是相等的：</p><pre class="highlight"><code class="jsx">&lt;MyComponent&gt;foo&lt;<span class="hljs-regexp">/MyComponent&gt;&lt;MyComponent&gt;&#123;'foo'&#125;&lt;/</span>MyComponent&gt;</code></pre><p>这对于渲染任意长度的JSX表达式列表是很有用的。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Item</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;props.message&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TodoList</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> todos = [<span class="hljs-string">'finish doc'</span>, <span class="hljs-string">'submit pr'</span>, <span class="hljs-string">'nag dan to review'</span>];  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>      &#123;todos.map((message) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;message&#125;</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&#123;message&#125;</span> /&gt;</span>)&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>  );&#125;</span></code></pre><p>JavaScript表达式可以和其它类型混合成子元素。这在字符串模板里是很有用的。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hello</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello &#123;props.addressee&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;&#125;</code></pre><h4 id="函数作为子元素"><a class="markdownIt-Anchor" href="#函数作为子元素"></a> 函数作为子元素</h4><p>通常，JavaScript表达式插入到JSX中得到一个字符串，一个React元素或者是那些东西的列表。然而，props.children就像其它prop一样可以传递任何类型的数据，不仅仅是React知道如何渲染的类型。例如，如果你有一个自定义组件，你可以让它带一个回调函数作为props.children：</p><pre class="highlight"><code class="jsx"><span class="hljs-comment">// Calls the children callback numTimes to produce a repeated component</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Repeat</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">let</span> items = [];  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; props.numTimes; i++) &#123;    items.push(props.children(i));  &#125;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;items&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListOfTenThings</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Repeat</span> <span class="hljs-attr">numTimes</span>=<span class="hljs-string">&#123;10&#125;</span>&gt;</span>      &#123;(index) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;index&#125;</span>&gt;</span>This is item &#123;index&#125; in the list<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">Repeat</span>&gt;</span></span>  );&#125;</code></pre><p>子元素可以通过自定义组件传递任何类型。</p><p>被忽略的Boolean、Null和Undefined</p><p>fase、null、undefined和true是有效的子元素。它们只是不渲染。下面JSX表达式呈现的效果是一样的：</p><pre class="highlight"><code class="jsx">&lt;div /&gt;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;false&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;null&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;undefined&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;true&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>这些在条件渲染React元素的时候是有用的。下面代码，如果showHeader是true则渲染<Header>组件：</Header></p><pre class="highlight"><code class="jsx">&lt;div&gt;  &#123;showHeader &amp;&amp; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Header</span> /&gt;</span>&#125;  <span class="hljs-tag">&lt;<span class="hljs-name">Content</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>但请注意，一些“falsy” 值，诸如数字0，仍然会被渲染。例如：下面代码不会得到预期的行为，因为props.messages为空值的时候会打印0</p><pre class="highlight"><code class="jsx">&lt;div&gt;  &#123;props.messages.length &amp;&amp;    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MessageList</span> <span class="hljs-attr">messages</span>=<span class="hljs-string">&#123;props.messages&#125;</span> /&gt;</span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>修复上面代码，确保表达式&amp;&amp;前总是布尔值</p><pre class="highlight"><code class="jsx">&lt;div&gt;  &#123;props.messages.length &gt; <span class="hljs-number">0</span> &amp;&amp;    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MessageList</span> <span class="hljs-attr">messages</span>=<span class="hljs-string">&#123;props.messages&#125;</span> /&gt;</span>  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span></code></pre><p>相反地，如果你想要打印出false、true、null或者undefined，你必须先把它转换成一个字符串：</p><pre class="highlight"><code class="jsx">&lt;div&gt;  My JavaScript variable is &#123;<span class="hljs-built_in">String</span>(myVariable)&#125;.&lt;<span class="hljs-regexp">/div&gt;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJs </tag>
            
            <tag> HTML </tag>
            
            <tag> React学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记——提升state(v15.5)</title>
      <link href="2017/04/25/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8F%90%E5%8D%87state(v15.5)/"/>
      <url>2017/04/25/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%8F%90%E5%8D%87state(v15.5)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>通常几个组件需要反映相同数据变化，我们推荐提升共享的state到它们最近的共同祖先元素。实现如下：</p><p>创建一个温度计算器来计算，给定温度的水是否会沸腾。</p><p>我们将从一个BoilingVerdict组件开始，它接收一个celsius作为prop参数，并且打印水温度。</p><span id="more"></span><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BoilingVerdict</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">if</span> (props.celsius &gt;= <span class="hljs-number">100</span>) &#123;    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The water would boil.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;  &#125;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The water would not boil.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>;&#125;</code></pre><p>接下来，创建一个Calculator组件，它渲染一个&lt;input&gt;用来输入一个摄氏温度，并且保存它的值在this.state.temperature之中。</p><p>此外，它根据输入的值来渲染BoilingVerdict组件</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.state = &#123;<span class="hljs-attr">temperature</span>: <span class="hljs-string">''</span>&#125;;  &#125;  handleChange(e) &#123;    <span class="hljs-keyword">this</span>.setState(&#123;<span class="hljs-attr">temperature</span>: e.target.value&#125;);  &#125;  render() &#123;    <span class="hljs-keyword">const</span> temperature = <span class="hljs-keyword">this</span>.state.temperature;    <span class="hljs-keyword">return</span> (      &lt;fieldset&gt;        &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt;        &lt;input          value=&#123;temperature&#125;          onChange=&#123;this.handleChange&#125; /&gt;        &lt;BoilingVerdict          celsius=&#123;parseFloat(temperature)&#125; /&gt;      &lt;/fieldset&gt;    );  &#125;&#125;</code></pre><p>添加第二个输入框</p><p>我们的新要求是，除了一个摄氏度输入外，再提供一个华氏度输入，并且它们保持同步。</p><p>我们可以从Calculator组件提取一个TemperatureInput组件，增加一个scale prop参数，它可的取值可以是“c”或者“f”:</p><pre class="highlight"><code class="jsx"><span class="hljs-keyword">const</span> scaleNames = &#123;  <span class="hljs-attr">c</span>: <span class="hljs-string">'Celsius'</span>,  <span class="hljs-attr">f</span>: <span class="hljs-string">'Fahrenheit'</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.state = &#123;<span class="hljs-attr">temperature</span>: <span class="hljs-string">''</span>&#125;;  &#125;  handleChange(e) &#123;    <span class="hljs-keyword">this</span>.setState(&#123;<span class="hljs-attr">temperature</span>: e.target.value&#125;);  &#125;  render() &#123;    <span class="hljs-keyword">const</span> temperature = <span class="hljs-keyword">this</span>.state.temperature;    <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.props.scale;    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Enter temperature in &#123;scaleNames[scale]&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span>               <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span>    );  &#125;&#125;</span></code></pre><p>现在，修改Calculator组件，渲染两个不同的温度输入：</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;TemperatureInput scale="c" /&gt;        &lt;TemperatureInput scale="f" /&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><p>现在已经实现了两个输入框，接下来实现输入其中一个，另一个同时更新功能。</p><h3 id="编写转换函数"><a class="markdownIt-Anchor" href="#编写转换函数"></a> 编写转换函数</h3><p>首先，我们写两个函数用于在摄氏度和华氏度之间的单位转换：</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toCelsius</span>(<span class="hljs-params">fahrenheit</span>) </span>&#123;  <span class="hljs-keyword">return</span> (fahrenheit - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toFahrenheit</span>(<span class="hljs-params">celsius</span>) </span>&#123;  <span class="hljs-keyword">return</span> (celsius * <span class="hljs-number">9</span> / <span class="hljs-number">5</span>) + <span class="hljs-number">32</span>;&#125;</code></pre><p>这两个是转换数字的函数，我们将另外写一个函数，它接收一个字符串temperature参数和一个converter函数作为参数，并返回一个字符串。我们使用它基于一个输入框的值计算出另一个输入框的值。</p><p>当它接收一个无效的temperature参数时返回空字符串，并且它保证输出到小数点后三位。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tryConvert</span>(<span class="hljs-params">temperature, convert</span>) </span>&#123;  <span class="hljs-keyword">const</span> input = <span class="hljs-built_in">parseFloat</span>(temperature);  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Number</span>.isNaN(input)) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>;  &#125;  <span class="hljs-keyword">const</span> output = convert(input);  <span class="hljs-keyword">const</span> rounded = <span class="hljs-built_in">Math</span>.round(output * <span class="hljs-number">1000</span>) / <span class="hljs-number">1000</span>;  <span class="hljs-keyword">return</span> rounded.toString();&#125;</code></pre><p>例如，tryConvert(‘abc’, toCelsius)返回一个空字符串;　tryConvert(‘10.22’, toFahrenheit)　返回　‘50.396’。</p><h3 id="提升state"><a class="markdownIt-Anchor" href="#提升state"></a> 提升state</h3><p>一般的，TemperatureInput组件的值独立保存到它们的局部state上，然而我们想让两个输入框同步，就需要将共享state移动到需要它的最近共同的祖先组件上。这就叫做“提升state”。</p><p>我们将移除TemperatureInput组件局部state到Calculator组件上。</p><p>具体步骤：</p><p>1.把TemperatureInput组件的　this.state.temperature　换成　this.props.temperature</p><pre class="highlight"><code class="jsx">render() &#123;    <span class="hljs-comment">// 修改前: const temperature = this.state.temperature;</span>    <span class="hljs-keyword">const</span> temperature = <span class="hljs-keyword">this</span>.props.temperature;｝</code></pre><p>我们知道props是只读的。当temperature在局部state时，可以能setState()修改。然而，现在temperature作为一个prop从父类传过来，TemperatureInput组件无法再控制它。</p><p>在React中，通常用组件来解决这种控制问题。就像Dom元素&lt;input/&gt;接收一个value和一个onChange作为prop参数一样，因此可以自定义TemperatureInput组件接收temperature和onTemperatureChange作为prop参数，从它的父组件Calculator中传过来。</p><p>现在当TemperatureInput组件想要更新它的temperature时，它可以调用this.props.onTemperatureChange：</p><pre class="highlight"><code class="jsx">handleChange(e) &#123;    <span class="hljs-comment">// 修改前: this.setState(&#123;temperature: e.target.value&#125;);</span>    <span class="hljs-keyword">this</span>.props.onTemperatureChange(e.target.value);｝</code></pre><p>注意此处的temperature 或者 onTemperatureChange仅仅作为prop参数名，没有什么特殊的涵义。我们可以定义任意自己喜欢的名字，像value和onChange这种通用的惯例。</p><p>onTemperatureChange和temperature作为prop参数由父组件Calculator提供。它将通过修改局部state时行改变，因此两个input的值被重新呈现。修改后的完整代码：</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemperatureInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>);  &#125;  handleChange(e) &#123;    <span class="hljs-keyword">this</span>.props.onTemperatureChange(e.target.value);  &#125;  render() &#123;    <span class="hljs-keyword">const</span> temperature = <span class="hljs-keyword">this</span>.props.temperature;    <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.props.scale;    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>Enter temperature in &#123;scaleNames[scale]&#125;:<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;temperature&#125;</span>               <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span>    );  &#125;&#125;</span></code></pre><h3 id="实现calculator组件"><a class="markdownIt-Anchor" href="#实现calculator组件"></a> 实现Calculator组件</h3><p>我们会将input里的temperature 和 scale存储到Calulator组件的局部state，这个state是从inputs中提升来的，并且作为它们的数据源。这是我们为了显示两个input值所需要知道的最小条件。</p><p>例如，我们摄氏度input中输入37，Calculator组件的state应为</p><pre class="highlight"><code class="json">&#123;temperature: '<span class="hljs-number">37</span>',scale: 'c'&#125;</code></pre><p>如果在华氏度的input中输入212，Calculator组件的state应为</p><pre class="highlight"><code class="json">&#123;temperature: '<span class="hljs-number">212</span>',scale: 'f'&#125;</code></pre><p>我们可以同时保存两个input的值，但它是不必要的。我们可以根据temperature 和 scale值推断出，其它输入框的值。</p><p>两个input保持同步的原因在于，它们的计算来自同一个state：</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.handleCelsiusChange = <span class="hljs-keyword">this</span>.handleCelsiusChange.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.handleFahrenheitChange = <span class="hljs-keyword">this</span>.handleFahrenheitChange.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.state = &#123;<span class="hljs-attr">temperature</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">scale</span>: <span class="hljs-string">'c'</span>&#125;;  &#125;  handleCelsiusChange(temperature) &#123;    <span class="hljs-keyword">this</span>.setState(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">'c'</span>, temperature&#125;);  &#125;  handleFahrenheitChange(temperature) &#123;    <span class="hljs-keyword">this</span>.setState(&#123;<span class="hljs-attr">scale</span>: <span class="hljs-string">'f'</span>, temperature&#125;);  &#125;  render() &#123;    <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.state.scale;    <span class="hljs-keyword">const</span> temperature = <span class="hljs-keyword">this</span>.state.temperature;    <span class="hljs-keyword">const</span> celsius = scale === <span class="hljs-string">'f'</span> ? tryConvert(temperature, toCelsius) : temperature;    <span class="hljs-keyword">const</span> fahrenheit = scale === <span class="hljs-string">'c'</span> ? tryConvert(temperature, toFahrenheit) : temperature;    <span class="hljs-keyword">return</span> (      &lt;div&gt;        &lt;TemperatureInput          scale="c"          temperature=&#123;celsius&#125;          onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt;        &lt;TemperatureInput          scale="f"          temperature=&#123;fahrenheit&#125;          onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt;        &lt;BoilingVerdict          celsius=&#123;parseFloat(celsius)&#125; /&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><h3 id="整体流程"><a class="markdownIt-Anchor" href="#整体流程"></a> 整体流程：</h3><p>1、React在Dom的&lt;input/&gt;上通过onChange事件调用指定方法。在上面示例中是TemperatureInput组件中的handleChange方法。</p><p>2、方法handleChange中通过输入的值e.target.value调用this.props.onTemperatureChange()方法，它是父组件Calculator传递过来的一个prop。</p><p>3、当它被渲染的时候，父组件Calculator已经为TemperatureInput组件onTemperatureChange属性指定了摄氏度handleCelsiusChange和华氏度handleFahrenheitChange方法。它会依据被编辑的输入框，决定调用哪个方法。</p><p>4、在这些方法内部，Calculator组件通过input输入的值和scale来调用setState()方法修改state。</p><p>5、React调用Calculator组件的render方法，通过当前state，调用转换方法进行温度转换。</p><p>6、React在render方法中通过新的prop参数逐个调用TemperatureInput组件。</p><p>7、React更新匹配的input值，被编辑的input值保持不变，其它的input同步更新转换后的值。</p><p>每次更新都保持相同的步骤，所以input保持同步。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJs </tag>
            
            <tag> HTML </tag>
            
            <tag> React学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记——组合与继承(v15.5)</title>
      <link href="2017/04/25/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF(v15.5)/"/>
      <url>2017/04/25/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF(v15.5)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>React有一个强大的组合模型，并且推荐组合代替继承，在组件间重用代码。</p><p>一些组件不能提前知道它们的子组件。它些问题在一些公共组件尤其明显。如：侧边栏或者弹出框等组件。</p><p>我们推荐这样的组件使用prop的特殊属性children，直接传递子元素到它们的输出中。</p><span id="more"></span><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FancyBorder</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>'<span class="hljs-attr">FancyBorder</span> <span class="hljs-attr">FancyBorder-</span>' + <span class="hljs-attr">props.color</span>&#125;&gt;</span>      &#123;props.children&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  );&#125;<span class="hljs-comment">//传递JSX中嵌套的任意子元素</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WelcomeDialog</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"blue"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"Dialog-title"</span>&gt;</span>        Welcome      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"Dialog-message"</span>&gt;</span>        Thank you for visiting our spacecraft!      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span>  );&#125;</code></pre><p>JSX标签<FancyBorder>内任何内容通过prop children参数传递到FancyBorder组件中。由于，FancyBorder组件把{prop.children}渲染在一个&lt;div&gt;中，所以传入的元素最终被输入在这里。</FancyBorder></p><p>虽然这种情况是不常见的，很多时候，我们需要的是在一个组件的多个地方，使用这种嵌套。在这种情况下，我们得自己定义规则来代替使用chidren。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SplitPane</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"SplitPane"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"SplitPane-left"</span>&gt;</span>        &#123;props.left&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"SplitPane-right"</span>&gt;</span>        &#123;props.right&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  );&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SplitPane</span>      <span class="hljs-attr">left</span>=<span class="hljs-string">&#123;</span>        &lt;<span class="hljs-attr">Contacts</span> /&gt;</span>      &#125;      right=&#123;        <span class="hljs-tag">&lt;<span class="hljs-name">Chat</span> /&gt;</span>      &#125; /&gt;  );&#125;</span></code></pre><p>React元素像&lt;Contacts/&gt;和&lt;Chat/&gt;只是对象，所以可以像其它任何数据一样作为prop传递它们。</p><p>有时候，我们认为组件是其它组件的“特殊实例”。例如，我们可能说组件WelcomeDialog是组件Dialog它的特殊实例。</p><p>在React中，这也可以通过组合完成。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dialog</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"blue"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"Dialog-title"</span>&gt;</span>        &#123;props.title&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"Dialog-message"</span>&gt;</span>        &#123;props.message&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span>  );&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WelcomeDialog</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span>      <span class="hljs-attr">title</span>=<span class="hljs-string">"Welcome"</span>      <span class="hljs-attr">message</span>=<span class="hljs-string">"Thank you for visiting our spacecraft!"</span> /&gt;</span>  );&#125;</span></code></pre><p>组合对于类定义的组件同样有效。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dialog</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FancyBorder</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"blue"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"Dialog-title"</span>&gt;</span>        &#123;props.title&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"Dialog-message"</span>&gt;</span>        &#123;props.message&#125;      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>      &#123;props.children&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">FancyBorder</span>&gt;</span></span>  );&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SignUpDialog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.handleSignUp = <span class="hljs-keyword">this</span>.handleSignUp.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.state = &#123;<span class="hljs-attr">login</span>: <span class="hljs-string">''</span>&#125;;  &#125;  render() &#123;    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Dialog</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"Mars Exploration Program"</span>              <span class="hljs-attr">message</span>=<span class="hljs-string">"How should we refer to you?"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.login&#125;</span>               <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleSignUp&#125;</span>&gt;</span>          Sign Me Up!        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">Dialog</span>&gt;</span>    );  &#125;  handleChange(e) &#123;    this.setState(&#123;login: e.target.value&#125;);  &#125;  handleSignUp() &#123;    alert(`Welcome aboard, $&#123;this.state.login&#125;!`);  &#125;&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJs </tag>
            
            <tag> HTML </tag>
            
            <tag> React学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记——表单(v15.5)</title>
      <link href="2017/04/24/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%A1%A8%E5%8D%95(v15.5)/"/>
      <url>2017/04/24/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%A1%A8%E5%8D%95(v15.5)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>React中的HTML表单元素有点不同于其它DOM元素，因为表单元素天生具备一些内部状态。</p><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>    Name:    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> /&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Submit"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre><span id="more"></span><p>这个表单具有HTML默认行为，当用户提交表单后跳转到一个新页面。如果你想要在React中实现这种行为，它是有效的。但是，大多数情况是，使用一个JavaScript函数来处理表单提交以及对用户输入表单的数据操作是很方便的。实现这一标准的方法是一种称为“控制组件”的技术。</p><h3 id="控制组件"><a class="markdownIt-Anchor" href="#控制组件"></a> 控制组件</h3><p>在HTML表单元素中，诸如&lt;input&gt;、 &lt;textarea&gt; 和 &lt;select&gt;元素，通常保持着它们自己的状态并且根据用户的输入而更新。在React中可变的状态通常保存在组件的state属性中，并且只能使用setState()来更新它们。</p><p>我们可以这两个结合起来，使React state成为单一数据源。然后React组件渲染表单并且控制用户后的输入。这种React控制表单元素值的方法被叫做“控制组件”。</p><p>例如，前面示例提交表单记录Name时，我们可以把表单写成一个控制组件：</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NameForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.state = &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">''</span>&#125;;    <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.handleSubmit = <span class="hljs-keyword">this</span>.handleSubmit.bind(<span class="hljs-keyword">this</span>);  &#125;  handleChange(event) &#123;    <span class="hljs-keyword">this</span>.setState(&#123;<span class="hljs-attr">value</span>: event.target.value&#125;);  &#125;  handleSubmit(event) &#123;    alert(<span class="hljs-string">'A name was submitted: '</span> + <span class="hljs-keyword">this</span>.state.value);    event.preventDefault();  &#125;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        &lt;label&gt;          Name:          &lt;input type="text" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;        &lt;/label&gt;        &lt;input type="submit" value="Submit" /&gt;      &lt;/form&gt;    );  &#125;&#125;</code></pre><p>由于表单元素上设置有value属性，显示的值永远this.state.value的值。</p><h3 id="textarea标签"><a class="markdownIt-Anchor" href="#textarea标签"></a> textarea标签</h3><p>在HTML中textarea标签的文本内容写在标签里面</p><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>&gt;</span>  Hello there, this is some text in a text area<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span></code></pre><p>但是在React中使用value属性代替</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EssayForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.state = &#123;      <span class="hljs-attr">value</span>: <span class="hljs-string">'Please write an essay about your favorite DOM element.'</span>    &#125;;    <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.handleSubmit = <span class="hljs-keyword">this</span>.handleSubmit.bind(<span class="hljs-keyword">this</span>);  &#125;  handleChange(event) &#123;    <span class="hljs-keyword">this</span>.setState(&#123;<span class="hljs-attr">value</span>: event.target.value&#125;);  &#125;  handleSubmit(event) &#123;    alert(<span class="hljs-string">'An essay was submitted: '</span> + <span class="hljs-keyword">this</span>.state.value);    event.preventDefault();  &#125;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;        &lt;label&gt;          Name:          &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;        &lt;/label&gt;        &lt;input type="submit" value="Submit" /&gt;      &lt;/form&gt;    );  &#125;&#125;</code></pre><h3 id="处理多个input"><a class="markdownIt-Anchor" href="#处理多个input"></a> 处理多个Input</h3><p>如果想处理多个input元素，可以给每个元素加上name属性，并让事件处理函数依据event.targe.name选择处理。</p><pre class="highlight"><code class="jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reservation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.state = &#123;      <span class="hljs-attr">isGoing</span>: <span class="hljs-literal">true</span>,      <span class="hljs-attr">numberOfGuests</span>: <span class="hljs-number">2</span>    &#125;;    <span class="hljs-keyword">this</span>.handleInputChange = <span class="hljs-keyword">this</span>.handleInputChange.bind(<span class="hljs-keyword">this</span>);  &#125;  handleInputChange(event) &#123;    <span class="hljs-keyword">const</span> target = event.target;    <span class="hljs-keyword">const</span> value = target.type === <span class="hljs-string">'checkbox'</span> ? target.checked : target.value;    <span class="hljs-keyword">const</span> name = target.name;    <span class="hljs-keyword">this</span>.setState(&#123;      [name]: value    &#125;);  &#125;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;form&gt;        &lt;label&gt;          Is going:          &lt;input            name="isGoing"            type="checkbox"            checked=&#123;this.state.isGoing&#125;            onChange=&#123;this.handleInputChange&#125; /&gt;        &lt;/label&gt;        &lt;br /&gt;        &lt;label&gt;          Number of guests:          &lt;input            name="numberOfGuests"            type="number"            value=&#123;this.state.numberOfGuests&#125;            onChange=&#123;this.handleInputChange&#125; /&gt;        &lt;/label&gt;      &lt;/form&gt;    );  &#125;&#125;</code></pre><p>注意，示例18行使用了ES6的计算属性语法，如果用ES5语法实现如下：</p><pre class="highlight"><code class="jsx"><span class="hljs-keyword">var</span> partialState = &#123;&#125;;partialState[name] = value;<span class="hljs-keyword">this</span>.setState(partialState);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJs </tag>
            
            <tag> HTML </tag>
            
            <tag> React学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记——列表和Keys(v15.5)</title>
      <link href="2017/04/21/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8%E5%92%8CKeys(v15.5)/"/>
      <url>2017/04/21/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%88%97%E8%A1%A8%E5%92%8CKeys(v15.5)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="渲染多个组件"><a class="markdownIt-Anchor" href="#渲染多个组件"></a> 渲染多个组件</h3><p>你可以创建一个元素集合，通过‘{}’在JSX中使用</p><pre class="highlight"><code class="jsx"><span class="hljs-comment">//创建元素集合</span><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;number&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>);<span class="hljs-comment">//使用集合放到ul标签</span>ReactDOM.render(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>,  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'root'</span>));</code></pre><span id="more"></span><h3 id="基础列表组件"><a class="markdownIt-Anchor" href="#基础列表组件"></a> 基础列表组件</h3><p>通常希望在一个组件内部渲染列表，修改上面的示例：</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberList</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> numbers = props.numbers;  <span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span>&gt;</span>      &#123;number&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>  );  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItems&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>  );&#125;<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];ReactDOM.render(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">NumberList</span> <span class="hljs-attr">numbers</span>=<span class="hljs-string">&#123;numbers&#125;</span> /&gt;</span>,  document.getElementById('root'));</span></code></pre><h3 id="keys"><a class="markdownIt-Anchor" href="#keys"></a> Keys</h3><p>注意上面示例第4行的‘key’，它是一个特殊的字符串属性，当创建一个列表元素是必须要包含它，否则会有如下警告：</p><p>a warning that a key should be provided for list items</p><p>Keys是帮助React识别哪些项目被修改、添加、删除。主键将给数组中的元素一个稳定的身份。</p><p>最好的方式使用一个在列表同级元素中唯一的字符串作为key。例如我们经常使用数据中的IDs作为Keys,但是不建议在没其它办法的情况下使用元素索引作为key,因为如果数据被重新排序，那么对于React来说，识别变动的元素仍然是很慢的。</p><h3 id="使用keys提取组件"><a class="markdownIt-Anchor" href="#使用keys提取组件"></a> 使用Keys提取组件</h3><p>Keys中有在数组的上下文中才有意义。例如：抽取一个ListItem组件，你应该保持key在数据中的&lt;ListItem /&gt;元素上，而不是在ListItem自己的根元素&lt;li&gt;上。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ListItem</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> value = props.value;  <span class="hljs-keyword">return</span> (    <span class="hljs-comment">// 错误！此处不需要key</span>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;value.toString()&#125;</span>&gt;</span>      &#123;value&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>  );&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberList</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> numbers = props.numbers;  <span class="hljs-keyword">const</span> listItems = numbers.map(<span class="hljs-function">(<span class="hljs-params">number</span>) =&gt;</span>    <span class="hljs-comment">// 错误！此处应该指定key</span>    &lt;ListItem value=&#123;number&#125; /&gt;  );  return (    &lt;ul&gt;      &#123;listItems&#125;    &lt;/ul&gt;  );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render(  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,  document.getElementById('root'));function ListItem(props) &#123;  //正确！此处没有key  return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123;  const numbers = props.numbers;  const listItems = numbers.map((number) =&gt;    // 正确！key被放在了数组里面    &lt;ListItem key=&#123;number.toString()&#125;              value=&#123;number&#125; /&gt;  );  return (    &lt;ul&gt;      &#123;listItems&#125;    &lt;/ul&gt;  );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render(  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,  document.getElementById('root'));</code></pre><h3 id="keys同级元素间必须是唯一的"><a class="markdownIt-Anchor" href="#keys同级元素间必须是唯一的"></a> Keys同级元素间必须是唯一的</h3><p>如同上面提过的key在数组内部的同级元素间必须唯一，但是并不需要全局唯一，可以在两个不同的数组中使用相同的key:</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Blog</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> sidebar = (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>      &#123;props.posts.map((post) =&gt;        <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;post.id&#125;</span>&gt;</span>          &#123;post.title&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>      )&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>  );  <span class="hljs-keyword">const</span> content = props.posts.map(<span class="hljs-function">(<span class="hljs-params">post</span>) =&gt;</span>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;post.id&#125;</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>&#123;post.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;post.content&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  );  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      &#123;sidebar&#125;      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>      &#123;content&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  );&#125;<span class="hljs-keyword">const</span> posts = [  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Hello World'</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">'Welcome to learning React!'</span>&#125;,  &#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">'Installation'</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">'You can install React from npm.'</span>&#125;];ReactDOM.render(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Blog</span> <span class="hljs-attr">posts</span>=<span class="hljs-string">&#123;posts&#125;</span> /&gt;</span>,  document.getElementById('root'));</span></code></pre><blockquote><p>Keys作为React的一个提示服务，不会传递到组件内部。如果需要在组件内部使用，必须明确的使用不同的名字作为pops传入组件：</p></blockquote><pre class="highlight"><code class="jsx"><span class="hljs-keyword">const</span> content = posts.map(<span class="hljs-function">(<span class="hljs-params">post</span>) =&gt;</span>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Post</span>    <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;post.id&#125;</span>    <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;post.id&#125;</span>    <span class="hljs-attr">title</span>=<span class="hljs-string">&#123;post.title&#125;</span> /&gt;</span>);</span></code></pre><h3 id="在jsx中嵌入map"><a class="markdownIt-Anchor" href="#在jsx中嵌入map"></a> 在JSX中嵌入map</h3><p>JSX允许在‘{}’中嵌入任意表达式，因此可以内联使用map()</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NumberList</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> numbers = props.numbers;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>      &#123;numbers.map((number) =&gt;        <span class="hljs-tag">&lt;<span class="hljs-name">ListItem</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;number.toString()&#125;</span>                  <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;number&#125;</span> /&gt;</span>      )&#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>  );&#125;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJs </tag>
            
            <tag> HTML </tag>
            
            <tag> React学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习笔记——条件渲染(v15.5)</title>
      <link href="2017/04/21/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93(v15.5)/"/>
      <url>2017/04/21/React/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93(v15.5)/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>React条件渲染和JavaScript的条件工作方式是一样的。</p><ul><li>使用JavaScript中if或者条件运算符来创建一个代表当前状态的元素，然后让React来更新匹配的UI。</li></ul><span id="more"></span><pre class="highlight"><code class="jsx"><span class="hljs-comment">//创建登陆用户后组件</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserGreeting</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Welcome back!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;<span class="hljs-comment">//创建访客组件</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GuestGreeting</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Please sign up.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;&#125;<span class="hljs-comment">//创建Greeting组件来动态显示登陆用户或访客组件</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Greeting</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> isLoggedIn = props.isLoggedIn;  <span class="hljs-keyword">if</span> (isLoggedIn) &#123;    <span class="hljs-keyword">return</span> &lt;UserGreeting /&gt;;  &#125;  return &lt;GuestGreeting /&gt;;&#125;//渲染Greeting组件ReactDOM.render(  // Try changing to isLoggedIn=&#123;true&#125;:  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,  document.getElementById('root'));</code></pre><h3 id="元素变量"><a class="markdownIt-Anchor" href="#元素变量"></a> 元素变量</h3><p>可以使用变量保存元素，这可有条件的渲染组件的一部分，输出的其余部分保持不变。</p><pre class="highlight"><code class="jsx"><span class="hljs-comment">//创建LoginButton按钮组件</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LoginButton</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;props.onClick&#125;</span>&gt;</span>      Login    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>  );&#125;<span class="hljs-comment">//创建LogoutButton按钮组件</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LogoutButton</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;props.onClick&#125;</span>&gt;</span>      Logout    <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>  );&#125;<span class="hljs-comment">//创建一个LoginControl组件，它可以根据当前的状态渲染LoginButton或者LogoutButton组件，它也将渲染上面的Gretting组件</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginControl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.handleLoginClick = <span class="hljs-keyword">this</span>.handleLoginClick.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.handleLogoutClick = <span class="hljs-keyword">this</span>.handleLogoutClick.bind(<span class="hljs-keyword">this</span>);    <span class="hljs-keyword">this</span>.state = &#123;<span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">false</span>&#125;;  &#125;  handleLoginClick() &#123;    <span class="hljs-keyword">this</span>.setState(&#123;<span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">true</span>&#125;);  &#125;  handleLogoutClick() &#123;    <span class="hljs-keyword">this</span>.setState(&#123;<span class="hljs-attr">isLoggedIn</span>: <span class="hljs-literal">false</span>&#125;);  &#125;  render() &#123;    <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-keyword">this</span>.state.isLoggedIn;    <span class="hljs-keyword">let</span> button = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">if</span> (isLoggedIn) &#123;      button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;    &#125; else &#123;      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;    &#125;    return (      &lt;div&gt;        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;        &#123;button&#125;      &lt;/div&gt;    );  &#125;&#125;ReactDOM.render(  &lt;LoginControl /&gt;,  document.getElementById('root'));</code></pre><h3 id="内联if使用逻辑操作符"><a class="markdownIt-Anchor" href="#内联if使用逻辑操作符"></a> 内联if使用逻辑‘&amp;&amp;’操作符</h3><p>声明一个变量并且使用if语句有条件的渲染组件是一个很好的方法，然而，有时候你想使用一些简短的语法，就需要用到JSX内联表达式。</p><p>JSX可以在‘{}’内嵌套任何表达式，这其中就包括JavaScript逻辑&amp;&amp;操作符，这对于有条件的引入一个元素是很方便的。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Mailbox</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">const</span> unreadMessages = props.unreadMessages;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>      &#123;unreadMessages.length &gt; 0 &amp;&amp;        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>          You have &#123;unreadMessages.length&#125; unread messages.        <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>      &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  );&#125;<span class="hljs-keyword">const</span> messages = [<span class="hljs-string">'React'</span>, <span class="hljs-string">'Re: React'</span>, <span class="hljs-string">'Re:Re: React'</span>];ReactDOM.render(  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Mailbox</span> <span class="hljs-attr">unreadMessages</span>=<span class="hljs-string">&#123;messages&#125;</span> /&gt;</span>,  document.getElementById('root'));</span></code></pre><p>它之所以起作用是因为true &amp;&amp; 表达式　总是得到一个表达式，而false &amp;&amp; 表达式 总是计算为false。因此，如果条件是true,&amp;&amp;后面元素将会被输出，相反如果条件是false，React将会忽略并且跳过它。</p><h3 id="内联if-else条件运算符"><a class="markdownIt-Anchor" href="#内联if-else条件运算符"></a> 内联if-else条件运算符</h3><p>另一种内联方式条件渲染元素是使用JavaScript条件运算符：condition ? true : false</p><pre class="highlight"><code class="jsx"><span class="hljs-comment">//使用条件运算符渲染一小块文本</span>render() &#123;  <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-keyword">this</span>.state.isLoggedIn;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>      The user is <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>&#123;isLoggedIn ? 'currently' : 'not'&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span> logged in.    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  );&#125;<span class="hljs-comment">//它也可以使用在大的表达式中，尽管看起来不明显</span>render() &#123;  <span class="hljs-keyword">const</span> isLoggedIn = <span class="hljs-keyword">this</span>.state.isLoggedIn;  <span class="hljs-keyword">return</span> (    &lt;div&gt;      &#123;isLoggedIn ? (        &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;      ) : (        &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;      )&#125;    &lt;/div&gt;  );&#125;</code></pre><p>就像JavaScript一样，根据你和团队的考虑，可以选择一种适合风格。但要记住，当一个组件的的条件判断过于复杂时，应该考虑拆分组件了。</p><h3 id="阻止组件渲染"><a class="markdownIt-Anchor" href="#阻止组件渲染"></a> 阻止组件渲染</h3><p>极少的情况下，你可能一个组件隐藏它自己，即使它被其它组件渲染。想隐藏组件可以把它的返回值设为null。</p><pre class="highlight"><code class="jsx"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WarningBanner</span>(<span class="hljs-params">props</span>) </span>&#123;  <span class="hljs-keyword">if</span> (!props.warn) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;  <span class="hljs-keyword">return</span> (    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"warning"</span>&gt;</span>      Warning!    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>  );&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(props) &#123;    <span class="hljs-keyword">super</span>(props);    <span class="hljs-keyword">this</span>.state = &#123;<span class="hljs-attr">showWarning</span>: <span class="hljs-literal">true</span>&#125;    <span class="hljs-keyword">this</span>.handleToggleClick = <span class="hljs-keyword">this</span>.handleToggleClick.bind(<span class="hljs-keyword">this</span>);  &#125;  handleToggleClick() &#123;    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">prevState</span> =&gt;</span> (&#123;      <span class="hljs-attr">showWarning</span>: !prevState.showWarning    &#125;));  &#125;  render() &#123;    <span class="hljs-keyword">return</span> (      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">WarningBanner</span> <span class="hljs-attr">warn</span>=<span class="hljs-string">&#123;this.state.showWarning&#125;</span> /&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleToggleClick&#125;</span>&gt;</span>          &#123;this.state.showWarning ? 'Hide' : 'Show'&#125;        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    );  &#125;&#125;ReactDOM.render(  <span class="hljs-tag">&lt;<span class="hljs-name">Page</span> /&gt;</span>,  document.getElementById('root'));</span></code></pre><p>组件的render方法返回null，不能影响到组件生命周期方法。例如：componentWillUpdate 和 componentDidUpdate方法仍然后执行。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJs </tag>
            
            <tag> HTML </tag>
            
            <tag> React学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS Sierra触摸板滑动敏感问题解决方案</title>
      <link href="2016/10/08/tech_stack/MacOS%20Sierra%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%BB%91%E5%8A%A8%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2016/10/08/tech_stack/MacOS%20Sierra%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%BB%91%E5%8A%A8%E6%95%8F%E6%84%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>升级完macOS Sierra系统后，JAVA开发工具滚动条过于敏感问题，原因是由于JDK和Sierra不兼容，由于 Sierra 的触发事件参数比之前系统都复杂一些，而JAVA统一将这些参数处理为默认值，导致滚动速度快了很多，事实上可以发现升级系统后所有Java应用都存在这个问题，包括Eclipse。</p><span id="more"></span><p>下载openJDK112版本：</p><p><a href="http://bintray.com/jetbrains/intellij-jdk/download_file?file_path=jbsdk8u112b403_osx_x64.tar.gz">http://bintray.com/jetbrains/intellij-jdk/download_file?file_path=jbsdk8u112b403_osx_x64.tar.gz</a><br>解压后，移动到/Library/Java/JavaVirtualMachines<br>打开idea,双击shift，弹出对话框，输入Switch IDE JDK</p><p>选择选项后，将openJDK跟换为刚才下载的版本</p><p>重启！</p><p>原文：<a href="https://youtrack.jetbrains.com/issue/IDEA-158500">https://youtrack.jetbrains.com/issue/IDEA-158500</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写Oracle存储过程</title>
      <link href="2015/11/19/tech_stack/%E7%BC%96%E5%86%99Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>2015/11/19/tech_stack/%E7%BC%96%E5%86%99Oracle%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="整体结构"><a class="markdownIt-Anchor" href="#整体结构"></a> 整体结构</h3><pre class="highlight"><code class="sql"><span class="hljs-keyword">create</span> [<span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>] <span class="hljs-keyword">procedure</span> 过程名称(        参数　<span class="hljs-keyword">IN</span>|<span class="hljs-keyword">OUT</span>|<span class="hljs-keyword">IN</span> <span class="hljs-keyword">OUT</span> 类型|表.字段%<span class="hljs-keyword">type</span> [<span class="hljs-keyword">default</span> 默认值],        ……) <span class="hljs-keyword">AS</span>|<span class="hljs-keyword">IS</span>    变量 类型|表.字段%<span class="hljs-keyword">type</span> [<span class="hljs-keyword">default</span> 默认值];    ……<span class="hljs-keyword">begin</span>    ……<span class="hljs-keyword">exception</span>    ……<span class="hljs-keyword">end</span> 过程名称;</code></pre><span id="more"></span><blockquote><p>or replace若存在则替换<br>IN输入参数<br>OUT输出参数<br>IN OUT即可做输入参数，也可做输出参数<br>%type与表的字段同类型<br>default赋默认值（out参数不能赋默认值）<br>过程中参数类型不用指定大小，而声明的变量类型要指定大小。如：字符类型varchar2(30)声明时需要指定30<br>AS|IS没有区别，任选一个即可<br>exception异常处理[可选]</p></blockquote><h3 id="逻辑判断"><a class="markdownIt-Anchor" href="#逻辑判断"></a> 逻辑判断</h3><pre class="highlight"><code class="sql">IF判断if 条件 then    ……elsif 条件 then　　……else    ……<span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;</code></pre><h3 id="for循环"><a class="markdownIt-Anchor" href="#for循环"></a> FOR循环：</h3><p>1、自定义循环次数：</p><pre class="highlight"><code class="sql">for i in 1..1000 loop    ……<span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;</code></pre><p>2、利用游标循环：</p><pre class="highlight"><code class="sql">CURSOR cur IS <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> xxx;for cur_result in cur LOOP    ……<span class="hljs-keyword">END</span> <span class="hljs-keyword">LOOP</span>;</code></pre><h3 id="while循环"><a class="markdownIt-Anchor" href="#while循环"></a> WHILE循环：</h3><pre class="highlight"><code class="sql">while 条件　loop    ……<span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;</code></pre><h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3><table><thead><tr><th style="text-align:center">系统异常</th><th style="text-align:center">异常原因</th></tr></thead><tbody><tr><td style="text-align:center">access_into_null</td><td style="text-align:center">未定义对象</td></tr><tr><td style="text-align:center">case_not_foundcase</td><td style="text-align:center">中若未包含相应的when，并且没有设置</td></tr><tr><td style="text-align:center">collection_is_null</td><td style="text-align:center">集合元素未初始化</td></tr><tr><td style="text-align:center">curser_already_open</td><td style="text-align:center">游标已经打开</td></tr><tr><td style="text-align:center">dup_val_on_index</td><td style="text-align:center">唯一索引对应的列上有重复的值</td></tr><tr><td style="text-align:center">invalid_cursor</td><td style="text-align:center">在不合法的游标上进行操作</td></tr><tr><td style="text-align:center">invalid_number</td><td style="text-align:center">内嵌的 sql 语句不能将字符转换为数字</td></tr><tr><td style="text-align:center">no_data_found</td><td style="text-align:center">使用 select into 未返回行，或应用索引表未初始化的</td></tr><tr><td style="text-align:center">too_many_rows</td><td style="text-align:center">执行 select into 时，结果集超过一行</td></tr><tr><td style="text-align:center">zero_divide</td><td style="text-align:center">除数为 0</td></tr><tr><td style="text-align:center">subscript_beyond_count</td><td style="text-align:center">元素下标超过嵌套表或varray的最大值</td></tr><tr><td style="text-align:center">subscript_outside_limit</td><td style="text-align:center">使用嵌套表或 varray 时，将下标指定为负数</td></tr><tr><td style="text-align:center">value_error</td><td style="text-align:center">赋值时，变量长度不足以容纳实际数据</td></tr><tr><td style="text-align:center">login_denied</td><td style="text-align:center">pl/sql 应用程序连接到 oracle 数据库时，提供了不正确的用户名或密码确的用户名或密码</td></tr><tr><td style="text-align:center">not_logged_on</td><td style="text-align:center">pl/sql应用程序在没有连接 oralce 数据库的情况下访问数据问数据</td></tr><tr><td style="text-align:center">program_error</td><td style="text-align:center">pl/sql 内部问题，可能需要重装数据字典＆ pl./sql系统包统包</td></tr><tr><td style="text-align:center">rowtype_mismatch</td><td style="text-align:center">主游标变量与 pl/sql 游标变量的返回类型不兼容</td></tr><tr><td style="text-align:center">self_is_null</td><td style="text-align:center">使用对象类型时，在 null 对象上调用对象方法</td></tr><tr><td style="text-align:center">storage_error</td><td style="text-align:center">运行 pl/sql 时，超出内存空间</td></tr><tr><td style="text-align:center">sys_invalid_id</td><td style="text-align:center">无效的 rowid 字符串</td></tr><tr><td style="text-align:center">timeout_on_resource</td><td style="text-align:center">oracle 在等待资源时超时</td></tr></tbody></table><h3 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h3><pre class="highlight"><code class="sql"><span class="hljs-keyword">create</span> [<span class="hljs-keyword">or</span> <span class="hljs-keyword">replace</span>] <span class="hljs-keyword">procedure</span> 过程名称(        参数　<span class="hljs-keyword">IN</span>|<span class="hljs-keyword">OUT</span>|<span class="hljs-keyword">IN</span> <span class="hljs-keyword">OUT</span> 类型|表.字段%<span class="hljs-keyword">type</span> [<span class="hljs-keyword">default</span> 默认值],        ……) <span class="hljs-keyword">AS</span>|<span class="hljs-keyword">IS</span>    变量 类型|表.字段%<span class="hljs-keyword">type</span> [<span class="hljs-keyword">default</span> 默认值];    ……    userException exception;<span class="hljs-keyword">begin</span>    <span class="hljs-keyword">if</span> 条件　<span class="hljs-keyword">then</span>        <span class="hljs-keyword">raise</span> userException;    <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;    ……exception    when no_data_found then        <span class="hljs-comment">--系统异常</span>　　when userException then        <span class="hljs-comment">--自定义异常</span>    when others then       <span class="hljs-comment">--其他异常</span><span class="hljs-keyword">end</span> 过程名称;</code></pre><h3 id="goto语句"><a class="markdownIt-Anchor" href="#goto语句"></a> goto语句：</h3><p>Oracle中没有continue关键字，在loop中可以用goto语句实现同样的效果。<br>goto会增加程序复杂度，可读性变差使程序不易控制和维护。<br>&lt;&lt; &gt;&gt;后面不能直接跟EXCEPTION这种关键字类的语句，要用NULL把标签跟关键字隔开。类似的关键字还有END LOOP之类的，等等。</p><pre class="highlight"><code class="sql"><span class="hljs-keyword">declare</span>   i <span class="hljs-built_in">int</span> := <span class="hljs-number">1</span>;<span class="hljs-keyword">begin</span>   <span class="hljs-keyword">loop</span>   dbms_output.put_line(<span class="hljs-string">'输出i='</span> || i);   if i = 10 then   goto end_loop;   <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span>;   i := i + 1;   <span class="hljs-keyword">end</span> <span class="hljs-keyword">loop</span>;   &lt;&lt;end_loop&gt;&gt;   null;exception    ……<span class="hljs-keyword">end</span>;</code></pre><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3><p>– 单行注释<br>/* */ 多行注释</p><p>注释必须在create [or replace] procedure之内，否则不能保存。</p><p>其他问题<br>DBMS_OUTPUT.put_line()打印方法可用于跟踪调试<br>PL/SQL DEVELOPER自带调试功能</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> 存储过程 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪</title>
      <link href="2015/11/07/blog/%E9%9B%AA/"/>
      <url>2015/11/07/blog/%E9%9B%AA/</url>
      
        <content type="html"><![CDATA[<p>北风卷地白草折，胡天八月即飞雪。忽如一夜春风来，千树万树梨花开。</p><p><img src="/2015/11/07/blog/%E9%9B%AA/QQ20151107135838.jpg" alt="下雪了"><span class="image-caption">下雪了</span></p><span id="more"></span><p>是的，这就是昨天早晨首先映入我眼帘的景象，虽然远远没有达到这个程度，但对于J城来说，也可以这样来说了。雪，对于我这样一个很久没看到过的东北人来说是一种常人很难体会到的感觉。当我走出房屋融入到其中的那一刻，心里徘徊的一个念头告诉我“我想家了”。</p><p>是啊，离家多年却从来没有真正意义的回过家乡了，很久没有感受过腊九寒冬，没有看到过银装素裹的北国风光了，甚至可能已经渐渐的忘记那种冷的感觉，有很多朋友问我是怎么忍耐那种严寒呢，我的回答是你怎么知道我们不是在享受呢。没错没有经历过的你，也许觉得难以置信。让我无耐的是有一些人，仅仅去过几次却妄加评判，我也只能呵呵了。</p><p>记得小学的时候，语文课的一篇作文，题目就是《雪》，当时外面大雪纷飞，老师为了让我们能写好决定那节课可以自由外出去感受，结果所有同学都跑到操场去写作文，当时写作文都是套用的各种模版像什么“银装素裹”，“雪你是可爱的美容师”等等，还有什么“鹅毛大雪，漫天飘舞”，结果交作业的时候，大多数人的写法都差不多==!</p><p>在我印象中那时候的雪总是特别的大的，过膝盖也是很平常的，鹅毛大雪说的真不是特别夸张，下雪后的全校上午可以少上一到两节课去操场扫雪，虽然挺累但是大家的兴致还是特别高，其中的乐趣无穷无尽。课间的时候打雪仗、堆雪人、摔跤，每当这个时候每个人包括老师都会忘记自己的身份，而变成对手。</p><p>往事总是让人感觉很美好，更多的是因为当时没有好好体会，一直是认为是理所当然，等到失去后才知道难能可贵，到头来也只能触景生情罢了。</p><p>多么希望的画面能定格在此时，一个孤寂的黑色身影走在茫茫的白色世界中……</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>折腾</title>
      <link href="2015/10/26/blog/%E6%8A%98%E8%85%BE/"/>
      <url>2015/10/26/blog/%E6%8A%98%E8%85%BE/</url>
      
        <content type="html"><![CDATA[<p>又是疲劳的一个月，又是一个又爱又恨的月分。</p><p>十一小长假又去一趟北戴河，不过这次却少了些上一次的感觉，却多了几分回味和体会，本来是想去青岛的，还好没抢到青岛的票，38元一只的虾想想都后怕……俗话说“乐极生悲，物极必反”，疯狂的假期后迎接我的就是一轮疯狂的加班，累的我是前仰后合。</p><span id="more"></span><p>一直以来都对自己的这个网站都不是特别满意，不论是功能、布局、还是内容等等，所以一直都在不断的改啊改调啊调的，这次做了比较大的调整，虽然也不算特别满意，但也可以让自己的心里抗一段时间了。</p><p>前些天用了一年的.info域名到期了，我犹豫了好久决定换回.com域名，总感觉其它域名有些不正规，应该是先入为主的影响吧。之前一直用的是.com的，去年也不知怎么的头脑发热，用了一年的.info其实主要还是因为当时比较便宜。这次换回来以后也不会再变了，除非这个站不开了。为了以后可以拓展更多功能，这次加上了二级域名blog，以后博客这块都会在这个二级域名下了，这样才能完全利用域名。</p><p>说来真是惭愧，网站建了好几年了，天天折腾外皮，内容却没怎么更新太多，正如某些博客前辈所批评的那样，目前域名Google PR 是1，这也还是我第一年刚申请时攒下来的，后来就没涨过。</p><p>本来也没想把这件事发展成怎样，其实也就算是一种娱乐吧，也不想天天弄什么长篇大论，也不想通篇BUG攻略什么，所以每当这个时候，写的都是一些流水文吧，不过那又怎么样呢，感觉也挺好的！<br>你好，10月！</p>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS Content</title>
      <link href="2015/04/11/tech_stack/CSS%20Content/"/>
      <url>2015/04/11/tech_stack/CSS%20Content/</url>
      
        <content type="html"><![CDATA[<h3 id="定义与用法"><a class="markdownIt-Anchor" href="#定义与用法"></a> 定义与用法</h3><p>content 属性与 :before 及 :after 伪元素配合使用，来插入生成内容。该属性用于定义元素之前或之后放置的生成内容。默认地，这往往是行内内容，不过该内容创建的框类型可以用属性 display 控制。</p><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">none</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">normal</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">content specifications</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">inherit</td><td style="text-align:center">规定应该从父元素继承 content 属性的值。</td></tr></tbody></table><span id="more"></span><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:before</span>&#123; <span class="hljs-attribute">content</span>:<span class="hljs-string">"书记说："</span>; <span class="hljs-attribute">color</span>:red;&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>同志们好！<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="浏览器支持"><a class="markdownIt-Anchor" href="#浏览器支持"></a> 浏览器支持</h3><p>所有浏览器都支持 content 属性。</p><h3 id="特殊字符"><a class="markdownIt-Anchor" href="#特殊字符"></a> 特殊字符</h3><p>content属性同样支持ASCII 特殊字符，具体字符请参考(X)HTML的特殊字符，如果想要查询某个符号的数值可以使用the Entity Conversion Calculator进行转换或者反向转换。</p><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:before</span>&#123; <span class="hljs-attribute">content</span>:<span class="hljs-string">"\2660"</span>; <span class="hljs-attribute">color</span>:red;&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>A（红桃A）<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="属性的使用"><a class="markdownIt-Anchor" href="#属性的使用"></a> 属性的使用</h3><p>content属性还可以通过attr(属性名)方式与标签属性相结合使用。</p><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:before</span>&#123; <span class="hljs-attribute">content</span>:<span class="hljs-built_in">attr</span>(title); <span class="hljs-attribute">color</span>:red;&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"副"</span>&gt;</span>总经理说：全体涨工资！<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h3 id="功能进阶"><a class="markdownIt-Anchor" href="#功能进阶"></a> 功能进阶</h3><p>与CSS3相配合实现类似title属性的功能，但是比title体验效果好。</p><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-tag">a</span> &#123;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#900</span>;  <span class="hljs-attribute">text-decoration</span>: none;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;  <span class="hljs-attribute">color</span>: red;  <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[tip]</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">:after</span> &#123;  <span class="hljs-attribute">content</span>: <span class="hljs-built_in">attr</span>(tip);  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">8px</span>;  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;   <span class="hljs-attribute">top</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">white-space</span>: nowrap;   <span class="hljs-attribute">z-index</span>: <span class="hljs-number">20px</span>;  <span class="hljs-attribute">-moz-border-radius</span>: <span class="hljs-number">5px</span>;   <span class="hljs-attribute">-webkit-border-radius</span>: <span class="hljs-number">5px</span>;    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;    <span class="hljs-attribute">-moz-box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">#222</span>;    <span class="hljs-attribute">-webkit-box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">#222</span>;    <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span> <span class="hljs-number">4px</span> <span class="hljs-number">#222</span>;    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">-moz-linear-gradient</span>(top, #eeeeee, #cccccc);    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">-webkit-gradient</span>(linear,left top,left bottom,color-stop(0, #eeeeee),<span class="hljs-built_in">color-stop</span>(1, #cccccc));  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">-webkit-linear-gradient</span>(top, #eeeeee, #cccccc);    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">-moz-linear-gradient</span>(top, #eeeeee, #cccccc);    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">-ms-linear-gradient</span>(top, #eeeeee, #cccccc);    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">-o-linear-gradient</span>(top, #eeeeee, #cccccc);  &#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">tip</span>=<span class="hljs-string">"鼠标已悬浮！"</span>&gt;</span>请把鼠标悬浮在此！<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> CSS </tag>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等我</title>
      <link href="2015/04/07/blog/%E7%AD%89%E6%88%91/"/>
      <url>2015/04/07/blog/%E7%AD%89%E6%88%91/</url>
      
        <content type="html"><![CDATA[<p>等我有时间了……等我有钱了……等我……等我……</p><p>曾经或者现在不知道被这句话忽悠了多少次，一次又一次拿着这句连鬼不都信的话在敷衍着，欺骗着自己那纯洁的心灵。</p><span id="more"></span><p>体育运动是我一直以来的爱好，尤其篮球是我最喜欢的运动，从小学开始我就接触到了篮球，当时我是我们班里第一个学会三步篮的人，同学们那羡慕的眼神让我至今记忆犹新。都说好的开始是成功的一半，在我看来却未必，这只是一些人为了让自己坚持下去而找的一个鼓励自己的方式。到了中学时期，我几乎每次都是篮球比赛中的首发阵容，随着一年年的长大，除了年龄没被落下外，身高和体重到后来却慢慢的被甩开了一大截，以至于从原来的锋位掉到了后来的后位。虽然一些客观原因让我无法控制，但还是凭借着我那无人能及的速度和投篮精准的优势没让我彻底掉下神坛。后来我和我的室友们发展了第二纵队（由第二阵容人员组成）王朝，当时整个学校没有几个能打过我们那个阵容，现在想想依旧心潮澎湃。后来学习压力越来越大，渐渐地玩球的时间越来越少，当时我对自己说的一句话就是“等我以后有时间了，要好好的玩”，现在时间是有了，可是人却再也凑不齐了。</p><p>都说现在过年过节越来越没有味道了，方式方法没什么变化，为什么会变得没意思了呢。对我来说原因有几条，以前家庭经济条件不太好，平时省吃俭用的过日子，只有过年时才能吃得到平时吃不到的东西，玩到平时玩不到的，年少无愁。记得当时过完除夕盼十五，因为只有那天才有我最喜欢的元宵，家里有时为了省钱，不会去外面买，自己用糖和花生什么的自己包，有时候包的不好咬的特别硬，即使那样我还吃的满嘴留香，而且总是吃不够，当时我就想“等我挣钱了，我要买好多好多圆宵吃”。后来，我真的挣钱了，<a href="/2015/03/09/blog/%E5%90%83%E6%B1%A4%E5%9C%86/">正月十八买的勉强吃了两次，现在还剩半袋在冰箱放着</a>！</p><p>最近我的朋友圈里有一个每天坚持学英语的，每天为了鼓励自己都写一句话，今天写的是“困难就怕坚持二字”，我想了想这句话改成“困难就怕行动二字”更适合我。很多时候真的不太需要等我，只是我们更想等我而已，莫怠明日……</p><hr><p>明 ·钱鹤滩《明日歌》</p><p>明日复明日， 明日何其多？<br>我生待明日， 万事成蹉跎。<br>世人若被明日累，春去秋来老将至。<br>朝看水东流， 暮看日西坠。<br>百年明日能几何？ 请君听我明日歌！</p><hr>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>寻找失去的记忆</title>
      <link href="2015/04/02/blog/%E5%AF%BB%E6%89%BE%E5%A4%B1%E5%8E%BB%E7%9A%84%E8%AE%B0%E5%BF%86/"/>
      <url>2015/04/02/blog/%E5%AF%BB%E6%89%BE%E5%A4%B1%E5%8E%BB%E7%9A%84%E8%AE%B0%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p>我可能是个喜欢回忆的人，往往越久远的事，我越喜欢去想，然后是一阵感慨，然后再怀念，然后再伤感，然后再…</p><p>不知怎么着，已经几年都没联系过的高中同学最近异常活跃，还建立了微信讨论组。每天都说个不停，我也“有幸”被拽了进去，偶尔也参与一下讨论，大多数情况都没人理我，让我找不到存在感，于是我慢慢的发展成了潜水一族，现在想想那几年混的挺失败的，没有什么人缘，唯一的几个死党也随着时间的流逝逐渐疏远了。这就是当初我死活都不敢相信的现实，我不知道时间改变了什么，我只知道我还是那个我。</p><span id="more"></span><p>现在我身边讨论最多的话题就是结婚了，同事结婚，同学结婚，朋友结婚，身边的人都在结婚。是啊，到了这该死的年纪除了结婚还能有什么呢。前两天有个同学在qq上问我现在在哪怎么样之类的，我当时很诧异因为我已经和他几年没联系过了，上学的时候关系不能说有多深交情至少面上还是不错的。我开玩笑回复他我在外地谋生啊，然后他说：”是吗，我要结婚了，还想请你来喝喜酒呢，你也回不来了啊！“。我又回复他，是啊，最近有好多同学都结婚了，我也回不去，只能祝福你们了。当我还在等着他的回复时，却再也没有声音了。后来我得知有一个同学也没参加，但是礼钱到了。</p><p>没错我确实人缘不行，如果美好的东西非要带上铜臭的气味，我宁愿抛弃。如果要加上一个期限的话，那就永远吧！今夜我再一次迷失了自己，回到了无穷无尽的记忆中。”同学你叫什么名字，朋友我们在哪见过，兄弟你还记得我吗“，当我得知我曾经暗恋过的女生，已经为人妻为人母的那一刻，我才知道我当时的愚蠢。疯狂一次也许一切都会不一样，可是谁又能说那就是错呢，也许错的是我依旧还在原地踏步。</p><p>打开相册，寻找记忆中的点滴，虽然我可能忘记了你，但我却依然努力的想起…标记…</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Z的自白</title>
      <link href="2015/03/21/blog/Z%E7%9A%84%E8%87%AA%E7%99%BD/"/>
      <url>2015/03/21/blog/Z%E7%9A%84%E8%87%AA%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<p>“Z，22岁生日快。”<br>“谢谢！希望新的一岁我会抬头……”<br>我来自H市X县的一个小地方，以前的我一直都认为是自命不凡的，这个想法不知道是何时萌生的，也许是从我来到这个世界的那一刻吧，因为<a href="ttp://baike.baidu.com/subview/26664/8839700.htm">龙抬头</a>那天，我注定的不平凡人生就这样开始了。</p><span id="more"></span><p>这还得从我和我现在已经不认识了的表弟第一天上学说起，那个时候学校离家比较远，交通条件也不好，只能步行两三里地去上学，当时我不知道我为什么要去一个那么多人地方，妈妈告诉我上课不许说话，铃声响后就下课了。于是，我一直没有说话，别人跟我说话我都不理会。而在妈妈走后不知过了多久，我终于听到了铃声，而我却把课间休息当成了放学，我跑到学校门口找了妈妈很久都没找到，于是我做了一次不寻常的事，自己走回了家，回到家里大人们都震惊了，当时应该是5岁左右，具体记不清了。</p><p>辗转间来到了一个新的地方开始了我的小学，那也是我记忆中最美好无忧的时光。班长，委员，同桌，最好的组长，最好的朋友，最美的同学……当时忘记了是什么原因，我和一个同学打架把他推倒在地上，脸都划破了。那也是我人生中第一次打架，回到家后我很害怕，也没敢告诉父母，那个同学的家长找到了家里，我都没敢出门，后来因为大人们都认识也就不了了之了。漫长的小学时光终于在我的长大成材梦中结束了，毕业晚会上也随着当时非常火的同一首歌落下的帷幕，炉火徐徐……我们毕业了。“鲜花曾告诉我你怎样走过，大地知道你心中的第一个角落，甜蜜的梦啊谁都不会错过……”</p><p>就这样一点点，一步步，我醒了，醒得那么干脆。</p><p>我叫Z，我来自H市X县的一个小地方，以前的我一直都自命不凡！<br>(未完待续……)</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>站长也要懂项目</title>
      <link href="2015/03/18/blog/%E7%AB%99%E9%95%BF%E4%B9%9F%E8%A6%81%E6%87%82%E9%A1%B9%E7%9B%AE/"/>
      <url>2015/03/18/blog/%E7%AB%99%E9%95%BF%E4%B9%9F%E8%A6%81%E6%87%82%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在当今社会中，一切都是项目，一切都将成为项目。</p></blockquote><blockquote><p>——美国项目管理专业资质认证委员会主席Paul Grace</p></blockquote><p>博客建立也有一年多啦，一直在断断续续的维护着，三天打渔，几个月晒网，找个好听点的借口“忙”。</p><span id="more"></span><p>俗话说“麻雀虽小，五脏俱全”，我这小站点也算是经历过风风雨雨啦，建立之初的想法是怎么也算是个ＩＴ人啦，给人做过的网站也有很多啦，为什么还没有自己的小站呢。于是网上找了好久买了一个云服务器，整个网站的全部架构全是我自己设计的，做了半个多月试运行上线了，虽然功能不是很全，但是一直在不断的完善，当时成就感天天爆棚。半年后通过一点点的了解，发现大多数的个人网站用的都是虚拟主机，于是将目光移到了这边，经两三考虑对于没有收入的网站来说，云服务器确实像它的名字一样，有点高不可及，可是虚拟主机一般支持的都是ＰＨＰ网站而我那个网站是ＪＡＶＡ做的自然就不能用了，还是有一些失望，再三衡量下我还站在了成本这一面。那么问题来啦，“空间技术哪家强”，“怎么建站”……，对于ＰＨＰ我也是一窍不通，于是网上搜罗各种攻略，手册等等直到现在，虽不敢说是什么大牛，但建站各种问题，我也应该能说说一二啦，看来抽时间我也可以写一篇建站攻略啦<sup>_</sup>。</p><p>对于网站来说，其实最重要的就是Search Engine Optimization，也就是我们常说的搜索引擎优化简称ＳＥＯ，网上对这方面的攻略比比绋皆是，除非你向我一样不是特别追求页面的访问量，否则我相信你应该看过很多类似的文章。虽然我并没有对这方面的技术有过太多的研究，但是我却对这方面有一些特别的看法。</p><p>我认为站长优先关注的，恰恰不是ＳＥＯ（也不是瓜子），而是网站本身质量。首先内容是否有吸引力、新颖，如果你的网站能在这方面搏到访客的满意，那么你就不太需要做别的来浪费时间啦。然而往往大多数人都是废在这儿了，这是硬实力的体现，只能自己努力啦。其次，是页面的流畅度和交互感觉方面。我相信如果一个受访页面在３秒之内加载不出来，这个网站在访客心中印象的地位就大打折扣了，如果５秒中之内还打不开，我会选择直接关掉，除非你有让我不得不看的理由。不过你真的有这本事，你还优化什么流量啊！你不就垄断了吗……质量是一个项目最基本的要求，如果一产品边最基本的质量都保证不了，那么这个产品可能不会成功。之所以用“可能”两字，原因在于不同环境下有不同的需求，不同的需求下又造成了不同的标准，所以不同的产品质量的好坏也就无法做到统一评判。归结一句话就是干系人是否满意，从马桶盖上就可以看出些问题了…….</p><p>影响到用户体验的因素往往有很多，比如常说的主机类型，带宽大小，以及智能交互的体验等方面，而说到这些往往也都会牵扯一个问题“成本”，尤其对没有收益的小网站来说，当然要想办法越低越好啦。但是这里需要注意到一个前提“不影响体验效果”，也就是一直说的保证质量。有些人可能不太想花钱，但是也想搭建一个网站，于是就到处搜寻免费空间，费了好大的劲终于弄好了，也写了好多内容，功能和体验上也花费了好多心思，结果没过几个月或者几天，主机数据全部丢失或停止运营，最后连灰都没见着！你可能会想，没事反正也没花钱没啥损失。但是，真的没什么损失吗，你所付出的精力，你辛辛苦苦写出来文章，即使你的内容全都是些流水仗，那也是付出了机会成本的。当然一个产品的好与坏不能仅仅用成本的高低来区分，最根本的因素还是质量达标－干系人满意。然而质量有时又不仅仅说的是产品的本身，雾霾就是很好的例证……</p><p>虽然我并不是什么技术大牛，但凭借这么多年的实践，我相信做到每天几更应该是不成问题的，但事实上我并没有这么做，因为从最开始的定位上我就不想让我的地盘变成一个纯技术类型，我只想在这里记录的是日常的点点滴滴，可以是任何类型。这个问题也就涉及到你的网站想要发展的范围，它是整个网站的骨架，直接影响着你网站的流量。你的网站到底是什么类型，一定要做到心中有数。</p><p>前面谈到硬实力，须要长时间的积累，但是就像我一样眼下并不达不到，难道就被判死刑了吗。也不一定，硬的不行咱来软的呗，交流是可以很好解决这一问题的办法，只有互动多了才能发掘出更多的想法和不被所知的见解，流量也自然而然就上去了。</p><p>有了这些，你还用ＳＥＯ吗？用，当然用，锦上添花嘛<sup>_</sup>……</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>吃汤圆</title>
      <link href="2015/03/09/blog/%E5%90%83%E6%B1%A4%E5%9C%86/"/>
      <url>2015/03/09/blog/%E5%90%83%E6%B1%A4%E5%9C%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>独在异乡为异客，每逢佳节倍思亲。遥知兄弟登高处，遍插茱萸少一人。<br>—王维</p></blockquote><p>十五的元宵十八吃，说到元宵让我想起前天下班高峰期的８号线瘫痪，好多人都去鸟巢看灯，导致截流限行排了半个小时才上去。</p><span id="more"></span><p>记得以前在家的时候每到十五那天，家家户户都会走出家门，我们那里叫做“走百步”，意思是除百病，让一年有个好身体。大街上人来人往，有的跑着，有的蹦着，有的手里提着灯笼，有的嘴里嚼着冰糖葫芦；有集体放烟花的，也有组织扭大秧歌的，雪花飞舞，冰灯闪耀，街边到处都是点的透亮的火堆……</p><p>另一个习俗应该就是往河里仍硬币了，一块的，五角的，一毛的，还有几分的。好多人到了第二天就下去捡，据说可以让你小发一笔的。路上遇到卖小灯笼的，我们叫喊着让母亲给买一个，软磨硬泡下母亲终于给我和小哥一人买了一个，小灯笼是玻璃做的，在里面放上蜡烛，专门喜欢往黑暗的地方跑，那叫一个开心，整个晚上都高兴的无法入睡。</p><p>散步回来，最大的期待就是煮元宵啦，那个时候一年到头来就只有这一天才能吃得到元宵，满满吃了两大碗小肚子撑的圆鼓鼓的，却还是眼巴巴的看着锅里剩下的，真嫌自己的肚子太小。</p><p>后来，大一些了才知道了，有北方“滚”元宵，南方“包”汤圆的说法，那个时候记得大人总是喜欢给小孩讲一个故事，大意就是说俄罗斯人来中国看到元宵，怎么也弄不明白为什么中国人能把元宵包的那么圆，然后大人总是自豪的说滚圆的呗。</p><p>再大一些后，总是在十五的时候吃元宵，可是我发现每次回来时候包装上写的都是汤圆，从没看过有写着元宵的，不知为何，我开始怀疑我是否吃过真的元宵，难免总有一些失落感！</p><p>…</p><p>哐嘁哐嘁，终于做上地铁啦，吃了点快餐，到家了……</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回归平常</title>
      <link href="2015/03/02/blog/%E5%9B%9E%E5%BD%92%E5%B9%B3%E5%B8%B8/"/>
      <url>2015/03/02/blog/%E5%9B%9E%E5%BD%92%E5%B9%B3%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>龙应台写给儿子安德烈的一段话，“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。</p></blockquote><p>转眼间，年已过，节已跑，与预想中一样，除了又老了一岁，就真的再也没有别的了。送走了亲朋暂别了好友，生活又回归到了原有，一个春节过后钱包在不知不觉中少了几千块大洋，还引起不小风波。算了算小时候一共收到的红包都没这一次发出去的多，Ｄuang！！！</p><span id="more"></span><p>节前信誓旦旦的不惰落，又荡成了一波波水纹，放松了一个小长假后，又要转换回奔波学习的节奏，确实有很大的挑战，有些不知所措。</p><p>刚看了一下最近讨论最热的<a href="https://www.baidu.com/s?wd=%E7%A9%B9%E9%A1%B6%E4%B9%8B%E4%B8%8B%20%E6%9F%B4%E9%9D%99">《穹顶之下》</a>，这部百万巨作，终于解答了我一直以来的疑问。“是什么？从哪来？到哪去？”　发展可以与环境同在，但铜臭才是万恶之根！</p><p>好了，不唠叨啦，戴上口罩谋生去了……</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无心</title>
      <link href="2015/02/03/blog/%E6%97%A0%E5%BF%83/"/>
      <url>2015/02/03/blog/%E6%97%A0%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<p>无心工作，无心看书，两周，一周，5天，3天……，人人都在倒数着，期盼着！</p><p>冬去春来，新年的脚步已然渐渐走近，不知不觉中，时光悄然逝去，到头来浑浑噩噩的不是唱着<a href="http://music.baidu.com/song/128356356?fm=altg4">时间都去哪了</a>就是什么<a href="http://music.baidu.com/song/13132725?fm=altg3">时光时光慢些吧</a>，了然无趣。</p><span id="more"></span><p>今年春节应该是近几年比较热闹的一年，好多亲戚都要聚到一起来过年，记得小时候每逢春节都有好多人，欢聚一堂，只有经历过才能体会到什么叫年味；长大后，为生活，为“幸福”，或者不知道为了什么，各自四散，得到了很多，却失去了更多。</p><p>Ｊ城今冬下三场雪，一场十分钟（没有亲眼看见），一场五分钟，一场在梦里。</p><p>总是想做一些事情，可实现起来才知道想和做的结合有多么困难，明日复明日，于是，一连串的恶性循环就开始了。</p><p>明年是期待收获的一年，想要花开，就不能停止灌溉！</p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>等一分钟MV</title>
      <link href="2015/01/09/blog/%E7%AD%89%E4%B8%80%E5%88%86%E9%92%9FMV/"/>
      <url>2015/01/09/blog/%E7%AD%89%E4%B8%80%E5%88%86%E9%92%9FMV/</url>
      
        <content type="html"><![CDATA[<p>最近迷上mv于是拿出以前录的歌用了十几个小时的视频制作，完成了这个mv，也算是处女作啦，瑕疵很多，但毕竟也算是一点成果,相信后续会起来越来越精致。</p><iframe width="510" height="498" src="http://player.youku.com/embed/XODY3ODc2MTEy" frameborder="0" allowfullscreen="allowfullscreen"></iframe><p><em>歌曲录制于2011年</em></p>]]></content>
      
      
      <categories>
          
          <category> 自娱自乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MV </tag>
            
            <tag> 翻唱 </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又到一年十一时(一)</title>
      <link href="2014/10/01/blog/%E5%8F%88%E5%88%B0%E4%B8%80%E5%B9%B4%E5%8D%81%E4%B8%80%E6%97%B6/"/>
      <url>2014/10/01/blog/%E5%8F%88%E5%88%B0%E4%B8%80%E5%B9%B4%E5%8D%81%E4%B8%80%E6%97%B6/</url>
      
        <content type="html"><![CDATA[<p>雨依旧淅沥沥的飘个不停仿佛从未停息,转眼间冬去秋来又是一年，徘徊与迷茫仍是这一年的主题，不同的是收获了更多新鲜而有意义的人或事，<a href="/2013/10/08/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%B8%80">回想起去年那雨中穿梭，奋勇前行的情景</a>,仍在继续，必将终身难忘，而如此更多的激情我想才刚刚开始。</p><p>今年的北京比每年冷的有些早，刚进十月就已经有些冬天的感觉了，整个黄金周只能猫在窝里了，外面的世界虽然很精彩，但是一票难求的咱们却是桑不起啊。</p><span id="more"></span><p>听说又有砖家同志发言了建议取消黄金周，此人正是当年提出取消五一的那位，我的小心脏又开始担心了，这不会是最后的黄金“粥”了吧，可惜我还没有抓住机会去享受；听说高考要取消英语了，我不禁泪流满面啊；听说乌克兰要闹独立，我不禁又要泪流满面；听说……听说……。好吧这一年发生的事还真不少，可怜我这小小的记忆内存啊！</p><p>话说我今年又搬了两次家，这让我越来越觉得漂着的感觉是多么的让人无奈了。不禁让我想起了一句诗词“有的房空着，可你却住不起；有些人住的起，可他们却不惜住。”于是乎，我渐渐的靠近了七环，疏远了组织。</p><p>明年也许依旧是平凡的一年，但更是我期待的一年，也会是我努力收获的一年，也许在别人眼中不值一提。</p><h3 id="努力共勉-2014"><a class="markdownIt-Anchor" href="#努力共勉-2014"></a> 努力，共勉-2014</h3>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网页head内容跑到了body中</title>
      <link href="2014/09/29/tech_stack/%E7%BD%91%E9%A1%B5head%E5%86%85%E5%AE%B9%E8%B7%91%E5%88%B0%E4%BA%86body%E4%B8%AD/"/>
      <url>2014/09/29/tech_stack/%E7%BD%91%E9%A1%B5head%E5%86%85%E5%AE%B9%E8%B7%91%E5%88%B0%E4%BA%86body%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<p>最近发现博客的favicon图标在chrome浏览器中不显示，但在IE中却可以，于是我打开调试工具查看，结果发现HTML head标签的内容全部跑到body中去了，由于favicon必须在head标签中所以现在不能显示了。于是排查可能出现的问题：</p><blockquote><p>1.存在标签未闭合等问题<br>2.存在移动head内容的js代码等问题<br>3.存在编码或乱码等问题</p></blockquote><span id="more"></span><p>经过检查后排除了1.2项的问题于是把注意力集中在第三个问题上，经过一阵咕弄终于发现了由于文件保存的时候编码存在BOM标记。</p><p>BOM是Windows下记事本软件保存一个UTF-8编码的文件时开头正文的一部分来表明编码方式的隐藏字符，对于一般文件貌似没有什么太大麻烦，但对于PHP来说却不是个福星，它会被PHP完全读取出来，使整个网页向下填充无法紧贴浏览器顶部，并且可能出现标签混乱。</p><p>既然找到了问题就着手解决问题吧。</p><ul><li><p>一种方法是手动将文本在编辑器中打开，将编码转换为UTF-8无BOM编码方式，当然如果你的文件太多这个方法就不太适用了。</p></li><li><p>第二种方法如下</p></li></ul><pre class="highlight"><code class="php"><span class="hljs-meta">&lt;?php</span> $basedir = str_replace(<span class="hljs-string">'/clearBOM.php'</span>,<span class="hljs-string">''</span>,str_replace(<span class="hljs-string">'\\'</span>,<span class="hljs-string">'/'</span>,dirname(<span class="hljs-keyword">__FILE__</span>)));$auto = <span class="hljs-number">1</span>;checkdir($basedir);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkdir</span><span class="hljs-params">($basedir)</span></span>&#123;<span class="hljs-keyword">if</span> ($dh = opendir($basedir)) &#123;<span class="hljs-keyword">while</span> (($file = readdir($dh)) !== <span class="hljs-keyword">false</span>) &#123;<span class="hljs-keyword">if</span> ($file != <span class="hljs-string">'.'</span> &amp;&amp; $file != <span class="hljs-string">'..'</span>)&#123;<span class="hljs-keyword">if</span> (!is_dir($basedir.<span class="hljs-string">'/'</span>.$file)) &#123;$filename = $basedir.<span class="hljs-string">'/'</span>.$file;<span class="hljs-keyword">echo</span> <span class="hljs-string">'filename:'</span>.$basedir.<span class="hljs-string">'/'</span>.$file.checkBOM($filename).<span class="hljs-string">'&lt;br&gt;'</span>;&#125; <span class="hljs-keyword">else</span> &#123;$dirname = $basedir.<span class="hljs-string">'/'</span>.$file;checkdir($dirname);&#125;&#125;&#125;closedir($dh);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkBOM</span> <span class="hljs-params">($filename)</span> </span>&#123;<span class="hljs-keyword">global</span> $auto;$contents = file_get_contents($filename);$charset[<span class="hljs-number">1</span>] = substr($contents, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);$charset[<span class="hljs-number">2</span>] = substr($contents, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);$charset[<span class="hljs-number">3</span>] = substr($contents, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<span class="hljs-keyword">if</span> (ord($charset[<span class="hljs-number">1</span>]) == <span class="hljs-number">239</span> &amp;&amp; ord($charset[<span class="hljs-number">2</span>]) == <span class="hljs-number">187</span> &amp;&amp; ord($charset[<span class="hljs-number">3</span>]) == <span class="hljs-number">191</span>) &#123;<span class="hljs-keyword">if</span> ($auto == <span class="hljs-number">1</span>) &#123;$rest = substr($contents, <span class="hljs-number">3</span>);rewrite ($filename, $rest);<span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;font color=red&gt;BOM found,automatically removed.&lt;/font&gt;'</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;font color=red&gt;BOM found.&lt;/font&gt;'</span>;&#125;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">'BOM Not Found.'</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rewrite</span> <span class="hljs-params">($filename, $data)</span> </span>&#123;$filenum = fopen($filename, <span class="hljs-string">'w'</span>);flock($filenum, LOCK_EX);fwrite($filenum, $data);fclose($filenum);&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>将上面代码保存为PHP文件（注意编码格式哦），然后上传后在浏览器中执行一下就OK了，看一下效果，搞定收工……^^!</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> BOM </tag>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Properties文件</title>
      <link href="2014/09/28/tech_stack/Java%20Properties%E6%96%87%E4%BB%B6/"/>
      <url>2014/09/28/tech_stack/Java%20Properties%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>Java开发者对Properties一定再熟悉不过了,它是JAVA项目里特有的一种配置文件，Properties 继承于 Hashtable，所以可对 Properties 对象应用 put 和 putAll 方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是 String 的项，应该使用 setProperty 方法。如果在“不安全”的 Properties 对象（即包含非 String 的键或值）上调用 store 或 save 方法，则该调用将失败。</p><p>最近做项目想在项目中实现动态配置文件的功能，本来以为水到渠成的事，结果遇到了一点小麻烦，现将问题记录下来。</p><span id="more"></span><p>通常用法：</p><pre class="highlight"><code class="java"><span class="hljs-keyword">package</span> com.test;<span class="hljs-keyword">import</span> java.io.FileNotFoundException;<span class="hljs-keyword">import</span> java.io.FileOutputStream;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.io.OutputStream;<span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-comment">/** *  * <span class="hljs-doctag">@author</span> Windus * <span class="hljs-doctag">@version</span> v1.0 * */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertiesUtil</span> </span>&#123;<span class="hljs-keyword">private</span> Properties properties;<span class="hljs-comment">// properties文件路径</span><span class="hljs-keyword">private</span> String proPath;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PropertiesUtil</span><span class="hljs-params">(String proPath)</span> </span>&#123;<span class="hljs-keyword">this</span>.proPath = proPath;loadProperties();&#125;<span class="hljs-comment">/** * 加载Properties文件 *  * <span class="hljs-doctag">@param</span> proPath */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadProperties</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;properties = <span class="hljs-keyword">new</span> Properties();InputStream is = <span class="hljs-keyword">this</span>.getClass().getResourceAsStream(proPath);properties.load(is);is.close();&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;e.printStackTrace();&#125;&#125;<span class="hljs-comment">/** * 读取配置文件键值 *  * <span class="hljs-doctag">@param</span> key * <span class="hljs-doctag">@return</span> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getProperties</span><span class="hljs-params">(String key)</span> </span>&#123;<span class="hljs-keyword">if</span> (properties != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> properties.getProperty(key);&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;<span class="hljs-comment">/** * 设置键值 *  * <span class="hljs-doctag">@param</span> key * <span class="hljs-doctag">@param</span> value */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(String key, String value)</span> </span>&#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">if</span> (properties != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// 设置键值</span>properties.setProperty(key, value);OutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(proPath);properties.store(fos,<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">"yyyy-MM-dd"</span>).format(<span class="hljs-keyword">new</span> Date()));fos.flush();fos.close();&#125;&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<span class="hljs-comment">// TODO Auto-generated catch block</span>e.printStackTrace();&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<span class="hljs-comment">// TODO Auto-generated catch block</span>e.printStackTrace();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;PropertiesUtil propertiesUtil = <span class="hljs-keyword">new</span> PropertiesUtil(<span class="hljs-string">"/test.properties"</span>);<span class="hljs-comment">//打印当前键值</span>System.out.println(propertiesUtil.getProperties(<span class="hljs-string">"name"</span>));<span class="hljs-comment">//设置键值</span>propertiesUtil.setProperties(<span class="hljs-string">"name"</span>, <span class="hljs-string">"windus"</span>);<span class="hljs-comment">//打印修改后的值</span>System.out.println(propertiesUtil.getProperties(<span class="hljs-string">"name"</span>));<span class="hljs-comment">//重新加载properties文件读取</span>PropertiesUtil propertiesUtil = <span class="hljs-keyword">new</span> PropertiesUtil(<span class="hljs-string">"/test.properties"</span>);System.out.println(propertiesUtil.getProperties(<span class="hljs-string">"name"</span>));&#125; &#125;</code></pre><p>当我在启动Tomcat后，重新在前台传入key值后调用设置方法后重新读取，如main方法中一样调用，发现每次修改后的properties文件本身确实改变了，但读取出来的值确不是实时更新的，原因在于getProperties每次读取都是从内存中读取，而对于文件的更新后没有实时加载到内存中。</p><p>经过轮番的修改……测试……不行；修改……测试……不行；…… ……后：得出解决方法，问题出现在加载properties文件的方法上：如上37行</p><pre class="highlight"><code class="java">InputStream is = <span class="hljs-keyword">this</span>.getClass().getResourceAsStream(proPath);<span class="hljs-comment">//修改为</span>InputStream is = <span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(getClass().getResource(proPath).getPath()));</code></pre><p>getResourceAsStream每次读取来自内存中，所以可以通过getResource(proPath).getPath()来获取properties文件路径，然后读取到输入流中实时加载properties文件，此时即可得到每次改变后的值。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> Properties </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux上分不清的查询指令</title>
      <link href="2014/05/05/tech_stack/Linux%E4%B8%8A%E5%88%86%E4%B8%8D%E6%B8%85%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4/"/>
      <url>2014/05/05/tech_stack/Linux%E4%B8%8A%E5%88%86%E4%B8%8D%E6%B8%85%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>whatis [指令或数据]:</strong></p><p>列出相关指令的说明文件（相当于man -f）</p><p><strong>apropos [指令或数据]:</strong></p><p>列出系统的说明文件中，相关指令或关键词（相当于man -k）</p><blockquote><p>whatis/apropos两个指令想要使用必须用makewhatis(root权限)建立whatis数据库。</p></blockquote><span id="more"></span><p><strong>whois:</strong></p><p>查找并显示指定帐号(或域名)的用户相关信息，因为它是到Network Solutions的WHOIS数据库去查找，所以该帐号名称必须在上面注册方能寻获，不区分大小写。</p><p><strong>whereis [-bmsu] 档案或目录名:</strong></p><p>从指定目录中搜寻特定档案。</p><pre class="highlight"><code class>-b : 查找binary格式档案-m : 查找在说明文件manual路径下的文件-s : 查找source来源档案-u : 查找不在上述档案中的其它特殊档案</code></pre><p><strong>locate [-ir] 搜寻字符串:</strong></p><p>和whereis类似locate是从数据库中搜寻档案，由于数据库默认每天更新一次，所以会有数据不实时的限制问题。（如：最新文档搜寻不到、已删除档案仍然存在等问题）</p><p>updatedb指令可以读取/etc/updatedb.conf,然后在硬盘中搜寻文件动作，最后更新/var/lib/mlocate数据库。<br>locate：依据 /var/lib/mlocate 内癿数据库记载，找出用户输入癿关键词文件名。</p><p><strong>which:</strong></p><p>从PATH路径中搜寻执行档（默认显示第一个，加-a显示全部）</p><p><strong>type [-typa] name:</strong></p><p>查找指令类型（如：内建指令builtin）,如果后面名称不能以执行档的状态找到，那该名称不会被找到。也可以作为which用来找指令。</p><p><strong>file:</strong></p><p>查看档案基本数据的类型（如：ASCII、data 档案、binary等），并且其中没有使用到动态函式库。</p><p><strong>find [选项] :</strong></p><p>功能强大的搜寻指令，由于是硬盘操作，速度稍慢。</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乔迁之喜,开門大吉</title>
      <link href="2014/03/09/blog/%E4%B9%94%E8%BF%81%E4%B9%8B%E5%96%9C,%E5%BC%80%E9%96%80%E5%A4%A7%E5%90%89/"/>
      <url>2014/03/09/blog/%E4%B9%94%E8%BF%81%E4%B9%8B%E5%96%9C,%E5%BC%80%E9%96%80%E5%A4%A7%E5%90%89/</url>
      
        <content type="html"><![CDATA[<p>新博客终于搭建完毕了,由于先前从一个国外免费空间先试了一下手,所以一切还很顺利,没有遇到什么难题,只是主题真是让我煞费苦心,想要一种自由,大气,舒适的,确始终没找到.最后发现了这一款还算满意吧.</p><span id="more"></span><p>对自已的文彩很有自知之明的我建立这个博客只是为了自我生活中比较有意义的人或事以一篇或一段文字的形式记录下来,如果恰巧其中的某些只言片语能够让你感受到乐趣或是对你有所帮助,那便是我又一收获实乃三生有幸.</p><p>最近翻我以前的物品时,从中发现了我一本10多年以前的一篇日记,我从头到尾翻了一遍往事一幕幕浮现在我脑海,回想起那时青涩的我,还有我那年青的母亲.多年以后我越长越大,离家也越来越远.回家就越来越少.时过境迁,物是人非唯有那本快要泛黄的日记本记录着那一幕幕永恒的瞬间.那一笔笔的画面比影像还要清晰的在我的脑海放映.那一夜我兴愤的失眠了.</p><p>所以我决定重新捡起笔头来记录这生活的点点滴滴.等到下一十年、下下一个十年再来回忆.由于我对个人网站的喜爱我会公开我部分记录到到我的个人博客来,其中可能包括但不限于生活感悟、个人游记、技术文摘等等.</p><p><strong>Dolly’ll never go away <sup>_</sup></strong></p>]]></content>
      
      
      <categories>
          
          <category> 心情随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决浏览器模式兼容问题</title>
      <link href="2014/01/06/tech_stack/%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
      <url>2014/01/06/tech_stack/%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>网站前端开发在我看来是开发中最让人郁闷的工作，并不是其技术有多难，而是因为它的各种不稳定因素。今天浏览器厂商一个标准，明天浏览器厂商一个标准，这家厂商一个标准，那家一个厂商一个标准。前端开发大多数时候并不是因为一个布局实现方式而苦恼，而是为了各种浏览器的兼容。然而，最让人头疼的就属IE6啦。虽然这个浏览器，曾经立下过汗马功劳，但真的到了功成身退的时候了。</p><iframe width="510" height="498" src="http://player.youku.com/embed/XMjc4MzYxMTY0" frameborder="0" allowfullscreen="allowfullscreen"></iframe><span id="more"></span><p>IE7在我看来只是微软公司临时抱佛脚的替代品，过渡产品自然用的就比较少，就像曾经的vista系统。<br>从IE8浏览器开始，微软向 Web 标准进行靠拢。改变重大，但是IE6的市场占有率仍然居高不下，且其代码标准与W3C的标准有许多出入，故按照 IE6/7 的规范来编写代码在IE8中也未必兼容，为了解决这个问题IE8浏览器增加了一种叫做“兼容性视图”的功能。从此处牵出两个功能“浏览器模式”和“文档模式”。<br>“浏览器模式”用于切换IE针对该网页的默认文档模式、对不同版本浏览器的条件备注解析、发送给网站服务器的用户代理（User-Agent）字符串的值。网站可以根据浏览器返回的不同用户代理字符串判断浏览器的版本和安装的功能，这样就可以向不同的浏览器返回不同的页面内容。<br>“文档模式”用于指定IE的页面排版引擎（Trident）以哪个版本的方式来解析并渲染网页代码。切换文档模式会导致网页被刷新，但不会更改用户代理字符串中的版本号，也不会从服务器重新下载网页。切换浏览器模式的同时，浏览器也会自动切换到相应的文档模式。<br>问题出现了，既然这么多模式那么怎么选择使用哪种模式，X-UA-Compatible出现了这是一匹神马。有了它开发者无需考虑网页是否兼容IE8浏览器，只要确保网页在IE6、IE7下的表现就可以了。</p><p>页面中用法:</p><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge,chrome=1"</span> /&gt;</span></code></pre><p>在&lt;head&gt;标签下面加入上面代码：IE=edge告诉IE使用最新的引擎渲染网页(其它可选值：IE5、IE6、IE7、IE8 )，chrome=1则可以激活Chrome Frame(可以让旧版IE浏览器使用Chrome的WebKit渲染引擎处理网页，因此旧版IE用户可以体验到包括HTML5在内的众多现代网页技术。)<br>参考：<a href="http://blogs.msdn.com/b/ie/archive/2010/06/16/ie-s-compatibility-features-for-site-developers.aspx">http://blogs.msdn.com/b/ie/archive/2010/06/16/ie-s-compatibility-features-for-site-developers.aspx</a></p><p>Apache设置方法:[信息参考自]<br>可以在Apache主机做一些设置让服务器告诉IE采用何种引擎来渲染。在网站作用目录找到或新建.htaccess文件，添加下面的内容保存即可。</p><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">IfModule</span> <span class="hljs-attr">mod_setenvif.c</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">IfModule</span> <span class="hljs-attr">mod_headers.c</span>&gt;</span>    BrowserMatch MSIE ie    Header set X-UA-Compatible "IE=Edge" env=ie    BrowserMatch chromeframe gcf    Header append X-UA-Compatible "chrome=1" env=gcf  <span class="hljs-tag">&lt;/<span class="hljs-name">IfModule</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">IfModule</span>&gt;</span></code></pre><p>Ngnix设置方法:<br>找到\nginx\conf\nginx.conf并编辑，在server { }区域里（最好是闭合符前面起一行）添加下列代码即可。</p><pre class="highlight"><code class="nginx"><span class="hljs-attribute">add_header</span> <span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-string">"IE=Edge,chrome=1"</span>;</code></pre><p>360浏览器内核控制:<br>由于WebKit内核的浏览器逐渐盛行，越来越多的人加入它的行列，然而国内windows系统的大环境下IE几乎是每台电脑必有的浏览器，所以目前很多网站只支持IE浏览器。如：银行系统<br>从而越来越多的双核浏览器诞生了。其中360浏览器就是个典型的Chrome+IE=360,相信很多人都发现过有的页面用360浏览器打开是IE内核，有的是WebKit内核。然而当我的只想用WebKit内核或是IE内核时，360提借供了一个内核选择功能：</p><p>html代码:</p><pre class="highlight"><code class="html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"renderer"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"webkit|ie-comp|ie-stand"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。<br>详细参考：<a href="http://se.360.cn/v6/help/meta.html">http://se.360.cn/v6/help/meta.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> WEB </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五笔学习小记</title>
      <link href="2013/11/26/blog/%E4%BA%94%E7%AC%94%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
      <url>2013/11/26/blog/%E4%BA%94%E7%AC%94%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="键盘分区和区号"><a class="markdownIt-Anchor" href="#键盘分区和区号"></a> 键盘分区和区号</h3><p>汉字有五种基本笔划，  横、竖、撇、捺、折，所有的字根都是由这五种笔划组成的，分别划为5个区。<br>每个区有五个位，按一定顺序编号，就叫区位号。比如1区顺序是从G到A，G为1区第1位，它的区位号就是11，F为1区第2位，区位号就是12</p><h3 id="键名字根"><a class="markdownIt-Anchor" href="#键名字根"></a> 键名字根</h3><p>王土大木工 目日口田山<br>禾白月人金 言立水火之<br>已子女又纟</p><span id="more"></span><h3 id="字根一般分布规律"><a class="markdownIt-Anchor" href="#字根一般分布规律"></a> 字根一般分布规律</h3><p>(1)总体规律：一区：横 二区：竖 三区：撇 四区：捺 五区：折</p><p><strong>注意</strong>:<br>在五笔中，笔划“提”归在“横”里，“点”归在“捺”里，“竖钩”归在“竖”里</p><p>(2)非定性规律 如：<br><code>规律1</code>：<br>在1区1位，里面有一横这个字根，在1区2位有二横这个字根，在1区3位，里面有三横这个字根。<br>第2区1位，有一竖这个字根，2区2位，有二竖这个字根，2区3 位，有三竖这个字根，2 区4位，有四竖这个字根。<br>第3区1位里一撇，3区2位里二撇，3区3位里三撇。<br>第4区，41区位里有点，42区位里有二点水，43区位里有三点水，44区位里有四点底。<br>第5区，51区位中的“乙”是一折，52区位中的“&lt;”“  ”是二折，53区位中的“巛”是三折</p><p><code>规律2</code>：<br>1区1位，“王”的第一笔是横，第二笔还是横；1区2位，“土”的第一笔是横，第二笔是竖；1区3位，“大”的第一笔是横，第二笔是撇；再看1区5位，“七”的第一笔是横，第二笔是折。（字根的第二笔与位号一致。不是所有的字根都符合这个规律，还是有很多特殊的。）</p><p><code>规律3</code>：相似性<br>如：W键，里面的“人、八、 、 ”这四个字根形态都差不多。还有B键，里面的“阝、卩”很容易联想到字母B。<br>L键，里面的这四个字根：，彼此长得很像，和四竖也很像。</p><h3 id="字根顺口溜"><a class="markdownIt-Anchor" href="#字根顺口溜"></a> 字根顺口溜</h3><p><code>横区</code>:<br>王旁青头(兼)五一(G), 土士二干十寸雨(F)<br>大犬三(羊)古石厂(D), 木丁西(S)<br>工戈草头右框七(A)</p><p><code>竖区</code>:<br>目具上止卜虎皮(H), 日早两竖与虫依(J)<br>口与川 字根稀(K), 田甲方框四车力(L)<br>山由贝 下框几(M)</p><p><code>撇区</code>:<br>禾竹一撇双人立 反文条头共三一(T), 白手看头三二斤®<br>月彡(衫)乃用家衣底(E), 人和八 三四里(W)<br>金勺缺点无尾鱼 犬旁留乂一点夕 氏无七(妻)(Q)</p><p><code>捺区</code>:<br>言文方广在四一 高头一捺谁人去(Y), 立辛两点六门病(U)<br>水旁兴头小倒立(I),  火业头 四点米(O)<br>之字军盖建到底 摘礻(示)衤(衣)§</p><p><code>折区</code>:<br>已半巳满不出己 左框折尸心和羽(N), 子耳了也框向上(B)<br>女刀九臼山朝西(V), 又巴马 丢矢矣©<br>慈母无心弓和匕 幼无力</p><h3 id="汉字拆分"><a class="markdownIt-Anchor" href="#汉字拆分"></a> 汉字拆分</h3><p>字根间的结构关系可以概括为四种类型，单、散、连、交。<br>单，就是指这个字根本身就是一个汉字。包括五种基本笔划“一、丨、丿、丶、<br>乙”，25个键名字根和字根中的汉字。比如“言、虫、寸、夕”等。<br>散，就是指构成汉字的字根不止一个，且汉字之间有一定的距离。比如“苗”字，由“艹”和“田”两个字根组成，字根间还有点距离。<br>连，就是指一个字根与一个单笔划相连。比如“勺”，就是“勹”和点组成的，我们认为它们是相连的。这样的例子还有“术、太、主、义、斗、头”等。</p><p><strong>注意</strong>:<br>有些字，字根虽然连着，但在五笔中不认为它们是相连的，如“足、充、首、左、页”等，还有，单笔划与字根间有明显距离的也不认为是相连，比如“个、少、么、旦、全”等。<br>交就是指两个或多个字根交叉重叠构成的汉字。比如“本”，就是由字根“木”和“一”相交构成的。<br>(1)多字跟拆分由四个或四个以上的字根的合体字，它的输入方法是按照书写顺序，取第一、二、三、末四个字根的编码。如：“毅”字是由“立、 、几、又”四个字根组成的，这四个字根的编码依次是UEMC，那么在五笔输入法中，键入UEMC，就输入了“毅”字。<br>　<br><strong>注意</strong>:<br>1.在拆分汉字时，先要注意按书写顺序来拆分汉字，然后对里面的一些复杂字根，按照它的自然界限进行拆分，对界线不明显了，就要按拆分原则进行拆分。<br>2.先左后右，先上后下，先横后竖，先撇后捺，先内后外，先中间后两边，先进门后关门。<br>3.取大优先，兼顾直观，能散不连，能连不交。</p><p>(2)拆分原则取大优先原则。在各种可能的拆法中，保证按书写顺序拆分出尽可能大的字根，以保证拆分出的字根数最少。兼顾直观原则。就是说在拆字时，尽量照顾字的直观性，一个笔划不能分割在两个字根中。【“兼顾直观”和“取大优先”原则是相通的，都是取大字根，笔划不能重复或是截断。】能散不连原则。如果字可以拆成几个字根散的结构，就不要拆成连的结构。能连不交原则。如果字可以能按连的结构拆分,  就不要按交的结构拆分。</p><p>(3)汉字字型1、左右型—代号12、上下型—代号23、杂合型—代号3</p><p><strong>注意</strong>:<br>1.包围和半包围关系的汉字，一律视为杂合型，如“团、同、医、凶、句”等。<br>2.含有“辶”的字也是杂合型，如“过、进、延”等。<br>3.“厂、尸、眉(上半部)”等字根组成的一些字也是杂合型。<br>4.一个基本字根和一个单笔划相连，也视为杂合型，如自己的“自”。<br>5.一个基本字根之前或之后有孤立点的也当作杂合型，比如“勺、术、太、主、斗”等。<br>6.几个基本字根交叉重叠之后构成的汉字，也视为杂合型。比如“申、里、半、串、东、电”等。</p><p>(4)少字根拆分由少于4个字根构成的字需要加入末笔字型交叉识别码。末笔字型交叉识别码=末笔代码+字型代码</p><p><strong>末笔字型交叉识别码列表</strong></p><table><thead><tr><th style="text-align:center"> </th><th style="text-align:center">左右型</th><th style="text-align:center">上下型</th><th style="text-align:center">杂合型</th></tr></thead><tbody><tr><td style="text-align:center">横</td><td style="text-align:center">G(11)</td><td style="text-align:center">F(12)</td><td style="text-align:center">D(13)</td></tr><tr><td style="text-align:center">竖</td><td style="text-align:center">H(21)</td><td style="text-align:center">J(22)</td><td style="text-align:center">K(23)</td></tr><tr><td style="text-align:center">撇</td><td style="text-align:center">T(31)</td><td style="text-align:center">R(32)</td><td style="text-align:center">E(33)</td></tr><tr><td style="text-align:center">捺</td><td style="text-align:center">Y(41)</td><td style="text-align:center">U(42)</td><td style="text-align:center">I(43)</td></tr><tr><td style="text-align:center">折</td><td style="text-align:center">N(51)</td><td style="text-align:center">B(52)</td><td style="text-align:center">V(53)</td></tr></tbody></table><p>末笔特殊约定:</p><p>1.为了有足够多的区分能力，对“辶”、“廴”的字和全包围字，它们的“末笔”规定为被包围部分的末笔。<br>2.如果“囗”包围的一个字根组成的双码字根再位于另一个字根之后，所得到的三根字的末笔仍然是被包围的那个字根的末笔。<br>3.如果用“辶”包围一个字根组成的双码字再位于另一个字根后面，所得到的三根字末笔为“辶”的末笔“丶”，如“链”，编码为OLPY。<br>4.对“九、刀、七、力、匕”等字根，当它们参加“识别”时一律用“折笔”作为末笔。<br>5.我们接着讲末笔约定。“我”、“贱”、“成”等字的“末笔”，遵循“从上到下”的原则，末笔应该是“丿”。<br>6.带单独点的字，比如“义”，“太”，“勺”等，我们把点当作末笔，并且认为“丶”与附近的字根是“连”的关系。</p><p>(5)成子字根输入<br>在字根总表中，除了键名字根外，本身就是汉字的字根。<br>输入方法是：先打一下该字根所在的键，再打该字根的第一、第二及最末一个单笔画。</p><p>(6) 一级简码</p><p>一地在要工，上是中国同。<br>gfdsa hjklm<br>和的有人我，主产不为这。<br>trewq yuiop<br>民了发以经。<br>nbvcx</p><p>(7) 二级简码<br>输入方法：一笔代码+二笔代码+空格键 如：<br>睡：全码（htgf）简码（ht）<br>二级简码是由25个键位代码排列组合而成的。25×25=625，去掉一些没有的空字，二级简码将近六百个。</p><p>(8) 三级简码<br>输入方法：一笔代码+二笔代码+三笔代码+空格键<br>字的前三个字根编码在五笔中是唯一的，这个字都可以作为三级简码来输入。在汉字中，三级简码一共有4000多个。</p><p>(9) 二字词汇<br>输入方法：取每个字的前两个字根的代码<br>如：热爱 － rvyo epdc = rvep</p><p><strong>注意</strong>:<br>当“键名”及“成字字根”参加组词时，应该从这个字的全码中取头两位编码<br>如：土地 — ffff  fbn = fffb</p><p>(10) 多字词汇<br>三字词汇：取前两个字的第一个字根+最后一个字前两个字根<br>如：计算机－yfh  thaj smn＝ytsm<br>四字词汇：取每个字的第一个字根 如：操作系统－rwtx</p><h3 id="偏旁部首打法"><a class="markdownIt-Anchor" href="#偏旁部首打法"></a> 偏旁部首打法</h3><p>一 ggll<br>丨 hhll<br>丿 ttll<br>丶 yyll<br>𠃌 nnll</p><p><strong>注意:</strong> 补位码 ll</p>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 输入法 </tag>
            
            <tag> 五笔学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的一次骑行经历-北戴河(三)</title>
      <link href="2013/11/21/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86-%E5%8C%97%E6%88%B4%E6%B2%B3(%E4%B8%89)/"/>
      <url>2013/11/21/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86-%E5%8C%97%E6%88%B4%E6%B2%B3(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>时间：4:10分…<br>地点：离海边约500米…<br>目的：南戴河海边日出…<br>人员：我自己…<br>环境：漆黑一片，海风搜身<br>感觉：冷、黑、冷、黑……</p></blockquote><span id="more"></span><p>又是一阵清澈的水流声，把我从甜美的梦乡中拉了回来。经过两天的劳累现在的我已经是严重缺觉，虽然很疲惫但日出的诱惑，还是将我沉重的身体拉了起来。起来洗脸、刷牙，刚喝了一口水，咸咸的滋味又让我吐了出来，这水怎么这么咸啊，不会是直接把海水引过来的吧！由于不知道日出的准确时间，快速的洗漱完毕，穿上比平常厚的衣服，出门向海边走去(事实证明我穿的太少了)。</p><p>走出旅馆，外面一片漆黑，大门还是别着的，打开大门向外走，越走越黑，连路都有点看不见了（南戴河人民晚上都不开路灯的吗？），凭着昨天晚上对方位的判断，以为大海应该在旅馆前方，走了有5分钟竟然连海的影子都没看见，我意识到时走错了，正常应该只有500米，回想起刚才看见的一个很高的建筑物，和网上所说的天马浴场很像，于是变换方向朝建筑物走去。果然没出5分钟，伴随着大海的声音越来越大，风也越来越大，很快就来到了天马浴场。此时：4:点40分</p><p>来到海边后，我走到沙滩上，大海深处一片漆黑但却没有黑暗的寂静，相反的是一阵阵海浪拍打岸边的声音，我看见一排排白色的不知道什么东西，在海中从北向南的滑着（最初我以为是小船，后来天亮了我才知道原来是浪花）。岸边的海风太大，让我寒冷难耐，于是我走回上边的广场找物体避风，但是却没有效果，于是我就绕着旁边的花坛绕圈跑了起来，好在稍微缓解了一下冻透的身体。</p><p>早晨5:00，陆陆续续出现了一波人，跟着他们来到了沙滩旁边的健身器，此时身体依旧很冷，于是乎拼命玩着各种健身器材来提升身上的温度。</p><p>5:30分，人越来越多，我沿着沙滩一路向东看到有一条探进海中十几米的小长廊，走上长廊走进海中感觉到海风之大，我这单薄的衣服，让我再一次后悔没有带更厚的衣物。</p><p><img src="/2013/11/21/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86-%E5%8C%97%E6%88%B4%E6%B2%B3(%E4%B8%89)/1.jpeg" alt></p><p>5:40分，天边出现红晕，感觉海风越来越大，海水都被吹到了桥上，有人说，太阳已经出来了，只是今天有浮尘所以还要等会才能看见。</p><p>5:50分，越来越多的人回到沙滩上，只剩下寥寥无几的几个人和我还站在这里！</p><p>5:58分，天边红霞越来越亮了，太阳要升起来了，此时我已经冻的哆哆嗦嗦了。升起来啦……</p><p><img src="/2013/11/21/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86-%E5%8C%97%E6%88%B4%E6%B2%B3(%E4%B8%89)/2.jpeg" alt></p><p>日出升起来那一过程非常漂亮，手机照的不是特别的好。等到太阳完全升上来以后，沙滩上到处都是海鸥，他就会落在你身边感觉更是美，后来沿着沙滩走了一圈，本来想捡两个海螺的，可是一个都没发现（后来才知道，我没去对地方，沙滩南边有很多）。之后去了吃了点早点，回去补个回笼觉了！</p><p><img src="/2013/11/21/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86-%E5%8C%97%E6%88%B4%E6%B2%B3(%E4%B8%89)/3.jpeg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 骑行 </tag>
            
            <tag> 北戴河 </tag>
            
            <tag> 大海 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的一次骑行经历—北戴河(二)</title>
      <link href="2013/10/28/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%BA%8C/"/>
      <url>2013/10/28/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>朦胧中一阵阵清澈的溪水声，将我从梦中带回到现实。关闭手机，起床洗漱，酸痛感遍布全身，但体力恢复的差不多了。收拾了半个小时后，下楼准备退房出发，旅馆老板还没起床，叫醒老板后，老板把旅店们打开，一股清凉感，拂面而来，让我神清气爽。太阳刚刚升起，车子整理好，沿着大道向前走，找早餐的地方，走了很远 <strong><sup>1</sup></strong>，看到一家早餐点，坐下来吃了了点早餐。以前没注意过，这次近距离接触，发现唐山话很好说啊，只要每个字都发二声音再加点儿音 <strong><sup>2<sup></sup></sup></strong>，听起来就就很像了^_^。</p><span id="more"></span><p>吃完早点，全身充满能量，感觉一天能骑200公里 <strong><sup>3</sup></strong>。感觉总是会骗人的，出了玉田县，又与久违的102国道交汇了，灰依然很大，车依然很多，之前的豪言壮语烟消云散，怎么一个“累”字了得。</p><blockquote><p>当前坐标(117,40)当前位置(玉田县)<br>当前目标(唐山丰润区)里程(40KM)。</p></blockquote><p>由于昨天的120公里行程，今天的任务尤显艰巨160。丰润这段路，甚是奇怪，都是缓坡,最好的路况也就算是平道了(几乎没有感觉到)。经过两个小时左右接近丰润的时候，道路坑坑洼洼尤其的难走，路上漫天“灰”舞，简直无法形容，我的两层魔术头巾，已经起不到多大的作用了。幸好这样的路只有一段，后来换入曹雪芹西道，进入丰润区。这一段路总体感觉，没什么好感，一路缓坡平路，我现在的感觉只能用一首歌来形容“走过了一村又一寨……（当然我不是小和尚）”，其它的就没什么印象了。</p><p>8点20分,曹雪芹西道，简单休息了一下，看了一下地图，确定路线后继续前行，话说曹雪芹道可真是够长的，单曹雪芹西道就走了半个小时(当然速度不是很快，毕竟城区里人多，车多，红灯多。中间路过曹雪芹像，让我终于相信原来他真是个男的。)。</p><p>到曹雪芹东道的尽头向南走，继续踏上熟悉的102国道。快要离开丰润前，下车休息了一下，补充点食物和水，还遇到了三个骑友，他们是直接去北戴河的。他们没耽误多久又出发了，他们走后我们又休息了十几分钟，也继续前进了。</p><p>下一站，滦县60公里，进入102国道继续前行，从此时起，每每看到一个指示牌，我的心里都会相当兴奋，因为我知道距离目标黄金海岸南戴河越来越近了。骑行了大约20分钟左右，我们追上了刚刚先走的几个骑友，他们中有一个人体力下滑严重，骑得特别慢，导致他们整体速度很慢。我们一起骑行了一段距离，他们速度实在太慢了，我们就走到了他们前边，于是102国道上就上演了这样我们停下来休息，他们追上来，他们停下休息，我们追上去……无休止的卡位战，又过了2-3个小时，已经12点多了，距离滦县还有20公里，看来我们先前估算的路程少了，实际上不只60公里。我们也有点很累了，早上5点多出发到现在也很长时间，再不补充的点食物，下午可就有问题了。于是我们到了滦县方向与102国道的交叉点“野鸡坨镇” <strong><sup>4</sup></strong>，解决午饭问题，点了几个菜，吃点米饭(这块吃饭还行，不怎么贵，味道一般吧)。午饭一个小时，继续向前走，这一段的102国道不是怎么好走，到处积水，因为我们要在野鸡坨镇向南走252省道，但是前方道路积水，我没敢尝试过去，几经打听在一位阿姨的帮助下，绕了半天终于在一个小道上了省道。</p><p>省道果然比国道强的多，马路宽阔无比，并行四辆大车，都绰绰有余。一路平道，骑起来不怎么费劲，一直到了滦县，几十公里的路，一点没感到累。不过话说回来这条道还真是长啊，骑了半个多小时，到了一个大牌楼收费站，上面俩个大字“滦北”，此时看一下地图，晕，这条道才走了一半。又过了半个小时，看到一个立交桥，上面写着“千年古县”什么的，此时终于接近此段路的目的地滦县！</p><p>这段路从里程上看确实比到丰润的距离远了20公里 <strong><sup>5</sup></strong>，不过这段路骑得要比前一段路爽的多啊，虽然道路依旧一般,而且有几段距离满地是泥，灰依旧不小，最主要是这段路有起伏，有上坡，有下坡，有平道，就像生活，风平浪静，虽然舒服但总感觉缺少点什么，跌宕起伏，虽然艰难，却乐在其中。</p><p><img src="/2013/10/28/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%BA%8C/76d504eajw1ea11v88suij20g90lowf4.jpg" alt></p><p>上了205，路却是好走的多了，路上的风景也好的多了，这可能就是人们口中传颂的苦尽甘来吧，呵呵。一个下坡，开启了我几公里的30+巡航。走了几十公里后，倒处是在修路，路上又遇到一个骑友，从山东来的，要去大连！走了一段路，就不见踪影了，看来我们一路，一直超越啊，不知过了多久，看见一座大山，终于接近昌黎县了！休息了一下，吃了一些食物，喝了一罐红牛 <strong><sup>6<sup></sup></sup></strong>。</p><p>进入昌黎，有两条路：一条继续205，另一条是横穿昌黎继续向前。经过导航定位后我们选择了前者 <strong><sup>7</sup></strong>，我们几乎绕了一圈后，发现走的有点不对，于是换入365省道，走入了一条不归路！！！于是越走越远，越走越黑，差不多六点左右，天色已经快看不见了，我们停下来，把车子上安上手电、尾灯等，此时已经意识到走错了路.</p><p>于是决定继续换入一个向北的路，这条路没有路灯到处漆黑一片，很窄，车还很多 <strong><sup>8</sup></strong>。这条路还真不是一般的长，走了好久，此时地点是黄金海岸不知道哪个门，换入364省道，恩路是真好，就是没有灯,这条路我骑得依然很兴奋 <strong><sup>9</sup></strong>，因为这条道的尽头，就是我们的目的地。终于在8点左右，我们到达了南戴河，去了事先订好好的旅店！我们的骑行旅程到此结束了，骑行里数190公里……</p><p>一路上来虽然有很多艰辛，但同时也有很多了欢乐和享受,这也正是我骑行的乐趣所在。由于，我们是第一次去，走了很多弯路，也带了些无用的东西，是我们骑行负担更重，所以我把需要的东西，大致总结了一下：</p><blockquote><p>骑行装备（头盔、眼镜、口罩&lt;魔术头巾&gt;、手套、裤带、备胎、修车组合工具、气筒、货架、行李包&lt;其实去北戴河，我感觉没必要带行李包，真不需要带太多，我们这 次就带的多了，完全可以，用一个大一点的背包搞定&gt;）等.</p><p>衣服(至少2套衣服&lt;十月份早晚天气很冷，带些厚的&gt;、拖鞋&lt;去海边，相当有用，我这次没带，后悔死了&gt;、鞋&lt;我带了2双，雨中骑行湿了一双&gt;)等.</p><p>手机软件(导航软件&lt;这点可真要选好，我这次可是深受其害啊，一定要多下载几款，总结一下我用的导航软件：高德，查询路线还行，定位可真是不准啊。凯立德： 定位准确，但是小地方查不到&gt;)<br>其它，可根据自己实际条件和爱好了，如：帐篷啊，充气船啊等等。</p></blockquote><hr><p>¹玉田这地，吃饭的真的好少啊！<br>²包子(báo zī)儿.<br>³万万没想到最后真的成了现实.<br><sup>4</sup>这个地名很有意思，这一片的地名貌似都喜欢以“坨”结尾.<br><sup>5</sup>对这种长距离骑行，远几公里的感觉都是不一样的.<br><sup>6</sup>这真不是一个广告，我估计这就是导致我后来越骑越有力气的原因^<em>^!<br><sup>7</sup>事实上我们真的错了，205其实是绕了昌黎一圈==!.<br><sup>8</sup>虽然如此，但此时丝毫没有疲惫感，非常兴奋，因为我已经闻到大海的腥味了，我知道这次是真的快到了，当然也许是红牛的作用^</em>^.<br><sup>9</sup>当然，我也归功于红牛上了！我的队友在滦县的时候就喝了准备的红牛，我告诉他会后悔的,果然他现在的状态，惨不忍睹.</p><hr>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 骑行 </tag>
            
            <tag> 北戴河 </tag>
            
            <tag> 大海 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>struts2 xhEditor富文本编辑器-ajax图片上传</title>
      <link href="2013/10/26/tech_stack/struts2%20xhEditor%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-ajax%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/"/>
      <url>2013/10/26/tech_stack/struts2%20xhEditor%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-ajax%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<p>JAVA上传类代码:</p><span id="more"></span><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ActionSupport</span> </span>&#123;        <span class="hljs-keyword">private</span> File filedata;<span class="hljs-comment">//xheditor提供的上传文件名不可更改</span>        <span class="hljs-keyword">private</span> String filedataFileName; <span class="hljs-comment">// 上传文件名 注意filedata</span>        <span class="hljs-keyword">private</span> String filedataContentType;<span class="hljs-comment">// 上传文件类型</span>        <span class="hljs-comment">/**         * 上传文件         */</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">upload</span><span class="hljs-params">()</span> </span>&#123;                logger.info(<span class="hljs-string">"上传文件:"</span> + filedataFileName);                String filePath = Struts2Util.getRequest().getSession()                                .getServletContext().getRealPath(<span class="hljs-string">"/"</span>)                                + filedataFileName;                File file = <span class="hljs-keyword">new</span> File(filePath);                <span class="hljs-keyword">if</span> (file.exists()) &#123;                        file.delete();                        file = <span class="hljs-keyword">new</span> File(filePath);                &#125;                <span class="hljs-keyword">try</span> &#123;                        FileUtils.copyFile(filedata, file);                        <span class="hljs-comment">// copy(uploadFile, file);</span>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                        <span class="hljs-comment">// TODO Auto-generated catch block</span>                        e.printStackTrace();                &#125;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> File <span class="hljs-title">getFiledata</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> filedata;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFiledata</span><span class="hljs-params">(File filedata)</span> </span>&#123;                <span class="hljs-keyword">this</span>.filedata = filedata;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFiledataFileName</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> filedataFileName;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFiledataFileName</span><span class="hljs-params">(String filedataFileName)</span> </span>&#123;                <span class="hljs-keyword">this</span>.filedataFileName = filedataFileName;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFiledataContentType</span><span class="hljs-params">()</span> </span>&#123;                <span class="hljs-keyword">return</span> filedataContentType;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFiledataContentType</span><span class="hljs-params">(String filedataContentType)</span> </span>&#123;                <span class="hljs-keyword">this</span>.filedataContentType = filedataContentType;        &#125;&#125;</code></pre><p>下载临时文件夹</p><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">constant</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"struts.multipart.saveDir"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"/tmp"</span>/&gt;</span>  </code></pre><p>下载文件大小</p><pre class="highlight"><code class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">constant</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"struts.multipart.maxSize"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10000000"</span>/&gt;</span></code></pre><p>js代码:</p><pre class="highlight"><code class="javascript">$(<span class="hljs-string">'#xh'</span>).xheditor(&#123;<span class="hljs-attr">upImgUrl</span>: projectName + <span class="hljs-string">"/manage/upload!upload"</span>,<span class="hljs-attr">upImgExt</span>:<span class="hljs-string">"jpg,jpeg,gif,png"</span>&#125;);</code></pre><p>搞定测试，始终获取不到文件，相信很多人都遇到了遇到过这一步，经过百般尝试后发现js加上</p><p><strong>html5Upload:false</strong></p><p>继续测试，上传可以了，但是总提示返回错误，而且我想加自定义回调函数 <strong>onUpload:unloadComplete</strong>  发现回调函数不执行。<br>查找了很多资料，才发现我的返回值不正确，上传方法返回必须是json格式的数据，格式如下：<br><strong>{“err”:&quot;&quot;,“msg”:“上传成功！”}</strong><br>搞定收工!</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
            <tag> xhEditor </tag>
            
            <tag> struts2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的一次骑行经历—北戴河(一)</title>
      <link href="2013/10/08/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%B8%80/"/>
      <url>2013/10/08/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<!--居中引号--><blockquote><p>似乎每一个骑行者都要至少一次雨中骑行的经历才能体会到骑行的乐趣，似乎每一次旅行都要经历种种磨砺才算是完美！</p></blockquote><p>向往已久的骑行终于在这次十一小长假实现了，前一个月就想去北戴河了，由于种种问题终于没能成行。恰巧同事买了个新车子，俩人一商量走你……</p><blockquote><p>原计划骑行路线：<br>D1:北京-廊坊三河(55KM G102)-天津蓟县(90KM G102)-唐山玉田县(118KM G102)-唐山丰润区(152KM G102)<br>D2:丰润—滦县(60KM)——昌黎(100KM G205)—(黄金海岸118KM G205)</p></blockquote><span id="more"></span><p>D1）5点钟起床：天气晴，哦不对，是起来晴，洗漱完后，天气开始下雨了，哇塞！！！好大一声雷。难道Game就要Over了，管它呢先吃早餐的说。吃完饭后，天气雨点貌似有点小了，准备出发，Go Go Go！自行车刚搬下楼，大雨再一次与我们拥抱,计划貌似再一次与我们惜别。</p><p>肿么办，我真想冒着大雨出发，可是这次出行并不是我自己一个人，所以要争求同伴的意见，经商议等雨停了再出发 <strong><sup>1</sup></strong>。然后同伴上楼等待，我依然站在楼下默默祈祷，又过了十几分钟雨丝毫没有停下的迹象，我第一次有了放弃的想法。</p><p>又过了十几分钟，已经7点多了，与原计划5点足足晚了2个小时。再不走计划行程可能就要泡汤了！此时，我的心里一直有个声音呼喊着我：“出发……出发……”！最后的决定是无论如何也要去。我跑上楼去问一下同伴还要不要去，最后同伴也下定决心，冒雨出发！于是我们穿上雨披上车出发了，这时雨变的小些了；</p><p><img src="/2013/10/08/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%B8%80/76d504eajw1e95aj6k7n6j20hs0npab7.jpg" alt></p><p>老天总喜欢和我们开些小玩笑，骑车来到附近ATM，只见屏幕上一排大字:“暂停服务！”= =！。好吧，只有上四环绕到大望路去取了 <strong><sup>2</sup></strong>,开拔!</p><blockquote><p>目的地：大望路 soho取款机。</p></blockquote><p>到了大望路取完钱后，整理了一下随身物品，现在真正要出发了，此时脑海里浮现出那句歌词“你问我要去向何方，我指着大海的方向！……”。</p><blockquote><p>第一站&gt;京通快速—燕郊（约30KM），上了京通快速，雨越来越大，雨披渐渐失去了作用，骑行也倍感吃力。雨中骑行怎么一个“爽”字了得，可是停下来后的感觉，可就真心难受了！</p></blockquote><p>原本潮白河大桥想留影的，无耐雨太大，没有停歇继续前进，又走了几公里，在燕郊一处小市场内，休息一会，补充点水和食物 <strong><sup>3</sup></strong>。休息了十几分钟，下身湿透伴随着小风[哆嗦]，赶紧上车继续前行！</p><blockquote><p>第二站&gt;燕郊—三河(约25KM)，此时码表莫名其妙的罢工了，在11点左右，我们看到了一个高大无比，相当气派的门楼，上面写着几个大字“三河欢迎您”！哇塞，这就是传说的三河，果然不一般 →_→ 。</p></blockquote><p>雨依旧很大，没有机会照相，继续向三河城区方向前进。到了城区，找了半天，只发现一个还可以的清真兰州拉面(PS：河北人应该酷爱面食，一路上到处是拉面、火烧之类的。)，对于我来说面食很不抗饿，一碗牛肉拉面入肚后感觉没饱，于是我们拿出自己带来的牛肉，刚想吃被老板阻止了。外带非本店清真食品不能在这吃。好吧，那就不吃了，虽然没吃饱 <strong><sup>4</sup></strong>。</p><p><img src="/2013/10/08/blog/%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%B8%80/76d504eajw1e9dt2g5ostj20hc0ahq4s.jpg" alt></p><blockquote><p>下午1点，三河出发—目标丰润(约100KM)，天气逐渐变晴，温暖的阳光，精神焕发，可是浪费掉的体力，却是找不回了，体力感到明显下滑。</p></blockquote><p>过了蓟县，走了大约20多公里，我的队友体力严重不支，骑行速度只能维持在15KM/H。此时，距离最近地点玉田还有40多公里，此时距离北京已经80多公里，为了不让我们行程落后，也是为了激励队友，我尽量把速度控制在20KM/H以上。又走走停停过了十几公里，我也明显感到体力不行了 <strong><sup>5</sup></strong>。</p><p>此时已经四点了，看来到丰润已是不太可能了，于是选择了玉田落脚。接下来的20公里，成了自我骑行以来最艰难的20公里。到达玉田后，夜色将近，于是现在最重要的一个任务就是找旅馆。就在我们要选定一个名为“XXX宾馆”的时候，一个哥们走进我们视线，上来询问我们从哪里来，到哪里去。经了解他是玉田本地人，也是骑行爱好者，于是我们向他询问这家宾馆怎么样，他告诉我们不要在这家很贵，然后告诉我们哪块的便宜。</p><p>正在此时，恰巧一个女的开车经过，听到我们谈话后开始对那个哥们发飙了：“我们家也不贵啊，你谁啊，你哪家的，你别走……”此处省略500字。于是我们赶紧掉头走，没想到那哥们又跟了上来，告诉我们详细的地址(多么热心，真诚的人)，在此我要对那位哥们说声谢谢！按照那位哥们说的路线，我们很容易找到了一个不错的旅馆，俩人才50块钱。车子和行李搬到旅馆后我们出去满足了肚子一个愿望^_^。之后又去超市采购了一些明天行程的用品，然后回到旅馆，洗了一下被泥水灌溉过的车子。感觉明天的东西准备差不多了，于是上床昏昏沉沉的睡着了……</p><p><strong>总结：</strong> <em>今天总体感觉还好主要是上午雨中骑行浪费大部分体力，下午导致体力不支，不过下雨其实也真不是什么坏事102国道的灰，真不是吹的，多亏下雨让我们少吃了一些！</em></p><hr><p>¹我真没抱有雨停的希望,事实也确实如此.<br>²因为我们只知道这块有ATM.<br>³主要是食物，“水”真是不缺.<br><sup>4</sup>据我事后分析，这也是导致后来我们体力不支，惜叹止步玉田的原因之一^<em>^.<br><sup>5</sup>最主要是车座部位难受^</em>^.</p><hr>]]></content>
      
      
      <categories>
          
          <category> 芬芳年华 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 骑行 </tag>
            
            <tag> 北戴河 </tag>
            
            <tag> 大海 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA设计模式学习笔记</title>
      <link href="2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="遵循原则"><a class="markdownIt-Anchor" href="#遵循原则"></a> 遵循原则</h2><h3 id="开闭原则"><a class="markdownIt-Anchor" href="#开闭原则"></a> 开闭原则</h3><p>一个软件实体(类、模块、函数)应该对外扩展开放，对修改关闭。<br>运维尽量减少对原代码的修改，保持历史代码的纯洁性，提高系统的稳定性；</p><h3 id="里氏替换原则"><a class="markdownIt-Anchor" href="#里氏替换原则"></a> 里氏替换原则：</h3><p>里氏替换原则是实现开闭原则的重要方式之一。<br>子类可以扩展父类的功能，但不能改变父类原有的功能。<br>即，子类继承父类时，除了添加新方法外，尽量不要重写父类方法。</p><h3 id="依赖倒置原则"><a class="markdownIt-Anchor" href="#依赖倒置原则"></a> 依赖倒置原则：</h3><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。<br>高层模块不应该依赖底层模块，两者都应该依赖其抽象类；<br>抽象不应该依赖细节；细节应该依赖抽象。<br>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性。</p><h3 id="单一职责原则"><a class="markdownIt-Anchor" href="#单一职责原则"></a> 单一职责原则：</h3><p>一个类或接口只有一个职责；<br>应该仅有一个原因引起类的变更，否则类应该被拆分；</p><p>在日常使用中很难完全做到。<br>提高了可读性和可维护性，降低变更引起的风险。</p><h3 id="接口隔离原则"><a class="markdownIt-Anchor" href="#接口隔离原则"></a> 接口隔离原则</h3><p>尽量将臃肿庞大的接口拆分成更小的和更具体的接口，但是要有限度;<br>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><h3 id="迪米特法则"><a class="markdownIt-Anchor" href="#迪米特法则"></a> 迪米特法则</h3><p>核心观念是类间解耦，弱耦合；<br>如果两个实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><h3 id="合成复用原则"><a class="markdownIt-Anchor" href="#合成复用原则"></a> 合成复用原则</h3><p>在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。<br>如果要使用继承关系，则必须严格遵循里氏替换原则。</p><h3 id="java中的常见规则"><a class="markdownIt-Anchor" href="#java中的常见规则"></a> Java中的常见规则：</h3><ul><li><p>接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。</p></li><li><p>各个类或模块的实现彼此独立，不相互影响，实现模块间的松耦合。</p></li><li><p>接口尽可能小，一个接口只服务于一个子模块或业务逻辑</p></li><li><p>已经被污染的接口，若变更的风险较大，则采用适配器模式进行处理。</p></li></ul><h2 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h2><h3 id="单例模式singleton"><a class="markdownIt-Anchor" href="#单例模式singleton"></a> 单例模式（Singleton）</h3><p><code>定义</code>：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p><p><code>使用场景</code>：<br>1、要求生成唯一序列号的环境；<br>2、整个项目需要一个共享访问点或共享数据。<br>3、创建对象需要消耗的资源过多，如访问IO和数据库等资源。</p><h4 id="懒汉模式"><a class="markdownIt-Anchor" href="#懒汉模式"></a> 懒汉模式：</h4><p>该模式在类加载时没有生成实例，只有当第一次调用 getInstance 方法时才去创建这个实例。</p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClass1</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonClass1 instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonClass1</span><span class="hljs-params">()</span></span>&#123;&#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonClass1 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != instance)&#123;         instance = <span class="hljs-keyword">new</span> SingletonClass1();      &#125;       <span class="hljs-keyword">return</span> instance;   &#125;&#125;</code></pre><h4 id="饿汉模式"><a class="markdownIt-Anchor" href="#饿汉模式"></a> 饿汉模式：</h4><p>该模式在类加载就创建一个实例，保证在调用 getInstance 方法之前实例已经存在。</p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClass2</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonClass2 instance = <span class="hljs-keyword">new</span> SingletonClass2();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonClass2</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonClass2 <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> instance;&#125;   &#125;</code></pre><h3 id="工厂方法模式factory-method"><a class="markdownIt-Anchor" href="#工厂方法模式factory-method"></a> 工厂方法模式（Factory Method）</h3><p><code>定义</code>： 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。<br>主要角色有：</p><ul><li><strong>产品（Product）</strong> 属于框架方，负责定义了生成实例的特有接口，具体处理是由子类 ConcreteProduct 角色决定。</li><li><strong>创建者（Creator）</strong> 即工厂类，属于框架方，负责生成 Product 角色，具体处理由子类 ConcreteCreator 角色决定。</li><li><strong>具体产品（ConcreteProduct）</strong> 属于加工方，实现 Product 角色，决定了具体产品。</li><li><strong>具体创建者（ConcreteCreator）</strong> 属于加工方，负责生成具体的产品。</li></ul><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/factoryMethod1.png" alt="工厂模式" style="height:300px"><span class="image-caption">工厂模式</span><p><code>优点</code>：</p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p>被创建的对象称为“产品”，创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。简单工厂模式缺点是增加新产品时会违背“开闭原则”。</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/simpleFactory.png" alt="简单工厂模式" style="height:300px"><span class="image-caption">简单工厂模式</span><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span></span>        System.out.println(<span class="hljs-string">"简单工厂模式创建实际产品A!"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> </span>        System.out.println(<span class="hljs-string">"简单工厂模式创建实际产品B!"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductFactory</span> </span>&#123;  <span class="hljs-comment">/**  * 写法一 判断  */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Product <span class="hljs-title">getProduct</span><span class="hljs-params">(String type)</span></span>&#123;  Product product = <span class="hljs-keyword">null</span>;      <span class="hljs-keyword">if</span>(type == <span class="hljs-string">"A"</span>)&#123;        product =  <span class="hljs-keyword">new</span> ConcreteProductA();      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type == <span class="hljs-string">"B"</span>)&#123;        product =  <span class="hljs-keyword">new</span> ConcreteProductB();      &#125;  <span class="hljs-keyword">return</span> product;    &#125;    <span class="hljs-comment">/**  * 写法二　反射  */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProduct</span><span class="hljs-params">(Class c)</span> </span>&#123;        Product product = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            product = (Product) Class.forName(c.getName).newInstance();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> (T)product;    &#125;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;      <span class="hljs-comment">// 写法一</span>      Product product = ProductFactory.getProduct(<span class="hljs-string">"A"</span>);      product.create();      <span class="hljs-comment">// 写法二</span>        Product product = ProductFactory.getProduct(ConcreteProductA.class);        product.create(); <span class="hljs-comment">// 打印“简单工厂模式创建实际产品A!”</span>    &#125;&#125;</code></pre><blockquote><p>简单工厂模式使用<code>static</code>工厂方法，造成工厂角色无法被继承。</p><p>简单工厂有两种实现方式，第一种通过判断要返回的产品类型返回实例，此种情况不满足开闭原则 ;第二种通过反射机制返回实例。</p></blockquote><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/factoryMethod.png" alt="工厂方法模式" style="height:300px"><span class="image-caption">工厂方法模式</span><p>工厂方法模式是简单工厂的近一步深化，不同的产品对象提供不同的工厂，即，每个对象都有一个与之对应的工厂工。</p><pre class="highlight"><code class="java"><span class="hljs-comment">// --------&gt;在简单工厂模式基本上增加各产品对象工作</span><span class="hljs-comment">/** * 产品创建工厂接口 * * <span class="hljs-doctag">@author</span> Windus * <span class="hljs-doctag">@date</span> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CreateFactory</span> </span>&#123;    <span class="hljs-function">Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 产品 A 创建工厂 * <span class="hljs-doctag">@date</span> * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductAFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CreateFactory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductA();    &#125;&#125;<span class="hljs-comment">/** * 产品 B 创建工厂 * <span class="hljs-doctag">@date</span> * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductBFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CreateFactory</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConcreteProductB();    &#125;&#125;<span class="hljs-comment">// --------&gt;修改 app  类调用</span><span class="hljs-comment">/** * <span class="hljs-doctag">@author</span> Windus * <span class="hljs-doctag">@date</span>  */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    <span class="hljs-comment">// 创建产品 A</span>        CreateFactory factoryA = <span class="hljs-keyword">new</span> ProductAFactory();        Product productA = factoryA.createProduct();        productA.create();        <span class="hljs-comment">// 创建产品 B</span>        CreateFactory factoryB = <span class="hljs-keyword">new</span> ProductBFactory();        Product productB = factoryB.createProduct();        productB.create();    &#125;&#125;</code></pre><h3 id="抽象工厂模式abstract-factory"><a class="markdownIt-Anchor" href="#抽象工厂模式abstract-factory"></a> 抽象工厂模式(Abstract Factory)</h3><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p><strong>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点有</strong>：</p><ul><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</li></ul><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/absFactory.png" style="height:300px;" alt="抽象工厂模式"><span class="image-caption">抽象工厂模式</span><p><code>示例</code>：小米和华为两个工厂生产不同品牌电视和手机。</p><pre class="highlight"><code class="java"><span class="hljs-comment">/*** 电视产品* <span class="hljs-doctag">@date</span> 2021-07-18 16:18* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Television</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/*** 手机产品* <span class="hljs-doctag">@date</span> 2021-07-18 16:19* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Mobile</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 华为电视 * <span class="hljs-doctag">@date</span> 2021-07-18 16:20 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zhihuiping</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Television</span> </span>&#123;  <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"创建华为电视！"</span>);&#125;&#125;<span class="hljs-comment">/*** 小米电视* <span class="hljs-doctag">@date</span> 2021-07-18 16:21* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoMiProTv</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Television</span> </span>&#123;  <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"创建小米电视！"</span>);&#125;&#125;<span class="hljs-comment">/*** 华为手机* <span class="hljs-doctag">@date</span> 2021-07-18 16:21* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P40</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mobile</span> </span>&#123;  <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"创建华为P40手机！"</span>);&#125;&#125;<span class="hljs-comment">/*** 小米手机* <span class="hljs-doctag">@date</span> 2021-07-18 16:22* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedMi</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Mobile</span> </span>&#123;  <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"创建红米手机！"</span>);&#125;&#125;<span class="hljs-comment">/*** 工厂抽象类* <span class="hljs-doctag">@date</span> 2021-07-18 16:22* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductFactory</span> </span>&#123;<span class="hljs-comment">/*** 创建电视* <span class="hljs-doctag">@return</span>* <span class="hljs-doctag">@date</span> 2021-07-18 16:23* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-function">Television <span class="hljs-title">creaTelevision</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/*** 创建手机* <span class="hljs-doctag">@return</span>* <span class="hljs-doctag">@date</span> 2021-07-18 16:23* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-function">Mobile <span class="hljs-title">createMobile</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/*** 华为工厂* <span class="hljs-doctag">@date</span> 2021-07-18 16:23* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HuaWeiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Television <span class="hljs-title">creaTelevision</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"华为工厂创建！"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Zhihuiping();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Mobile <span class="hljs-title">createMobile</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"华为工厂创建！"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> P40();&#125;&#125;<span class="hljs-comment">/*** 小米工厂* <span class="hljs-doctag">@date</span> 2021-07-18 16:33* <span class="hljs-doctag">@author</span> Windus*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiaoMiFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductFactory</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Television <span class="hljs-title">creaTelevision</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"小米工厂创建！"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> XiaoMiProTv();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Mobile <span class="hljs-title">createMobile</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"小米工厂创建！"</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RedMi();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 华为</span>ProductFactory hwProductFactory = <span class="hljs-keyword">new</span> HuaWeiFactory();Television hwTelevision = hwProductFactory.creaTelevision();hwTelevision.create();Mobile hwMobile = hwProductFactory.createMobile();hwMobile.create();<span class="hljs-comment">// 小米</span>ProductFactory xmProductFactory = <span class="hljs-keyword">new</span> XiaoMiFactory();Television xmTelevision = xmProductFactory.creaTelevision();xmTelevision.create();Mobile xmMobile = xmProductFactory.createMobile();xmMobile.create();&#125;&#125;</code></pre><blockquote><ol><li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li><li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li></ol></blockquote><h3 id="代理模式proxy"><a class="markdownIt-Anchor" href="#代理模式proxy"></a> 代理模式(Proxy)</h3><p><code>定义</code>：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。 因为访问对象不适合或者不能直接引用目标对象，代理对象就可以作为访问对象和目标对象之间的中介。</p><p><code>角色</code>：</p><ul><li><strong>主体（Subject）</strong> 定义了使 Proxy 和 Real Subject 角色之间具有一致性接口。</li><li><strong>真实主体（Real Subject）</strong> 实现 Subject 角色接口，是代理对象所代表的真实对象。</li><li><strong>代理（Proxy）</strong> 提供与 Real Subject 相同方法，内部引用 Real Subject 角色。</li></ul><p><code>优点</code>：</p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Contra.png" alt="普通代理模式" style="height:300px;"><span class="image-caption">普通代理模式</span><p><code>普通代理</code>：通过代理来访问角色，不能直接访问真实角色；真实角色的初始化放在代理类中。</p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Game</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contra</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Game</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"魂斗罗游戏 开始！"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContraProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Game</span></span>&#123;    <span class="hljs-keyword">private</span> Contra contra;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ContraProxy</span><span class="hljs-params">(Contra contra)</span> </span>&#123;        <span class="hljs-keyword">this</span>.contra = contra;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        prePlay();        contra.play();        afterPlay();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prePlay</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"玩魂斗罗游戏 开始前！"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPlay</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"玩魂斗罗游戏 结束后！"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Contra contra = <span class="hljs-keyword">new</span> Contra();        ContraProxy contraProxy = <span class="hljs-keyword">new</span> ContraProxy(contra);        contraProxy.play();    &#125;&#125;</code></pre><p><code>强制代理</code>：真实角色初始化后，不能直接使用，必须获取代理类，用代理类调用对应的方法。<br>强制代理通常通过增加<code>getProxy()</code>方法实现获取方法。</p><pre class="highlight"><code class="java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Contra</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Game</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Contra</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"魂斗罗游戏，开始！"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ContraProxy <span class="hljs-title">getProxy</span><span class="hljs-params">()</span> </span>&#123;        Contra contra = <span class="hljs-keyword">new</span> Contra();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ContraProxy(contra);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContraProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Game</span> </span>&#123;    <span class="hljs-keyword">private</span> Contra contra;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ContraProxy</span><span class="hljs-params">(Contra contra)</span> </span>&#123;        <span class="hljs-keyword">this</span>.contra = contra;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        prePlay();        contra.play();        afterPlay();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prePlay</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"魂斗罗 开始前"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPlay</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"魂斗罗 结束后"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        ContraProxy proxy = Contra.getProxy();        proxy.play();    &#125;&#125;</code></pre><blockquote><p>代理模式可以在不修改被代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。代理类和被代理类应该共同实现一个接口，或者是共同继承某个类。</p></blockquote><p><code>动态代理</code>：在实现阶段不用关心代理谁，在运行阶段才指定代理那个对象。<br>静态代理中(普通代理和强制代理)，每一个代理类只能为一个接口服务，而且，所有的代理操作除了调用的方法不一样之外，其他的操作都一样，则此时导致代码是重复代码，可以通过动态代理解决这个问题。</p><p>动态代理通过调用<code>Proxy</code>的静态方法执行实现<code>InvocationHandler</code>接口的类实现动态创建代理。</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/DynamicProxy.png" alt="动态代理模式" style="height:300px;"><span class="image-caption">动态代理模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">// 增加一款新游戏</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HonorKing</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Game</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"王者荣耀 开始！"</span>);    &#125;&#125;<span class="hljs-comment">// 增加游戏媒介类(小孩玩游戏)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Kid</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-keyword">private</span> Game game;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Kid</span><span class="hljs-params">(Game game)</span> </span>&#123;        <span class="hljs-keyword">this</span>.game = game;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        prePlay();        method.invoke(game, args);        afterPlay();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prePlay</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"玩游戏 开始前！"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPlay</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"玩游戏 结束后！"</span>);    &#125;&#125;<span class="hljs-comment">// 动态代理实现</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 玩魂斗罗</span>        Contra contra = <span class="hljs-keyword">new</span> Contra();        InvocationHandler invocationHandler1 = <span class="hljs-keyword">new</span> Kid(contra);        Game gameDynamicProxy1 = (Game) Proxy.newProxyInstance(Contra.class.getClassLoader(),                Contra.class.getInterfaces(), invocationHandler1);        gameDynamicProxy1.play();        <span class="hljs-comment">// 玩王者荣耀</span>        HonorKing honorKing = <span class="hljs-keyword">new</span> HonorKing();        InvocationHandler invocationHandler2 = <span class="hljs-keyword">new</span> Kid(honorKing);        Game gameDynamicProxy2 = (Game) Proxy.newProxyInstance(KingofGlory.class.getClassLoader(),                KingofGlory.class.getInterfaces(), invocationHandler2);        gameDynamicProxy2.play();    &#125;&#125;</code></pre><h3 id="建造者模式builder"><a class="markdownIt-Anchor" href="#建造者模式builder"></a> 建造者模式(Builder)</h3><p>将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。<br>主要角色有：</p><ul><li><strong>建造者（Builder）</strong> 负责定义用于生成实例的接口</li><li><strong>具体建造者（ConcreteBuilder）</strong> 实现 Builder 接口，定义生成实例时实际被调用的方法。</li><li><strong>监工（Director）</strong> 负责使用 Builder 接口生成实例。它并不依赖于 ConcreteBuilder ，保证不论 ConcreteBuilder 如何定义，Director 都能正常工作。</li></ul><p><code>优点</code>：</p><ul><li>各个具体的建造者相互独立，有利于系统的扩展。</li><li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li></ul><p><code>缺点</code>：</p><ul><li>产品的组成部分必须相同，这限制了其使用范围。</li><li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li></ul><p><code>示例</code>：将电子邮件对象分解成发件人、收件人、主题、内容、附件等内容对象。</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Builder.png" alt="建造者模式" style="height:400px;"><span class="image-caption">建造者模式</span><pre class="highlight"><code class="java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Email</span> </span>&#123;    <span class="hljs-comment">/**     * 收件人     */</span>    <span class="hljs-keyword">private</span> String receiver;    <span class="hljs-comment">/**     * 发件人     */</span>    <span class="hljs-keyword">private</span> String addresser;    <span class="hljs-comment">/**     * 主题     */</span>    <span class="hljs-keyword">private</span> String subject;    <span class="hljs-comment">/**     * 内容     */</span>    <span class="hljs-keyword">private</span> String content;    <span class="hljs-comment">/**     * 附件     */</span>    <span class="hljs-keyword">private</span> String attachment;&#125;<span class="hljs-comment">/** * 建造者 * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Builder</span> </span>&#123;    <span class="hljs-function">Email <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildReceiver</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildAddresser</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildSubject</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildContent</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildAttachment</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 实际建造者 * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Builder</span> </span>&#123;    <span class="hljs-keyword">private</span> Email email = <span class="hljs-keyword">new</span> Email();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Email <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> email;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildReceiver</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.email.setReceiver(<span class="hljs-string">"建造发送者！"</span>);        System.out.println(<span class="hljs-string">"建造发送者！"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildAddresser</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.email.setAddresser(<span class="hljs-string">"建造收件者！"</span>);        System.out.println(<span class="hljs-string">"建造收件者！"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSubject</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">this</span>.email.setSubject(<span class="hljs-string">"建造主题！"</span>);        System.out.println(<span class="hljs-string">"建造主题！"</span>);    &#125;&#125;<span class="hljs-comment">/** * 指挥者 * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;    <span class="hljs-keyword">private</span> Builder builder;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;        <span class="hljs-keyword">this</span>.builder = builder;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;        builder.buildReceiver();        builder.buildAddresser();        builder.buildSubject();        builder.buildContent();        builder.buildAttachment();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Builder builder = <span class="hljs-keyword">new</span> ConcreteBuilder();        Director director = <span class="hljs-keyword">new</span> Director(builder);        director.send();        System.out.println(builder.getResult().toString());    &#125;&#125;</code></pre><h3 id="原型模式prototype"><a class="markdownIt-Anchor" href="#原型模式prototype"></a> 原型模式（Prototype）</h3><p><code>定义</code>：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。通过对象 clone() 方法实现。</p><p><code>使用场景</code>：</p><ul><li>资源优化场景：类初始化需要消耗非常多的资源。</li><li>性能和安全要求的场景：通过new产生对象需要繁琐的数据准备或访问权限。</li><li>一个对象多个修改者场景。</li></ul><p><code>角色</code>：</p><ul><li><strong>原型（Prototype）</strong> 定义用于复制现有实例来生成新实例的方法。</li><li><strong>具体原型（ConcretePrototype）</strong> 负责实现复制现有实例并生成新实例的方法。</li></ul><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/prototype.png" alt="原型模式" style="height:400px;"><span class="image-caption">原型模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 复制功能接口（原型角色） *  * <span class="hljs-doctag">@date</span> 2021-05-24 14:03 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Cloneable</span> </span>&#123;    <span class="hljs-comment">/**     * 产品方法     *      * <span class="hljs-doctag">@param</span> s     * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-24 14:08     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">(String s)</span></span>;    <span class="hljs-comment">/**     * 创建克隆错象     *      * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-24 14:10     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function">Product <span class="hljs-title">createClone</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 具体原型 *  * <span class="hljs-doctag">@date</span> 2021-05-24 14:11 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">createClone</span><span class="hljs-params">()</span> </span>&#123;        Product product = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            product = (Product) <span class="hljs-keyword">super</span>.clone();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> product;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">use</span><span class="hljs-params">(String s)</span> </span>&#123;        System.out.println(s);    &#125;&#125;<span class="hljs-comment">/** * 管理器 *  * <span class="hljs-doctag">@date</span> 2021-05-24 14:17 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> </span>&#123;    <span class="hljs-keyword">private</span> HashMap&lt;String, Product&gt; cacheMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(String name, Product proto)</span> </span>&#123;        <span class="hljs-keyword">this</span>.cacheMap.put(name, proto);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">create</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> cacheMap.get(name);    &#125;&#125;<span class="hljs-comment">/** * Client 使用类 *  * <span class="hljs-doctag">@date</span> 2021-05-24 14:20 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 注册</span>        Manager manager = <span class="hljs-keyword">new</span> Manager();        Apple apple = <span class="hljs-keyword">new</span> Apple();        manager.register(<span class="hljs-string">"ap"</span>, apple);        <span class="hljs-comment">// 复制</span>        Product product = manager.create(<span class="hljs-string">"ap"</span>);        <span class="hljs-comment">// 使用</span>        product.use(<span class="hljs-string">"一斤苹果！"</span>);    &#125;&#125;</code></pre><h3 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h3><p><code>定义</code>：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象会得到通知并被自动更新。这种模式有时又称作发布-订阅模式。<br>该模式主要角色有：</p><ul><li><strong>观察对象（Subject）</strong>，即被观察者角色。提供用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。</li><li><strong>具体观察对象（Concrete Subject）</strong>。它实现观察对象中的通知方法，当具体观察者的内部状态发生改变时，通知所有注册过的观察者对象。</li><li><strong>观察者（Observer）</strong>。包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。</li><li><strong>具体观察者（Concrete Observer）</strong>。实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。</li></ul><p><code>使用场景</code>：</p><ul><li>关联行为场景；</li><li>事件多级触发场景；</li><li>跨系统的消息交换场景，如消息队列的处理机制。</li></ul><p><code>优点</code>：</p><ul><li>将被观察者和观察者进行解耦，使得他们之间的依赖性更小，甚至做到毫无依赖</li></ul><p><code>缺点</code>：</p><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</li></ul><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/observer.png" alt="观察者模式" style="height:400px;"><span class="image-caption">观察者模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 彩票 * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lottery</span> </span>&#123;    <span class="hljs-comment">/**     * 号码     */</span>    <span class="hljs-keyword">private</span> String no;    <span class="hljs-comment">/**     * 期号     */</span>    <span class="hljs-keyword">private</span> String issue;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Lottery</span><span class="hljs-params">(String no, String issue)</span> </span>&#123;        <span class="hljs-keyword">this</span>.no = no;        <span class="hljs-keyword">this</span>.issue = issue;    &#125;&#125;<span class="hljs-comment">/** * 被观察对象 * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;    <span class="hljs-comment">/**     * 增加观察者     *     * <span class="hljs-doctag">@param</span> observer     * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer observer)</span></span>;    <span class="hljs-comment">/**     * 删除观察者     *     * <span class="hljs-doctag">@param</span> observer     * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delObserver</span><span class="hljs-params">(Observer observer)</span></span>;    <span class="hljs-comment">/**     * 通知观察者     *     * <span class="hljs-doctag">@param</span> lottery     * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(Lottery lottery)</span></span>;    <span class="hljs-comment">/**     * 开奖     *     * <span class="hljs-doctag">@param</span> lottery     * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lottery</span><span class="hljs-params">(Lottery lottery)</span></span>;&#125;<span class="hljs-comment">/** * 彩票管理中心(具体被观察对象) * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LotteryCenter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;Observer&gt; observerList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;        <span class="hljs-keyword">this</span>.observerList.add(observer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;        <span class="hljs-keyword">this</span>.observerList.remove(observer);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(Lottery lottery)</span> </span>&#123;        <span class="hljs-keyword">for</span> (Observer observer : observerList) &#123;            observer.lottery(lottery);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lottery</span><span class="hljs-params">(Lottery lottery)</span> </span>&#123;        notifyObservers(lottery);    &#125;&#125;<span class="hljs-comment">/** * 观察者 * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;    <span class="hljs-comment">/**     * 开奖     *     * <span class="hljs-doctag">@param</span> lottery     * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lottery</span><span class="hljs-params">(Lottery lottery)</span></span>;&#125;<span class="hljs-comment">/** * 彩票持有者A（具体观察者） * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LotteryHoldersA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;    <span class="hljs-keyword">private</span> Lottery lottery;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LotteryHoldersA</span><span class="hljs-params">(String no, String issue)</span> </span>&#123;        lottery = <span class="hljs-keyword">new</span> Lottery(no, issue);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lottery</span><span class="hljs-params">(Lottery lottery)</span> </span>&#123;        System.out.println(<span class="hljs-string">"LotteryHoldersA 接收到开奖通知："</span> + lottery.toString());        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lottery.getIssue().equals(lottery.getIssue())) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lottery.getNo().equals(lottery.getNo())) &#123;                System.out.println(<span class="hljs-string">"|"</span>);                System.out.println(<span class="hljs-string">"|___ 中奖啦～\n"</span>);            &#125;        &#125;    &#125;&#125;<span class="hljs-comment">/** * 彩票持有者B（具体观察者） * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LotteryHoldersB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;    <span class="hljs-keyword">private</span> Lottery lottery;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LotteryHoldersB</span><span class="hljs-params">(String no, String issue)</span> </span>&#123;        lottery = <span class="hljs-keyword">new</span> Lottery(no, issue);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lottery</span><span class="hljs-params">(Lottery lottery)</span> </span>&#123;        System.out.println(<span class="hljs-string">"LotteryHoldersB 接收到开奖通知："</span> + lottery.toString());        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lottery.getIssue().equals(lottery.getIssue())) &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lottery.getNo().equals(lottery.getNo())) &#123;                System.out.println(<span class="hljs-string">"|"</span>);                System.out.println(<span class="hljs-string">"|___ 中奖啦～\n"</span>);            &#125;        &#125;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Subject subject = <span class="hljs-keyword">new</span> LotteryCenter();        Observer obsA = <span class="hljs-keyword">new</span> LotteryHoldersA(<span class="hljs-string">"82 43 23 32 67 75 07 92"</span>, <span class="hljs-string">"202005"</span>);        Observer obsB = <span class="hljs-keyword">new</span> LotteryHoldersB(<span class="hljs-string">"82 43 23 32 67 75 07 93"</span>, <span class="hljs-string">"202005"</span>);        <span class="hljs-comment">// 添加观察者</span>        subject.addObserver(obsA);        subject.addObserver(obsB);        <span class="hljs-comment">// 中奖号码</span>        Lottery lottery = <span class="hljs-keyword">new</span> Lottery(<span class="hljs-string">"82 43 23 32 67 75 07 92"</span>, <span class="hljs-string">"202005"</span>);        <span class="hljs-comment">// 开奖</span>        subject.lottery(lottery);    &#125;&#125;</code></pre><h3 id="适配器模式adapter"><a class="markdownIt-Anchor" href="#适配器模式adapter"></a> 适配器模式（Adapter）</h3><p><code>定义</code>：将一个类的接口变成客户端所期待的另一种接口，从而使原本不匹配而无法在一起工作的两个类一起工作。<br>通常包含三个角色：</p><ul><li><strong>Target(目标角色)</strong> 当前系统已定义的接口或抽象类。</li><li><strong>Adaptee(适配者角色)</strong> 需要被适配的现存组件库接口。</li><li><strong>Adapter(适配器角色)</strong> 使用 Adaptee 角色的方法来满足 Target 角色的需求转换器。</li></ul><p><code>使用场景</code>：已经投产的项目修改时，经常使用。</p><p><code>优点</code>：</p><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li></ul><p><code>适配器模式有两种形式</code>：</p><ul><li>类适配器模式（使用继承的适配器）</li></ul><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/adapter1.png" alt="类适配器模式" style="height:300px;"><span class="image-caption">类适配器模式</span><ul><li>对象适配器模式（使用委托的适配器）</li></ul><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/adapter2.png" alt="对象适配器模式" style="height:300px;"><span class="image-caption">对象适配器模式</span><p><code>示例</code>：<br><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/adapter.png" alt="适配器模式" style="height:300px;"><span class="image-caption">适配器模式</span></p><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 游戏手柄(Target 目标角色) * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GamePad</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">control</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * GTA 游戏 * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GTAGame</span> </span>&#123;    <span class="hljs-keyword">private</span> GamePad gamePad;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GTAGame</span><span class="hljs-params">(GamePad gamePad)</span> </span>&#123;        <span class="hljs-keyword">this</span>.gamePad = gamePad;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;        gamePad.control();    &#125;&#125;<span class="hljs-comment">/** * xbox 游戏手柄 * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XBoxPad</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GamePad</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">control</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"xbox 游戏开始！"</span>);    &#125;&#125;<span class="hljs-comment">/** * 特殊游戏手柄(Adaptee 适配者角色) * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SpecialGamePad</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">specialControl</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * BT 游戏手柄 * * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BTPad</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SpecialGamePad</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">specialControl</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"BT 游戏开始！"</span>);    &#125;&#125;<span class="hljs-comment">/** * 游戏手柄适配器(Adapter 适配器角色) * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GamePadAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GamePad</span> </span>&#123;    <span class="hljs-keyword">private</span> SpecialGamePad specialGamePad;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GamePadAdapter</span><span class="hljs-params">(SpecialGamePad specialGamePad)</span> </span>&#123;        <span class="hljs-keyword">this</span>.specialGamePad = specialGamePad;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">control</span><span class="hljs-params">()</span> </span>&#123;        specialGamePad.specialControl();    &#125;&#125;<span class="hljs-comment">/** * 模式应用(客户端角色) * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 原手柄调用 xbox</span>        GamePad gamePad = <span class="hljs-keyword">new</span> XBoxPad();        GTAGame gtaGame = <span class="hljs-keyword">new</span> GTAGame(gamePad);        gtaGame.start();        <span class="hljs-comment">// 适配其他手柄后调用 bt</span>        SpecialGamePad btPad = <span class="hljs-keyword">new</span> BTPad();        GamePadAdapter gamePadAdapter = <span class="hljs-keyword">new</span> GamePadAdapter(btPad);        gtaGame = <span class="hljs-keyword">new</span> GTAGame(gamePadAdapter);        gtaGame.start();    &#125;&#125;</code></pre><h3 id="迭代器模式iterator"><a class="markdownIt-Anchor" href="#迭代器模式iterator"></a> 迭代器模式（Iterator）</h3><p><code>定义</code>：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部信息。<br>该模式主要角色有：</p><ul><li><strong>Iterator（迭代器）</strong> 负责定义访问、遍历集合元素的接口，如：hasNext()、first()、next()等方法。</li><li><strong>ConcreteIterator（具体迭代器）</strong> 实现迭代器接口中定义的方法，包含遍历集合所必需的信息，记录遍历的当前位置。</li><li><strong>Aggregate（集合）</strong> 定义存储、添加、删除集合对象以及创建迭代器对象接口。</li><li><strong>ConcreteAggregate（具体集合）</strong> 实现集合中的接口，返回迭代器实例。</li></ul><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/iterator.png" alt="迭代器模式" style="height:400px;"><span class="image-caption">迭代器模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 迭代器接口 *  * <span class="hljs-doctag">@date</span> 2021-05-18 10:40 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span> </span>&#123;    <span class="hljs-comment">/**     * 是否有下一个     *      * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-18 10:43     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">/**     * 下一个元素     *      * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-18 10:43     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function">Object <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 书架迭代类 *  * <span class="hljs-doctag">@date</span> 2021-05-18 11:04 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookshelfIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span> </span>&#123;    <span class="hljs-comment">/**     * 书架     */</span>    <span class="hljs-keyword">private</span> BookShelf bookShelf;    <span class="hljs-comment">/**     * 索引     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookshelfIterator</span><span class="hljs-params">(BookShelf bookShelf)</span> </span>&#123;        <span class="hljs-keyword">this</span>.bookShelf = bookShelf;        <span class="hljs-keyword">this</span>.index = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.index &lt; bookShelf.getLength()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;        Book book = bookShelf.getBook(index);        index++;        <span class="hljs-keyword">return</span> book;    &#125;&#125;<span class="hljs-comment">/** * 集合接口 *  * <span class="hljs-doctag">@date</span> 2021-05-18 10:27 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Aggregate</span> </span>&#123;    <span class="hljs-comment">/**     * 迭代方法     *      * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-18 10:29     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function">Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 书架类 *  * <span class="hljs-doctag">@date</span> 2021-05-18 10:52 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookShelf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Aggregate</span> </span>&#123;    <span class="hljs-comment">/**     * 图书集合     */</span>    <span class="hljs-keyword">private</span> Book[] book;    <span class="hljs-comment">/**     * 最后一个     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> last = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookShelf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxsize)</span> </span>&#123;        <span class="hljs-keyword">this</span>.book = <span class="hljs-keyword">new</span> Book[maxsize];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Book <span class="hljs-title">getBook</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.book[index];    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendBook</span><span class="hljs-params">(Book book)</span> </span>&#123;        <span class="hljs-keyword">this</span>.book[last] = book;        last++;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> last;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BookshelfIterator(<span class="hljs-keyword">this</span>);    &#125;&#125;<span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-comment">/** * 图书类 *  * <span class="hljs-doctag">@date</span> 2021-05-18 10:44 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-comment">/**     * 书名     */</span>    <span class="hljs-keyword">private</span> String name;&#125;<span class="hljs-comment">/** * 执行类 *  * <span class="hljs-doctag">@date</span> 2021-05-18 11:12 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        BookShelf bookShelf = <span class="hljs-keyword">new</span> BookShelf(<span class="hljs-number">5</span>);        bookShelf.appendBook(<span class="hljs-keyword">new</span> Book(<span class="hljs-string">"图书1"</span>));        bookShelf.appendBook(<span class="hljs-keyword">new</span> Book(<span class="hljs-string">"图书2"</span>));        bookShelf.appendBook(<span class="hljs-keyword">new</span> Book(<span class="hljs-string">"图书3"</span>));        bookShelf.appendBook(<span class="hljs-keyword">new</span> Book(<span class="hljs-string">"图书4"</span>));        bookShelf.appendBook(<span class="hljs-keyword">new</span> Book(<span class="hljs-string">"图书5"</span>));        Iterator it = bookShelf.iterator();        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;            Book book = (Book) it.next();            System.out.println(book.getName());        &#125;    &#125;&#125;</code></pre><blockquote><p>引入 Iterator 后可以将遍历与集合实现分离，如上 159 行代码通过 Iterator 的 hasNext 方法和 next 方法获得 Book 信息，并不需要依赖 BookShelf 的实现。当开发人员打算使用 List 替换数组管理书架时，只需保证返回正确的 Iterator 实例，迭代相关代码无需任何修改即可正常工作。</p></blockquote><h3 id="模板方法模式template-method"><a class="markdownIt-Anchor" href="#模板方法模式template-method"></a> 模板方法模式（Template Method）</h3><p><code>定义</code>：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。<br>主要角色有：</p><ul><li><strong>AbstractClass(抽象类)</strong> 负责实现模板方法，声明在模板方法中使用的抽象方法。这些抽象方法由子类 <code>ConcreteClass</code> 负责实现。</li><li><strong>ConcreteClass(具体类)</strong> 负责实现 <code>AbstractClass</code> 角色中定义的抽象方法。</li></ul><blockquote><p>Java8中接口支持 <code>default</code> 和 <code>static</code> 关键字，接口已经和抽象类很接近，但是<strong>模板方法</strong>模式依然不能使用接口实现，因为，其一是接口不支持构造器;其次接口方法只能是 <code>public</code> 范围等限制。</p></blockquote><p><code>示例</code>：把大象放冰箱，总共分几步？</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/template.png" alt="模板方法模式" style="height:400px;"><span class="image-caption">模板方法模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 物品接口 *  * <span class="hljs-doctag">@date</span> 2021-05-20 18:25 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Goods</span> </span>&#123;    <span class="hljs-comment">/**     * 物品名字     *      * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-20 18:27     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 大象 *  * <span class="hljs-doctag">@date</span> 2021-05-20 18:28 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Elephant</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Goods</span> </span>&#123;    <span class="hljs-comment">/**     * 名称     */</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Elephant</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;&#125;<span class="hljs-comment">/** * 冰箱存储抽象类 *  * <span class="hljs-doctag">@date</span> 2021-05-20 18:21 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFridgeStore</span> </span>&#123;    <span class="hljs-comment">/**     * 物品     */</span>    <span class="hljs-keyword">protected</span> Goods goods;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractFridgeStore</span><span class="hljs-params">(Goods goods)</span> </span>&#123;        <span class="hljs-keyword">this</span>.goods = goods;    &#125;    <span class="hljs-comment">/**     *      * <span class="hljs-doctag">@param</span>     * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-20 18:23     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">store</span><span class="hljs-params">()</span> </span>&#123;        openDoor();        putGoogs();        closeDoor();    &#125;    <span class="hljs-comment">/**     * 把冰箱门打开     *      * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-20 18:32     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openDoor</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"把冰箱门打开！"</span>);    &#125;    <span class="hljs-comment">/**     * 把冰箱门关上     *      * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-20 18:32     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">closeDoor</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"把冰箱门关上！"</span>);    &#125;    <span class="hljs-comment">/**     * 放入物品（抽象方法交给子类实现）     *      * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-05-21 09:35     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putGoogs</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 冰箱存储大象类 *  * <span class="hljs-doctag">@date</span> 2021-05-20 18:39 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElephnatFridgeStore</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFridgeStore</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ElephnatFridgeStore</span><span class="hljs-params">(Goods goods)</span> </span>&#123;        <span class="hljs-keyword">super</span>(goods);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putGoogs</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(String.format(<span class="hljs-string">"把%s放入冰箱!"</span>, goods.name()));    &#125;&#125;<span class="hljs-comment">/** * 问：把大象放冰箱，总共分几步？ *  * <span class="hljs-doctag">@date</span> 2021-05-20 18:38 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Goods elephant = <span class="hljs-keyword">new</span> Elephant(<span class="hljs-string">"大象"</span>);        AbstractFridgeStore fridgeStore = <span class="hljs-keyword">new</span> ElephnatFridgeStore(elephant);        fridgeStore.store();    &#125;&#125;-------------------------------------把冰箱门打开！把大象放入冰箱!把冰箱门关上！</code></pre><h3 id="桥接模式bridge"><a class="markdownIt-Anchor" href="#桥接模式bridge"></a> 桥接模式(Bridge)</h3><p><code>类的层次结构</code>：</p><ul><li><p><strong>类的功能层次结构</strong> 在一个类需要增加新功能时(如：增加一个方法)，编写一个新的子类来继承当前类，此时就产生了一个小的功能层次结构。</p><pre class="highlight"><code class></code></pre></li></ul><p>ParentClass.java<br>|_  ChildClass.java<br>|_  AnotherChildClass.java</p><pre class="highlight"><code class>- **类的实现层次结构** 当在抽象类或接口中定义了一些抽象方法，然后子类去负责实现这些方法。父类的任务是定义接口，而子类的任务是实现接口中的方法，以便写出具有高可替换性的类。这里产生的层次结构并非用于增加功能，这种的层次结构叫做类的实现层次结构。</code></pre><p>AbstractClass.java<br>|_  ConcreteClass.java<br>|_  AnotherConcreteClass.java</p><pre class="highlight"><code class>`定义`：桥接模式就是在上面两种结构之间搭建一座桥梁将它们连接起来。主要角色：- **抽象化( Abstraction )** 角色位于类的功能层次结构最顶层，并包含一个 Implementor 角色的引用，用于使用该角色中的定义的方法。- **精确的抽象化( Refined Abstraction )** 是 Abstraction 角色的子类，在 Abstraction 角色基础上增加了新的功能。- **实现化( Implementor )** 角色位于类的层次结构最上层，定义实现化角色的接口，供扩展抽象化角色调用。- **具体实现化( Concrete Implementor )** 负责实现 Implementor 角色中定义的接口。`示例`：PhotoShop 画图时可以画各种形状(如：圆形、方形等)，各形状可以填充任意颜色(如红色、蓝色等)。两者之间可以任意组合，此时可以使用桥接模式解决这个问题。&lt;img src='bridge.png' alt=&quot;桥接模式&quot; style=&quot;height:400px;&quot;/&gt;```java/*** 颜色(实现化角色)* * @date 2021-06-01 10:10* @author Windus*/public interface Color &#123;  /**   * 颜色填充   *    * @return   * @date 2021-06-01 10:12   * @author Windus   */  void rawFill();&#125;/*** 红色（具体实现化角色）* * @date 2021-06-01 10:23* @author Windus*/public class Red implements Color &#123;  @Override  public void rawFill() &#123;      System.out.println(&quot;红色&quot;);  &#125;&#125;/*** 蓝色（具体实现化角色）* * @date 2021-06-01 10:24* @author Windus*/public class Bule implements Color &#123;  @Override  public void rawFill() &#123;      System.out.println(&quot;蓝色&quot;);  &#125;&#125;/*** 形状抽象类(抽象化角色)* * @date 2021-06-01 10:09* @author Windus*/public abstract class AbstractSharp &#123;  private Color color;  protected AbstractSharp(Color color) &#123;      this.color = color;  &#125;  private void fill() &#123;      color.rawFill();  &#125;  protected void draw() &#123;      fill();  &#125;&#125;/*** 圆形（精确的抽象化角色）* * @date 2021-06-01 10:14* @author Windus*/public class CircleSharp extends AbstractSharp &#123;  public CircleSharp(Color color) &#123;      super(color);  &#125;  public void drawCircle() &#123;      System.out.print(&quot;圆形：&quot;);      draw();  &#125;&#125;/*** 长方形（精确的抽象化角色）* * @date 2021-06-01 10:20* @author Windus*/public class SquareSharp extends AbstractSharp &#123;  public SquareSharp(Color color) &#123;      super(color);  &#125;  public void drawSquare() &#123;      System.out.print(&quot;方形：&quot;);      draw();  &#125;&#125;public class App &#123;  public static void main(String[] args) &#123;      Color red = new Red();      Color blue = new Bule();            // 抽象化调用      AbstractSharp abstractSharp = new CircleSharp(red);      abstractSharp.draw();      // 圆形精确抽象化调用      CircleSharp circleSharp = new CircleSharp(red);      circleSharp.drawCircle();            // 方形精确抽象化调用      SquareSharp squareSharp = new SquareSharp(blue);      squareSharp.drawSquare();  &#125;&#125;</code></pre><h3 id="策略模式strategy"><a class="markdownIt-Anchor" href="#策略模式strategy"></a> 策略模式(Strategy)</h3><p><code>定义</code>：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><p><code>优点</code>：</p><ul><li>避免使用多重条件语句，如 if…else 语句、switch…case 语句。</li><li>对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。</li><li>把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</li></ul><p><code>角色</code>：</p><ul><li><strong>抽象策略(Strategy)</strong> 定义一个接口，负责决定实现策略所必要的接口。</li><li><strong>具体策略(ConcreteStrategy)</strong> 负责实现具体的策略(战略、方向、方法和算法等)。</li><li><strong>上下文(Context)</strong> 保存具体策略的实例，给客户端调用。</li></ul><p><code>示例</code>：猜拳游戏，两个玩家多次出拳。</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/strategy.png" alt="策略模式" style="height:400px;"><span class="image-caption">策略模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 手掌类 *  * <span class="hljs-doctag">@date</span> 2021-06-17 17:50 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Getter</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hand</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HAND_VALUE_ROCK = <span class="hljs-number">0</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HAND_VALUE_SCISSORS = <span class="hljs-number">1</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HAND_VALUE_PAPER = <span class="hljs-number">2</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] HAND_NAMES = &#123; <span class="hljs-string">"石头"</span>, <span class="hljs-string">"剪刀"</span>, <span class="hljs-string">"布"</span> &#125;;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hand</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<span class="hljs-keyword">this</span>.value = value;<span class="hljs-keyword">this</span>.name = HAND_NAMES[value];&#125;<span class="hljs-comment">/** * 赢得对方 *  * <span class="hljs-doctag">@param</span> value * <span class="hljs-doctag">@return</span> true/false * <span class="hljs-doctag">@date</span> 2021-06-18 10:00 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isWinThan</span><span class="hljs-params">(Hand hand)</span> </span>&#123;<span class="hljs-keyword">return</span> fight(hand.getValue()) == <span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/** * 输给对方 *  * <span class="hljs-doctag">@param</span> value * <span class="hljs-doctag">@return</span> true/false * <span class="hljs-doctag">@date</span> 2021-06-18 10:01 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLoseThan</span><span class="hljs-params">(Hand hand)</span> </span>&#123;<span class="hljs-keyword">return</span> fight(hand.getValue()) == -<span class="hljs-number">1</span>;&#125;<span class="hljs-comment">/** * 出拳比较 *  * <span class="hljs-doctag">@param</span> value * <span class="hljs-doctag">@return</span> 0 平 1 胜 -1 败 * <span class="hljs-doctag">@date</span> 2021-06-18 09:43 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fight</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.value == value) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">this</span>.value + <span class="hljs-number">1</span>) % HAND_NAMES.length == value) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-comment">/** * 策略接口 *  * <span class="hljs-doctag">@date</span> 2021-06-17 17:48 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Strategy</span> </span>&#123;<span class="hljs-comment">/** * 下一次出拳 *  * <span class="hljs-doctag">@param</span> * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-06-17 17:48 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function">Hand <span class="hljs-title">nextHand</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** * 学习上一局结果 *  * <span class="hljs-doctag">@param</span> win 是否获胜 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-06-17 18:22 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> win)</span></span>;&#125;<span class="hljs-comment">/** * 玩家类 *  * <span class="hljs-doctag">@date</span> 2021-06-17 17:52 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Player</span> </span>&#123;<span class="hljs-comment">/** * 玩家姓名 */</span><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">/** * 玩家策略 */</span><span class="hljs-keyword">private</span> Strategy strategy;<span class="hljs-comment">/** * 赢次数 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> windCount;<span class="hljs-comment">/** * 输次数 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> loseCount;<span class="hljs-comment">/** * 游戏次数 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> gameCount;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Player</span><span class="hljs-params">(String name, Strategy strategy)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;<span class="hljs-keyword">this</span>.strategy = strategy;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Hand <span class="hljs-title">nexHand</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> strategy.nextHand();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">win</span><span class="hljs-params">()</span> </span>&#123;strategy.study(<span class="hljs-keyword">true</span>);windCount++;gameCount++;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lose</span><span class="hljs-params">()</span> </span>&#123;strategy.study(<span class="hljs-keyword">false</span>);loseCount++;gameCount++;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">even</span><span class="hljs-params">()</span> </span>&#123;gameCount++;&#125;&#125;<span class="hljs-comment">/** * 赢时策略 &lt;br/&gt; * 如果上一局获胜，则下局继续出相同手势 *  * <span class="hljs-doctag">@date</span> 2021-06-18 10:11 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WinningStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> won;<span class="hljs-keyword">private</span> Integer prevHandValue;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Hand <span class="hljs-title">nextHand</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (!won) &#123;Random random = <span class="hljs-keyword">new</span> Random();prevHandValue = random.nextInt(Hand.HAND_NAMES.length);&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Hand(prevHandValue);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> win)</span> </span>&#123;won = win;&#125;&#125;<span class="hljs-comment">/** * 概率策略&lt;br/&gt; * 计算每种出拳概率决定下次出拳 &lt;br/&gt; *  * histories[0][0] 两局分别出 石头 &lt;-&gt; 石头，时胜利次数 &lt;br/&gt; * histories[0][1] 两局分别出 石头 &lt;-&gt; 剪刀，时胜利次数 &lt;br/&gt; * histories[0][2] 两局分别出 石头 &lt;-&gt;布,胜利次数 &lt;br/&gt; *  * 例如：&lt;br/&gt; * histories[0][0] = 3 &lt;br/&gt; * histories[0][1] = 5 &lt;br/&gt; * histories[0][7] = 7 &lt;br/&gt; *  * 下一局出石头、剪刀、布的比率就是 3:5:7，然后在 15(3+5＋7) 中取一个随机数，小于 3 则出石头，小于 8(3+5) 则出剪刀，小于 15 * 则出布。 *  * <span class="hljs-doctag">@date</span> 2021-06-18 10:38 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span> </span>&#123;<span class="hljs-comment">/** * 上次出拳 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> prevHandValue = <span class="hljs-number">0</span>;<span class="hljs-comment">/** * 本次出拳 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentHandValue = <span class="hljs-number">0</span>;<span class="hljs-comment">/** * 出拳纪录 [上一次出拳][本次出拳]&lt;br/&gt; */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] histories;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PropStrategy</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// 初始化纪录数组</span><span class="hljs-keyword">int</span> historiesLen = Hand.HAND_NAMES.length;histories = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[historiesLen][historiesLen];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; historiesLen; i++) &#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; historiesLen; j++) &#123;histories[i][j] = <span class="hljs-number">1</span>;&#125;&#125;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Hand <span class="hljs-title">nextHand</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> handValue;Random random = <span class="hljs-keyword">new</span> Random();<span class="hljs-keyword">int</span> propValue = random.nextInt(getSum(currentHandValue));<span class="hljs-keyword">if</span> (propValue &lt; histories[currentHandValue][Hand.HAND_VALUE_ROCK]) &#123;handValue = Hand.HAND_VALUE_ROCK;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propValue &lt; histories[currentHandValue][Hand.HAND_VALUE_ROCK]+ histories[currentHandValue][Hand.HAND_VALUE_SCISSORS]) &#123;handValue = Hand.HAND_VALUE_SCISSORS;&#125; <span class="hljs-keyword">else</span> &#123;handValue = Hand.HAND_VALUE_PAPER;&#125;prevHandValue = currentHandValue;currentHandValue = handValue;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Hand(handValue);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">study</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> win)</span> </span>&#123;<span class="hljs-keyword">if</span> (win) &#123;<span class="hljs-comment">// 赢了当前局手势次数加 1　</span>histories[prevHandValue][currentHandValue]++;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 输了当前局除了当前手势，其他手势次数加 1</span>histories[prevHandValue][(currentHandValue + <span class="hljs-number">1</span>) % Hand.HAND_NAMES.length]++;histories[prevHandValue][(currentHandValue + <span class="hljs-number">2</span>) % Hand.HAND_NAMES.length]++;&#125;&#125;<span class="hljs-comment">/** * 计算指定手势值分别出石头、剪刀、步的次数的总和 *  * <span class="hljs-doctag">@param</span> value 手势值 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-06-18 10:56 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; Hand.HAND_NAMES.length; i++) &#123;sum += histories[value][i];&#125;<span class="hljs-keyword">return</span> sum;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Player zhangsan = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">"张三"</span>, <span class="hljs-keyword">new</span> WinningStrategy());Player wangwu = <span class="hljs-keyword">new</span> Player(<span class="hljs-string">"王五"</span>, <span class="hljs-keyword">new</span> PropStrategy());<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;Hand zsHand = zhangsan.nexHand();Hand wwHand = wangwu.nexHand();<span class="hljs-keyword">if</span> (zsHand.isWinThan(wwHand)) &#123;zhangsan.win();wangwu.lose();&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (zsHand.isLoseThan(wwHand)) &#123;zhangsan.lose();wangwu.win();&#125; <span class="hljs-keyword">else</span> &#123;zhangsan.even();wangwu.even();&#125;&#125;System.out.println(<span class="hljs-string">"----------------------------"</span>);System.out.println(zhangsan.toString());System.out.println(wangwu.toString());&#125;&#125;</code></pre><h3 id="组合模式composite"><a class="markdownIt-Anchor" href="#组合模式composite"></a> 组合模式(Composite)</h3><p><code>定义</code>：一种将对象组合成树状的层次结构的模式，用来表示“整体-部分”的关系，整体可以看作是容器，部分可以看作是内容。在容器中可以放入内容，也可以放入小容器，然后在小容器中可以放入更小的容器。这种结构模式，能够使容器与内容具有一致性，创造出递归模式。</p><p><code>优点</code>：</p><ul><li>组合模式可以一致的使用容器和内容，无须关心自己处理的是单个对象，还是组合对象，简化了客户端代码。</li><li>组合休内增加新对象，不需要修改源代码，满足开闭原则。</li></ul><p><code>角色</code>：</p><ul><li><p><strong>树叶(Leaf)</strong> 叶节点对象，表示内容，该角色不能放入其他对象。</p></li><li><p><strong>复合物(Composite)</strong> 表示容器，可以放入 Leaf 和 Composite 角色。</p></li><li><p><strong>抽象组件(Component)</strong> 为 Leaf 和 Composite 角色定义公共接口，是其父类，使其具有一致性的角色。</p></li></ul><p><code>示例</code>：系统目录与文件结构</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/composite.png" alt="组合模式" style="height:400px;"><span class="image-caption">组合模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 抽象组件角色 *  * <span class="hljs-doctag">@date</span> 2021-06-22 10:59 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span> </span>&#123;<span class="hljs-comment">/** * 获取名字 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-06-22 11:02 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** * 获取文件大小 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-06-22 11:02 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** * 添加条目 *  * <span class="hljs-doctag">@param</span> entry 条目(容器|内容) * <span class="hljs-doctag">@throws</span> Exception * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-06-22 11:04 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">default</span> Entry <span class="hljs-title">add</span><span class="hljs-params">(Entry entry)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();&#125;<span class="hljs-comment">/** * 打印列表 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-06-22 11:06 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">()</span> </span>&#123;printList(<span class="hljs-string">""</span>);&#125;<span class="hljs-comment">/** * 打印带前缀列表 *  * <span class="hljs-doctag">@param</span> prefix 前缀 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-06-22 11:07 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(String prefix)</span> </span>&#123;System.out.println(prefix + <span class="hljs-string">"/"</span> + printString());&#125;<span class="hljs-comment">/** * 打印字符串 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-06-22 14:07 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">printString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> getName() + <span class="hljs-string">"("</span> + getSize() + <span class="hljs-string">")"</span>;&#125;&#125;<span class="hljs-comment">/** * 目录类&lt;br/&gt; * 复合物角色 *  * <span class="hljs-doctag">@date</span> 2021-06-22 11:00 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Directory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Entry</span> </span>&#123;    <span class="hljs-comment">/**     * 文件夹名     */</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">/**     * 文件夹中条目集合     */</span>    <span class="hljs-keyword">private</span> ArrayList&lt;Entry&gt; items = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Directory</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (Entry entry : items) &#123;            size += entry.getSize();        &#125;        <span class="hljs-keyword">return</span> size;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(String prefix)</span> </span>&#123;        <span class="hljs-comment">// 打印文件夹本身</span>        System.out.println(prefix + <span class="hljs-string">"/"</span> + printString());        <span class="hljs-comment">// 打印文件夹内条目</span>        <span class="hljs-keyword">for</span> (Entry entry : items) &#123;            entry.printList(prefix + <span class="hljs-string">"/"</span> + name);        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Entry <span class="hljs-title">add</span><span class="hljs-params">(Entry entry)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        items.add(entry);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;&#125;<span class="hljs-comment">/** * 文件类&lt;br/&gt; * 树叶角色 *  * <span class="hljs-doctag">@date</span> 2021-06-22 11:00 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Entry</span> </span>&#123;    <span class="hljs-comment">/**     * 文件名     */</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">/**     * 文件大小     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Directory rootDir = <span class="hljs-keyword">new</span> Directory(<span class="hljs-string">"root"</span>);Directory tmpDir = <span class="hljs-keyword">new</span> Directory(<span class="hljs-string">"tmp"</span>);Directory cacheDir = <span class="hljs-keyword">new</span> Directory(<span class="hljs-string">"cache"</span>);rootDir.add(tmpDir);tmpDir.add(cacheDir);File setting = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"setting"</span>, <span class="hljs-number">1024</span>);cacheDir.add(setting);File log = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"catalina.log"</span>, <span class="hljs-number">800</span>);tmpDir.add(log);<span class="hljs-comment">// 打印 root 目录</span>rootDir.printList();<span class="hljs-comment">// 继续增加 bin 目录并打印</span>Directory binDir = <span class="hljs-keyword">new</span> Directory(<span class="hljs-string">"bin"</span>);rootDir.add(binDir);File rm = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"rm"</span>, <span class="hljs-number">104</span>);binDir.add(rm);rootDir.printList();&#125;&#125;</code></pre><blockquote><p>上例中由于 File类不添加子类，所以不应该有 add 方法，于是就产生了 add 去哪的问题？</p><ul><li><strong>定义在 Entry 中</strong> 使其什么都不做，或者抛出异常。这种模式叫做 <em><strong>透明组合模式</strong></em>。</li><li><strong>声明在 Entry 中</strong> 只声明但不实现，子类根据需要实现该方法。使用这种方式，即使子类中不需要该方法，也必须定义该方法。</li><li><strong>只定义在 Directory 中</strong> 使用这种方式时，如果要向父类 Entry 变量(实际保存的是 Directory)中的 add 时需将它们的类型转换为 Directory 类型。这种模式叫做 <em><strong>安全组合模式</strong></em>。</li></ul></blockquote><h3 id="装饰器模式decorator"><a class="markdownIt-Anchor" href="#装饰器模式decorator"></a> 装饰器模式(Decorator)</h3><p><code>定义</code>：在不改变现有对象结构的情况下，动态的地给对象增加额外的功能。</p><p><code>优点</code>：</p><ul><li>在不改变原有对象的结构情况下，为对象扩充功能。</li><li>使用不同装饰类，可以实现不同的效果，比继承更灵活。</li><li>完全遵循开闭原则</li></ul><p><code>角色</code>：</p><ul><li><strong>抽象组件(Component)</strong> 增加功能时的核心角色，定义抽象接口。</li><li><strong>具体组件(ConcreteComponent)</strong> 实现 Component 角色所定义的接口。</li><li><strong>装饰物(Decorator)</strong> 具有与 Component 角色相同的接口，内部保存了被装饰的对象(Component)。</li><li><strong>具体装饰物(ConcreteDecorator)</strong> 实现 Decorator 角色的相关方法，给具体构件对象增加额外功能。</li></ul><p><code>示例</code>：数码宝贝进化</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/decorator.png" alt="装饰器模式" style="height:400px;"><span class="image-caption">装饰器模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 数码宝贝&lt;br/&gt; * 抽象组件角色 *  * <span class="hljs-doctag">@date</span> 2021-06-24 09:43 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractDigimon</span> </span>&#123;    <span class="hljs-keyword">protected</span> String name;    <span class="hljs-keyword">protected</span> String display;    <span class="hljs-keyword">protected</span> String uniqueSkills;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractDigimon</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-comment">/**     * 战斗     *      * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-06-24 10:15     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 浮游兽&lt;br/&gt; * 具体组件角色 *  * <span class="hljs-doctag">@date</span> 2021-06-24 09:52 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poyomon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDigimon</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Poyomon</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">super</span>(name);        <span class="hljs-keyword">this</span>.display = <span class="hljs-string">"外观：「水母状漂浮」"</span>;        <span class="hljs-keyword">this</span>.uniqueSkills = <span class="hljs-string">"必杀技：「强酸泡泡」"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-keyword">this</span>.name);        System.out.println(<span class="hljs-keyword">this</span>.display);        System.out.println(<span class="hljs-keyword">this</span>.uniqueSkills);        System.out.println(<span class="hljs-string">"---------------------------------------"</span>);    &#125;&#125;<span class="hljs-comment">/** * 进化抽象类&lt;br/&gt; * 装饰物角色 *  * <span class="hljs-doctag">@date</span> 2021-06-24 09:56 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractEvolution</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractDigimon</span> </span>&#123;    <span class="hljs-comment">/**     * 被装饰物     */</span>    <span class="hljs-keyword">protected</span> AbstractDigimon digimon;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractEvolution</span><span class="hljs-params">(String name, AbstractDigimon digimon)</span> </span>&#123;        <span class="hljs-keyword">super</span>(name);        <span class="hljs-keyword">this</span>.digimon = digimon;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> </span>&#123;        digimon.fight();        System.out.print(<span class="hljs-string">"「"</span> + digimon.name + <span class="hljs-string">"」进化 ---&gt;"</span>);    &#125;&#125;<span class="hljs-comment">/** * 巴达兽&lt;/br/&gt; * 具体装饰物角色 *  * <span class="hljs-doctag">@date</span> 2021-06-24 09:55 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Patamon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractEvolution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Patamon</span><span class="hljs-params">(String name, AbstractDigimon digimon)</span> </span>&#123;        <span class="hljs-keyword">super</span>(name, digimon);        <span class="hljs-keyword">this</span>.display = <span class="hljs-string">"外观：「大耳朵哺乳类型数码兽」"</span>;        <span class="hljs-keyword">this</span>.uniqueSkills = <span class="hljs-string">"必杀技：「羽翼耳光」"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.fight();        System.out.println(<span class="hljs-string">"「"</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">"」"</span>);        System.out.println(<span class="hljs-keyword">this</span>.display);        System.out.println(<span class="hljs-keyword">this</span>.uniqueSkills);        System.out.println(<span class="hljs-string">"---------------------------------------"</span>);    &#125;&#125;<span class="hljs-comment">/** * 天使兽&lt;/br&gt; * 具体装饰物角色 *  * <span class="hljs-doctag">@date</span> 2021-06-24 09:49 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Angel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractEvolution</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Angel</span><span class="hljs-params">(String name, AbstractDigimon digimon)</span> </span>&#123;        <span class="hljs-keyword">super</span>(name, digimon);        <span class="hljs-keyword">this</span>.display = <span class="hljs-string">"外观：「纯白之衣的天使数码兽」"</span>;        <span class="hljs-keyword">this</span>.uniqueSkills = <span class="hljs-string">"必杀技：「天堂之拳」"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>.fight();        System.out.println(<span class="hljs-string">"「"</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">"」"</span>);        System.out.println(<span class="hljs-keyword">this</span>.display);        System.out.println(<span class="hljs-keyword">this</span>.uniqueSkills);        System.out.println(<span class="hljs-string">"---------------------------------------"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        AbstractDigimon poyomon = <span class="hljs-keyword">new</span> Poyomon(<span class="hljs-string">"浮游兽"</span>);        AbstractDigimon patamon = <span class="hljs-keyword">new</span> Patamon(<span class="hljs-string">"巴达兽"</span>, poyomon);        AbstractDigimon angel = <span class="hljs-keyword">new</span> Angel(<span class="hljs-string">"天使兽"</span>, patamon);        poyomon.fight();        patamon.fight();        angel.fight();        System.out.println(<span class="hljs-string">"\n\n**********************************************************************\n\n"</span>);        <span class="hljs-comment">// 无限装饰</span>        AbstractDigimon evolution = <span class="hljs-keyword">new</span> Angel(<span class="hljs-string">"天使兽"</span>, <span class="hljs-keyword">new</span> Patamon(<span class="hljs-string">"巴达兽"</span>, <span class="hljs-keyword">new</span> Poyomon(<span class="hljs-string">"浮游兽"</span>)));        evolution.fight();    &#125;&#125;</code></pre><h3 id="访问者模式visitor"><a class="markdownIt-Anchor" href="#访问者模式visitor"></a> 访问者模式(Visitor)</h3><p><code>定义</code>：将某种数据结构中各元素的操作分离出来，使其可以在不改变数据结构的情况下添加新的操作，为元素提供多种访问方式。</p><p><code>角色</code>：</p><ul><li><strong>访问者(Visitor)</strong> 对数据结构中每个具体元素定义一个用于访问的 visit() 方法。</li><li><strong>具体访问者(ConcreteVisitor)</strong> 实现 Visitor 角色定义的接口。</li><li><strong>抽象元素(Element)</strong> 表示 Visitor 角色的访问对象，定义一个 accept() 方法，接收参数是 Visitor 角色对象。</li><li><strong>具体元素(ConcreteElement)</strong> 实现 Element 角色中定义的接口。</li><li><strong>对象结构(ObjectStructure)</strong> 负责处理 Element 角色的集合，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。</li></ul><p><code>优缺点</code>：</p><ul><li>易于增加具体访问者。</li><li>难于增加具体元素，因为需要修改原有代码。因此该模式通常用于对象结构相对稳定，但其操作算法经常变化的程序。</li></ul><p><code>示例</code>：结合组合模式，用访问者模式实现文件系统的访问。</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/visitor.png" alt="访问者模式" style="height:400px;"><span class="image-caption">访问者模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 抽象元素角色 *  * <span class="hljs-doctag">@date</span> 2021-07-06 11:05 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Element</span> </span>&#123;    <span class="hljs-comment">/**     * 接收 visitor 方法     *      * <span class="hljs-doctag">@param</span> visitor     * <span class="hljs-doctag">@return</span>     * <span class="hljs-doctag">@date</span> 2021-07-06 11:05     * <span class="hljs-doctag">@author</span> Windus     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span></span>;&#125;<span class="hljs-comment">/** * 组合模式抽象组件角色 *  * <span class="hljs-doctag">@date</span> 2021-07-06 11:08 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Element</span> </span>&#123;<span class="hljs-comment">/** * 获取名字 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-07-06 11:09 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** * 获取大小 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-07-06 11:09 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** * 添加条目 *  * <span class="hljs-doctag">@param</span> entry * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@throws</span> Exception * <span class="hljs-doctag">@date</span> 2021-07-06 11:10 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">default</span> Entry <span class="hljs-title">add</span><span class="hljs-params">(Entry entry)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();&#125;<span class="hljs-comment">/** * 迭代 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@throws</span> Exception * <span class="hljs-doctag">@date</span> 2021-07-06 11:12 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">default</span> Iterator <span class="hljs-title">iterator</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();&#125;<span class="hljs-comment">/** * 打印字符串 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-07-06 11:11 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">printString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> getName() + <span class="hljs-string">"("</span> + getSize() + <span class="hljs-string">")"</span>;&#125;&#125;<span class="hljs-comment">/** * 文件夹类 &lt;br/&gt; * 组合模式复合物角色&lt;br/&gt; * 具体元素角色&lt;br/&gt; * 对象结构角色 -&gt; 实现了 iterator() 方法 *  * <span class="hljs-doctag">@date</span> 2021-07-06 11:16 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Directory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Entry</span> </span>&#123;<span class="hljs-comment">/** * 文件夹名 */</span><span class="hljs-keyword">private</span> String name;<span class="hljs-keyword">private</span> List&lt;Entry&gt; dir = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Directory</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;Iterator&lt;Entry&gt; iterator = iterator();<span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;Entry entry = iterator.next();size += entry.getSize();&#125;<span class="hljs-keyword">return</span> size;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Entry <span class="hljs-title">add</span><span class="hljs-params">(Entry entry)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;dir.add(entry);<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;Entry&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-keyword">return</span> dir.iterator();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;visitor.visit(<span class="hljs-keyword">this</span>);&#125;&#125;<span class="hljs-comment">/** * 文件类&lt;br/&gt; * 组合模式树叶角色&lt;br/&gt; * 具体元素角色 *  * <span class="hljs-doctag">@date</span> 2021-07-06 11:14 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">File</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Entry</span> </span>&#123;<span class="hljs-comment">/*** 文件名*/</span><span class="hljs-keyword">private</span> String name;<span class="hljs-comment">/*** 文件大小*/</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Visitor visitor)</span> </span>&#123;visitor.visit(<span class="hljs-keyword">this</span>);&#125;&#125;<span class="hljs-comment">/** * 访问者角色 *  * <span class="hljs-doctag">@date</span> 2021-07-06 11:03 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Visitor</span> </span>&#123;<span class="hljs-comment">/** * 访问文件 *  * <span class="hljs-doctag">@param</span> file * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-07-06 11:15 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(File file)</span></span>;<span class="hljs-comment">/** * 访问文件夹 *  * <span class="hljs-doctag">@param</span> directory * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-07-06 11:17 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Directory directory)</span></span>;&#125;<span class="hljs-comment">/** * 具体访问者角色 *  * <span class="hljs-doctag">@date</span> 2021-07-06 13:39 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListVisitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Visitor</span> </span>&#123;<span class="hljs-comment">/** * 当前目录 */</span><span class="hljs-keyword">private</span> String currentDir = <span class="hljs-string">""</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(File file)</span> </span>&#123;System.out.println(currentDir + java.io.File.separator + file.printString());&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Directory directory)</span> </span>&#123;System.out.println(currentDir + java.io.File.separator + directory.printString());String tempDir = currentDir;currentDir = currentDir + java.io.File.separator + directory.getName();Iterator&lt;Entry&gt; iterator = directory.iterator();<span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;Entry entry = iterator.next();entry.accept(<span class="hljs-keyword">this</span>);&#125;currentDir = tempDir;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Directory root = <span class="hljs-keyword">new</span> Directory(<span class="hljs-string">"root"</span>);Directory bin = <span class="hljs-keyword">new</span> Directory(<span class="hljs-string">"bin"</span>);Directory tmp = <span class="hljs-keyword">new</span> Directory(<span class="hljs-string">"tmp"</span>);File vi = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"vi"</span>, <span class="hljs-number">10000</span>);File latex = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"latex"</span>, <span class="hljs-number">20000</span>);root.add(bin);root.add(tmp);bin.add(vi);bin.add(latex);root.accept(<span class="hljs-keyword">new</span> ListVisitor());&#125;&#125;</code></pre><h3 id="责任链模式chain-of-responsibility"><a class="markdownIt-Anchor" href="#责任链模式chain-of-responsibility"></a> 责任链模式(Chain of Responsibility)</h3><p><code>定义</code>：将多个对象组成一条链表结构，然后将一个请求发送这个链表，让对象按照它们在链上的顺序一个一个地找出到底该谁来负责处理请求。</p><blockquote><p>可以把它想像成推卸责任的结构，有利于记忆。</p></blockquote><p><code>角色</code>：</p><ul><li><strong>抽象处理者 (Handler)</strong> 定义处理请求的接口，包含一个处理方法和下一个处理者(Handler)。</li><li><strong>具体处理者 (Concrete Handler)</strong> 实现抽象处理者的方法，实际处理请求。当自己无法处理请求时，将请求转给下一个处理者。</li><li><strong>请求者 (Client)</strong> 创建处理请求链，并向链头第一个处理者发送请求。</li></ul><p><code>优点</code>：</p><ul><li>弱化了发出请求和处理请求人之间的关系。</li><li>可以动态的改变职责链，增强了扩展性。</li><li>各个职责独立实现业务处理互不干扰。</li></ul><p><code>缺点</code>：</p><ul><li>导致请求处理速度延迟，如果请求者和处理者关系明确，不建议使用。</li><li>当责任链过长时，处理对象增长，导致性能下降。</li></ul><p><code>示例</code>：公司员工请假审批流程</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/chain.png" alt="责任链模式" style="height:400px;"><span class="image-caption">责任链模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 请假流程对象 *  * <span class="hljs-doctag">@date</span> 2021-07-23 14:28 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeaveProcess</span> </span>&#123;<span class="hljs-comment">/** * 请假标题 */</span><span class="hljs-keyword">private</span> String title;<span class="hljs-comment">/** * 请假原因 */</span><span class="hljs-keyword">private</span> String content;<span class="hljs-comment">/** * 请假天数 */</span><span class="hljs-keyword">private</span> Integer days;&#125;<span class="hljs-comment">/** * 领导抽象类（抽象处理者角色） *  * <span class="hljs-doctag">@date</span> 2021-07-23 14:13 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractLeader</span> </span>&#123;<span class="hljs-comment">/** * 职称 */</span><span class="hljs-keyword">protected</span> String title;<span class="hljs-comment">/** * 上级领导 */</span><span class="hljs-keyword">protected</span> AbstractLeader superior;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractLeader</span><span class="hljs-params">(String title)</span> </span>&#123;<span class="hljs-keyword">this</span>.title = title;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> AbstractLeader <span class="hljs-title">setSuperior</span><span class="hljs-params">(AbstractLeader superior)</span> </span>&#123;<span class="hljs-keyword">this</span>.superior = superior;<span class="hljs-keyword">return</span> superior;&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">done</span><span class="hljs-params">(LeaveProcess leaveProcess)</span> </span>&#123;System.out.println(leaveProcess + <span class="hljs-string">"被"</span> + <span class="hljs-keyword">this</span>.title + <span class="hljs-string">"审核通过！"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(LeaveProcess leaveProcess)</span> </span>&#123;System.out.println(leaveProcess + <span class="hljs-string">"被"</span> + <span class="hljs-keyword">this</span>.title + <span class="hljs-string">"审核拒绝！"</span>);&#125;<span class="hljs-comment">/** * 处理请求 *  * <span class="hljs-doctag">@param</span> leaveProcess 请假流程 *  * <span class="hljs-doctag">@date</span> 2021-07-23 14:29 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toProcess</span><span class="hljs-params">(LeaveProcess leaveProcess)</span></span>;&#125;<span class="hljs-comment">/** * 主管（具体处理者角色） *  * <span class="hljs-doctag">@date</span> 2021-07-23 14:53 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Direcoter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLeader</span> </span>&#123;<span class="hljs-comment">/** * 权限天数 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PERMISSIONS = <span class="hljs-number">2</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Direcoter</span><span class="hljs-params">(String title)</span> </span>&#123;<span class="hljs-keyword">super</span>(title);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toProcess</span><span class="hljs-params">(LeaveProcess leaveProcess)</span> </span>&#123;<span class="hljs-keyword">if</span> (leaveProcess.getDays() &gt; PERMISSIONS) &#123;superior.toProcess(leaveProcess);&#125; <span class="hljs-keyword">else</span> &#123;done(leaveProcess);&#125;&#125;&#125;<span class="hljs-comment">/** * 部门经理 *  * <span class="hljs-doctag">@date</span> 2021-07-23 15:46 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLeader</span> </span>&#123;<span class="hljs-comment">/** * 权限天数（具体处理者角色） */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PERMISSIONS = <span class="hljs-number">5</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String title)</span> </span>&#123;<span class="hljs-keyword">super</span>(title);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toProcess</span><span class="hljs-params">(LeaveProcess leaveProcess)</span> </span>&#123;<span class="hljs-keyword">if</span> (leaveProcess.getDays() &gt; PERMISSIONS) &#123;superior.toProcess(leaveProcess);&#125; <span class="hljs-keyword">else</span> &#123;done(leaveProcess);&#125;&#125;&#125;<span class="hljs-comment">/** * 总监（具体处理者角色） *  * <span class="hljs-doctag">@date</span> 2021-07-23 15:07 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Supervisor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLeader</span> </span>&#123;<span class="hljs-comment">/** * 权限天数 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PERMISSIONS = <span class="hljs-number">10</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Supervisor</span><span class="hljs-params">(String title)</span> </span>&#123;<span class="hljs-keyword">super</span>(title);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">toProcess</span><span class="hljs-params">(LeaveProcess leaveProcess)</span> </span>&#123;<span class="hljs-keyword">if</span> (leaveProcess.getDays() &gt; PERMISSIONS) &#123;failed(leaveProcess);&#125; <span class="hljs-keyword">else</span> &#123;done(leaveProcess);&#125;&#125;&#125;<span class="hljs-comment">/** * 请求者角色 *  * <span class="hljs-doctag">@date</span> 2021-07-23 17:10 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;AbstractLeader direcoter = <span class="hljs-keyword">new</span> Direcoter(<span class="hljs-string">"主管"</span>);AbstractLeader manager = <span class="hljs-keyword">new</span> Manager(<span class="hljs-string">"经理"</span>);AbstractLeader supervisor = <span class="hljs-keyword">new</span> Supervisor(<span class="hljs-string">"总监"</span>);<span class="hljs-comment">// 设置审批流程</span>direcoter.setSuperior(manager).setSuperior(supervisor);<span class="hljs-comment">// 请假两天</span>LeaveProcess twoDays = <span class="hljs-keyword">new</span> LeaveProcess(<span class="hljs-string">"请假"</span>, <span class="hljs-string">"家里有事儿！"</span>, <span class="hljs-number">2</span>);direcoter.toProcess(twoDays);<span class="hljs-comment">// 请假三天</span>LeaveProcess threeDays = <span class="hljs-keyword">new</span> LeaveProcess(<span class="hljs-string">"请假"</span>, <span class="hljs-string">"身体不舒服！"</span>, <span class="hljs-number">3</span>);direcoter.toProcess(threeDays);<span class="hljs-comment">// 请假六天</span>LeaveProcess sixDays = <span class="hljs-keyword">new</span> LeaveProcess(<span class="hljs-string">"请假"</span>, <span class="hljs-string">"休年假！"</span>, <span class="hljs-number">6</span>);direcoter.toProcess(sixDays);<span class="hljs-comment">// 请假一年</span>LeaveProcess oneYear = <span class="hljs-keyword">new</span> LeaveProcess(<span class="hljs-string">"请假"</span>, <span class="hljs-string">"世界那么大，我想去看看！"</span>, <span class="hljs-number">365</span>);direcoter.toProcess(oneYear);&#125;&#125;执行结果：----------------------------------------------------------------------------LeaveProcess(title=请假, content=家里有事儿！, days=<span class="hljs-number">2</span>)被主管审核通过！LeaveProcess(title=请假, content=身体不舒服！, days=<span class="hljs-number">3</span>)被经理审核通过！LeaveProcess(title=请假, content=休年假！, days=<span class="hljs-number">6</span>)被总监审核通过！LeaveProcess(title=请假, content=世界那么大，我想去看看！, days=<span class="hljs-number">365</span>)被总监审核拒绝！</code></pre><h3 id="外观模式facade"><a class="markdownIt-Anchor" href="#外观模式facade"></a> 外观模式(Facade)</h3><p><code>定义</code>：又叫<strong>门面模式</strong>，为互相关联在一起错综复杂的子系统整理出高层接口，让系统对外只开放一些简单的接口。外部应用程序不用关心内部子系统的具体细节，降低应用程序的复杂度，提高了程序的可维护性。</p><p><code>角色</code>：</p><ul><li><strong>外观角色（Facade)</strong> 也叫<strong>窗口角色</strong>，为子系统对外提供简单的高层接口。</li><li><strong>子系统角色（Sub System）</strong> 实现系统的部分功能，请求者角色可以通过外观角色访问它，而它们并不知道外观角色的存在。</li><li><strong>请求者角色（Client）</strong> 负责调用外观角色，但其并不包含在外观模式中。</li></ul><p><code>优点</code>：</p><ul><li>降低了子系统与客户端之间的耦合度，是“迪米特法则”的典型应用。</li><li>对客户屏蔽了子系统组件，减少了客户的API调用接口，使子系统更加容易被使用。</li></ul><p><code>缺点</code>：</p><ul><li>不能完全的限制客户使用子系统，容易存在未知风险。</li><li>增加子类系统时，需要修改外观，违背了“开闭原则”。</li></ul><p><code>示例</code>：</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/facade.png" alt="门面模式" style="height:400px;"><span class="image-caption">门面模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 子系统（一） *  * <span class="hljs-doctag">@date</span> 2021-07-26 10:27 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemOne</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excute</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"子系统一被调用！"</span>);&#125;&#125;<span class="hljs-comment">/** * 子系统（二） *  * <span class="hljs-doctag">@date</span> 2021-07-26 10:27 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemTwo</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excute</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"子系统二被调用！"</span>);&#125;&#125;<span class="hljs-comment">/** * 子系统（三） *  * <span class="hljs-doctag">@date</span> 2021-07-26 10:27 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystemThree</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excute</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"子系统三被调用！"</span>);&#125;&#125;<span class="hljs-comment">/** * 外观角色 *  * <span class="hljs-doctag">@date</span> 2021-07-26 10:30 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>&#123;<span class="hljs-keyword">private</span> SubSystemOne systemOne = <span class="hljs-keyword">new</span> SubSystemOne();<span class="hljs-keyword">private</span> SubSystemTwo systemTwo = <span class="hljs-keyword">new</span> SubSystemTwo();<span class="hljs-keyword">private</span> SubSystemThree systemThree = <span class="hljs-keyword">new</span> SubSystemThree();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">excute</span><span class="hljs-params">()</span> </span>&#123;systemOne.excute();systemTwo.excute();systemThree.excute();&#125;&#125;<span class="hljs-comment">/** * 请求者角色 *  * <span class="hljs-doctag">@date</span> 2021-07-26 10:31 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Facade facade = <span class="hljs-keyword">new</span> Facade();facade.excute();&#125;&#125;</code></pre><blockquote><p>如果门面接口很少，可以将它跟非门面接口放到一块，不需要特殊标记，当作普通接口调用即可。如果门面接口很多，可以在已有的接口之上，抽象出一层，专门放置门面接口，如果门面接口特别多，并且很多都是跨多个子系统的，可以将门面接口抽象出一个门面子系统单独调用和维护。</p></blockquote><h3 id="中介者模式mediator"><a class="markdownIt-Anchor" href="#中介者模式mediator"></a> 中介者模式(Mediator)</h3><p><code>定义</code>：用一个中介者对象封装一系列的对象交互，使各个对象不需要显示的互相引用，松散耦合，并且可以独立改变一组对象之间的交互关系，而不影响其他对象。</p><p><code>角色</code>：</p><ul><li><strong>中介者（Mediator）</strong> 定义了 Colleague 角色注册与转发的接口。</li><li><strong>具体中介者（Concrete Mediator）</strong> 实现中介者接口，协调 Colleague 角色之间的交互关系。</li><li><strong>同事（Colleague）</strong> 定义与 Mediator 角色进行通信的接口</li><li><strong>具体同事（Concrete Colleague）</strong> 实现 Colleague 接口，当需要与其他同事交互时，由 Mediator 负责交互。</li></ul><p><code>优点</code>：</p><ul><li>降低了对象之间的耦合性，符合迪米特法则。</li><li>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</li></ul><p><code>缺点</code>：</p><ul><li>当同事类越多时，中介者越臃肿。</li></ul><p><code>示例</code>：中介公司买房与卖房</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mediator.png" alt="中介者模式" style="height:400px;"><span class="image-caption">中介者模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 中介公司(中介者角色) *  * <span class="hljs-doctag">@date</span> 2021-08-02 14:40 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IntermediaryCompany</span> </span>&#123;<span class="hljs-comment">/** * 登记请求 *  * <span class="hljs-doctag">@param</span> trader * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-02 14:44 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(AbstractTrader trader)</span></span>;<span class="hljs-comment">/** * 转发请求 *  * <span class="hljs-doctag">@param</span> trader * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-02 14:49 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">relay</span><span class="hljs-params">(AbstractTrader trader)</span></span>;&#125;<span class="hljs-comment">/** * 链家(具体中介者角色 *  * <span class="hljs-doctag">@date</span> 2021-08-02 14:56 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lianjia</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IntermediaryCompany</span> </span>&#123;<span class="hljs-keyword">private</span> List&lt;AbstractTrader&gt; sellerList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-keyword">private</span> List&lt;AbstractTrader&gt; buyerList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">register</span><span class="hljs-params">(AbstractTrader trader)</span> </span>&#123;List&lt;AbstractTrader&gt; registerList = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (trader <span class="hljs-keyword">instanceof</span> Seller) &#123;registerList = sellerList;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (trader <span class="hljs-keyword">instanceof</span> Buyer) &#123;registerList = buyerList;&#125;<span class="hljs-keyword">if</span> (!registerList.contains(trader)) &#123;registerList.add(trader);&#125;trader.setIntermediaryCompany(<span class="hljs-keyword">this</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">relay</span><span class="hljs-params">(AbstractTrader trader)</span> </span>&#123;List&lt;AbstractTrader&gt; relayList = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (trader <span class="hljs-keyword">instanceof</span> Buyer) &#123;relayList = sellerList;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (trader <span class="hljs-keyword">instanceof</span> Seller) &#123;relayList = buyerList;&#125;<span class="hljs-keyword">for</span> (AbstractTrader t : relayList) &#123;House house = trader.getHouse();<span class="hljs-keyword">if</span> (house != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (house.equals(t.getHouse())) &#123;trader.receive(t);&#125;&#125;&#125;&#125;&#125;<span class="hljs-comment">/** * 房子对象 *  * <span class="hljs-doctag">@date</span> 2021-08-02 15:00 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Data</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-meta">@EqualsAndHashCode</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">House</span> </span>&#123;<span class="hljs-comment">/** * 建筑面积(平方米) */</span><span class="hljs-keyword">private</span> Integer builtUpArea;<span class="hljs-comment">/** * 房间数 */</span><span class="hljs-keyword">private</span> Integer rooms;<span class="hljs-comment">/** * 总价(万元) */</span><span class="hljs-keyword">private</span> Integer totalPrice;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<span class="hljs-keyword">if</span> (obj != <span class="hljs-keyword">null</span> &amp;&amp; obj <span class="hljs-keyword">instanceof</span> House) &#123;House house = (House) obj;<span class="hljs-keyword">if</span> (Math.abs(<span class="hljs-keyword">this</span>.totalPrice - house.totalPrice) &lt;= <span class="hljs-number">50</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;    <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> prime = <span class="hljs-number">31</span>;<span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;result = prime * result + ((builtUpArea == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : builtUpArea.hashCode());result = prime * result + ((rooms == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : rooms.hashCode());result = prime * result + ((totalPrice == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : totalPrice.hashCode());<span class="hljs-keyword">return</span> result;&#125;&#125;<span class="hljs-comment">/** * 交易人(同事角色) *  * <span class="hljs-doctag">@date</span> 2021-08-02 14:42 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Getter</span><span class="hljs-meta">@ToString</span>(exclude = <span class="hljs-string">"intermediaryCompany"</span>)<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractTrader</span> </span>&#123;<span class="hljs-comment">/** * 名字 */</span><span class="hljs-keyword">protected</span> String name;<span class="hljs-comment">/** * 房子信息 */</span><span class="hljs-keyword">protected</span> House house;<span class="hljs-comment">/** * 中介公司 */</span><span class="hljs-keyword">protected</span> IntermediaryCompany intermediaryCompany;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractTrader</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-comment">/** * 设置中介公司 *  * <span class="hljs-doctag">@param</span> intermediaryCompany 中介公司 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-02 14:51 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIntermediaryCompany</span><span class="hljs-params">(IntermediaryCompany intermediaryCompany)</span> </span>&#123;<span class="hljs-keyword">this</span>.intermediaryCompany = intermediaryCompany;&#125;<span class="hljs-comment">/** * 发送请求 *  * <span class="hljs-doctag">@param</span> house 房子信息 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-02 14:52 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(House house)</span></span>;<span class="hljs-comment">/** * 接收应答 *  * <span class="hljs-doctag">@param</span> trader 交易人 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-02 14:52 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(AbstractTrader trader)</span></span>;&#125;<span class="hljs-comment">/** * 卖方（具体同事角色） *  * <span class="hljs-doctag">@date</span> 2021-08-02 15:21 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Getter</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Seller</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTrader</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Seller</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">super</span>(name);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(AbstractTrader trader)</span> </span>&#123;System.out.println(<span class="hljs-string">"|"</span>);System.out.println(<span class="hljs-string">"|___ 买家["</span> + trader + <span class="hljs-string">"]"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(House house)</span> </span>&#123;<span class="hljs-keyword">this</span>.house = house;System.out.println(<span class="hljs-string">"卖家["</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">"]，发布信息"</span> + house);intermediaryCompany.relay(<span class="hljs-keyword">this</span>);&#125;&#125;<span class="hljs-comment">/** * 买方（具体同事角色） *  * <span class="hljs-doctag">@date</span> 2021-08-02 15:21 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Getter</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Buyer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractTrader</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Buyer</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">super</span>(name);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">receive</span><span class="hljs-params">(AbstractTrader trader)</span> </span>&#123;System.out.println(<span class="hljs-string">"|"</span>);System.out.println(<span class="hljs-string">"|___ 卖家["</span> + trader + <span class="hljs-string">"]"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(House house)</span> </span>&#123;<span class="hljs-keyword">this</span>.house = house;System.out.println(<span class="hljs-string">"买家["</span> + <span class="hljs-keyword">this</span>.name + <span class="hljs-string">"]，发布信息"</span> + house);intermediaryCompany.relay(<span class="hljs-keyword">this</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;System.out.println(<span class="hljs-string">"\n"</span>);<span class="hljs-comment">// 定义中介公司</span>IntermediaryCompany lianjia = <span class="hljs-keyword">new</span> Lianjia();<span class="hljs-comment">// 登记卖房人</span>AbstractTrader zhangsanSeller = <span class="hljs-keyword">new</span> Seller(<span class="hljs-string">"张三"</span>);lianjia.register(zhangsanSeller);AbstractTrader lisiSeller = <span class="hljs-keyword">new</span> Seller(<span class="hljs-string">"李四"</span>);lianjia.register(lisiSeller);AbstractTrader qianqiSeller = <span class="hljs-keyword">new</span> Seller(<span class="hljs-string">"钱七"</span>);lianjia.register(qianqiSeller);<span class="hljs-comment">// 登记买房人</span>AbstractTrader wangwuBuyer = <span class="hljs-keyword">new</span> Buyer(<span class="hljs-string">"王五"</span>);lianjia.register(wangwuBuyer);AbstractTrader zhaoliuBuyer = <span class="hljs-keyword">new</span> Buyer(<span class="hljs-string">"赵六"</span>);lianjia.register(zhaoliuBuyer);<span class="hljs-comment">// 发布卖房信息</span>zhangsanSeller.send(<span class="hljs-keyword">new</span> House(<span class="hljs-number">80</span>, <span class="hljs-number">2</span>, <span class="hljs-number">300</span>));lisiSeller.send(<span class="hljs-keyword">new</span> House(<span class="hljs-number">120</span>, <span class="hljs-number">3</span>, <span class="hljs-number">350</span>));System.out.println(<span class="hljs-string">"\n"</span>);<span class="hljs-comment">// 发布买房信息</span>wangwuBuyer.send(<span class="hljs-keyword">new</span> House(<span class="hljs-number">80</span>, <span class="hljs-number">2</span>, <span class="hljs-number">310</span>));System.out.println(<span class="hljs-string">"\n"</span>);zhaoliuBuyer.send(<span class="hljs-keyword">new</span> House(<span class="hljs-number">150</span>, <span class="hljs-number">4</span>, <span class="hljs-number">800</span>));System.out.println(<span class="hljs-string">"\n"</span>);<span class="hljs-comment">// 发布卖房信息</span>qianqiSeller.send(<span class="hljs-keyword">new</span> House(<span class="hljs-number">160</span>, <span class="hljs-number">4</span>, <span class="hljs-number">850</span>));&#125;&#125;</code></pre><h3 id="备忘录模式memento"><a class="markdownIt-Anchor" href="#备忘录模式memento"></a> 备忘录模式(Memento)</h3><p><code>定义</code>：又叫快照模式，在不破坏封装性的前提下，通过引入表示实例状态的角色，可以保存和恢复实例的模式。</p><p><code>角色</code>：</p><ul><li><strong>发起人（Originator）</strong> 保存自己最新状态时，创建 Memento(备忘录)。当把以前保存的 Memento(备忘录) 传递给 Originator(发起人) 时，会将自己恢复到生成该 Memento(备忘录) 时的状态。</li><li><strong>备忘录（Memento)</strong> 负责存储 Originator(发起人) 内部信息，但不会向外公开这些信息。</li><li><strong>管理者（Caretaker）</strong> 对 Memento(备忘录) 进行管理，负责发起保存或恢复 Memento(备忘录) 功能，不能对 Memento(备忘录) 内容进行访问和修改。</li></ul><blockquote><p>备忘录（Memento) 对外提供两种接口：</p><ul><li><strong>宽接口(wide interface)</strong>，用于恢复对象信息的接口集合，会暴露 <strong>Memento(备忘录)</strong> 内部所有信息，因此只对 <strong>Originator(发起人)</strong> 开放。</li><li><strong>窄接口(narrow interface)</strong>，只能获取有限的内部信息，防止信息泄露，通常对 <strong>Caretaker(管理者)</strong> 开放。</li></ul><p>生成 <strong>Memento(备忘录)</strong> 实例后，<strong>Caretaker(管理者)</strong> 会一直保存该实例，用于将来恢复该实例。不过 <strong>Caretaker(管理者)</strong> 只能使用 <strong>窄接口(narrow interface)</strong>，因此它无法访问 <strong>Memento(备忘录)</strong> 中所有信息，<strong>它只是将 Memento(备忘录) 当作是一个黑盒子保存起来。</strong></p></blockquote><p><code>优点</code>：</p><ul><li>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤。</li><li>备忘录实现了对信息的封装，只允许发起人进行访问和修改。</li><li>管理者负责发起创建和撤销备忘录动作，发起人负责生成和恢复备忘录。两者各司其职，当需求改变时不需要修改发起人角色代码，并且满足单一职责原则。</li></ul><p><code>缺点</code>：</p><ul><li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><p><code>示例</code>：掷骰子游戏，在路上。</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/memento.png" alt="备忘录模式" style="height:400px;"><span class="image-caption">备忘录模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 备忘录角色 *  * <span class="hljs-doctag">@date</span> 2021-08-03 15:45 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Memento</span> </span>&#123;<span class="hljs-comment">/** * 游戏总步数 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> totalStep;<span class="hljs-comment">/** * 当前步数 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentStep;<span class="hljs-comment">/** * 游戏关卡 */</span><span class="hljs-keyword">private</span> String[] gamePoint;<span class="hljs-comment">/** * 构造函数 wide interface *  * <span class="hljs-doctag">@date</span> 2021-08-03 17:29 * <span class="hljs-doctag">@author</span> Windus */</span>Memento(<span class="hljs-keyword">int</span> totalStep, <span class="hljs-keyword">int</span> currentStep, String[] gamePoint) &#123;<span class="hljs-keyword">this</span>.totalStep = totalStep;<span class="hljs-keyword">this</span>.currentStep = currentStep;<span class="hljs-keyword">this</span>.gamePoint = gamePoint;&#125;<span class="hljs-comment">/** * 获取总步数 narrow interface *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-03 17:31 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getTotalStep</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.totalStep;&#125;<span class="hljs-comment">/** * 获取游戏关卡 wide interface *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-03 17:30 * <span class="hljs-doctag">@author</span> Windus */</span>String[] getGamePoint() &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.gamePoint;&#125;<span class="hljs-comment">/** * 获取当前步数 narrow interface *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-03 17:31 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCurrentStep</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.currentStep;&#125;&#125;<span class="hljs-comment">/** * 掷骰子游戏(发起人角色) *  * <span class="hljs-doctag">@date</span> 2021-08-03 15:46 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RollDice</span> </span>&#123;<span class="hljs-comment">/** * 游戏总步数 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> totalStep;<span class="hljs-comment">/** * 当前步数 */</span><span class="hljs-meta">@Getter</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> currentStep;<span class="hljs-comment">/** * 游戏关卡 */</span><span class="hljs-keyword">private</span> String[] gamePoint;<span class="hljs-comment">/** * 关卡符号&lt;br/&gt; * + 前进步数 - 后退步数 * 直接到终点 / 回退到起点 */</span><span class="hljs-keyword">private</span> String[] pointSymbols = &#123; <span class="hljs-string">"+1"</span>, <span class="hljs-string">"-2"</span>, <span class="hljs-string">"*"</span>, <span class="hljs-string">"+0"</span>, <span class="hljs-string">"/"</span>, <span class="hljs-string">"+2"</span> &#125;;<span class="hljs-keyword">private</span> Random random = <span class="hljs-keyword">new</span> Random();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RollDice</span><span class="hljs-params">(<span class="hljs-keyword">int</span> point)</span> </span>&#123;<span class="hljs-comment">// 初始化关卡</span><span class="hljs-keyword">this</span>.totalStep = point;gamePoint = <span class="hljs-keyword">new</span> String[totalStep];System.out.println(<span class="hljs-string">"\n---------------生成游戏地图------------------"</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; point; i++) &#123;<span class="hljs-keyword">int</span> index = random.nextInt(<span class="hljs-number">6</span>);gamePoint[i] = pointSymbols[index];System.out.print(<span class="hljs-string">"["</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">"]"</span> + pointSymbols[index] + <span class="hljs-string">"\t"</span>);&#125;System.out.println(<span class="hljs-string">"\n---------------生成游戏地图------------------"</span>);&#125;<span class="hljs-comment">/** * 掷骰子 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-03 15:58 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">roll</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> dice = random.nextInt(<span class="hljs-number">6</span>) + <span class="hljs-number">1</span>;currentStep += dice;System.out.print(<span class="hljs-string">"骰子点数["</span> + dice + <span class="hljs-string">"]\t"</span>);<span class="hljs-keyword">if</span> (currentStep &lt; totalStep) &#123;String pointSymbol = gamePoint[currentStep - <span class="hljs-number">1</span>];<span class="hljs-keyword">switch</span> (pointSymbol.charAt(<span class="hljs-number">0</span>)) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:currentStep += Integer.parseInt(pointSymbol.substring(<span class="hljs-number">1</span>));System.out.print(<span class="hljs-string">"前进["</span> + pointSymbol.charAt(<span class="hljs-number">1</span>) + <span class="hljs-string">"]步"</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:currentStep -= Integer.parseInt(pointSymbol.substring(<span class="hljs-number">1</span>));System.out.print(<span class="hljs-string">"后退["</span> + pointSymbol.charAt(<span class="hljs-number">1</span>) + <span class="hljs-string">"]步"</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:currentStep = totalStep;System.out.print(<span class="hljs-string">"搭上顺风车，到达终点^_^"</span>);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:currentStep = <span class="hljs-number">0</span>;System.out.print(<span class="hljs-string">"遇到情况，回到起点-_-!"</span>);<span class="hljs-keyword">break</span>;&#125;&#125;correctionStep();System.out.println(<span class="hljs-string">"，当前步数["</span> + currentStep + <span class="hljs-string">"]"</span>);<span class="hljs-keyword">if</span> (currentStep &gt;= totalStep) &#123;System.out.println(<span class="hljs-string">"游戏结束！"</span>);&#125;&#125;<span class="hljs-comment">/** * 创建备忘录 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-03 17:34 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">createMemento</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Memento(totalStep, currentStep, gamePoint);&#125;<span class="hljs-comment">/** * 恢复备忘录 *  * <span class="hljs-doctag">@param</span> memento 恢复对象 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-03 17:35 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">restoreMemento</span><span class="hljs-params">(Memento memento)</span> </span>&#123;<span class="hljs-keyword">this</span>.currentStep = memento.getCurrentStep();<span class="hljs-keyword">this</span>.totalStep = memento.getTotalStep();<span class="hljs-keyword">this</span>.gamePoint = memento.getGamePoint();&#125;<span class="hljs-comment">/** * 校正当前步数 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-03 17:10 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">correctionStep</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentStep &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">this</span>.currentStep = <span class="hljs-number">0</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentStep &gt; <span class="hljs-keyword">this</span>.totalStep) &#123;<span class="hljs-keyword">this</span>.currentStep = totalStep;&#125;&#125;&#125;<span class="hljs-comment">/** * 管理者角色 *  * <span class="hljs-doctag">@date</span> 2021-08-03 15:46 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">int</span> totalStep = <span class="hljs-number">10</span>;RollDice rollDice = <span class="hljs-keyword">new</span> RollDice(totalStep);<span class="hljs-comment">// 创建备忘录</span>Memento memento = rollDice.createMemento();<span class="hljs-keyword">int</span> loopIndex = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> (rollDice.getCurrentStep() &lt; totalStep) &#123;loopIndex++;rollDice.roll();<span class="hljs-keyword">if</span> (rollDice.getCurrentStep() &gt;= totalStep &amp;&amp; loopIndex &lt; <span class="hljs-number">3</span>) &#123;System.out.println(<span class="hljs-string">"\n\n太简单了，再来一次......\n\n"</span>);<span class="hljs-comment">// 恢复备忘录</span>rollDice.restoreMemento(memento);&#125;&#125;&#125;&#125;</code></pre><h3 id="状态模式state"><a class="markdownIt-Anchor" href="#状态模式state"></a> 状态模式(State)</h3><p><code>定义</code>：用类对象表示状态，把复杂的“逻辑判断”提取到不同的状态对象中，用类表示状态，用方法来判断状态。</p><p><code>角色</code>：</p><ul><li><strong>状态（State）</strong> 定义根据不同状态进行不同处理的接口。</li><li><strong>具体状态（Concrete State)</strong> 实现 State 角色，表示各个具体的状态。</li><li><strong>上下文（Context）</strong> 定义了客户端调用 State 模式的接口，内部维护一个状态，负责具体状态的切换。</li></ul><p><code>优点</code>：</p><ul><li>结构清晰，将不同状态的行为分割开来，容易增加新状态，易扩展，满足“单一职责原则”。</li><li>状态交给上下文类管理，减少对象间的相互依赖。</li></ul><p><code>缺点</code>：</p><ul><li>类对象数量增多，增加系统复杂性。</li><li>增加新状态时，需要修改上下文类，违背“开闭原则”。</li></ul><p><code>示例</code>：公路电子测速</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/state.png" alt="状态模式" style="height:400px;"><span class="image-caption">状态模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 状态角色 *  * <span class="hljs-doctag">@date</span> 2021-08-04 10:30 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@Getter</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractState</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> speedLimit;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span> </span>&#123;<span class="hljs-keyword">this</span>.speedLimit = speed;&#125;<span class="hljs-comment">/** * 低速 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-04 10:32 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lowSpeed</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** * 超速 10％ *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-04 10:32 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfTen</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** * 超速 20％ *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-04 10:32 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfTwenty</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** * 超速 50％ *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-04 10:32 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfFifty</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">/** * 超速 70％ *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-04 10:32 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfSeventy</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * 乡村道路(具体状态角色) *  * <span class="hljs-doctag">@date</span> 2021-08-04 10:38 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountryRoad</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractState</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CountryRoad</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span> </span>&#123;<span class="hljs-keyword">super</span>(speed);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lowSpeed</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"低速行驶，予以警告！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfTen</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速10％以上，扣3分，罚款100！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfTwenty</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速20％以上，扣3分，罚款150！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfFifty</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速50％以上，扣12分，罚款500！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfSeventy</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速70％以上，扣12分，罚款1000！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"CountryRoad 限速：["</span> + speedLimit + <span class="hljs-string">"]"</span>;&#125;&#125;<span class="hljs-comment">/** * 城市道路(具体状态角色) *  * <span class="hljs-doctag">@date</span> 2021-08-04 10:53 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CityRoad</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractState</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CityRoad</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span> </span>&#123;<span class="hljs-keyword">super</span>(speed);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lowSpeed</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"低速行驶，扣3分，罚款100！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfTen</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速10％以上，扣3分，罚款150！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfTwenty</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速20％以上，扣3分，罚款200！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfFifty</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速50％以上，扣12分，罚款1000！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfSeventy</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速70％以上，扣12分，罚款1500！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"CityRoad 限速：["</span> + speedLimit + <span class="hljs-string">"]"</span>;&#125;&#125;<span class="hljs-comment">/** * 高速公路(具体状态角色) *  * <span class="hljs-doctag">@date</span> 2021-08-04 10:54 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Freeway</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractState</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Freeway</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span> </span>&#123;<span class="hljs-keyword">super</span>(speed);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lowSpeed</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"低速行驶，扣3分，罚款200！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfTen</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速10％以上，扣3分，罚款200！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfTwenty</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速10％以上，扣3分，罚款200！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfFifty</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速50％以上，扣12分，罚款1500！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">overPercentOfSeventy</span><span class="hljs-params">()</span> </span>&#123;System.out.println(<span class="hljs-string">"超速70％以上，扣12分，罚款2000！"</span>);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Freeway 限速：["</span> + speedLimit + <span class="hljs-string">"]"</span>;&#125;&#125;<span class="hljs-comment">/** * 电子眼上下文 *  * <span class="hljs-doctag">@date</span> 2021-08-04 13:42 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElectronicEyeContext</span> </span>&#123;<span class="hljs-keyword">private</span> AbstractState state;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ElectronicEyeContext</span><span class="hljs-params">(AbstractState state)</span> </span>&#123;changeState(state);&#125;<span class="hljs-comment">/** * 改变状态 *  * <span class="hljs-doctag">@param</span> state 状态 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-04 14:00 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span><span class="hljs-params">(AbstractState state)</span> </span>&#123;System.out.println(<span class="hljs-string">"切换公路类型"</span> + state);<span class="hljs-keyword">this</span>.state = state;&#125;<span class="hljs-comment">/** * 监控 *  * <span class="hljs-doctag">@param</span> speed 车速 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-04 13:59 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> speed)</span> </span>&#123;<span class="hljs-keyword">int</span> overSpeed = speed - state.speedLimit;<span class="hljs-keyword">if</span> (state.getSpeedLimit() * <span class="hljs-number">0.7</span> &lt; overSpeed) &#123;state.overPercentOfSeventy();&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.getSpeedLimit() * <span class="hljs-number">0.5</span> &lt; overSpeed) &#123;state.overPercentOfFifty();&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.getSpeedLimit() * <span class="hljs-number">0.2</span> &lt; overSpeed) &#123;state.overPercentOfTwenty();&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state.getSpeedLimit() * <span class="hljs-number">0.1</span> &lt; overSpeed) &#123;state.overPercentOfTen();&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (speed &gt; <span class="hljs-number">10</span> &amp;&amp; speed &lt; <span class="hljs-number">30</span>) &#123;state.lowSpeed();&#125;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 道路状态</span>AbstractState countryRoad = <span class="hljs-keyword">new</span> CountryRoad(<span class="hljs-number">80</span>);AbstractState cityRoad = <span class="hljs-keyword">new</span> CityRoad(<span class="hljs-number">100</span>);AbstractState freeway = <span class="hljs-keyword">new</span> Freeway(<span class="hljs-number">120</span>);ElectronicEyeContext electronicEyeContext = <span class="hljs-keyword">new</span> ElectronicEyeContext(countryRoad);<span class="hljs-keyword">int</span> speed = <span class="hljs-number">0</span>;<span class="hljs-keyword">while</span> ((speed += <span class="hljs-number">10</span>) &lt; <span class="hljs-number">204</span>) &#123;System.out.print(<span class="hljs-string">"当前车速：["</span> + speed + <span class="hljs-string">"]\t"</span>);electronicEyeContext.monitor(speed);System.out.println(<span class="hljs-string">""</span>);<span class="hljs-keyword">if</span> (speed == <span class="hljs-number">170</span>) &#123;electronicEyeContext.changeState(freeway);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (speed == <span class="hljs-number">140</span>) &#123;electronicEyeContext.changeState(cityRoad);&#125;&#125;&#125;&#125;</code></pre><h3 id="享元模式flyweight"><a class="markdownIt-Anchor" href="#享元模式flyweight"></a> 享元模式(Flyweight)</h3><p><code>定义</code>：Flyweight是拳击比赛中选手体重最轻的等级，用在这里表示特别小的对象，所以享元模式也就可以理解为共享元对象，即尽量共享实例减少对象占用的内存空间。</p><p><code>角色</code>：</p><ul><li><strong>享元角色（Flyweight）</strong> 抽象对象，定义享元规范的公共接口。</li><li><strong>具体享元角色（Concrete Flyweight）</strong> 可共享对象，实现 Flyweight 角色中定义的接口。</li><li><strong>非享元角色（Unsharable Concrete Flyweight）</strong> 非共享对象。</li><li><strong>享元工厂（Flyweight Factory）</strong> 负责创建和管理享元对象。</li></ul><p><code>状态</code></p><ul><li>内部状态，指对象共享出来的信息，存储在享元对象内部并且不会随环境的改变而改变，其他对象只能读取但不能修改其数值。 （<em>比如，连接池中的连接对象，保存在连接对象中的用户名、密码、连接url等信息，在创建对象的时候就设置好了，不会随环境的改变而改变，这些是内部状态</em>）。</li><li>外部状态，指对象得以依赖得一个标志，是随环境改变而改变的、不可共享的状态。</li></ul><blockquote><p>享元模式建议不在对象中存储外在状态， 而是将其传递给依赖于它的一个特殊方法。 程序只在对象中保存内在状态， 以方便在不同情景下重用。 这些对象的区别仅在于其内在状态 （与外在状态相比， 内在状态的变体要少很多）， 因此所需的对象数量会大大削减。</p></blockquote><p><code>优点</code>：</p><ul><li>减少对象创建，降低内存，提高效率。</li></ul><p><code>缺点</code>：</p><ul><li>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</li></ul><p><code>示例</code>：下围棋</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/flyweight.png" alt="享元模式" style="height:400px;"><span class="image-caption">享元模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 棋子（享元角色） * <span class="hljs-doctag">@date</span> 2021-08-09 16:52 * <span class="hljs-doctag">@author</span> Windus *  * 控制台打印颜色#格式：　　设置颜色开始 ：\033[显示方式;前景色;背景色m#说明：前景色            背景色           颜色---------------------------------------30                40              黑色31                41              红色32                42              绿色33                43              黃色34                44              蓝色35                45              紫红色36                46              青蓝色37                47              白色显示方式           意义-------------------------0                终端默认设置1                高亮显示4                使用下划线5                闪烁7                反白显示8                不可见-----------------------------#例子：\033[1;31;40m    &lt;!--1-高亮显示 31-前景色红色  40-背景色黑色--&gt;\033[0m          &lt;!--采用终端默认设置，即取消颜色设置--&gt; */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Piece</span> </span>&#123;<span class="hljs-comment">/** * 下子 *  * <span class="hljs-doctag">@param</span> point 位置 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-09 16:52 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">downPieces</span><span class="hljs-params">(Point point)</span></span>;&#125;<span class="hljs-comment">/** * 白子（具体享元角色） *  * <span class="hljs-doctag">@date</span> 2021-08-09 16:53 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhitePiece</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Piece</span> </span>&#123;<span class="hljs-comment">/** * 颜色 */</span><span class="hljs-keyword">private</span> String color;<span class="hljs-comment">/** * 半径 */</span><span class="hljs-keyword">private</span> Integer radius;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WhitePiece</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>.color = <span class="hljs-string">"\033[0;37;43m"</span>;<span class="hljs-keyword">this</span>.radius = <span class="hljs-number">30</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downPieces</span><span class="hljs-params">(Point point)</span> </span>&#123;System.out.println(<span class="hljs-keyword">this</span>.color + <span class="hljs-string">"白方落子，大小:["</span> + <span class="hljs-keyword">this</span>.radius + <span class="hljs-string">"]，位置：["</span> + point + <span class="hljs-string">"]\033[0m"</span>);&#125;&#125;<span class="hljs-comment">/** * 黑子（具体享元角色） *  * <span class="hljs-doctag">@date</span> 2021-08-09 17:12 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlackPiece</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Piece</span> </span>&#123;<span class="hljs-comment">/** * 颜色 */</span><span class="hljs-keyword">private</span> String color;<span class="hljs-comment">/** * 半径 */</span><span class="hljs-keyword">private</span> Integer radius;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BlackPiece</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>.color = <span class="hljs-string">"\033[0;30;43m"</span>;<span class="hljs-keyword">this</span>.radius = <span class="hljs-number">30</span>;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">downPieces</span><span class="hljs-params">(Point point)</span> </span>&#123;System.out.println(<span class="hljs-keyword">this</span>.color + <span class="hljs-string">"落子，大小:["</span> + <span class="hljs-keyword">this</span>.radius + <span class="hljs-string">"]，位置：["</span> + point + <span class="hljs-string">"]\033[0m"</span>);&#125;&#125;<span class="hljs-comment">/** * 围棋工厂类（享元工厂角色） *  * <span class="hljs-doctag">@date</span> 2021-08-09 17:39 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeiqiFactory</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> WeiqiFactory weiqiFactory = <span class="hljs-keyword">new</span> WeiqiFactory();<span class="hljs-comment">/** * 享元对象 map */</span><span class="hljs-keyword">private</span> Map&lt;String, Piece&gt; pieceMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">WeiqiFactory</span><span class="hljs-params">()</span> </span>&#123;&#125;<span class="hljs-comment">/** * 获取工厂实例（单例模式） *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-09 17:41 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WeiqiFactory <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> weiqiFactory;&#125;<span class="hljs-comment">/** * 获取棋子 *  * <span class="hljs-doctag">@param</span> key 享元对象存储key * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-09 17:42 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> Piece <span class="hljs-title">getPiece</span><span class="hljs-params">(String key)</span> </span>&#123;Piece piece = pieceMap.get(key);<span class="hljs-keyword">if</span> (piece == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-string">"w"</span>.equals(key)) &#123;piece = <span class="hljs-keyword">new</span> WhitePiece();&#125; <span class="hljs-keyword">else</span> &#123;piece = <span class="hljs-keyword">new</span> BlackPiece();&#125;pieceMap.put(key, piece);&#125;<span class="hljs-keyword">return</span> piece;&#125;&#125;<span class="hljs-comment">/** * 落子位置（非享元角色） *  * <span class="hljs-doctag">@date</span> 2021-08-09 17:15 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@ToString</span><span class="hljs-meta">@AllArgsConstructor</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<span class="hljs-comment">/** * 横坐标 */</span><span class="hljs-keyword">private</span> Integer x;<span class="hljs-comment">/** * 纵坐标 */</span><span class="hljs-keyword">private</span> Integer y;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;WeiqiFactory weiqiFactory = WeiqiFactory.getInstance();Random random = <span class="hljs-keyword">new</span> Random();<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<span class="hljs-comment">// 白子先行</span>Point wPoint = <span class="hljs-keyword">new</span> Point(random.nextInt(), random.nextInt());Piece white = weiqiFactory.getPiece(<span class="hljs-string">"w"</span>);white.downPieces(wPoint);<span class="hljs-comment">// 围棋落子</span>Point bPoint = <span class="hljs-keyword">new</span> Point(random.nextInt(), random.nextInt());Piece black =  weiqiFactory.getPiece(<span class="hljs-string">"b"</span>);black.downPieces(bPoint);&#125;&#125;&#125;</code></pre><h3 id="命令模式command"><a class="markdownIt-Anchor" href="#命令模式command"></a> 命令模式(Command)</h3><p><code>定义</code>：将一个请求封装为一个对象，该转换可以根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p><p><code>角色</code>：</p><ul><li><strong>命令（Command)</strong> 定义命令接口，拥有执行命令方法<em>excute()</em>。</li><li><strong>具体命令（Concrete Command）</strong> 实现 Command 接口。拥有 Receiver 对象，调用其方法完成命令要执行的操作。</li><li><strong>接收者（Receiver)</strong> 执行命令时的对象，也可以称为命令接收者。</li><li><strong>调用者（Invoker)</strong> 请求的发送者，负责对请求进行初始化，触发命令， 而不向接收者直接发送请求。</li><li><strong>请求者（Client)</strong> 具体命令的创建者，并分配接收者。</li></ul><p><code>优点</code>：</p><ul><li>通过引入中间件（抽象接口）降低系统的耦合度。</li><li>增加与删除命令不会影响其他类，且满足“开闭原则”。</li><li>方便实现 Undo 和 Redo 操作。可以与<strong>备忘录模式</strong>结合，实现命令的撤销与恢复。</li><li>可以在现有命令的基础上，增加额外功能。比如日志记录，结合<strong>装饰器模式</strong>会更加灵活。</li></ul><p><code>缺点</code>：</p><ul><li>每一个具体操作都需要设计一个具体命令类，产生大量类，增加系统复杂性。</li></ul><p><code>示例</code>：模拟 git 提交文件命令，用户可以看作是请求者，bash环境可以看作是调用者，操作系统可以看作是接收者，git的add、commit、reset看作是具体命令角色。</p><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/command.png" alt="享元模式" style="height:400px;"><span class="image-caption">享元模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 命令角色 *  * <span class="hljs-doctag">@date</span> 2021-08-16 10:36 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractCommand</span> </span>&#123;<span class="hljs-comment">/** * 接收者 */</span><span class="hljs-keyword">protected</span> OperatingSystem operatingSystem;<span class="hljs-comment">/** * 命令参数 */</span><span class="hljs-keyword">protected</span> String param;<span class="hljs-comment">/** * 命令执行结果描述 */</span><span class="hljs-meta">@Getter</span><span class="hljs-keyword">protected</span> String result;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractCommand</span><span class="hljs-params">(OperatingSystem operatingSystem)</span> </span>&#123;<span class="hljs-keyword">this</span>.operatingSystem = operatingSystem;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractCommand</span><span class="hljs-params">(OperatingSystem operatingSystem, String param)</span> </span>&#123;<span class="hljs-keyword">this</span>.operatingSystem = operatingSystem;<span class="hljs-keyword">this</span>.param = param;&#125;<span class="hljs-comment">/** * 执行命令 *  * <span class="hljs-doctag">@param</span> param 参数 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-16 14:12 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">excute</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-comment">/** * Git add 命令 &lt;br/&gt; * 具体命令角色 *  * <span class="hljs-doctag">@date</span> 2021-08-16 10:39 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GitAddCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCommand</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GitAddCommand</span><span class="hljs-params">(OperatingSystem operatingSystem)</span> </span>&#123;<span class="hljs-keyword">super</span>(operatingSystem);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GitAddCommand</span><span class="hljs-params">(OperatingSystem operatingSystem, String param)</span> </span>&#123;<span class="hljs-keyword">super</span>(operatingSystem, param);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">excute</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>.result = <span class="hljs-string">"文件["</span> + <span class="hljs-keyword">this</span>.param + <span class="hljs-string">"]已被添加到暂存区！"</span>;operatingSystem.action(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;<span class="hljs-comment">/** * Git commit 命令 &lt;br/&gt; * 具体命令角色 *  * <span class="hljs-doctag">@date</span> 2021-08-16 10:39 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GitCommitCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCommand</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GitCommitCommand</span><span class="hljs-params">(OperatingSystem operatingSystem)</span> </span>&#123;<span class="hljs-keyword">super</span>(operatingSystem);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GitCommitCommand</span><span class="hljs-params">(OperatingSystem operatingSystem, String param)</span> </span>&#123;<span class="hljs-keyword">super</span>(operatingSystem, param);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">excute</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>.result = <span class="hljs-string">"暂存区已被提交到版本库！"</span>;operatingSystem.action(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">return</span> UUID.randomUUID().toString().replace(<span class="hljs-string">"-"</span>, <span class="hljs-string">""</span>);&#125;&#125;<span class="hljs-comment">/** * Git reset 命令 &lt;br/&gt; * 具体命令角色 *  * <span class="hljs-doctag">@date</span> 2021-08-16 10:39 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GitResetCommand</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCommand</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GitResetCommand</span><span class="hljs-params">(OperatingSystem operatingSystem)</span> </span>&#123;<span class="hljs-keyword">super</span>(operatingSystem);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GitResetCommand</span><span class="hljs-params">(OperatingSystem operatingSystem, String param)</span> </span>&#123;<span class="hljs-keyword">super</span>(operatingSystem, param);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">excute</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>.result = <span class="hljs-string">"版本库已被回退到["</span> + <span class="hljs-keyword">this</span>.param + <span class="hljs-string">"]提交！"</span>;operatingSystem.action(<span class="hljs-keyword">this</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;<span class="hljs-comment">/** * 操作系统 &lt;br/&gt; * 命令接收者 *  * <span class="hljs-doctag">@date</span> 2021-08-16 11:06 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OperatingSystem</span> </span>&#123;<span class="hljs-comment">/** * 执行命令 *  * <span class="hljs-doctag">@param</span> command 命令对象 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-16 11:10 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">(AbstractCommand command)</span></span>;&#125;<span class="hljs-comment">/** * Linux 系统 &lt;br&gt; * 具体接收者 *  * <span class="hljs-doctag">@date</span> 2021-08-16 11:49 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Linux</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OperatingSystem</span> </span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">(AbstractCommand command)</span> </span>&#123;System.out.println(<span class="hljs-string">"Linux系统执行命令---&gt;"</span> + command.getResult());&#125;&#125;<span class="hljs-comment">/** * 调用者 *  * <span class="hljs-doctag">@date</span> 2021-08-16 11:59 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractShell</span> </span>&#123;<span class="hljs-comment">/** * 命令执行历史 */</span><span class="hljs-keyword">private</span> MacroCommand history;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AbstractShell</span><span class="hljs-params">(MacroCommand history)</span> </span>&#123;<span class="hljs-keyword">this</span>.history = history;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">(AbstractCommand command)</span> </span>&#123;history.append(command);<span class="hljs-keyword">return</span> command.excute();&#125;&#125;<span class="hljs-comment">/** * bash Shell &lt;br/&gt; * 具体调用者 *  * <span class="hljs-doctag">@date</span> 2021-08-16 14:02 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bash</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractShell</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bash</span><span class="hljs-params">(MacroCommand history)</span> </span>&#123;<span class="hljs-keyword">super</span>(history);&#125;&#125;<span class="hljs-comment">/** * 请求者 *  * <span class="hljs-doctag">@date</span> 2021-08-16 14:27 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 接收者</span>OperatingSystem linuxOS = <span class="hljs-keyword">new</span> Linux();<span class="hljs-comment">// 命令历史对象</span>MacroCommand history = <span class="hljs-keyword">new</span> MacroCommand(linuxOS);<span class="hljs-comment">// 调用者</span>AbstractShell bash = <span class="hljs-keyword">new</span> Bash(history);<span class="hljs-comment">// 添加文件到暂存区</span>AbstractCommand gitAddCommand = <span class="hljs-keyword">new</span> GitAddCommand(linuxOS, <span class="hljs-string">"test.java"</span>);bash.call(gitAddCommand);System.out.println(<span class="hljs-string">"------------------------------------"</span>);<span class="hljs-comment">// 提交暂存区</span>AbstractCommand gitCommitCommand = <span class="hljs-keyword">new</span> GitCommitCommand(linuxOS);String commitId = bash.call(gitCommitCommand);System.out.println(commitId);System.out.println(<span class="hljs-string">"------------------------------------"</span>);<span class="hljs-comment">// 回退版本</span>AbstractCommand gitResetCommand = <span class="hljs-keyword">new</span> GitResetCommand(linuxOS, commitId);bash.call(gitResetCommand);System.out.println(<span class="hljs-string">"------------------------------------"</span>);<span class="hljs-comment">// undo</span>AbstractCommand undoCommand = history.undo();<span class="hljs-keyword">if</span> (undoCommand != <span class="hljs-keyword">null</span>) &#123;System.out.println(<span class="hljs-string">"撤销命令"</span>);System.out.println(undoCommand.getResult());&#125;&#125;&#125;</code></pre><h3 id="解释器模式interpreter"><a class="markdownIt-Anchor" href="#解释器模式interpreter"></a> 解释器模式(Interpreter)</h3><p><code>定义</code>：为分析对象定义一个语言，并定义该语言的***文法***（语法规则）表示，再设计一个解释器来解析语言中的***句子***（语言集中的元素）。</p><p><code>角色</code>：</p><ul><li><strong>抽象表达式（Abstract Expression）</strong> 定义解释器的接口，主要包含 interpret() 方法。</li><li><strong>终结符表达式（Terminal Expression）</strong> 实现 Abstract Expression 角色，对应 BNF 中的***终结符表达式***。</li><li><strong>非终结符表达式（Nonterminal Expression）</strong> 实现 Abstract Expression 角色，对应 BNF 中的***非终结符表达式***。</li><li><strong>上下文（Context)</strong> 为解释器进行语法解释提供必要的信息，一般用来传递共享数据，以便后面解释器从这里获得信息。</li><li><strong>客户端（Client)</strong> 将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法。</li></ul><p><code>优点</code>：</p><ul><li>易扩展，易实现</li></ul><p><code>缺点</code>：</p><ul><li>解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。</li><li>解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。</li></ul><p><code>示例</code>：定义前进、向左、向右、重复等指令解释器。</p><pre class="highlight"><code class="bnf"><span class="hljs-attribute">&lt;program&gt;</span> ::= program &lt;command list&gt;<span class="hljs-attribute">&lt;command list&gt;</span> ::= &lt;command&gt;* end<span class="hljs-attribute">&lt;command&gt;</span> ::= &lt;repeat command&gt; | &lt;primitive command&gt;<span class="hljs-attribute">&lt;repeat command&gt;</span> ::= repeat &lt;number&gt; &lt;command list&gt;<span class="hljs-attribute">&lt;primitive command&gt;</span> ::= go | right | left</code></pre><blockquote><p>上面表达式使用的是<code>EBNF</code>，因此循环使用<code>*</code>表示，程序按照自上而下顺序进行解析。</p><p>在定义的 <code>&lt;repeat command&gt;</code> 时又使用了<code>&lt;command list&gt;</code> 这种定义为递归定义。</p><ul><li><strong>终结符表达式</strong> 像<code>&lt;primitive command&gt;</code>这样不会被进一步展开的表达式，表示语法规则的终点。</li><li><strong>非终结符表达式</strong> 像<code>&lt;program&gt;</code>和<code>&lt;command&gt;</code>需要被进一步展开的表达式。</li></ul></blockquote><img src="/2013/09/01/tech_stack/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/interpreter.png" alt="解释器模式" style="height:400px;"><span class="image-caption">解释器模式</span><pre class="highlight"><code class="java"><span class="hljs-comment">/** * 抽象表达式角色 *  * <span class="hljs-doctag">@date</span> 2021-08-17 14:18 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Expression</span> </span>&#123;<span class="hljs-comment">/** * 语法解析 *  * <span class="hljs-doctag">@param</span> ctx 上下文 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@throws</span> ParseException * <span class="hljs-doctag">@date</span> 2021-08-17 11:58 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> <span class="hljs-keyword">throws</span> ParseException</span>;&#125;<span class="hljs-comment">/** * program 命令 &lt;br/&gt; * 非终结表达式角色 *  * <span class="hljs-doctag">@date</span> 2021-08-17 14:07 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Expression</span> </span>&#123;<span class="hljs-keyword">private</span> Expression commandList;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;ctx.skipToken(Context.PROGRAM_TOKEN);commandList = <span class="hljs-keyword">new</span> CommandList();commandList.interpret(ctx);&#125;&#125;<span class="hljs-comment">/** * &lt;command list&gt; 非终结符 &lt;br/&gt; * 非终结符表达式角色 *  * <span class="hljs-doctag">@date</span> 2021-08-17 14:19 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommandList</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Expression</span> </span>&#123;<span class="hljs-keyword">private</span> ArrayList&lt;Expression&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<span class="hljs-keyword">if</span> (ctx.getCurrentToken() == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseException(<span class="hljs-string">"丢失 end 标记！"</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ctx.getCurrentToken().equals(Context.END_TOKEN)) &#123;ctx.skipToken(Context.END_TOKEN);<span class="hljs-keyword">break</span>;&#125; <span class="hljs-keyword">else</span> &#123;Expression command = <span class="hljs-keyword">new</span> Command();command.interpret(ctx);list.add(command);&#125;&#125;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"CommandList [list="</span> + list.toString() + <span class="hljs-string">"]"</span>;&#125;&#125;<span class="hljs-comment">/** * &lt;command&gt; 非终结符 &lt;br/&gt; * 非终结符表达式角色 *  * <span class="hljs-doctag">@date</span> 2021-08-17 14:23 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Command</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Expression</span> </span>&#123;<span class="hljs-keyword">private</span> Expression expression;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<span class="hljs-keyword">if</span> (ctx.getCurrentToken().equals(Context.REPEAT_TOKEN)) &#123;expression = <span class="hljs-keyword">new</span> RepeatCommand();expression.interpret(ctx);&#125; <span class="hljs-keyword">else</span> &#123;expression = <span class="hljs-keyword">new</span> PrimitiveCommand();expression.interpret(ctx);&#125;&#125;&#125;<span class="hljs-comment">/** * &lt;repeat command&gt; 非终结符 &lt;br/&gt; * 非终结符表达式角色 *  * <span class="hljs-doctag">@date</span> 2021-08-17 14:56 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RepeatCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Expression</span> </span>&#123;<span class="hljs-comment">/** * 重复命令次数 */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number;<span class="hljs-keyword">private</span> Expression commandList;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;ctx.skipToken(Context.REPEAT_TOKEN);number = ctx.currentNumber();ctx.nextToken();commandList = <span class="hljs-keyword">new</span> CommandList();commandList.interpret(ctx);&#125;&#125;<span class="hljs-comment">/** * &lt;primitive command&gt; 终结符 &lt;br/&gt; * 终结符表达式角色 *  * <span class="hljs-doctag">@date</span> 2021-08-17 15:01 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-meta">@ToString</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimitiveCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Expression</span> </span>&#123;<span class="hljs-comment">/** * 结束符标记 */</span><span class="hljs-keyword">private</span> String primitiveToken;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;primitiveToken = ctx.getCurrentToken();ctx.skipToken(primitiveToken);<span class="hljs-keyword">if</span> (!primitiveToken.equals(Context.GO_TOKEN) &amp;&amp; !primitiveToken.equals(Context.RIGHT_TOKEN)&amp;&amp; !primitiveToken.equals(Context.LEFT_TOKEN)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseException(<span class="hljs-string">"primitiveToken["</span> + primitiveToken + <span class="hljs-string">"]无效！"</span>);&#125;&#125;&#125;<span class="hljs-comment">/** * 上下文角色 *  * <span class="hljs-doctag">@date</span> 2021-08-17 14:26 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<span class="hljs-comment">/** * 当前标记 */</span><span class="hljs-meta">@Getter</span><span class="hljs-keyword">private</span> String currentToken;<span class="hljs-comment">/** * 字符串分词对象 */</span><span class="hljs-keyword">private</span> StringTokenizer tokenizer;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String PROGRAM_TOKEN = <span class="hljs-string">"program"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String END_TOKEN = <span class="hljs-string">"end"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String REPEAT_TOKEN = <span class="hljs-string">"repeat"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GO_TOKEN = <span class="hljs-string">"go"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String RIGHT_TOKEN = <span class="hljs-string">"right"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LEFT_TOKEN = <span class="hljs-string">"left"</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(String text)</span> </span>&#123;tokenizer = <span class="hljs-keyword">new</span> StringTokenizer(text);nextToken();&#125;<span class="hljs-comment">/** * 跳过当前标记 *  * <span class="hljs-doctag">@param</span> toke 标记 * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-17 14:28 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">skipToken</span><span class="hljs-params">(String token)</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<span class="hljs-keyword">if</span> (!token.equals(currentToken)) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseException(<span class="hljs-string">"非法标记！"</span>);&#125;nextToken();&#125;<span class="hljs-comment">/** * 下一个标记 *  * <span class="hljs-doctag">@return</span> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">nextToken</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (tokenizer.hasMoreTokens()) &#123;currentToken = tokenizer.nextToken();&#125; <span class="hljs-keyword">else</span> &#123;currentToken = <span class="hljs-keyword">null</span>;&#125;<span class="hljs-keyword">return</span> currentToken;&#125;<span class="hljs-comment">/** * 当前标记数值 *  * <span class="hljs-doctag">@return</span> * <span class="hljs-doctag">@date</span> 2021-08-17 14:36 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">currentNumber</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ParseException </span>&#123;<span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<span class="hljs-keyword">try</span> &#123;number = Integer.parseInt(currentToken);&#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ParseException(<span class="hljs-string">"无效数值！"</span>);&#125;<span class="hljs-keyword">return</span> number;&#125;&#125;<span class="hljs-comment">/** * 自定义转换异常类 *  * <span class="hljs-doctag">@date</span> 2021-08-17 14:43 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParseException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ParseException</span><span class="hljs-params">(String message)</span> </span>&#123;<span class="hljs-keyword">super</span>(message);&#125;&#125;<span class="hljs-comment">/** * 客户端角色 *  * <span class="hljs-doctag">@date</span> 2021-08-17 15:13 * <span class="hljs-doctag">@author</span> Windus */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;System.out.print(<span class="hljs-string">"my-language &gt; "</span>);String inputText = scanner.nextLine();<span class="hljs-keyword">if</span> (!<span class="hljs-string">""</span>.equals(inputText)) &#123;<span class="hljs-keyword">if</span> (<span class="hljs-string">"exit"</span>.equals(inputText)) &#123;System.out.print(<span class="hljs-string">"bye~   "</span>);System.exit(<span class="hljs-number">0</span>);&#125;Expression program = <span class="hljs-keyword">new</span> Program();Context ctx = <span class="hljs-keyword">new</span> Context(inputText);<span class="hljs-keyword">try</span> &#123;program.interpret(ctx);System.out.println(program);&#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;e.printStackTrace();&#125;&#125;&#125;&#125;&#125;</code></pre><h2 id="gof设计模式分类"><a class="markdownIt-Anchor" href="#gof设计模式分类"></a> GoF设计模式分类</h2><h3 id="创建型设计模式"><a class="markdownIt-Anchor" href="#创建型设计模式"></a> 创建型设计模式</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">单例模式</td><td style="text-align:center">工厂方法模式</td><td style="text-align:center">抽象工厂模式</td></tr><tr><td style="text-align:center">建造者模式</td><td style="text-align:center">原型模式</td><td style="text-align:center"></td></tr></tbody></table><h3 id="结构型设计模式"><a class="markdownIt-Anchor" href="#结构型设计模式"></a> 结构型设计模式</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">适配器模式</td><td style="text-align:center">桥接模式</td><td style="text-align:center">组合模式</td></tr><tr><td style="text-align:center">装饰器模式</td><td style="text-align:center">外观模式</td><td style="text-align:center">享元模式</td></tr><tr><td style="text-align:center">代理模式</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="行为型设计模式"><a class="markdownIt-Anchor" href="#行为型设计模式"></a> 行为型设计模式</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">责任链模式</td><td style="text-align:center">迭代器模式</td><td style="text-align:center">观察者模式</td></tr><tr><td style="text-align:center">策略模式</td><td style="text-align:center">模板方法模式</td><td style="text-align:center">访问者模式</td></tr><tr><td style="text-align:center">状态模式</td><td style="text-align:center">备忘录模式</td><td style="text-align:center">中介者模式</td></tr><tr><td style="text-align:center">命令模式</td><td style="text-align:center">解释器模式</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> JAVA </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
