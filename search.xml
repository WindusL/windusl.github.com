<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux正则与文件格式化]]></title>
    <url>%2F2018%2F03%2F21%2FLinux%2FLinux%E6%AD%A3%E5%88%99%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%2F</url>
    <content type="text"><![CDATA[[TOC] 基础正则表达式基础正则字符包括:^ $ . \ * [] [n1-n2] [^] \{n,m\} 语系对正则表达式的影响由于不同语系的编码数据并不相同，所以就会造成数据撷取结果的差异。 123456789C和zh_TW.big5语系下,英文大小写的编码顺序:LANG=C 时：0 1 2 3 4 ... A B C D ... Z a b c d ...zLANG=zh_TW 时：0 1 2 3 4 ... a A b B c C d D ... z Z# C语系$ ll -d /etc/[^a-z]* # 正确显示# zh_TW.big5语系(测试zh_CN.UTF-8语系可以正确显示)$ ll -d /etc/[^a-z]* # 显示混乱 上面由于C语系字母是连续的所以正则表达式可以进行匹配,而zh_CN.UTF-8语系字母是非连续排列所以找不到该文件.由于一般正则表达式，使用的是相容于 POSIX 的标准，因此就使用“ C ”这个语系,所以通常使用正则将系统语系设置成C后使用. 12345678910# 搜寻特定字符串(-v表示反向)$ grep -n (-v) &apos;the&apos; regular_express.txt # 利用中括号[]搜寻集合字符$ grep -n &apos;t[ae]st&apos; regular_express.txt$ grep -n &apos;[^a-z]oo&apos; regular_express.txt$ grep -n &apos;[0-9]&apos; regular_express.txt#如上考虑到语系的影响可以使用特殊符号代替连续编码(&quot; - &quot;)$ grep -n &apos;[^[:lower:]]oo&apos; regular_express.txt$ grep -n &apos;[[:digit:]]&apos; regular_express.txt 为了要避免这样编码所造成的英文与数字的撷取问题,所以可以使用特殊符号代替 特殊符号 代表意义 [:alnum:] 代表英文大小写字符及数字，亦即 0-9, A-Z, a-z [:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z [:blank:] 代表空白键与 [Tab] 按键两者 [:cntrl:] 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等 [:digit:] 代表数字而已，亦即 0-9 [:graph:] 除了空白字符 （空白键与 [Tab] 按键） 外的其他所有按键 [:lower:] 代表小写字符，亦即 a-z [:print:] 代表任何可以被打印出来的字符 [:punct:] 代表标点符号 （punctuation symbol），亦即：” ‘ ? ! ; : # $… [:upper:] 代表大写字符，亦即 A-Z [:space:] 任何会产生空白的字符，包括空白键, [Tab], CR 等等 [:xdigit:] 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字符 sed 工具12345678910111213141516171819[dmtsai@study ~]$ sed [-nefr] [动作]选项与参数：-n ：使用安静（silent）模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到屏幕上。 但如果加上 -n 参数后，则只有经过 sed 特殊处理的那一行（或者动作）才会被列出来。-e ：直接在命令行界面上进行 sed 的动作编辑；-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以执行 filename 内的 sed 动作；-r ：sed 的动作支持的是延伸型正则表达式的语法。（默认是基础正则表达式语法）-i ：直接修改读取的文件内容，而不是由屏幕输出。动作说明： [n1[,n2]]functionn1, n2 ：不见得会存在，一般代表“选择进行动作的行数”，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则“ 10,20[动作行为] ”function 有下面这些：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现（目前的下一行）～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现（目前的上一行）；p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作！通常这个 s 的动作可以搭配正则表达式！ 以行为单位的功能 1234567891011121314# 将/etc/passwd 的内容列出并且打印行号，同时，请将第 2~5 行删除！$ nl /etc/passwd | sed &apos;2,5d&apos; 1 root:x:0:0:root:/root:/bin/bash 6 sync:x:5:0:sync:/sbin:/bin/sync 7 shutdown:x:6:0:shutdown:/sbin:/sbin/ shutdown .....（后面省略）..... # 承上，在第二行后（亦即是加在第三行）加上“drink tea?”字样！$ nl /etc/passwd | sed &apos;2a drink tea&apos; 1 root:x:0:0:root:/root:/bin/bash 2 bin:x:1:1:bin:/bin:/sbin/nologin drink tea 3 daemon:x:2:2:daemon:/sbin:/sbin/nologin .....（后面省略）..... 部分数据的搜索与取代功能 sed &#39;s/要被取代的字串(或正则)/新的字串/g 如果想用以行为单位取代 sed &#39;n1,n2s/要被取代的字串(或正则)/新的字串/g 直接修改文件内容（危险动作） -i 选项可以让 sed 直接去修改后面接的文件内容而不是由屏幕输出！ 123456#用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !$ sed -i &apos;s/\.$/\!/g&apos; regular_express.txt#利用 sed 直接在 regular_express.txt 最后一行加 入“# This is a test”$ sed -i &apos;$a # This is a test&apos; regular_express.txt# 由于 $ 代表的是最后一行，而 a 的动作是新增，因此该 文件最后新增！ 延伸正则表达式grep 默认仅支持基础正则表达式，如果要使用延伸型正则表达式，你可以使用 grep -E ， 不过更建议直接使用 egrep 12345#去除空白行与首先为#的行列(需要使用管线命令来搜寻两次)grep -v &apos;^$&apos; | grep -v &apos;^#&apos; regular_express.txt#使用延伸正则表达式(延伸型正则表达式可以通过群组功能“ | ”来进行一次搜寻！)egrep -v &apos;^$|^#&apos; regular_express.txt 延伸正则字符包括:+ ? | () ()+ 文件格式化处理格式化打印12345678910111213141516printf &apos;打印格式&apos; 实际内容选项与参数：关于格式方面的几个特殊样式： \a 警告声音输出 \b 倒退键（backspace） \f 清除屏幕 （form feed） \n 输出新的一行 \r 亦即 Enter 按键 \t 水平的 [tab] 按键 \v 垂直的 [tab] 按键 \xNN NN 为两位数的数字，可以转换数字成为字符。关于 C 程序语言内，常见的变量格式 %ns 那个 n 是数字， s 代表 string ，亦即多少个字符； %ni 那个 n 是数字， i 代表 integer ，亦即多少整数码数； %N.nf 那个 n 与 N 都是数字， f 代表 floating （浮点），如果有小数码数， 假设我共要十个位数，但小数点有两位，即为 %10.2f ！ awk工具]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的Bash]]></title>
    <url>%2F2018%2F03%2F06%2FLinux%2FLinux%E7%9A%84Bash%2F</url>
    <content type="text"><![CDATA[[TOC] Shell/etc/shells记录系统所有shell Bash shell 功能命令编修能力 默认指令记忆功能可以达到1000个记录位置~/.bash_history(当前指令用户指令在内存中,登出后才记录到文件此内) 命令与文件实例功能(tab补全) 命令别名设置功能 工作控制/前景背景控制 程序化脚本shell script 万用字符(*) type指令type 这个指令我们可以知道每个指令是否为 bash 的内置指令。 此外，type只能查找可执行文件. 123456789[dmtsai@study ~]$ type [-tpa] name选项与参数： ：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令-t ：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义： file ：表示为外部指令； alias ：表示该指令为命令别名所设置的名称； builtin ：表示该指令为 bash 内置的指令功能；-p ：如果后面接的 name 为外部指令时，才会显示完整文件名；-a ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias 快速编辑 反斜杠( \ )命令输入太长需要换行,利用反斜杠( \ )[Enter]开启下一行,而不执行命令.注意: [Enter] 按键是紧接着反斜线 （ \ ） 快捷键 组合键 功能与示范 [ctrl]+u/[ctrl]+k 分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k） [ctrl]+a/[ctrl]+e 分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e） Ctrl + C 终止目前命令 Ctrl + D 输入结束(EOF),例如:邮件结束的时候 Ctrl + M 就是Enter Ctrl + S 暂停屏幕输出 Ctrl + Q 恢复屏幕输出 Ctrl + U 在提示字符下，将整列命令删除 Ctrl + Z “暂停”目前的命令 配合fg/bg/jobs命令使用 变量echo 指令显示变量内容,”-e”选项可以格式化打印内容 1[dmtsai@study ~]$ echo $PATH 变量设置规则 变量与变量内容以一个”=”来连接. myname=Windus 等号两边不能直接接空白符. 123#错误myname= Windusmyname=Windus L 变量内容若有空白符可使用双引号或单引号将变量内容结合起来. 1234567#双引号内特殊字符可保持原本特性,如:&quot;$&quot;等var=&quot;lang is $LANG&quot;echo $var --&gt; lang is UTF8#单引号内的特殊字符仅为一般字符(纯文本)var=&apos;lang is $LANG&apos;echo $var --&gt; lang is $LANG 变量名称只能是英文字母与数字,但开头字符不能是数字. 可用跳脱字符” \ “,将特殊符号变成一般符号。(如： [Enter], $, \, 空白字符等） myname=Windus\ L 在一串指令的执行中，还需要借由其他额外的指令所提供的信息时，可以使用反单引号“指令”或 “$（指令） 12version=$（uname -r）echo $version --&gt; 3.10.0-229.el7.x86_64 若该变量为扩增变量内容时，则可用 “\$变量名称” 或 ${变量} 累加内容 123PATH=&quot;$PATH&quot;:/home/bin或PATH=$&#123;PATH&#125;:/home/bin 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量 export PATH 通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断 （纯粹依照使用者兴趣与嗜好,在 Linux 默认的情况中，使用{大写的字母}来设置的变量一般为系统内定需要的变量） 取消变量用unsetunset myname 环境变量 env命令 查看所有环境变量 HOME 使用者主文件夹变量, ~就会读取此变量 SHELL 目前环境使用的SHELL程序(Linux默认:/bin/bash) HISTSIZE 历史命令记录笔数 MAIL 当前用户邮箱文件 PATH 可执行文件搜寻的路径(目录与目录中间:分隔).由于搜寻顺序依据PATH变量内目录顺序,所以目录顺序也是重要的. LANG 语系数据 RANDOM 随机数变量(/dev/random),内容介于0~32767之间. 1234#想要获取指定范围内的数,使用delcare声名数值类型[dmtsai@study ~]$ declare -i number=$RANDOM*10/32768 ; echo $number8 &lt;== 此时会随机取出 0~9 之间的数值喔！ set命令 查看所有变量(含环境变量与自定变量) PS1 提示字符的设置 12345678910111213\d ：可显示出“星期 月 日”的日期格式，如：&quot;Mon Feb 2&quot;\H ：完整的主机名称。举例来说，鸟哥的练习机为“study.centos.vbird”\h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为“study”后面省略\t ：显示时间，为 24 小时格式的“HH:MM:SS”\T ：显示时间，为 12 小时格式的“HH:MM:SS”\A ：显示时间，为 24 小时格式的“HH:MM”\@ ：显示时间，为 12 小时格式的“am/pm”样式\u ：目前使用者的帐号名称，如“dmtsai”；\v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46（1）-release，仅取“4.2”显示\w ：完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以 ~ 取代；\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。\# ：下达的第几个指令。\$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ - \$ 本shell的PID `echo $$` - ? 上个指令的回传值 执行某些指令时， 这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令， 则会回传一个 0 值,如果执行过程发生错误,就会传回错误代码.一般以非0代码取代. export命令 当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是一个称为程序识别码，被称为 PID 的就是。 接下来你在这个 bash 下面所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了. 子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自订变量.所以你在原本 bash 的自订变量在进入了子程序后就会消失不见， 一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！此时,把自定变量变成环境变量就变得很有必要了:export 变量名称 如果export后面不加变量名称,就会将系统所有变量列出来,等同于set命令. 语系变量 查看Linux支持的语系 123456789[dmtsai@study ~]$ locale -a....（前面省略）....zh_TWzh_TW.big5 &lt;==大五码的中文编码zh_TW.euctwzh_TW.utf8 &lt;==万国码的中文编码zu_ZAzu_ZA.iso88591zu_ZA.utf8 修改Linux语系 12345678910locale &lt;==后面不加任何选项与参数即可！LANG=en_US &lt;==主语言的环境LC_CTYPE=&quot;en_US&quot; &lt;==字符（文字）辨识的编码LC_NUMERIC=&quot;en_US&quot; &lt;==数字系统的显示讯息LC_TIME=&quot;en_US&quot; &lt;==时间系统的显示数据LC_COLLATE=&quot;en_US&quot; &lt;==字串的比较与排序等LC_MONETARY=&quot;en_US&quot; &lt;==币值格式的显示等LC_MESSAGES=&quot;en_US&quot; &lt;==讯息显示的内容，如功能表、错误讯息等LC_ALL= &lt;==整体语系的环境....（后面省略）.... 可以逐一设置每个与语系有关的变量数据,可也以直接设置LANG或LC_ALL(其它语系变量会被这两个变量所取代). 系统默认语系文件是: **/etc/locale.conf** 变量范围环境变量可以被子程序引用的原理: 当启动一个shell,系统会分配一个记忆区给shell使用,使此内存内的变量,即环境变量可让子程序使用. 若父程序用export功能,将自定变量内容写到上述内存区块当中(环境变量). 当载入另一个shell时(亦启动一个子程序,离开原本父程序),子程序可以将父shell的环境变量所在记忆区导入自己的环境变量区块当中. 变量键盘读取/阵列与宣告 read命令 程序执行的过程当中，会等待使用者输入 “yes/no” 之类的讯息,和使用者对谈时使用此命令. 1234[dmtsai@study ~]$ read [-pt] variable选项与参数：-p ：后面可以接提示字符！-t ：后面可以接等待的“秒数！”这个比较有趣～不会一直等待使用者啦！ declare/typeset declare 或 typeset 是一样的功能，就是在“宣告变量的类型. 123456789101112131415[dmtsai@study ~]$ declare [-aixr] variable选项与参数：-a ：将后面名为 variable 的变量定义成为阵列 （array） 类型-i ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型-x ：用法与 export 一样，就是将后面的 variable 变成环境变量；-r ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset-p : 仅列出变量类型范例一：让变量 sum 进行 100+300+50 的加总结果[dmtsai@study ~]$ sum=100+300+50[dmtsai@study ~]$ echo $&#123;sum&#125;100+300+50 &lt;==咦！怎么没有帮我计算加总？因为这是文字体态的变量属性啊！[dmtsai@study ~]$ declare -i sum=100+300+50[dmtsai@study ~]$ echo $&#123;sum&#125;450 &lt;==瞭乎？？ 注意: bash环境下,变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。 所以上述第一个执行的结果才会出现那个情况的；bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0； 变量内容删除/取代/替换 暂时跳过 系统限制关系 ulimit123456789101112131415[dmtsai@study ~]$ ulimit [-SHacdfltu] [配额]选项与参数：-H ：hard limit ，严格的设置，必定不能超过这个设置的数值；-S ：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。 在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 80 而 hard 设置为 100，那么你可以使用到 90 （因为没有超过 100），但介于 80~100 之间时， 系统会有警告讯息通知你！-a ：后面不接任何选项与参数，可列出所有的限制额度；-c ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用）， 这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量。-f ：此 shell 可以创建的最大文件大小（一般可能设置为 2GB）单位为 KBytes-d ：程序可使用的最大断裂内存（segment）容量；-l ：可用于锁定 （lock） 的内存量-t ：可使用的最大 CPU 时间 （单位为秒）-u ：单一使用者可以使用的最大程序（process）数量。 命令别名与历史命令别名设置 alias / unalias1234#设置别名[dmtsai@study ~]$ alias lm=&apos;ls -al | more#取消别名[dmtsai@study ~]$ unalias lm 设置别名,在机器重启后将丢失,如果想永久存在,需要写在~/.bash_profile文件内 历史命令 history历史命令记录在~/.bash_history文件中,记录的数量由HISTFILESIZE环境变量决定. 12345678[dmtsai@study ~]$ history [-raw] histfiles选项与参数：n ：数字，意思是“要列出最近的 n 笔命令列表”的意思！-c ：将目前的 shell 中的所有 history 内容全部消除-a ：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ， 则默认写入 ~/.bash_history-r ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中；-w ：将目前的 history 记忆内容写入 histfiles 中！ 历史命令的使用: 12345[dmtsai@study ~]$ !选项与参数：number ：执行第几笔指令的意思；command ：由最近的指令向前搜寻“指令串开头为 command”的那个指令，并执行；!! ：就是执行上一个指令（相当于按↑按键后，按 Enter） 同一帐号同时多次登陆的history写入问题 因为这些 bash 在同时以同一个身份登陆， 因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到登出时才会更新记录文件，所以，最后登出的那个 bash 才会是最后写入的数据。如此一来其他 bash 的指令操作就不会被记录下来了 （其实有被记录，只是被后来的最后一个 bash 所覆盖更新了） 。 历史命令时间问题 历史命令还有一个问题，那就是无法记录指令下达的时间。由于这 1000 笔历史命令是依序记录的， 但是并没有记录时间，所以在查询方面会有一些不方便。其实可以通过~/.bash_logout 来进行 history 的记录，并加上 date 来增加时间参数. Bash Shell操作环境Bash 进站欢迎信息 /etc/issue /etc/motd12345678910issue 内的各代码意义: \d 本地端时间的日期； \l 显示第几个终端机接口； \m 显示硬件的等级 （i386/i486/i586/i686...）； \n 显示主机的网络名称； \O 显示 domain name； \r 操作系统的版本 （相当于 uname -r） \t 显示本地端时间的时间； \S 操作系统的名称； \v 操作系统的版本 当我们使用 telnet 连接到主机时，主机的登陆画面就会显示 /etc/issue.net 而不是 /etc/issue/etc/motd 里面显示的则是文字信息 bash环境配置文件login与non-login Shell login shell：取得 bash 时需要完整的登陆流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登陆，需要输入使用者的帐号与密码，此时取得的 bash 就称为“ login shell ” non-login shell：取得 bash 接口的方法不需要重复登陆的举动，举例来说，（1）你以 X window 登陆 Linux 后， 再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入帐号与密码，那个 bash 的环境就称为 non-login shell了。（2）你在原本的 bash 环境下再次下达 bash 这个指令，同样的也没有输入帐号密码， 那第二个 bash （子程序） 也是 non-login shell 。 这两个Shell，读取的配置文件数据并不一样. /etc/profile (login Shell读取)这个配置文件可以利用使用者的识别码 （UID） 来决定很多重要的变量数据， 也是每个使用者登陆取得 bash 时一定会读取的配置文件.所以设置全局环境就要改这个文件! 1234567主要变量:PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；MAIL：依据帐号设置好使用者的 mailbox 到 /var/spool/mail/帐号名；USER：根据使用者的帐号设置此一变量内容；HOSTNAME：依据主机的 hostname 指令决定此一变量内容；HISTSIZE：历史命令记录笔数。CentOS 7.x 设置为 1000 ；umask：包括 root 默认为 022 而一般用户为 002 等！ /etc/profile 还会调用外部的设置数据,主要有如下: /etc/profile.d/*.sh “这个目录内的众多文件！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使用者能够具有 r 的权限， 那么该文件就会被 /etc/profile 调用进来。在 CentOS 7.x 中，这个目录下面的文件规范了 bash 操作接口的颜色、 语系、ll 与 ls 指令的命令别名、vi 的命令别名、which 的命令别名等等。如果你需要帮所有使用者设置一些共享的命令别名时， 可以在这个目录下面自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可！ /etc/locale.conf 这个文件是由 /etc/profile.d/lang.sh 调用进来的！这也是我们决定 bash 默认使用何种语系的重要配置文件！ 文件里最重要的就是 LANG/LC_ALL 这些个变量的设置！ /usr/share/bash-completion/completions/* 这个目录下除前面谈过 [tab] 命令补齐、文件名补齐之外，还可以进行指令的选项/参数补齐功能！那就是从这个目录里面找到相对应的指令来处理的！ 其实这个目录下面的内容是由 /etc/profile.d/bash_completion.sh 这个文件载入的啦！ ~/.bash_profile (login Shell读取)bash 在读完了整体环境设置的 /etc/profile 并借此调用其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是： 1231. ~/.bash_profile2. ~/.bash_login3. ~/.profile 其实 bash 的 login shell 设置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 ~/.bash_profile 存在，那么其他两个文件不论有无存在，都不会被读取。 如果 ~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思。 会有这么多的文件，其实是因应其他 shell 转换过来的使用者的习惯而已。 source 读入环境配置文件指令由于 /etc/profile 与 ~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以， 如果你将自己的偏好设置写入上述的文件后，通常都是得登出再登陆后，该设置才会生效。利用这个指令可以直接生效! 12345[dmtsai@study ~]$ source 配置文件文件名范例：将主文件夹的 ~/.bashrc 的设置读入目前的 bash 环境中[dmtsai@study ~]$ source ~/.bashrc &lt;==下面这两个指令是一样的！[dmtsai@study ~]$ . ~/.bashrc ~/.bashrc （non-login shell 读取）CentOS 7.x 还会主动的调用 /etc/bashrc 这个文件1234/etc/bashrc文件记录内容1. 依据不同的 UID 规范出 umask 的值；2. 依据不同的 UID 规范出提示字符 （就是 PS1 变量）；3. 调用 /etc/profile.d/*.sh 的设置 /etc/bashrc文件是Red Hat系统特有的,如果此文件丢失,可以复制 /etc/skel/.bashrc 到你的主文件夹. 终端机环境设置 stty , setstty命令查阅目前的一些按键内容 123456789101112131415161718192021222324[dmtsai@study ~]$ stty [-a]选项与参数：-a ：将目前所有的 stty 参数列出来；#列出所有的按键与按键内容[dmtsai@study ~]$ stty -aspeed 38400 baud; rows 20; columns 90; line = 0;intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;flush = ^O; min = 1; time = 0;....（以下省略）....#设置按键[dmtsai@study ~]$ stty erase ^h意义:intr : 送出一个 interrupt （中断） 的讯号给目前正在 执行的程序 （就是终止啰！）；quit : 送出一个 quit 的讯号给目前正在执行的程序；erase : 向后删除字符，kill : 删除在目前命令行上的所有文字；eof : End of file 的意思，代表“结束输入”。start : 在某个程序停止后，重新启动他的 outputstop : 停止目前屏幕的输出；susp : 送出一个 terminal stop 的讯号给正在 run 的程序。 set命令 暂无 万用字符与特殊符号万用字符: 1234567* 代表“ 0 个到无穷多个”任意字符? 代表“一定有一个”任意字符[] 同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”[-] 若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！[^] 若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。 特殊字符: 12345678910111213141516# 注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行\ 跳脱符号：将“特殊字符或万用字符”还原成一般字符| 管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；; 连续指令下达分隔符号：连续性命令的界定 （注意:与管线命令并不相同）~ 使用者的主文件夹$ 取用变量前置字符：亦即是变量之前需要加的变量取代值&amp; 工作控制 （job control）：将指令变成背景下工作! 逻辑运算意义上的“非” not 的意思！/ 目录符号：路径分隔的符号&gt;, &gt;&gt; 数据流重导向：输出导向，分别是“取代”与“累加”&lt;, &lt;&lt; 数据流重导向：输入导向 &apos;&apos; 单引号，不具有变量置换的功能 （$ 变为纯文本）&quot;&quot; 具有变量置换的功能！ （$ 可保留相关功能）`` 两个“ ` ”中间为可以先执行的指令，亦可使用 $（ ）() 在中间为子 shell 的起始与结束&#123;&#125; 在中间为命令区块的组合！ 数据流重导向数据流输入/输出标准输出:指的是“指令执行所回传的正确的讯息”标准错误输出:“ 指令执行失败后，所回传的错误讯息” 标准输入 （stdin） ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；标准输出 （stdout）：代码为 1 ，使用 &gt; 或 &gt;&gt; ；标准错误输出（stderr）：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ； /dev/null 垃圾桶黑洞设备与特殊写法/dev/null 可以吃掉任何导向这个设备的信息 2&gt;&amp; | &amp;&gt;123#将指令的数据全部写入名为 list 的文件中(包括错误信息)[dmtsai@study ~]$ find /home -name .bashrc &gt; list 2&gt;&amp;1 [dmtsai@study ~]$ find /home -name .bashrc &amp;&gt; list 标准输入123456789101112131415161718192021222324252627#利用 cat 指令来创建一个文件的简单流程[dmtsai@study ~]$ cat &gt; catfiletestingcat file test&lt;==这里按下 [ctrl]+d 来离开[dmtsai@study ~]$ cat catfiletestingcat file test#用 stdin 取代键盘的输入以创建新文件的简单流程[dmtsai@study ~]$ cat &gt; catfile &lt; ~/.bashrc[dmtsai@study ~]$ ll catfile ~/.bashrc# 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！-rw-r--r--. 1 dmtsai dmtsai 231 Mar 6 06:06 /home/dmtsai/.bashrc-rw-rw-r--. 1 dmtsai dmtsai 231 Jul 9 18:58 catfile#用 cat 直接将输入的讯息输出到 catfile 中， 且当由键盘输入 eof 时，该次输入就结束[dmtsai@study ~]$ cat &gt; catfile &lt;&lt; &quot;eof&quot;&gt; This is a test.&gt; OK now stop&gt; eof &lt;==输入这关键字，立刻就结束而不需要输入 [ctrl]+d[dmtsai@study ~]$ cat catfileThis is a test.OK now stop &lt;==只有这两行，不会存在关键字那一行！ 命令执行的判断依据 ; &amp;&amp; ||不考虑指令相关性的连续指令下达 cmd;cmd1[root@study ~]# sync; sync; shutdown -h now $? （指令回传值） 与 &amp;&amp; 或 ||若前一个指令执行的结果为正确，在 Linux 下面会回传一个 $? = 0 的值 指令 说明 cmd1 &amp;&amp; cmd2 1. 若 cmd1 执行完毕且正确执行（$?=0），则开始执行 cmd2。 2. 若 cmd1 执行完毕且为错误 （$?≠0），则 cmd2 不执行。 cmd1 || cmd2 1. 若 cmd1 执行完毕且正确执行（$?=0），则 cmd2 不执行。 2. 若 cmd1 执行完毕且为错误 （$?≠0），则开始执行 cmd2。 1[dmtsai@study ~]$ ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe Linux 下面的指令都是由左往右执行,上面执行结果:情况一:（1）若 /tmp/abc 不存在故回传 $?≠0，则（2）因为 || 遇到非为 0 的 \$? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc 会成功进行，所以回传 \$?=0（3）因为 &amp;&amp; 遇到 \$?=0 故会执行 touch /tmp/abc/hehe，最终 hehe 就被创建了； 情况二:（1）若 /tmp/abc 存在故回传 $?=0，则（2）因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故（3）因为 &amp;&amp; 遇到 \$?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。 1234ls /tmp/vbirding || echo &quot;not exist&quot; &amp;&amp; echo &quot;exist”#返回结果:not existexist 由于指令是一个接着一个去执行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错(如上面例子).一般来说，假设判断式有三个，也就是：command1 &amp;&amp; command2 || command3 管线命令(pipe)管线命令使用的是“ | ”这个界定符号！ 另外，管线命令与“连续下达命令”是不一样！管线命令“ | ”仅能处理经由前面一个指令传来的正确信息，也就是 standard output 的信息，对于 stdandard error 并没有直接处理的能力.每个管线后面接的第一个数据必定是“指令”喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以是为“管线命令” 撷取命令 cut grepcut将一段讯息的某一段给他“切”出来～ 处理的讯息是以“行”为单位 1234567891011121314151617181920212223242526[dmtsai@study ~]$ cut -d&apos;分隔字符&apos; -f fields &lt;==用于有特定分隔字符[dmtsai@study ~]$ cut -c 字符区间 &lt;==用于排列整齐的讯息选项与参数：-d ：后面接分隔字符。与 -f 一起使用；-f ：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；-c ：以字符 （characters） 的单位取出固定字符区间；[dmtsai@study ~]$ echo $&#123;PATH&#125; | cut -d &apos;:&apos; -f 5 #显示切割后的第5个[dmtsai@study ~]$ echo $&#123;PATH&#125; | cut -d &apos;:&apos; -f 3,5 #显示切割后的3-5个[dmtsai@study ~]$ echo $&#123;PATH&#125; | cut -d &apos;:&apos; -f 3- #显示切割后的3到最后一个#将 export 输出的讯息，取得第 12 字符以后的所有字串[dmtsai@study ~]$ exportdeclare -x HISTCONTROL=&quot;ignoredups&quot;declare -x HISTSIZE=&quot;1000&quot;declare -x HOME=&quot;/home/dmtsai&quot;declare -x HOSTNAME=&quot;study.centos.vbird&quot;.....（其他省略）.....# 注意看，每个数据都是排列整齐的输出！如果我们不想要“ declare -x ”时，就得这么做：[dmtsai@study ~]$ export | cut -c 12-HISTCONTROL=&quot;ignoredups&quot;HISTSIZE=&quot;1000&quot;HOME=&quot;/home/dmtsai&quot;HOSTNAME=&quot;study.centos.vbird&quot;.....（其他省略）..... grep12345678910[dmtsai@study ~]$ grep [-acinv] [--color=auto] &apos;搜寻字串&apos; filename选项与参数：-a ：将 binary 文件以 text 文件的方式搜寻数据-c ：计算找到 &apos;搜寻字串&apos; 的次数-i ：忽略大小写的不同，所以大小写视为相同-n ：顺便输出行号-v ：反向选择，亦即显示出没有 &apos;搜寻字串&apos; 内容的那一行！--color=auto ：可以将找到的关键字部分加上颜色的显示喔！-A : 后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；-B : 后面可加数字，为 before 的意思，除了列出该行外，前面的 n 行也列出来； 排序命令 sort wc uniqsort12345678910111213141516171819202122[dmtsai@study ~]$ sort [-fbMnrtuk] [file or stdin]选项与参数：-f ：忽略大小写的差异，例如 A 与 a 视为编码相同；-b ：忽略最前面的空白字符部分；-M ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；-n ：使用“纯数字”进行排序（默认是以文字体态来排序的）；-r ：反向排序；-u ：就是 uniq ，相同的数据中，仅出现一行代表；-t ：分隔符号，默认是用 [tab] 键来分隔；-k ：以那个区间 （field） 来进行排序的意思#/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？[dmtsai@study ~]$ cat /etc/passwd | sort -t &apos;:&apos; -k 3root:x:0:0:root:/root:/bin/bashdmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bashalex:x:1001:1002::/home/alex:/bin/basharod:x:1002:1003::/home/arod:/bin/bash# 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～# 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：# cat /etc/passwd | sort -t &apos;:&apos; -k 3 -n# 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！ uniq重复的数据仅列出一个显示 12345678910111213141516[dmtsai@study ~]$ uniq [-ic]选项与参数：-i ：忽略大小写字符的不同；-c ：进行计数#使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；[dmtsai@study ~]$ last | cut -d &apos; &apos; -f1 | sort | uniq#承上,继续显示每个帐号登录次数[dmtsai@study ~]$ last | cut -d &apos; &apos; -f1 | sort | uniq -c 1 6 （unknown 47 dmtsai 4 reboot 7 root 1 wtmp wc12345678910[dmtsai@study ~]$ wc [-lwm]选项与参数：-l ：仅列出行；-w ：仅列出多少字（英文单字）；-m ：多少字符；#/etc/man_db.conf 里面到底有多少相关字、行、字符数？[dmtsai@study ~]$ cat /etc/man_db.conf | wc 131 723 5171# 输出的三个数字中，分别代表： “行、字数、字符数 双重导向tee可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理. 123456789[dmtsai@study ~]$ tee [-a] file选项与参数：-a ：以累加 （append） 的方式，将数据加入 file 当中！[dmtsai@study ~]$ ls -l /home | tee ~/homefile | more# 将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！[dmtsai@study ~]$ ls -l / | tee -a ~/homefile | more# 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。 字符转换命令 tr, col, join, paste, expandtrtr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！ 1234567891011[dmtsai@study ~]$ tr [-ds] SET1 ...选项与参数：-d ：删除讯息当中的 SET1 这个字串；-s ：取代掉重复的字符！#将 last 输出的讯息中，所有的小写变成大写字符：[dmtsai@study ~]$ last | tr &apos;[a-z]&apos; &apos;[A-Z]&apos;# 不加单引号也是可以执行的，如：“ last | tr [a-z] [A-Z] ”#将 /etc/passwd 输出的讯息中，将冒号 （:） 删除[dmtsai@study ~]$ cat /etc/passwd | tr -d &apos;:&apos; col用来简单的处理将 [tab] 按键取代成为空白键.(还有其它用途???) 1234567[dmtsai@study ~]$ col [-xb]选项与参数：-x ：将 tab 键转换成对等的空白键#利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白[dmtsai@study ~]$ cat -A /etc/man_db.conf &lt;==此时会看到很多 ^I 的符号，那就是 tab[dmtsai@study ~]$ cat /etc/man_db.conf | col -x | cat -A | more 分区命令 split如果有文件太大，导致一些携带式设备无法复制的问题，split 可以将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了 12345[dmtsai@study ~]$ split [-bl] file PREFIX选项与参数：-b ：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；-l ：以行数来进行分区。PREFIX ：代表前置字符的意思，可作为分区文件的前导文字。 范例一：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？ 123456[dmtsai@study ~]$ cd /tmp; split -b 300k /etc/services services[dmtsai@study tmp]$ ll -k services*-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul 9 22:52 servicesaa-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul 9 22:52 servicesab-rw-rw-r--. 1 dmtsai dmtsai 55893 Jul 9 22:52 servicesac# 那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa, xxxab, xxxac 等方式来创建小文件的！ “范例二：如何将上面的三个小文件合成一个文件，文件名为 servicesback 12#用数据流重导向合成文件[dmtsai@study tmp]$ cat services* &gt;&gt; servicesback 范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件 1234567[dmtsai@study tmp]$ ls -al / | split -l 10 - lsroot[dmtsai@study tmp]$ wc -l lsroot* 10 lsrootaa 10 lsrootab 4 lsrootac 24 total# 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～ 参数代换 xargs12345678[dmtsai@study ~]$ xargs [-0epn] command选项与参数：-0 ：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数 可以将他还原成一般字符。这个参数可以用于特殊状态！-e ：这个是 EOF （end of file） 的意思。后面可以接一个字符串，当 xargs 分析到这个字串时，就会停止继续工作！-p ：在执行每个指令的 argument 时，都会询问使用者的意思；-n ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！ 范例一：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来. 1234567891011121314151617181920[dmtsai@study ~]$ id rootuid=0（root） gid=0（root） groups=0（root） # 这个 id 指令可以查询使用者的 UID/GID 等信息[dmtsai@study ~]$ id $(cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3)# 虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！# 所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | iduid=1000 (dmtsai) gid=1000 (dmtsai) groups=1000 (dmtsai),10(wheel)# 因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | xargs id# 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但id 就接受 1 个参数！[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | xargs -n 1 iduid=0（root） gid=0（root） groups=0（root）uid=1（bin） gid=1（bin） groups=1（bin）uid=2（daemon） gid=2（daemon） groups=2（daemon）# 通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！ 范例二：同上，但是每次执行 id 时，都要询问使用者是否动作？ 123456[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | head -n 3 | xargs -p -n 1 idid root ?...yuid=0（root） gid=0（root） groups=0（root）id bin ?...y.....（下面省略）.....# 呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！ 范例三：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串 1234[dmtsai@study ~]$ cut -d &apos;:&apos; -f 1 /etc/passwd | xargs -e&apos;sync&apos; -n 1 id# 仔细与上面的案例做比较。也同时注意，那个 -e&apos;sync&apos; 是连在一起的，中间没有空白键。# 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e&apos;sync&apos; 后，则分析到 sync 这个字串时，# 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！ 很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！ 范例四：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性 123456[dmtsai@study ~]$ find /usr/sbin -perm /7000 | xargs ls -l-rwx--s--x. 1 root lock 11208 Jun 10 2014 /usr/sbin/lockdev-rwsr-xr-x. 1 root root 113400 Mar 6 12:17 /usr/sbin/mount.nfs-rwxr-sr-x. 1 root root 11208 Mar 6 11:05 /usr/sbin/netreport.....（下面省略）.....# 也可以使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！ 减号 “ - “ 的用途管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 “-“ 来替代. 12[root@study ~]# mkdir /tmp/homeback[root@study ~]# tar -cvf - /home | tar -xvf - -C /tmp/homeback 上面这个例子是：“将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - ”。后面的这个 - 则是取用前一个指令的 stdout， 因此，我们就不需要使用 filename 了]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件压缩/打包/备份]]></title>
    <url>%2F2018%2F03%2F02%2FLinux%2F%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%3A%E6%89%93%E5%8C%85%3A%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[[TOC] 压缩文件的技术压缩文件简单原理:目前我们使用的计算机系统中都是使用所谓的 Bytes 单位来计量的！不过，事实上，计算机最小的计量单位应该是 bits 才对啊。此外，我们也知道 1 Byte = 8 bits 。但是如果今天我们只是记忆一个数字，亦即是 1 这个数字呢?由于我们记录数字是 1 ，考虑计算机所谓的二进制喔，如此一来， 1 会在最右边占据 1 个 bit ，而其他的 7 个 bits 将会自动的被填上 0 啰！你看看，其实在这样的例子中，那 7 个 bits 应该是“空的”才对！不过，为了要满足目前我们的操作系统数据的存取，所以就会将该数据转为 Byte 的型态来记录了！而一些聪明的计算机工程师就利用一些复杂的计算方式， 将这些没有使用到的空间“丢”出来，以让文件占用的空间变小！这就是压缩的技术啦！ 另外一种压缩技术也很有趣，他是将重复的数据进行统计记录的。举例来说，如果你的数据为“111….”共有100个1时， 那么压缩技术会记录为“100个1”而不是真的有100个1的位存在！简单的说，你可以将他想成，其实文件里面有相当多的“空间”存在，并不是完全填满的， 而“压缩”的技术就是将这些“空间”填满，以让整个文件占用的容量下降！ 不过，这些“压缩过的文件”并无法直接被我们的操作系统所使用的，因此， 若要使用这些被压缩过的文件数据，则必须将他“还原”回来未压缩前的模样， 那就是所谓的“解压缩 常见的压缩指令 .Z compress 程序压缩的文件； .zip zip 程序压缩的文件；.gz gzip 程序压缩的文件； .bz2 bzip2 程序压缩的文件；.xz xz 程序压缩的文件； .tar tar 程序打包的数据，并没有压缩过；.tar.gz tar 程序打包的文件，其中并且经过 gzip 的压缩 .tar.bz2 tar 程序打包的文件，其中并且经过 bzip2 的压缩*.tar.xz tar 程序打包的文件，其中并且经过 xz 的压缩 gzip, zcat/zmore/zless/zgrepgzip是目前应用最广的压缩指令,后缀为*.gz如果压缩的文件是文本文件,压缩后可以使用zcat相关指令读取出来. 1234567[dmtsai@study ~]$ gzip [-cdtv#] 文件名选项与参数：-c ：将压缩的数据输出到屏幕上，可通过数据流重导向来处理；-d ：解压缩的参数；-t ：可以用来检验一个压缩文件的一致性～看看文件有无错误；-v ：可以显示出原文件/压缩文件的压缩比等信息；-# ：#为数字的意思，代表压缩等级，-1最快，但是压缩比最差、-9最慢，但是压缩比最好！默认是 -6 gzip压缩默认会删除原文件,如果想保留原文件可以使用如下命令: 12[dmtsai@study tmp]$ gzip -9 -c services &gt; services.gz-c 选项打印出文件到屏幕,然后使用 &gt; 重定向 找出压缩文件中的关键字命令: 12345[dmtsai@study tmp]$ zgrep -n &apos;http&apos; services.gz14:# http://www.iana.org/assignments/port-numbers89:http 80/tcp www www-http # WorldWideWeb HTTP90:http 80/udp www www-http # HyperText Transfer Protocol.....（下面省略）..... bzip2, bzcat/bzmore/bzless/bzgrep与gzip用法类似,比gzip压缩比更好后缀为*.bz2 12345678[dmtsai@study ~]$ bzip2 [-cdkzv#] 文件名选项与参数：-c ：将压缩的过程产生的数据输出到屏幕上！-d ：解压缩的参数-k ：保留原始文件，而不会删除原始的文件喔！-z ：压缩的参数 （默认值，可以不加）-v ：可以显示出原文件/压缩文件的压缩比等信息；-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！ xz, xzcat/xzmore/xzless/xzgrep与gzip,bzip2用法类似,比bzip2压缩比更好后缀为*.xz 12345678[dmtsai@study ~]$ xz [-dtlkc#] 文件名选项与参数：-d ：就是解压缩啊！-t ：测试压缩文件的完整性，看有没有错误-l ：列出压缩文件的相关信息-k ：保留原本的文件不删除～-c ：同样的，就是将数据由屏幕上输出的意思！-# ：同样的，也有较佳的压缩比的意思！” 打包文件虽然 gzip, bzip2, xz 也能够针对目录来进行压缩，不过， 这两个指令对目录的压缩指的是“将目录内的所有文件 “分别” 进行压缩”的动作！而不像在 Windows 的系统，可以使用类似 WinRAR 这一类的压缩软件来将好多数据“包成一个文件”的样式。 tar命令常用选项1234567891011121314151617181920[dmtsai@study ~]$ tar [-z|-j|-J][cv][-f 待创建的新文件名] filename... &lt;==打包与压缩[dmtsai@study ~]$ tar [-z|-j|-J][tv] [-f 既有的 tar文件名] &lt;==察看文件名[dmtsai@study ~]$ tar [-z|-j|-J] [xv] [-f 既有的 tar文件名][-C 目录] &lt;==解压缩选项与参数：-c ：创建打包文件，可搭配 -v 来察看过程中被打包的文件名（filename）-t ：察看打包文件的内容含有哪些文件名，重点在察看“文件名”就是了；-x ：解打包或解压缩的功能，可以搭配 -C （大写） 在特定目录解开 特别留意的是， -c, -t, -x 不可同时出现在一串命令行中。-z ：通过 gzip 的支持进行压缩/解压缩：此时文件名最好为 *.tar.gz-j ：通过 bzip2 的支持进行压缩/解压缩：此时文件名最好为 *.tar.bz2-J ：通过 xz 的支持进行压缩/解压缩：此时文件名最好为 *.tar.xz 特别留意， -z, -j, -J 不可以同时出现在一串命令行中-v ：在压缩/解压缩的过程中，将正在处理的文件名显示出来！-f filename：-f 后面要立刻接要被处理的文件名！建议 -f 单独写一个选项啰！（比较不会忘记）-C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。其他后续练习会使用到的选项介绍：-p（小写） ：保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件-P（大写） ：保留绝对路径，亦即允许备份数据中含有根目录存在之意；--exclude=FILE：在压缩的过程中，不要将 FILE 打包！ tar备份123456789[dmtsai@study ~]$ su - # 因为备份 /etc 需要 root 的权限，否则会出现一堆错误[root@study ~]# time tar -zpcv -f /root/etc.tar.gz /etctar: Removing leading `/&apos; from member names &lt;==注意这个警告讯息/etc/....（中间省略）..../etc/hostname#多了time会显示程序运行时间#加上&quot;-p&quot;选项原因是为了保存原本文件的权限和属性 tar备份默认是没有根目录的,那为什么要拿掉根目录呢？主要是为了安全！我们使用 tar 备份的数据可能会需要解压缩回来使用， 在 tar 所记录的文件名 （就是我们刚刚使用 tar -jtvf 所察看到的文件名） 那就是解压缩后的实际文件名。 如果拿掉了根目录，假设你将备份数据在 /tmp 解开，那么解压缩的文件名就会变成“/tmp/etc/xxx”。 但“如果没有拿掉根目录，解压缩后的文件名就会是绝对路径， 亦即解压缩后的数据一定会被放置到 /etc/xxx 去！”如此一来，你的原本的 /etc/ 下面的数据， 就会被备份数据所覆盖过去了！如果想保存根目录可以使用-P选项 解压tar包内单一文件123456789101112131415161718# 1. 先找到我们要的文件名，假设解开 shadow 文件好了：[root@study ~]# tar -jtv -f /root/etc.tar.bz2 | grep &apos;shadow&apos;---------- root/root 721 2015-06-17 00:20 etc/gshadow---------- root/root 1183 2015-06-17 00:20 etc/shadow----------- root/root 1210 2015-06-17 00:20 etc/shadow &lt;==这是我们要的！---------- root/root 707 2015-06-17 00:20 etc/gshadow-# 先搜寻重要的文件名！其中那个 grep 是“撷取”关键字的功能！我们会在第三篇说明！# 这里您先有个概念即可！那个管线 | 配合 grep 可以撷取关键字的意思！# 2. 将该文件解开！语法与实际作法如下：[root@study ~]# tar -jxv -f 打包档.tar.bz2 待解开文件名[root@study ~]# tar -jxv -f /root/etc.tar.bz2 etc/shadowetc/shadow[root@study ~]# ll etctotal 4----------. 1 root root 1210 Jun 17 00:20 shadow# 很有趣！此时只会解开一个文件而已！不过，重点是那个文件名！你要找到正确的文件名。# 在本例中，你不能写成 /etc/shadow ！因为记录在 etc.tar.bz2 内的并没有 / 之故！ tarfile与tarball使用tar打包的文件称为tarfile如果打包文件同时使用压缩则称为tarball.]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[例行性工作调度]]></title>
    <url>%2F2017%2F12%2F11%2FLinux%2F%E4%BE%8B%E8%A1%8C%E6%80%A7%E5%B7%A5%E4%BD%9C%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[[TOC] 循环性执行的例行性工作高度循环执行的例行性工作调度由cron(crond)服务 控制.Lnux上有非常多的例行性工作,因此这个服务是默认启动的. 使用者的设置 123/etc/cron.allow 允许使用crontab的用户/etc/cron.deny 不允许使用crontab的用户allow优先级优于deny 当用户使用crontab指令创建工作调度之后,该项工作被纪录到/var/spool/cron里,而且是以账号作为判别的.如:用Windus使用后会纪录到/var/spool/cron/Windus注意:不要使用vim编辑该文件,可能由于输入法错误导致无法执行cron另外,cron执行的每一项任务都纪录到/var/log/cron中. 123456[root@study ~]# crontab [-u username] [-l|-e|-r]选项与参数：-u ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作调度；-e ：编辑 crontab 的工作内容-l ：查阅 crontab 的工作内容-r ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。 每项工作格式都有六个字段,意义为: 代表意义 分 时 日期 月 周 指令 数字范围 0~59 0~23 1~31 1~12 0~7 执行指令 特殊字符 字符 意义 (星号) 代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 ， 就代表着“不论何月、何日的礼拜几的 12:00 都执行后续指令”的意思！ ,(逗号) 代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是：0 3,6 command时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！ -(减号) 代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作：20 8-12 command仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！ /n(斜线) 那个 n 代表数字，亦即是“每隔 n 单位间隔”的意思，例如每五分钟进行一次，则：/5 command 用 与 /5 来搭配，也可以写成 0-59/5 ，相同意思! 注意:周指令0和7都代表星期天 crond服务读取配置文件位置 12345- /etc/crontab- /etc/cron.d/*- /var/spool/cron/*前两个跟系统有关的配置文件,后一个跟用户有关]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT学习笔记]]></title>
    <url>%2F2017%2F11%2F20%2FGIT%2FGIT%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一次安装设置123#因为git是分布式,这些就是你在提交commit时的签名。(--global全局设置,不加则设置当前版本库)$ git config [--global] user.name &quot;Your Name&quot;$ git config [--global] user.email &quot;email@example.com&quot; 创建版本仓库12345$ git init #创建版本仓库 $ git add #添加文件到版本仓库(可同时添加多个文件空格分割)$ git commit -m &apos;注释内容&apos; #提交版本 $ git commit (-v) #提交版本,启动编辑器编写注释(-v显示详细变更信息)$ git commit -a #提交版本,跳过使用暂存区(不用git add) 版本比对123456$ git status (-s/--short) #查看版本库状态以及文件修改状态(显示简单信息)1.未修改状态:nothing to commit,working tree clean2.修改后文件已在缓存区:Changes to be commited3.新增文件状态:Untracked files4.修改后文件未在缓存区:Changes not staged for commit3与4状态区别在于3无法用git commit –am命令将文件添加到本地仓库 git status -s符号意义:?? 新添加的未跟踪文件前面A 新添加到暂存区中的文件M 修改过的文件(出现在右边的,表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区) 版本回退 和SVN不一样,GIT每个提交版本的commit id不是1,2,3…的数字而是一个SHA1计算出来的十六进制数字.因为GIT是分布式控制系统,如果用1,2,3…数字表示多人协作会重复. 12345678HEAD #表示最新提交的版本HEAD^ #表示上一个提交版本HEAD~100 #表示往上100个版本(~ 代替多个 ^)|#git reset 版本号$ git reset (--mixed) HEAD^ #回退到上个版本,缓存区和你指定的提交同步，但工作目录不受影响(--mixed是默认选项,可以不加)$ git reset --soft HEAD^ #回退到上个版本,缓存区和工作区都不受影响$ git reset --hard HEAD^ #回退到上个版本,缓存区和工作目录都同步到你指定的提交(危险指令) git reset 后面如果是版本号不用写全,只写前几位就可以了.GIT版本回退非常快,因为GIT在内部有个指向当前版本的HEAD指针,当回退版本时GIT仅仅是把HEAD从指向当前版本改为指向回退版本(如下图),顺便把工作区更新了. 由于git log仅显示从当前版本到历史版本的纪录,如果回退了某个版本,又想还原到最新版本怎么办呢? 12$ git reflog #如果在回退以后又想再次回到之前的版本，git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log则不能察看已经删除了的commit记录 工作区和暂存区 git和其它版本控制系统,如SVN的一个不同之处就是有暂存区的概念.工作区:就是电脑能看到的仓库文件夹目录.版本库:工作区内的隐藏目录.git,这个不算工作区,而是git的版本库.GIT版本库里存了很多东西,其中最重要的就是stage(或者叫index)的暂存区,还有GIT为我们自动创建的第一个分支master,以及一个指向master的指针HEAD.实际上git add就是把所有修改放到暂存区,git commit是把暂缓区的修改提交到分支.因此,修改一个文件后必须要添加(git add)到暂存区,才能提交(git commit)到分支,否则提交无效 撤销修改123$ git commit --amend #撤消上次文件提交的修改,重新提交$ git checkout -- 文件名 #撤销工作区文件的修改(如果没有--应变成了切换分支的命令)$ git reset HEAD 文件名 #撤销暂存区文件修改(HEAD表示撤销到最新版本) 删除文件1$ git rm [--cached] 文件名 #从版本库中删除文件(--cached从缓存区中移除到工作区) GIT删除(git rm)文件后,直接提交(git commit)即可,不需要再添加到暂存区(git add).如果不小心删错了,可以直接撤销修改(git checkout – 文件名)如果文件已经提交到版本库,那么永远不用担心误删,但只能恢复到最新版本库,最新修改将丢失. 文件移动12345$ git mv file_from file_to #重命名文件实际相当于运行下面三个命令$ mv file_from file_to$ git rm file_from$ git add file_to 远程仓库12$ git remote add origin 远程仓库地址 #关联远程仓库(origin是git远程仓库的默认名,可以修改)$ git push #本地内容推送到远程仓库 关联后第一次推送仓库的所有内容使用命令:git push -u origin master此后,每次推送本地修改内容可以使用命令:git push origin master 123$ git clone 远程仓库地址 #克隆远程仓库到本地$ git fetch 远程仓库名 #从服务器上抓取本地没有的数据，它并不会修改工作目录中的内容, 它只会获取数据然后让你自己合并.$ git pull (--allow-unrelated-histories) #从服务器抓取分支数据并然后尝试合并. 由于git pull命令经常让人困惑,所以通常单独显式地使用 git fetch 与git merge 命令会更好一些。 1234567$ git remote #显示远程仓库名$ git ls-remote #显示远程引用完整列表$ git remote show [remote-name] #查看远程仓库更多信息$ git remote -v #显示远程仓库信息origin git@github.com:WindusL/LearningNotes.git (fetch)origin git@github.com:WindusL/LearningNotes.git (push) 上面显示了可以抓取和推送的origin地址。如果没有推送权限就看不到push的地址。 12$ git remote rename [oldname] [newname] #对远程仓库的简写名称重命名指令$ git remote rm [remote-name] #对远程仓库的简写名称进行移除的命令 分支管理 Git里默认有一个主分支master，其中HEAD严格来说指向的不是提交，而是当前分支，分支才指向提交。 Git创建一个分支只是增加一个指针，然后将HEAD指向新的分支 ，表示在当前分支，工作区的文件没有任何变化。 123456789101112$ git branch 分支名 #创建分支$ git checkout 分支名 #切换分支#上面两个命令相当于$ git checkout -b 分支名 #创建并切换分支(加上-b表示先创建后切换)$ git checkout -b 分支名 远程分支名 ＃拉取远程分支到本地分支((加上-b表示先创建后切换)$ git branch (-a/r) #列出所有本地分支(-a 包括远程分支,-r仅列出远程分支)$ git branch -v|-vv #查看每个分支最后一次的提交(-vv选项会列表更多信息)$ git merge 分支名 #合并指定分支到当前分支$ git branch -d (-r) 分支名 #删除已合并本地分支(加-r表示删除romote远程分支)$ git branch -D 分支名 #强制删除未合并的分支$ git branch -m|-M 旧分支名 新分支名 # 分支生命名（-M强制生命名） 重命名远程分支推荐做法:1、删除远程分支2、push本地新分支名到远程 1$ git branch --merged|--no-merged #查看已（未）合并的分支 分支-变基分支合并会产生记录,如果想不产生这些记录就可以使用分支变基后再合并. 12345678910$ git rebase 分支名 #把当前分支变基到指定分支#切换到要变基的分支进行变基$ git checkout experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command#回到合并分支进行合并$ git checkout master$ git merge experiment 变基注意事项:只在从未推送至共用仓库的提交上执行变基命令 分支管理策略 通常，合并分支，如果可能Git会用Fast Forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果强制禁用Fast Forward模式，Git会在merge时生成一个新的commit，这样从分支历史上就可以看出分支信息。 1$ git merge --no-ff -m 注释 分支名 #合并分支(--no-ff表示禁用Fast Forward模式，因为要生成一个新的commit所以要加上-m注释参数) Bug分支 当一个分支的工作还没有做完，不能提交，而此时又要及时做其它工作时，可以先把工作区储藏起来,创建bug分支(命名:fixbug-issueId)。 123456789101112$ git stash #储藏工作区(储藏后再用git status查看就是干净的, 除非是没有被git管理的文件)$ git stash save (--keep-index|-u|--patch)注释 #储藏工作区并添加注释(--keep-index #不储藏任何通过 git add 命令已暂存的;-u #储藏任何创建的未跟踪文件--patch #不会储藏所有修改过的任何东西，但是会交互式地提示哪些改动想要储藏、哪些改动需要保存在工作目录中。)$ git stash list #查看stash列表$ git stash apply #恢复stash，但stash不删除$ git stash pop #恢复stash，同时删除stash$ git stash drop #移除stash (会删除储存所有修改,谨慎使用)$ git stash show (-p/--patch) #查看stash(详细)修改 如果多次执行stash后，恢复stash就加上stash名，如：git stash pop/apply stash@{0} Feature分支 开发新功能时最好创建一个新的分支(命名:feature-x)。 预发布分支 发布正式版本之前（即合并到 Master 分支之前），我们可能需要有一个预发布的版本进行测试(命名:release-版本号)。 推送分支(同远程仓库)1$ git push origin 分支名 #推送分支到远程仓库 跟踪分支 从一个远程分支检出一个本地分支会自动创建一个叫做 “跟踪分支”（有时候也叫做 “上游分支”）。跟踪分支是与远程分支有直接关系的本地分支,Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。 1234#设置跟踪分支(将本地分支与远程库分支时行连接。)$ git branch --set-upstream|-u 分支名 origin/分支名 #最新版本已被废弃#最新版本命令$ git branch --set-upstream-to=origin/&lt;branch&gt; 分支名 多人协作 当从远程仓库克隆时，Git自动把本地master分支和远程分支对应起来。并且远程分为默认名是origin。 多人协作的工作模式：1.试图推送分支。2.推送失败则要先抓取远程分支，试图合并。3.合并有冲突，则解决冲突，并在本地提交。4.没有冲突或解决掉了冲突，再推送到远程分支。 标签管理 发布新版本时，通常在版本库打一个标签，来确定打标签时刻的版本。将来无论什么时候，取某个标签的版本就是那个打标签时候的历史版本。所以，标签也相当于版本库的一个快照。Git标签虽然是版本库的快照，但其实就是一个指向commit的指针（与分支类似，但分支可以移动，但标签不能移动）。所以，创建标签也是瞬间完成的。 12345678910111213141516$ git tag #查看所有标签$ git tag -l # 用特定的搜索模式列出符合条件的标签#指搜索1.4.2系统标签$ git tag -l &apos;v1.4.2.*&apos;v1.4.2.1v1.4.2.2v1.4.2.3v1.4.2.4$ git tag 标签名 #打标签(轻量标签)$ git tag 标签名 commitId #给指定commit打标签$ git show 标签名 #查看标签信息$ git tag -a 标签名 -m 注释 commitId #创建带有说明的标签(附注标签)$ git tag -d 标签名 #删除标签 还可以通过-s用私钥签名一个标签,采用PGP签名必须先安装gpg 1$ git tag -s 标签名 -m 注释 commitId 推送远程标签 12$ git push origin 标签名 #推送指定标签到远程仓库$ git push origin --tags #推送全部尚未推送到远程仓库的标签 删除远程标签 12$ git tag -d 标签名 #先删除本地标签$ git push origin :refs/tags/标签名 #然后删除远程标签 检出标签 1234#在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。#如果你想要工作目录与仓库中特定的标签版本完全一样，可以使在特定的标签上创建一个新分支：语法:git checkout -b [branchname] [tagname] 日志 git log12345678$ git log --stat #显示在每个提交(commit)中哪些文件被修改了$ git log -p #显示每次提交的内容差异$ git log -n #显示最近几条日志$ git log --pretty=oneline|format$ git log --graph #展示分支、合并历史$ git log --author #仅显示指定作者相关的提交。$ git log --committer #仅显示指定提交者相关的提交。$ git log --grep #仅显示含指定关键字的提交 提交区间 1234567891011121. 双点语法(..)$ git log master..dev #比对dev还没提交到master分支的记录$ git log origin/master..HEAD #输出在你当前分支中而不在远程 origin 中的提交(如果留空了其中的一边， Git 会默认为 HEAD)2. 多点语法(^ 或 --not)$ git log refA refB ^refC #查看所有被 refA 或 refB 包含的但是不被 refC 包含的提交$ git log refA refB --not refC3. 三点语法(...)语法可以选择出被两个引用中的一个包含但又不被两者同时包含的提交$ git log master...experiment #看 master 或者 experiment 中包含的但不是两者共有的提交$ git log --left-right master...experiment(--left-right显示是哪边分支的提交 &quot;&gt;&quot; 或 &quot;&lt;&quot;) 比较 git diff12345git diff &lt;filename&gt;#比较工作区与暂存区的差异 git diff --cached (&lt;commitId&gt;) &lt;filename&gt; #比较暂存区与上次(/指定commitId)提交的差异git diff HEAD/commitId &lt;filename&gt; #比较工作区与(上次/指定commitId)提交的差异git diff commitId commitId #比较Git仓库任意两次 commit 之间的差别git diff --stat #比较统计(如几处删除,几处增加等等) GIT工具交互式暂存修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交.12$ git add -i #进入交互终端$ git add -p(--patch) #Git暂存文件的特定部分(文件中做了两处修改，但只想要暂存其中的一个) 清理 git clean需要谨慎地使用这个命令，因为它被设计为从工作目录中移除没有忽略的未跟踪文件(任何与 .gitiignore 或其他忽略文件中的模式匹配的文件都不会被移除),可能无法再找回. 12345git clean -f 表示强制清理 -d 后面接要清理的目录 -n 演习删除,显示将要删除的内容 -x 完全干净删除 搜索 git grep从提交历史或者工作目录中查找一个字符串或者正则表达式. 123git grep -n 输出内容所在文件的行号 --count 输出内容所在文件的数量 日志搜索123456789101112git log -S 字符串 #显示新增和删除该字符串的提交 -G 相对于-S更精准,使用正则表达式搜索 -L 展示代码中一行或者一个函数的历史 #找到 ZLIB_BUF_MAX 常量是什么时候引入的$ git log -SZLIB_BUF_MAX --onelinee01503b zlib: allow feeding more than 4GB in one goef49a7a zlib: zlib can only process 4GB at a time #查看 zlib.c 文件中`git_deflate_bound` 函数的每一次变更$ git log -L :git_deflate_bound:zlib.c]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>GIT</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[磁盘与文件管理]]></title>
    <url>%2F2017%2F09%2F29%2FLinux%2F%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] EXT2文件系统 data block 用来放置文件内容数据的地方.在EXT2文件系统中支持block大小有1k 2k 4k.&gt; 每个block大小在与数量在格式化完成后就确定,不能再改变了.(**除非格 式化或使用resize2fs等指令变更文件系统大小**) &gt; 每个block最多只能放一个文件 &gt; 如果文件大于block大小,那文件会占用多个block &gt; 如果文件大小小于block,那么剩余容量就不能再使用了(磁盘空间会浪费). inode table 记录内容: 该文件的存取模式（read/write/excute）该文件的拥有者与群组（owner/group）该文件的容量该文件创建或状态改变的时间（ctime）最近一次的读取时间（atime）最近修改的时间（mtime）定义文件特性的旗标（flag），如 SetUID…该文件真正内容的指向 （pointer）不记录文件名(文件名记录在block上) 特点: 每个 inode 大小均固定为 128 Bytes（新的 ext4 与 xfs 可设置到 256 Bytes）每个文件都仅会占用一个 inode 而已承上，因此文件系统能够创建的文件数量与 inode 的数量有关系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用 者是否符合，若符合才能够开始实际读取 block 的内容。 inode要记录的数据特别多,而只有128Bytes.inode记录一个block号码要4Byte,所以大文件一个inode肯定是不够用的.为此,inode记录block号码区域定义了12个直接,一个间接,一个双间接,一个三间接记录区. 如上图,最左边为 inode 本身 （128 Bytes），里面有 12 个直接指向 block 号码的对照，这 12 笔记录就能够直接取得 block 号码啦！ 至于所谓的间接就是再拿一个 block 来当作记录 block 号码的记录区，如果文件太大时， 就会使用间接的 block 来记录号码。如上图 7.1.4 当中间接只是拿一个 block 来记录额外的号码而已。 同理，如果文件持续长大，那么就会利用所谓的双间接，第一个 block 仅再指出下一个记录号码的 block 在哪里， 实际记录的在第二个 block 当中。依此类推，三间接就是利用第三层 block 来记录号码啦！ 123456789101112inode指定block大小计算(block为1k):- 12 个直接指向： 12*1K=12K 由于是直接,12所以总共可以记录12笔- 1 个间接： 256*1K=256K 每笔 block 号码的记录会花去 4Bytes，因此 1K 的大小能够记录 256 笔记录- 1 个双间接: 256*256*1K=2562K 第一层 block 会指定256个第二层,每个第二层可以指定 256个号码- 1 个三间接： 256*256*256*1K=2563K 第一层 block 会指定256个第二层,每个第二层可以指定256个第三层，每个第三层可以指定 256 个号码得到:12 + 256 + 256*256 + 256*256*256 （K） = 16GB 上面方法不能用在2k及4k block大小计算中,因为大于2k block将会受到EXT2文件系统本身的限制,所以计算结果会不太符合之故. super block 记录整个文件系统信息,没有它就没有文件系统 记录信息 block 与 inode 的总量未使用与已使用的 inode / block 数量block 与 inode 的大小（block为1,2,4K,inode为 128Bytes或 256Bytes）filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 （fsck） 的时间等文件系统的相关信息一个 valid bit 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit 为 1 superblock大小为1024Bytes,文件系统除了第一个block group含有superblock以外,后续的block group都不一定含有supperblock,若含有则是对第一个block group的备份. block bitmap (区块对照表)文件修改时,记录block是否被占用. inode bitmap (inode对照表)与block bitmap功能类似,记录inode占用情况. Filesystem Description （文件系统描述说明）这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 （superblock, bitmap, inodemap, data block） 分别介于哪一个 block 号码之间。 dumpe2fs 查询 Ext 家族 superblock 信息的指令 由于目前centos7以xfs为默认文件系统,所以这个指令无法使用. 1234[root@study ~]# dumpe2fs [-bh] 设备文件名选项与参数：-b ：列出保留为坏轨的部分（一般用不到吧！？）-h ：仅列出 superblock 的数据，不会列出其他的区段内容！ 目录树的操作由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的 inode 号码，此时就能够得到根目录的 inode 内容，并依据该 inode 读取根目录的 block 内的文件名数据，再一层一层的往下读到正确的文件名。 读取步骤 12345[root@study ~]# ll -di / /etc /etc/passwd 128 dr-xr-xr-x. 17 root root 4096 May 4 17:56 /33595521 drwxr-xr-x. 131 root root 8192 Jun 17 00:20 /etc36628004 -rw-r--r--. 1 root root 2092 Jun 17 00:20 /etc/ passwd / 的 inode： 通过挂载点的信息找到 inode 号码为 128 的根目录 inode，且 inode 规范的权限让我们可以读取该 block 的内容（有 r 与 x） ； / 的 block： 经过上个步骤取得 block 的号码，并找到该内容有 etc/ 目录的 inode 号码 （33595521）； etc/ 的 inode： 读取 33595521 号 inode 得知 dmtsai 具有 r 与 x 的权限，因此可以读取 etc/ 的 block 内容； etc/ 的 block： 经过上个步骤取得 block 号码，并找到该内容有 passwd 文件的 inode 号码 （36628004）； passwd 的 inode： 读取 36628004 号 inode 得知 dmtsai 具有 r 的权限，因此可以读取 passwd 的 block 内容; passwd 的 block： 最后将该 block 内容的数据读出来。 写步骤 先确定使用者对于欲新增文件的目录是否具有 w 与 x 的权限，若有的话才能新增； 根据 inode bitmap 找到没有使用的 inode 号码，并将新文件的权限/属性写入； 根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode 的 block 指向数据； 将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap，并更新 superblock 的内容。 日志式文件系统由于各种情况,可能造成数据发生问题,导致写入数据只有inode/block,而缺失bitmap,此时发生metadata与实际数据存放区产生不一致的情况. 在早期的 Ext2 文件系统中，如果发生这个问题， 那么系统在重新开机的时候，就会借由 Superblock 当中记录的 valid bit （是否有挂载） 与 filesystem state （clean 与否） 等状态来判断是否强制进行数据一致性的检查！若有需要检查时则以 e2fsck 这支程序来进行的。因为要针对metadata区域和实际数据存放区域进行比对,所以非常耗时.为了避免上述问题的发生,应运而生了日志文件系统,具体执行步骤: 预备：当系统要写入一个文件时，会先在日志记录区块中纪录某个文件准备要写入的信息； 实际写入：开始写入文件的权限与数据；开始更新 metadata 的数据； 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录。 在这样的程序当中，万一数据的纪录过程当中发生了问题，那么我们的系统只要去检查日志记录区块， 就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整块 filesystem 去检查， 这样就可以达到快速修复 filesystem 的能力 XFS文件系统EXT文件系统目前对于格式化处理,采用预先规划出inode/block/meta data等数据,未来系统可以直接使用,由于现在硬盘越来越大,所以格式化越来越慢.因此,从centos7.x开始文件系统已默认更换成XFS这个比较适合大容量磁盘与巨型文件,性能较佳的文件系统了. 基本止,xfs就是一个日志文件系统,最早之前它就是被开发来用于大容量磁盘以及高性能文件系统之用.Ext4几乎所有的功能xfs都具备.xfs文件系统在数据分布上,主要规划三个部分:一个数据区(data section),一个文件系统活动登录区(log section),一个实时运行区(realtime section). 数据区(data section)基本上,数据区和Ext文件系统一样,包括inode/data block/superblock等数据,都放在这个区块.这个数据区与Ext家族的block group类似,也是分为多个存储区群组(allocation groups)来分别放置文件系统所要的数据.每个存储区群组都包含了(1)整个文件系统的superblock(2)剩余空间管理机制(3)inode的分配与追踪.此外，inode与 block 都是系统需要用到时， 这才动态配置产生，所以格式化动作超级快！ 另外，与 ext 家族不同的是， xfs 的 block 与 inode 有多种不同的容量可供设置，block 容量可由 512Bytes ~ 64K 调配，不过，Linux 的环境下， 由于内存控制的关系 （分页档 pagesize 的容量之故），因此最高可以使用的 block 大小为 4K 而已！（鸟哥尝试格式化 block 成为 16K 是没问题的，不过，Linux 核心不给挂载！ 所以格式化完成后也无法使用啦！） 至于 inode 容量可由 256Bytes 到 2M 这么大！不过，大概还是保留 256Bytes 的默认值就很够用了！ 文件系统活动登录区(log section)这个区域主要用来被记录文件系统的变化,其实有点像日志区. 实时运行区(realtime section)当有文件被创建时,xfs会在这个区域找一个到数个extent区块,将文件放置在这个区块内,等分配完毕后再写入data section的inode与block中去.这个extent区块大小要在格式化时候指定,最小值4K,最大可到1G.一般非磁盘阵列的磁盘默认64K,而具有磁盘阵列的情况下,则建议extent设置为与stripe一样大较佳. 1234567xfs文件系统的描述数据观察:#找出系统 /boot 这个挂载点下面的文件系统的 superblock 纪录 [root@study ~]# df -T /bootFilesystem Type 1K-blocks Used Available Use% Mounted on/dev/vda2 xfs 1038336 133704 904632 13% /boot[root@study ~]# xfs_info /dev/vda2 df命令列出文件系统的整体磁盘使用量 123456789[root@study ~]# df [-ahikHTm] [目录或文件名]选项与参数：-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；-k ：以 KBytes 的容量显示各文件系统；-m ：以 MBytes 的容量显示各文件系统；-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；-H ：以 M=1000K 取代 M=1024K 的进位方式；-T ：连同该 partition 的 filesystem 名称 （例如 xfs） 也列出；-i ：不用磁盘容量，而以 inode 的数量来显示 du命令评估文件系统的磁盘使用量（常用在推估目录所占容量） 12345678[root@study ~]# du [-ahskm] 文件或目录名称选项与参数：-a ：列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已。-h ：以人们较易读的容量格式 （G/M） 显示；-s ：列出总量而已，而不列出每个各别的目录占用容量；-S ：不包括子目录下的总计，与 -s 有点差别。-k ：以 KBytes 列出容量显示；-m ：以 MBytes 列出容量显示； df 主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要是在 Superblock 内的信息， 所以这个指令显示结果的速度非常的快速.du 这个指令其实会直接到文件系统内去搜寻所有的文件数据，这个指令的会执行一小段时间！ Hard Link （实体链接, 硬式链接或实际链接）由于每个文件都占用一个inode,文件内容由inode记录指向,想要读取文件必须经过目录记录的文件名来指向到正确的inode号码才能读取.也就是说,其实文件名只与目录有关,但是文件内容则与inode有关.如果有多个文件名对应一个inode,那就是实体链接的由来.限制: 不能跨FileSystem 不能link目录 如果hard link到链接到目录时,链接的数据需要连同被链接目录下面的所有数据都创建链接，举例来说，如果你要将 /etc 使用实体链接创建一个 /etc_hd 的目录时，那么在 /etc_hd 下面的所有文件名同时都与 /etc 下面的文件名要创建 hard link 的，而不是仅链接到 /etc_hd 与 /etc 而已。 并且，未来如果需要在 /etc_hd 下面创建新文件时，连带的， /etc 下面的数据又得要创建一次 hard link ，因此造成环境相当大的复杂度.所以啰，目前 hard link 对于目录暂时还是不支持的啊！ Symbolic Link(符号链接)Symbolic link 就是在创建一个独立的文件，而这个文件会让数据的读取指向他 link 的那个文件的文件名！由于只是利用文件来做为指向的动作， 所以，当来源文件被删除之后，symbolic link 的文件会“开不了”， 会一直说“无法打开某文件！”。实际上就是找不到原始“文件名”而已啦！ 1234[root@study ~]# ln -s /etc/crontab crontab2[root@study ~]# ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab 上面结果我们可以知道两个文件指向不同的 inode 号码，当然就是两个独立的文件存在！ 而且链接文件的重要内容就是他会写上目标文件的“文件名”， 你可以发现为什么上表中链接文件的大小为 12 Bytes 呢？ 因为箭头（–&gt;）右边的文件名“/etc/crontab”总共有 12 个英文，每个英文占用 1 个 Bytes ，所以文件大小就是 12Bytes了！ ln命令 1234[root@study ~]# ln [-sf] 来源文件 目标文件选项与参数：-s ：如果不加任何参数就进行链接，那就是hard link，至于 -s 就是symbolic link-f ：如果 目标文件 存在时，就主动的将目标文件直接移除后再创建！]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件与目录管理]]></title>
    <url>%2F2017%2F09%2F13%2FLinux%2F%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[[TOC] 目录相关操作 . 代表此层目录.. 代表上一层目录 代表前一个工作目录~ 代表“目前使用者身份”所在的主文件夹~account 代表 account 这个使用者的主文件夹（account是个帐号名称） pwd命令1234567891011#显示所在目录root@study ~]# pwd [-P]-P ：显示出确实的路径，而非使用链接 （link） 路径。 [root@study mail]# ls -ld /var/maillrwxrwxrwx. 1 root root 10 May 4 17:51 /var/mail -&gt; spool/mail[root@study ~]# cd /var/mail [root@study mail]# pwd/var/mail &lt;==列出目前的工作目录[root@study mail]# pwd -P/var/spool/mail mkdir 创建目录123root@study ~]# mkdir [-p] 目录名-p : 创建层级目录mkdir -p /home/windus/test/linux ls命令12345678910111213141516171819202122232425262728 选项与参数：-a ：全部的文件，连同隐藏文件（ 开头为 . 的文件） 一起列出来（常用）-A ：全部的文件，连同隐藏文件，但不包括 . 与 .. 这两个目录-d ：仅列出目录本身，而不是列出目录内的文件数据（常用）-f ：直接列出结果，而不进行排序 （ls 默认会以文件名排序！）-F ：根据文件、目录等信息，给予附加数据结构，例如： *:代表可可执行文件； /:代表目录； =:代表 socket 文件； |:代表 FIFO 文件；-h ：将文件大小以人类较易读的方式（例如 GB, KB 等等）列出来；-i ：列出 inode 号码，inode 的意义下一章将会介绍；-l ：长数据串行出，包含文件的属性与权限等等数据；（常用）字段说明:1.文件属性：drwxr-xr-x2.文件硬链接数量 33.所有者：user4.所属用户组：group5.文件大小：102 byte6.修改时间：Mar11 22:567.文件名：Filename-n ：列出 UID 与 GID 而非使用者与群组的名称 （UID与GID会在帐号管理提到！）-r ：将排序结果反向输出，例如：原本文件名由小到大，反向则为由大到小；-R ：连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来；-S ：以文件大小大小排序，而不是用文件名排序；-t ：依时间排序，而不是用文件名。--color=never ：不要依据文件特性给予颜色显示；--color=always ：显示颜色--color=auto ：让系统自行依据设置来判断是否给予颜色--full-time ：以完整时间模式 （包含年、月、日、时、分） 输出--time=&#123;atime,ctime&#125; ：输出 access 时间或改变权限属性时间 （ctime）而非内容变更时间 （modification time） cp命令12345678910选项与参数:-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明；（常用）-d ：若来源文件为链接文件的属性（link file），则复制链接文件属性而非文件本身；-i ：若目标文件（destination）已经存在时，在覆盖时会先询问动作的进行（常用）-l ：进行硬式链接（hard link）的链接文件创建，而非复制文件本身；-p ：连同文件的属性（权限、用户、时间）一起复制过去，而非使用默认属性（备份常用）；-r ：递回持续复制，用于目录的复制行为；（常用）-s ：复制成为符号链接文件 （symbolic link），亦即“捷径”文件；-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制。--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了。 rmdir命令123root@study ~]# rmdir [-p] 目录名称选项与参数：-p ：连同“上层”“空的”目录也一起删除 rm命令 1.在指令前加上反斜线，可以忽略掉 alias 的指定选项喔！^[详见bash章节]2.删除一个带有 - 开头的文件。（因为“－”是选项,所以系统误判了！ 123456#错误[root@study tmp]# rm -aaa-rm: invalid option -- &apos;a‘#正确 rm --help查找[root@study tmp]# rm ./-aaa-[root@study tmp]# rm -- -aaa- mv命令1234选项与参数：-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；-i ：若目标文件 （destination） 已经存在时，就会询问是否覆盖！-u ：若目标文件已经存在，且 source 比较新，才会更新 （update） 特殊用处:1.文件更名(类似命令rename)2.可同时移动多个文件到同一目录 rename命令123456参数:原字符串：将文件名需要替换的字符串； 目标字符串：将文件名中含有的原字符替换成目标字符串； 文件：指定要改变文件名的文件列表#[root@study tmp]# rename .htm .html *.htm basename获取文件/目录名 12345678910选项:-a, --multiple support multiple arguments and treat each as a NAME-s, --suffix=SUFFIX remove a trailing SUFFIX-z, --zero separate output with NUL rather than newline #例子basename /usr/bin/sort -&gt; &quot;sort&quot;basename include/stdio.h .h -&gt; &quot;stdio&quot;basename -s .h include/stdio.h -&gt; &quot;stdio&quot;basename -a any/str1 any/str2 -&gt; &quot;str1&quot; followed by &quot;str2&quot; dirname1234#例子dirname /usr/bin/ -&gt; &quot;/usr&quot;dirname dir1/str dir2/str -&gt; &quot;dir1&quot; followed by &quot;dir2&quot;dirname stdio.h -&gt; &quot;.&quot; 文件内容审阅cat命令由第一行开始显示内容(与tac相反) 1234567选项与参数：-A ：相当于 -vET 的整合选项，可列出一些特殊字符而不是空白而已；-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！-E ：将结尾的断行字符 $ 显示出来；-n ：打印出行号，连同空白行也会有行号，与 -b 的选项不同；-T ：将 [tab] 按键以 ^I 显示出来；-v ：列出一些看不出来的特殊字符 nl指令添加行号打印,默认不打印空行行号.“其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能呢。 123456789101112nl [选项]... [文件]...-b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)；-n ：列出行号表示的方法，主要有三种： -n ln ：行号在萤幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ；-w ：行号栏位的占用的位数。(与-n ln 或 -n rz配合使用)-p 在逻辑定界符处不重新开始计算。$ nl -n ln -w 3 test.txt 可翻页检视 more / less两者区别在于前者不能向前翻页(管线操作),后者可以向前翻页并支持更多其它操作 数据撷取- head 撷取前面几行 - tail 取出后几行,默认10行 ***注意:当用-f |grep 选项时,默认会有缓存区不能及时显示可加--line-buffered*** 123例题：假如我想要显示 /etc/man_db.conf 的第 11 到第 20 行呢？head -n 20 /etc/man_db.conf | tail -n 10 非纯文本文件 od12345678选项或参数：-t ：后面可以接各种“类型 （TYPE）”的输出，例如： a ：利用默认的字符来输出； c ：使用 ASCII 字符来输出 d[size] ：利用十进制（decimal）来输出数据，每个整数占用 size Bytes ； f[size] ：利用浮点数值（floating）来输出数据，每个数占用 size Bytes ； o[size] ：利用八进位（octal）来输出数据，每个整数占用 size Bytes ； x[size] ：利用十六进制（hexadecimal）来输出数据，每个整数占用 size Bytes ； 如果对纯文本文件使用这个指令，你甚至可以发现到 ASCII 与字符的对照表！例题：想要立刻找到 password 这几个字的 ASCII 对照，该如何通过 od 来判断？答：echo password | od -t oCc 文件时间 modification time （mtime）：当该文件的“内容数据”变更时，就会更新这个时间！内容数据指的是文件的内容，而不是文件的属性或权限喔！ status time （ctime）：当该文件的“状态 （status）”改变时，就会更新这个时间，举例来说，像是权限与属性被更改了，都会更新这个时间啊。 access time （atime）：当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 cat 去读取 /etc/man_db.conf ， 就会更新该文件的 atime 了。 修改文件时间 touch命令123456选项与参数：-a ：仅修订 access time；-c ：仅修改文件的时间，若该文件不存在则不创建新文件；-d ：后面可以接欲修订的日期而不用目前的日期，也可以使用 --date=&quot;日期或时间&quot;-m ：仅修改 mtime ；-t ：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]. 该命令也可用来新建文件 file命令查看某个文件的基本数据类型,如:ASCII/data文件/binary文件等等信息,也可用来判断tar包文件是用哪种压缩功能打包的. ##文件与文件夹权限在Linux传统的Ext2/Ext3/Ext4文件系统下，我们还可以设置其他的系统隐藏属性， 这部份可使用 chattr 来设置，而以 lsattr 来查看，最重要的属性就是可以设置其不可修改的特性！让连文件的拥有者都不能进行修改！ 这个属性可是相当重要的，尤其是在安全机制上面 （security）！比较可惜的是，在 CentOS 7.x 当中利用 xfs 作为默认文件系统， 但是 xfs 就没有支持所有的 chattr 的参数了！仅有部份参数还有支持而已！ 文件默认权限 umaskumask 的分数指的是“该默认值需要减掉的权限！ 若使用者创建为“文件”则默认“没有可执行（ x ）权限”，亦即只有 rw 这两个项目，也就是最大为 666 分，默认权限如下：-rw-rw-rw- 若使用者创建为“目录”，则由于 x 与是否可以进入此目录有关，因此默认为所有权限均开放，亦即为 777 分，默认权限如下：drwxrwxrwx 12345[root@study ~]# umask0022 &lt;==与一般权限有关的是后面三个数字！[root@study ~]# umask -Su=rwx,g=rx,o=rx [root@study ~]# umask 022 &lt;==设置默认权限 文件隐藏属性 chattrchattr指令只能在Ext2/Ext3/Ext4的 Linux 传统文件系统上面完整生效， 其他的文件系统可能就无法完整的支持这个指令了，例如 xfs 仅支持部份参数而已 1234567891011121314151617181920[root@study ~]# chattr [+-=][ASacdistu] 文件或目录名称选项与参数：+ ：增加某一个特殊参数，其他原本存在参数则不动。- ：移除某一个特殊参数，其他原本存在参数则不动。= ：设置一定，且仅有后面接的参数A ：当设置了 A 这个属性时，若你有存取此文件（或目录）时，他的存取时间 atime 将不会被修改， 可避免 I/O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）S ：一般文件是非同步写入磁盘的（原理请参考前一章sync的说明），如果加上 S 这个属性时，当你进行任何文件的修改，该更动会“同步”写入磁盘中。a ：当设置 a 之后，这个文件将只能增加数据，而不能删除也不能修改数据，只有root 才能设置这属性c ：这个属性设置之后，将会自动的将此文件“压缩”，在读取的时候将会自动解压缩， 但是在储存的时候，将会先进行压缩后再储存（看来对于大文件似乎蛮有用的！）d ：当 dump 程序被执行的时候，设置 d 属性将可使该文件（或目录）不会被 dump 备份i ：这个 i 可就很厉害了！他可以让一个文件“不能被删除、改名、设置链接也无法写入或新增数据！ 对于系统安全性有相当大的助益！只有 root 能设置此属性s ：当文件设置了 s 属性时，如果这个文件被删除，他将会被完全的移除出这个硬盘空间， 所以如果误删了，完全无法救回来了喔！u ：与 s 相反的，当使用 u 来设置文件时，如果该文件被删除了，则数据内容其实还存在磁盘中， 可以使用来救援该文件喔！注意1：属性设置常见的是 a 与 i 的设置值，而且很多设置值必须要身为 root 才能设置注意2：xfs 文件系统仅支持 AadiS 而已 显示文件隐藏属性 lsattr12345678root@study ~]# lsattr [-adR] 文件或目录选项与参数：“-a ：将隐藏文件的属性也秀出来；-d ：如果接的是目录，仅列出目录本身的属性而非目录内的文件名；-R ：连同子目录的数据也一并列出来！ [root@study tmp]# chattr +aiS attrtest[root@study tmp]# lsattr attrtest--S-ia---------- attrtest 文件特殊权限Set UID -&gt; SUID权限12[root@study ~]# ls -l /usr/bin/passwd-rwsr-xr-x. 1 root root 27832 Jun 10 2014 /usr/bin/ 注意:上面passwd指令,一般账号没有写入权限,为什么一般账号还能修改密码呢?这就是USID的功能了（注意拥有者的“s”）:1、dmtsai 对于 /usr/bin/passwd 这个程序来说是具有 x 权限的，表示 dmtsai 能执行 passwd；2、passwd 的拥有者是 root 这个帐号；3、dmtsai 执行 passwd 的过程中，会“暂时”获得 root 的权限；4、/etc/shadow 就可以被 dmtsai 所执行的 passwd 所修改。如果一般用户用cat去读取/etc/shadow时,会提示权限不够,因为cat指令没有SUID权限。另外SUID只对二进制程序有用,不能用于shell脚本。 Set GID -&gt; SGID权限与SUID类似，当s标志在文件群组的x位置时，则称为SGID 123[root@study ~]# ll /usr/bin/locate /var/lib/mlocate/mlocate.db-rwx--s--x. 1 root slocate 40496 Jun 10 2014 /usr/bin/locate-rw-r-----. 1 root slocate 2349055 Jun 15 03:44 /var/lib/mlocate/mlocate.db 使用 dmtsai 这个帐号去执行 locate 时，那 dmtsai 将会取得 slocate 群组的支持， 因此就能够去读取 mlocate.db 啦 除了 binary program 之外，事实上 SGID 也能够用在目录上，这也是非常常见的一种用途！ 当一个目录设置了 SGID 的权限后，他将具有如下的功能： 使用者若对于此目录具有 r 与 x 的权限时，该使用者能够进入此目录； 使用者在此目录下的有效群组（effective group）将会变成该目录的群组； 用途：若使用者在此目录下具有 w 的权限（可以新建文件），则使用者所创建的新文件，该新文件的群组与此目录的群组相同。 Sticky Bit -&gt; SBIT权限*目前这个权限仅针对目录有效，对于文件已经没有效果了。在others上的t标识 当使用者对于此目录具有 w, x 权限，亦即具有写入的权限时； 当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件如:/tmp 本身的权限是“drwxrwxrwt”， 在这样的权限内容下，任何人都可以在 /tmp 内新增、修改文件，但仅有该文件/目录创建者与 root 能够删除自己的目录或文件。 SUID/SGID/SBIT 权限设置SUID : 4 SGID : 2 SBIT : 1在数字权限前面加上一个数字就表示几个特殊权限了. 假设要将一个文件权限改为“-rwsr-xr-x”时，由于 s 在使用者权限中，所以是 SUID ，因此， 在原先的 755 之前还要加上 4 ，也就是：“ chmod 4755 filename ”来设置！此外，还有大 S 与大 T 的产生喔！参考下面的范例啦！ 12[root@study tmp]# chmod 7666 test; ls -l test &lt;==具有空的 SUID/SGID 权限-rwSrwSrwT 1 root root 0 Jun 16 02:53 test 注意:上面大写SST,因为特殊权限要求必须有执行权限(上面是666),所以权限不能启作用为空权限 除了数字方法外,也可以通过符号来处理.其中 SUID 为 u+s ，而 SGID 为 g+s ，SBIT 则是 o+t 1234567 #设置权限成为 -rws--x--x 的模样：[root@study tmp]# chmod u=rwxs,go=x test; ls -l test-rws--x--x 1 root root 0 Jun 16 02:53 test #承上，加上 SGID 与 SBIT 在上述的文件权限中！[root@study tmp]# chmod g+s,o+t test; ls -l test-rws--s--t 1 root root 0 Jun 16 02:53 test 指令与文件的搜寻指令文件名搜寻which (寻找”可执行文件”)默认查找PATH内所规范的目录第一个被找到的执行文件 123456选项参数:-a 将所有由 PATH 目录中可以找到的指令均列出，而不止第一个被找到的指令名称 root@study ~]# which history/usr/bin/which: no history in （/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin） 因为history是bash内置命令所以不能用which查找，可以通过type命令查看。^[详见bash章节] 文件文件名搜寻whereis (由一些特定的目录中寻找文件文件名)1234567[root@study ~]# whereis [-bmsu] 文件或目录名选项与参数：-l :可以列出 whereis 会去查询的几个主要目录而已-b :只找 binary 格式的文件-m :只找在说明文档 manual 路径下的文件-s :只找 source 来源文件-u :搜寻不在上述三个项目当中的其他特殊文件 locate / updatedblocate寻找的数据是由/var/lib/mlocate里面的数据搜索到的,所以不用搜索硬盘,速度快。但由于数据库默认每天创建一次，所以新建的文件可能搜索不到，或者已删除文件还能搜索到 1234567[root@study ~]# locate [-ir] keyword选项与参数：-i ：忽略大小写的差异；-c ：不输出文件名，仅计算找到的文件数量-l ：仅输出几行的意思，例如输出五行则是 -l 5-S ：输出 locate 所使用的数据库文件的相关信息，包括该数据库纪录的文件/目录数量等-r ：后面可接正则表达式的显示方式 想要实时搜索就要手动更新数据库：updatedbupdatedb：根据 /etc/updatedb.conf 的设置去搜寻系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件； locate：依据 /var/lib/mlocate 内的数据库记载，找出使用者输入的关键字文件名。*因为 updatedb 会去搜寻硬盘，所以当你执行 updatedb 时，可能会等待数分钟的时间喔！ find12345678910111213141516171819202122232425262728293031323334353637383940414243444546[root@study ~]# find [PATH] [option] [action]选项与参数：1. 与时间有关的选项：共有 -atime, -ctime 与 -mtime ，以 -mtime 说明 -mtime n ：n 为数字，意义为在 n 天之前的“一天之内”被更动过内容的文件； -mtime +n ：列出在 n 天之前（不含 n 天本身）被更动过内容的文件文件名； -mtime -n ：列出在 n 天之内（含 n 天本身）被更动过内容的文件文件名。 -newer file ：file 为一个存在的文件，列出比 file 还要新的文件文件名 2. 与使用者或群组名称有关的参数： -uid n ：n 为数字，这个数字是使用者的帐号 ID，亦即 UID ，这个 UID 是记录在/etc/passwd 里面与帐号名称对应的数字。这方面我们会在第四篇介绍。 -gid n ：n 为数字，这个数字是群组名称的 ID，亦即 GID，这个 GID 记录在/etc/group -user name ：name 为使用者帐号名称喔！例如 dmtsai -group name：name 为群组名称喔，例如 users ； -nouser ：寻找文件的拥有者不存在 /etc/passwd 的人！ -nogroup ：寻找文件的拥有群组不存在于 /etc/group 的文件！ 当你自行安装软件时，很可能该软件的属性当中并没有文件拥有者， 这是可能的！在这个时候，就可以使用 -nouser 与 -nogroup 搜寻。3. 与文件权限及名称有关的参数： -name filename ：搜寻文件名称为 filename 的文件； -size [+-]SIZE ：搜寻比 SIZE 还要大（+）或小（-）的文件。这个 SIZE 的规格有： c: 代表 Byte， k: 代表 1024Bytes。 所以，要找比50KB还要大的文件，就是“ -size +50k” -type TYPE ：搜寻文件的类型为 TYPE 的， 类型主要有： 一般正规文件（f）, 设备文件（b, c）, 目录（d）, 链接文件（l）, socket（s）, 及 FIFO（p） 等属性。 -perm mode ：搜寻文件权限“刚好等于” mode 的文件，这个 mode 为类似 chmod的属性值，举例来说， -rwsr-xr-x 的属性为 4755 ！ -perm -mode ：搜寻文件权限“必须要全部囊括 mode 的权“限”的文件。 -perm /mode : 任何权限位 mode 被设置了的文件。举例：[root@study ~]# find / -perm +7000 *所谓的 7000 就是 ---s--s--t ，那么只要含有 s 或 t 的就列出，所以当然要使用 /7000，*使用 -7000 表示要同时含有 ---s--s--t 的所有三个权限。而只需要任意一个，就是 /7000 ～瞭乎？(旧版是：-perm +7000已经被/7000替换)4. 额外可进行的动作：-exec command ：command 为其他指令，-exec 后面可再接额外的指令来处理搜寻到的结果。-print ：将结果打印到屏幕上，这个动作是默认动作！[root@study ~]# find / -name &quot;passwd&quot; -exec ls -l &#123;&#125; \; -exec 后面不支持别名所以上面使用 ls -l{} 代表的是“由find找到的内容”由于find命令是硬盘搜索，所以速度会相对很慢]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件目录权限]]></title>
    <url>%2F2017%2F09%2F11%2FLinux%2F%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[[TOC] 文件属性 第一栏代表文件类型与权限 列表第一个字符意义:当为[ d ]则是目录，例如上表文件名为“.config”的那一行；当为[ - ]则是文件，例如上表第三行；若是[ l ]则表示为链接文件（link file）；若是[ b ]则表示为设备文件里面的可供储存的周边设备（可随机存取设备）；若是[ c ]则表示为设备文件里面的序列埠设备，例如键盘、鼠标（一次性读取设备）。 第二栏表示有多少文件名链接到此节点上 第三栏表示这个文件“拥有者账号” 第四栏表示这个文件所属群组 第五栏表示这个文件大小，默认单位Bytes 第六栏表示文件的创建日期或修改日期 第七栏为文件名 改变文件属性与权限 改变文件群组 chgrp [-R] 群组名 文件或目录 改变文件拥有者 chown [-R] 账号名:群组名 文件或目录 改变权限数字类型改变文件权限 r:4 w:2 o:1chmod [-R] 权限和 文件/文件夹 符号类型改变文件权限 user:u group:g others:o all:a+加入权限 -去除权限 =设置权限写法:chmod [-R] u=rwx,g=rw,o=rw 文件/文件夹 Linux目录配置 HFS要求必须存在的目录 /bin 放置的是单人维护模式下还能够被操作的命令。主要有：cat、chmod、chown、date、mv、mkdir、cp、bash等常用指令。 /boot 此目录主要放置在开机会使用的文件,包括Linux核心文件以及开机菜单与开机所需要的配置文件等等。 /dev Linux上,任何设置与周边设置都以文件形态存在于这个目录。通过读取这个目录下的文件，就等于存取这个设备。比较重要的文件有：/dev/null,/dev/zero,/dev/tty等等。 /etc 系统主要配置文件几乎都放在这个目录内,例如人员账号密码档、各种服务启动档等等。一般来说这个目录文件可以让一般用户查阅，但是只有root用户可以修改。FHS建议不要放置可可执行文件(binary)在这个目录中。 比较重要的文件有：/etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue /etc/opt(必要) 这个目录放置第三方软件/opt的相关配置文件。 /lib 放置的是开机时会用到的函数库,以及在/bin或/sbin下指令会调用的函数库. /lib/modules (必要) 这个目录放置可抽换式的核心模块(驱动程序) /media 放置可移除设置。包括：软盘、光盘、DVD等等设置都暂时挂载于此。常见的文件名有：/media/floppy, /media/cdrom等等。 /mnt 如果你想要暂时挂载某些额外的设备，一般建议你可以放置到这个目录中。 在早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。 /opt 第三方协力软件放置的目录。什么是第三方协力软件啊？ 举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到Linux系统中，因此KDE的软件就建议放置到此目录下了。 另外，如果你想要自行安装额外的软件（非原本的distribution提供的），那么也能够将你的软件安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ /run 早期的 FHS 规定系统开机后所产生的各项信息应该要放置到 /var/run 目录下，新版的 FHS 则规范到 /run 下面。 由于 /run 可以使用内存来仿真，因此性能上会好很多！ /sbin 放在/sbin下面的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到/usr/sbin/当中。至于本机自行安装的软件所产生的系统可执行文件（system binary）， 则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。 /srv srv可以视为“service”的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如WWW, FTP等等。举例来说，WWW服务器需要的网页数据就可以放置在/srv/www/里面。 不过，系统的服务数据如果尚未要提供给网际网络任何人浏览的话，默认还是建议放置到 /var/lib 下面即可。 /tmp 这是让一般使用者或者是正在执行的程序暂时放置文件的地方。 这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！ 因为FHS甚至建议在开机时，应该要将/tmp下的数据都删除唷！ /usr 第二层FHS设置,见后续… /var 第二层FHS设置,见后续… HFS要求可以存在的目录 /home 这是系统默认的使用者主文件夹（home directory）。在你新增一个一般使用者帐号时， 默认的使用者主文件夹都会规范到这里来 ~：代表目前这个使用者的主文件夹~dmtsai ：则代表 dmtsai 的主文件夹！ /lib\ 用来存放与 /lib 不同的格式的二进制函数库，例如支持 64 位的 /lib64 函数库等 /root 系统管理员（root）的主文件夹。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时， 该目录就能够拥有root的主文件夹，所以我们会希望root的主文件夹与根目录放置在同一个分区中。 事实上FHS针对根目录定义的标准仅有上面这些,不过Linux还有许多目录需要了解一下.下面几个目录也非常重要: /lost+found 这个目录是使用标准的ext2/ext3/ext4文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。不过如果使用的是 xfs 文件系统的话，就不会存在这个目录了！ /proc 这个目录本身是一个虚拟目录.它放置 的数据都是在内存中.例如系统核心、行程信息、周边设备状态以及网络状态等等。因为这个目录数据都在内存当中，所以本身不占任何磁盘空间。比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。 /sys 这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录核心与系统硬件信息较相关的信息。 包括目前已载入的核心模块与核心侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！ /usr目录 /usr 目录是Unix Software Resource的缩写， 也就是“Unix操作系统软件资源”所放置的目录，而不是使用者的数据啦！这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行创建该软件自己独立的目录。 FHS要求必须存在的目录 /usr/bin 所有一般用户使用的指令都放在这里! 目前CentOS7已经将全部指令放置于此,而使用链接文件的方式将 /bin 链接至此! 也就是说 /bin 与 /usr/bin 是一模一样了! 另外,FHS要求在此目录下不应该有子目录! /usr/lib 基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的！ /usr/local 系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)建议安装到此目录,这样会比较方便管理. 举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦！ 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录喔！ /usr/sbin 非系统正常运行所需要的系统指令。最常见的就是某些网络服务器软件的服务指令（daemon）啰！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的。 /usr/share 主要放置只读架构的数据文件，当然也包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文字文件嘛！ 常见的还有这些次目录：/usr/share/man 线上说明文档/usr/share/doc 软件杂项文件说明/usr/share/zoneinfo 与时区有关的时区文件 FHS建议可以存在的目录 /usr/games 与游戏比较相关的数据放置处 /usr/include c/c++等程序语言的文件开始（header）与包含档（include）放置处，当我们以tarball方式 （*.tar.gz 的方式安装软件）安装某些数据时，会使用到里头的许多包含档喔！ /usr/libexec 某些不被一般使用者惯用的可执行文件或脚本（script）等等，都会放置在此目录中。例如大部分的 X 窗口下面的操作指令， 很多都是放在此目录下的。 **/usr/lib\ 与 /lib\/功能相同，因此目前 /lib 就是链接到此目录中 /usr/src 一般源代码建议放在这里, src有source的意思. 至于核心源代码建议放到 /usr/src/linux 目录下./var目录 如果 /usr 是安装时会占用较大硬盘容量的目录，那么 /var 就是在系统运行后才会渐渐占用硬盘容量的目录。 因为 /var 目录主要针对常态性变动的文件，包括高速缓存（cache）、登录文件（log file）以及某些软件运行所产生的文件， 包括程序文件（lock file, run file），或者例如MySQL数据库的文件等等 FHS要求必须存在的目录 /var/cache 应用程序运行中会产生的一些暂存盘 /var/lib 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去！ /var/lock 某些设备或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该设备时， 就可能产生一些错误的状况，因此就得要将该设备上锁（lock），以确保该设备只会给单一软件所使用。 举例来说，烧录机正在烧录一块光盘，你想一下，会不会有两个人同时在使用一个烧录机烧片？ 如果两个人同时烧录，那片子写入的是谁的数据？所以当第一个人在烧录时该烧录机就会被上锁， 第二个人就得要该设备被解除锁定（就是前一个人用完了）才能够继续使用啰。目前此目录也已经挪到 /run/lock 中 /var/log 重要到不行！这是登录文件放置的目录！里面比较重要的文件如 /var/log/messages , /var/log/wtmp（记录登陆者的信息）等。 /var/mail 放置个人电子邮件信箱的目录，不过这个目录也被放置到 /var/spool/mail/ 目录中！ 通常这两个目录是互为链接文件啦！ /var/run 某些程序或者服务启动后, 会将它们的PID放置在这个目录下! 与 /run 相同，这个目录链接到 /run 去了！ /var/spool 这个目录通常放置一些伫列数据，所谓的“伫列”就是排队等待其他程序使用的数据啦！ 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作调度数据（crontab），就会被放置到/var/spool/cron/目录中！ CentOS观察 uname 1234[dmtsai@study ~]$ uname -r # 查看核心版本3.10.0-229.el7.x86_64[dmtsai@study ~]$ uname -m # 查看操作系统的位版本x86_64 lsb_release指令已经不是默认安装软件了.使用前需要安装 1234567[root@study ~]# dnf install redhat-lsb[root@study ~]# lsb_release -aLSB Version: :core-4.1-amd64:core-4.1-noarch:cxx-4.1-amd64:cxx-4.1-noarch:desktop-4.1-amd64:desktop-4.1-noarch:languages-4.1-amd64:languages-4.1-noarch:printing-4.1-amd64:printing-4.1-noarchDistributor ID: CentOSDescription: CentOS Linux release 7.3.1611 (Core)Release: 7.3.1611Codename: Core /etc/* 1234[root@study ~]# cat /etc/issueCentOS release 5.5 (Final)Kernel r on an m[root@study ~]# cat /etc/redhat-release]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开关机]]></title>
    <url>%2F2017%2F09%2F11%2FLinux%2F%E5%BC%80%E5%85%B3%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[[TOC] 重要热键 Tab 自动补全Ctrl+C 中断目前程序Ctrl+d 键盘输入结束Shift+Page [Up][Down] 上下翻页[Ctrl] + [Alt] + [F1]~[F6]的组合按钮 终端切换 开关机 shutdown [-krhc] [时间] [警告讯息] 关机命令 -k ： 不要真的关机，只是发送警告讯息出去！-r ： 在将系统的服务停掉之后就重新开机（常用）-h ： 将系统的服务停掉后，立即关机。 （常用）-c ： 取消已经在进行的 shutdown 指令内容。时间 ： 指定系统关机的时间！时间的范例下面会说明。若没有这个项目，则默认 1 分钟后自动进行。 reboot 重新开机命令 sync;reboot实际开关机命令默认都会执行sync命令,但为了保险起见还是手动执行一下此命令。 实际使用关机管理工具systemctl [指令] 上面提到的开关机命令实际都是调用此命令执行开关机 halt 进入系统停止的模式，屏幕可能会保留一些讯息，这与你的电源管理模式有关poweroff 进入系统关机模式，直接关机没有提供电力喔！reboot 直接重新开机suspend 进入休眠模式[root@study ~]# systemctl reboot # 系统重新开机[root@study ~]# systemctl poweroff # 系统关机]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[又到一年十一时(一)]]></title>
    <url>%2F2014%2F10%2F01%2Fblog%2F%E5%8F%88%E5%88%B0%E4%B8%80%E5%B9%B4%E5%8D%81%E4%B8%80%E6%97%B6%2F</url>
    <content type="text"><![CDATA[雨依旧淅沥沥的飘个不停仿佛从未停息,转眼间冬去秋来又是一年，徘徊与迷茫仍是这一年的主题，不同的是收获了更多新鲜而有意义的人或事，回想起去年那雨中穿梭，奋勇前行的情景,仍在继续，必将终身难忘，而如此更多的激情我想才刚刚开始。 今年的北京比每年冷的有些早，刚进十月就已经有些冬天的感觉了，整个黄金周只能猫在窝里了，外面的世界虽然很精彩，但是一票难求的咱们却是桑不起啊。 听说又有砖家同志发言了建议取消黄金周，此人正是当年提出取消五一的那位，我的小心脏又开始担心了，这不会是最后的黄金“粥”了吧，可惜我还没有抓住机会去享受；听说高考要取消英语了，我不禁泪流满面啊；听说乌克兰要闹独立，我不禁又要泪流满面；听说……听说……。好吧这一年发生的事还真不少，可怜我这小小的记忆内存啊！ 话说我今年又搬了两次家，这让我越来越学得漂着的感觉是多么的让人无奈了。不禁让我想起了一句诗词“有的房空着，可你却住不起；有些人住的起，可他们却不惜住。”于是乎，我渐渐的靠近了七环，疏远了组织。 明年也许依旧是平凡的一年，但更是我期待的一年，也会是我努力收获的一年，也许在别人眼中不值一提。努力，共勉-2014]]></content>
      <categories>
        <category>心情随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我的一次骑行经历—北戴河(二)]]></title>
    <url>%2F2013%2F10%2F28%2Fblog%2F%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[朦胧中一阵阵清澈的溪水声，将我从梦中带回到现实。关闭手机，起床洗漱，酸痛感遍布全身，但体力恢复的差不多了。收拾了半个小时后，下楼准备退房出发，旅馆老板还没起床，叫醒老板后，老板把旅店们打开，一股清凉感，拂面而来，让我神清气爽。太阳刚刚升起，车子整理好，沿着大道向前走，找早餐的地方，走了很远 1，看到一家早餐点，坐下来吃了了点早餐。以前没注意过，这次近距离接触，发现唐山话很好说啊，只要每个字都发二声音再加点儿音 2，听起来就就很像了\^_\^。 吃完早点，全身充满能量，感觉一天能骑200公里 3。感觉总是会骗人的，出了玉田县，又与久违的102国道交汇了，灰依然很大，车依然很多，之前的豪言壮语烟消云散，怎么一个“累”字了得。 当前坐标(117,40)当前位置(玉田县)当前目标(唐山丰润区)里程(40KM)。 由于昨天的120公里行程，今天的任务尤显艰巨160。丰润这段路，甚是奇怪，都是缓坡,最好的路况也就算是平道了(几乎没有感觉到)。经过两个小时左右接近丰润的时候，道路坑坑洼洼尤其的难走，路上漫天“灰”舞，简直无法形容，我的两层魔术头巾，已经起不到多大的作用了。幸好这样的路只有一段，后来换入曹雪芹西道，进入丰润区。这一段路总体感觉，没什么好感，一路缓坡平路，我现在的感觉只能用一首歌来形容“走过了一村又一寨……（当然我不是小和尚）”，其它的就没什么印象了。 8点20分,曹雪芹西道，简单休息了一下，看了一下地图，确定路线后继续前行，话说曹雪芹道可真是够长的，单曹雪芹西道就走了半个小时(当然速度不是很快，毕竟城区里人多，车多，红灯多。中间路过曹雪芹像，让我终于相信原来他真是个男的。)。 到曹雪芹东道的尽头向南走，继续踏上熟悉的102国道。快要离开丰润前，下车休息了一下，补充点食物和水，还遇到了三个骑友，他们是直接去北戴河的。他们没耽误多久又出发了，他们走后我们又休息了十几分钟，也继续前进了。 下一站，滦县60公里，进入102国道继续前行，从此时起，每每看到一个指示牌，我的心里都会相当兴奋，因为我知道距离目标黄金海岸南戴河越来越近了。骑行了大约20分钟左右，我们追上了刚刚先走的几个骑友，他们中有一个人体力下滑严重，骑得特别慢，导致他们整体速度很慢。我们一起骑行了一段距离，他们速度实在太慢了，我们就走到了他们前边，于是102国道上就上演了这样我们停下来休息，他们追上来，他们停下休息，我们追上去……无休止的卡位战，又过了2-3个小时，已经12点多了，距离滦县还有20公里，看来我们先前估算的路程少了，实际上不只60公里。我们也有点很累了，早上5点多出发到现在也很长时间，再不补充的点食物，下午可就有问题了。于是我们到了滦县方向与102国道的交叉点“野鸡坨镇” 4，解决午饭问题，点了几个菜，吃点米饭(这块吃饭还行，不怎么贵，味道一般吧)。午饭一个小时，继续向前走，这一段的102国道不是怎么好走，到处积水，因为我们要在野鸡坨镇向南走252省道，但是前方道路积水，我没敢尝试过去，几经打听在一位阿姨的帮助下，绕了半天终于在一个小道上了省道。 省道果然比国道强的多，马路宽阔无比，并行四辆大车，都绰绰有余。一路平道，骑起来不怎么费劲，一直到了滦县，几十公里的路，一点没感到累。不过话说回来这条道还真是长啊，骑了半个多小时，到了一个大牌楼收费站，上面俩个大字“滦北”，此时看一下地图，晕，这条道才走了一半。又过了半个小时，看到一个立交桥，上面写着“千年古县”什么的，此时终于接近此段路的目的地滦县！ 这段路从里程上看确实比到丰润的距离远了20公里 5，不过这段路骑得要比前一段路爽的多啊，虽然道路依旧一般,而且有几段距离满地是泥，灰依旧不小，最主要是这段路有起伏，有上坡，有下坡，有平道，就像生活，风平浪静，虽然舒服但总感觉缺少点什么，跌宕起伏，虽然艰难，却乐在其中。 上了205，路却是好走的多了，路上的风景也好的多了，这可能就是人们口中传颂的苦尽甘来吧，呵呵。一个下坡，开启了我几公里的30+。走了几十公里后，倒处是在修路，路上又遇到一个骑友，从山东来的，要去大连！走了一段路，就不见踪影了，看来我们一路，一直超越啊，不知过了多久，看见一座大山，终于接近昌黎县了！休息了一下，吃了一些食物，喝了一罐红牛 6。 进入昌黎，有两条路：一条继续205，另一条是横穿昌黎继续向前。经过导航定位后我们选择了前者 7，我们几乎绕了一圈后，发现走的有点不对，于是换入365省道，走入了一条不归路！！！于是越走越远，越走越黑，差不多六点左右，天色已经快看不见了，我们停下来，把车子上安上手电、尾灯等，此时已经意识到走错了路. 于是决定继续换入一个向北的路，这条路没有路灯到处漆黑一片，很窄，车还很多 8。这条路还真不是一般的长，走了好久，此时地点是黄金海岸不知道哪个门，换入364省道，恩路是真好，就是没有灯,这条路我骑得依然很兴奋 9，因为这条道的尽头，就是我们的目的地。终于在8点左右，我们到达了南戴河，去了事先订好好的旅店！我们的骑行旅程到此结束了，骑行里数190公里…… 一路上来虽然有很多艰辛，但同时也有很多了欢乐和享受,这也正是我骑行的乐趣所在。由于，我们是第一次去，走了很多弯路，也带了些无用的东西，是我们骑行负担更重，所以我把需要的东西，大致总结了一下： 骑行装备（头盔、眼镜、口罩&lt;魔术头巾&gt;、手套、裤带、备胎、修车组合工具、气筒、货架、行李包&lt;其实去北戴河，我感觉没必要带行李包，真不需要带太多，我们这 次就带的多了，完全可以，用一个大一点的背包搞定&gt;）等. 衣服(至少2套衣服&lt;十月份早晚天气很冷，带些厚的&gt;、拖鞋&lt;去海边，相当有用，我这次没带，后悔死了&gt;、鞋&lt;我带了2双，雨中骑行湿了一双&gt;)等. 手机软件(导航软件&lt;这点可真要选好，我这次可是深受其害啊，一定要多下载几款，总结一下我用的导航软件：高德，查询路线还行，定位可真是不准啊。凯立德： 定位准确，但是小地方查不到&gt;)其它，可根据自己实际条件和爱好了，如：帐篷啊，充气船啊等等。 &sup1;玉田这地，吃饭的真的好少啊！&sup2;包子(báo zī)儿.&sup3;万万没想到最后真的成了现实.4这个地名很有意思，这一片的地名貌似都喜欢以“坨”结尾.5对这种长距离骑行，远几公里的感觉都是不一样的.6这真不是一个广告，我估计这就是导致我后来越骑越有力气的原因\^\^!7事实上我们真的错了，205其实是绕了昌黎一圈==!.8虽然如此，但此时丝毫没有疲惫感，非常兴奋，因为我已经闻到大海的腥味了，我知道这次是真的快到了，当然也许是红牛的作用\^\^.9当然，我也归功于红牛上了！我的队友在滦县的时候就喝了准备的红牛，我告诉他会后悔的,果然他现在的状态，惨不忍睹.]]></content>
      <categories>
        <category>芬芳年华</category>
      </categories>
      <tags>
        <tag>骑行</tag>
        <tag>旅游</tag>
        <tag>北戴河</tag>
        <tag>大海</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的一次骑行经历—北戴河(一)]]></title>
    <url>%2F2013%2F10%2F08%2Fblog%2F%E6%88%91%E7%9A%84%E4%B8%80%E6%AC%A1%E9%AA%91%E8%A1%8C%E7%BB%8F%E5%8E%86%E2%80%94%E5%8C%97%E6%88%B4%E6%B2%B3-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[似乎每一个骑行者都要至少一次雨中骑行的经历才能体会到骑行的乐趣，似乎每一次旅行都要经历种种磨砺才算是完美！ 向往已久的骑行终于在这次十一小长假实现了，前一个月就想去北戴河了，由于种种问题终于没能成行。恰巧同事买了个新车子，俩人一商量走你…… 原计划骑行路线：D1:北京-廊坊三河(55KM G102)-天津蓟县(90KM G102)-唐山玉田县(118KM G102)-唐山丰润区(152KM G102)D2:丰润—滦县(60KM)——昌黎(100KM G205)—(黄金海岸118KM G205) D1）5点钟起床：天气晴，哦不对，是起来晴，洗漱完后，天气开始下雨了，哇塞！！！好大一声雷。难道Game就要Over了，管它呢先吃早餐的说。吃完饭后，天气雨点貌似有点小了，准备出发，Go Go Go！自行车刚搬下楼，大雨再一次与我们拥抱,计划貌似再一次与我们惜别。 肿么办，我真想冒着大雨出发，可是这次出行并不是我自己一个人，所以要争求同伴的意见，经商议等雨停了再出发 1。然后同伴上楼等待，我依然站在楼下默默祈祷，又过了十几分钟雨丝毫没有停下的迹象，我第一次有了放弃的想法。 又过了十几分钟，已经7点多了，与原计划5点足足晚了2个小时。再不走计划行程可能就要泡汤了！此时，我的心里一直有个声音呼喊着我：“出发……出发……”！最后的决定是无论如何也要去。我跑上楼去问一下同伴还要不要去，最后同伴也下定决心，冒雨出发！于是我们穿上雨披上车出发了，这时雨变的小些了； 老天总喜欢和我们开些小玩笑，骑车来到附近ATM，只见屏幕上一排大字:“暂停服务！”= =！。好吧，只有上四环绕到大望路去取了 2,开拔! 目的地：大望路 soho取款机。 到了大望路取完钱后，整理了一下随身物品，现在真正要出发了，此时脑海里浮现出那句歌词“你问我要去向何方，我指着大海的方向！……”。 第一站&gt;京通快速—燕郊（约30KM），上了京通快速，雨越来越大，雨披渐渐失去了作用，骑行也倍感吃力。雨中骑行怎么一个“爽”字了得，可是停下来后的感觉，可就真心难受了！ 原本潮白河大桥想留影的，无耐雨太大，没有停歇继续前进，又走了几公里，在燕郊一处小市场内，休息一会，补充点水和食物 3。休息了十几分钟，下身湿透伴随着小风[哆嗦]，赶紧上车继续前行！ 第二站&gt;燕郊—三河(约25KM)，此时码表莫名其妙的罢工了，在11点左右，我们看到了一个高大无比，相当气派的门楼，上面写着几个大字“三河欢迎您”！哇塞，这就是传说的三河，果然不一般 →_→ 。 雨依旧很大，没有机会照相，继续向三河城区方向前进。到了城区，找了半天，只发现一个还可以的清真兰州拉面(PS：河北人应该酷爱面食，一路上到处是拉面、火烧之类的。)，对于我来说面食很不抗饿，一碗牛肉拉面入肚后感觉没饱，于是我们拿出自己带来的牛肉，刚想吃被老板阻止了。外带非本店清真食品不能在这吃。好吧，那就不吃了，虽然没吃饱 4。 下午1点，三河出发—目标丰润(约100KM)，天气逐渐变晴，温暖的阳光，精神焕发，可是浪费掉的体力，却是找不回了，体力感到明显下滑。 过了蓟县，走了大约20多公里，我的队友体力严重不支，骑行速度只能维持在15KM/H。此时，距离最近地点玉田还有40多公里，此时距离北京已经80多公里，为了不让我们行程落后，也是为了激励队友，我尽量把速度控制在20KM/H以上。又走走停停过了十几公里，我也明显感到体力不行了 5。 此时已经四点了，看来到丰润已是不太可能了，于是选择了玉田落脚。接下来的20公里，成了自我骑行以来最艰难的20公里。到达玉田后，夜色将近，于是现在最重要的一个任务就是找旅馆。就在我们要选定一个名为“XXX宾馆”的时候，一个哥们走进我们视线，上来询问我们从哪里来，到哪里去。经了解他是玉田本地人，也是骑行爱好者，于是我们向他询问这家宾馆怎么样，他告诉我们不要在这家很贵，然后告诉我们哪块的便宜。 正在此时，恰巧一个女的开车经过，听到我们谈话后开始对那个哥们发飙了：“我们家也不贵啊，你谁啊，你哪家的，你别走……”此处省略500字。于是我们赶紧掉头走，没想到那哥们又跟了上来，告诉我们详细的地址(多么热心，真诚的人)，在此我要对那位哥们说声谢谢！按照那位哥们说的路线，我们很容易找到了一个不错的旅馆，俩人才50块钱。车子和行李搬到旅馆后我们出去满足了肚子一个愿望\^_\^。之后又去超市采购了一些明天行程的用品，然后回到旅馆，洗了一下被泥水灌溉过的车子。感觉明天的东西准备差不多了，于是上床昏昏沉沉的睡着了…… 总结： 今天总体感觉还好主要是上午雨中骑行浪费大部分体力，下午导致体力不支，不过下雨其实也真不是什么坏事102国道的灰，真不是吹的，多亏下雨让我们少吃了一些！ &sup1;我真没抱有雨停的希望,事实也确实如此.&sup2;因为我们只知道这块有ATM.&sup3;主要是食物，“水”真是不缺.4据我事后分析，这也是导致后来我们体力不支，惜叹止步玉田的原因之一\^\^.5最主要是车座部位难受\^\^.]]></content>
      <categories>
        <category>芬芳年华</category>
      </categories>
      <tags>
        <tag>骑行</tag>
        <tag>旅游</tag>
        <tag>北戴河</tag>
        <tag>大海</tag>
      </tags>
  </entry>
</search>
