<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="每个人的心里都有一扇窗!"><title>Linux的Bash | 风尘</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Linux的Bash</h1><a id="logo" href="/.">风尘</a><p class="description">每个人的心里都有一扇窗!</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/study/"><i class="fa fa-graduation-cap"> 学习</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/loveu/"><i class="fa fa-heart"> LOVE U</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Linux的Bash</h1><div class="post-meta">Mar 6, 2018<span> | </span><span class="category"><a href="/categories/软件开发/">软件开发</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2018/03/06/Linux/Linux的Bash/#vcomment"><span class="valine-comment-count" data-xid="/2018/03/06/Linux/Linux的Bash/"></span><span> 条评论</span></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell"><span class="toc-number">1.</span> <span class="toc-text">Shell</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash-shell-功能"><span class="toc-number">2.</span> <span class="toc-text">Bash shell 功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#命令编修能力"><span class="toc-number">2.1.</span> <span class="toc-text">命令编修能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type指令"><span class="toc-number">2.2.</span> <span class="toc-text">type指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#快速编辑"><span class="toc-number">2.3.</span> <span class="toc-text">快速编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量"><span class="toc-number">2.4.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#echo-指令"><span class="toc-number">2.4.1.</span> <span class="toc-text">echo 指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量设置规则"><span class="toc-number">2.4.2.</span> <span class="toc-text">变量设置规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#环境变量"><span class="toc-number">2.4.3.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#语系变量"><span class="toc-number">2.4.4.</span> <span class="toc-text">语系变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量范围"><span class="toc-number">2.4.5.</span> <span class="toc-text">变量范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量键盘读取-阵列与宣告"><span class="toc-number">2.4.6.</span> <span class="toc-text">变量键盘读取/阵列与宣告</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量内容删除-取代-替换"><span class="toc-number">2.4.7.</span> <span class="toc-text">变量内容删除/取代/替换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#系统限制关系-ulimit"><span class="toc-number">2.5.</span> <span class="toc-text">系统限制关系 ulimit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令别名与历史命令"><span class="toc-number">2.6.</span> <span class="toc-text">命令别名与历史命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#别名设置-alias-unalias"><span class="toc-number">2.6.1.</span> <span class="toc-text">别名设置 alias / unalias</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#历史命令-history"><span class="toc-number">2.6.2.</span> <span class="toc-text">历史命令 history</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bash-Shell操作环境"><span class="toc-number">3.</span> <span class="toc-text">Bash Shell操作环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bash-进站欢迎信息-etc-issue-etc-motd"><span class="toc-number">3.1.</span> <span class="toc-text">Bash 进站欢迎信息 /etc/issue  /etc/motd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bash环境配置文件"><span class="toc-number">3.2.</span> <span class="toc-text">bash环境配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#login与non-login-Shell"><span class="toc-number">3.2.1.</span> <span class="toc-text">login与non-login Shell</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#etc-profile-login-Shell读取"><span class="toc-number">3.2.2.</span> <span class="toc-text">/etc/profile (login Shell读取)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bash-profile-login-Shell读取"><span class="toc-number">3.2.3.</span> <span class="toc-text">~/.bash_profile (login Shell读取)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#source-读入环境配置文件指令"><span class="toc-number">3.2.4.</span> <span class="toc-text">source 读入环境配置文件指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bashrc-（non-login-shell-读取）"><span class="toc-number">3.2.5.</span> <span class="toc-text">~/.bashrc （non-login shell 读取）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终端机环境设置-stty-set"><span class="toc-number">3.3.</span> <span class="toc-text">终端机环境设置 stty , set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stty命令"><span class="toc-number">3.3.1.</span> <span class="toc-text">stty命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set命令"><span class="toc-number">3.3.2.</span> <span class="toc-text">set命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#万用字符与特殊符号"><span class="toc-number">3.4.</span> <span class="toc-text">万用字符与特殊符号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据流重导向"><span class="toc-number">4.</span> <span class="toc-text">数据流重导向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据流输入-输出"><span class="toc-number">4.1.</span> <span class="toc-text">数据流输入/输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dev-null-垃圾桶黑洞设备与特殊写法"><span class="toc-number">4.1.1.</span> <span class="toc-text">/dev/null 垃圾桶黑洞设备与特殊写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-gt-amp-amp-gt"><span class="toc-number">4.1.2.</span> <span class="toc-text">2&gt;&amp; | &amp;&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标准输入"><span class="toc-number">4.1.3.</span> <span class="toc-text">标准输入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令执行的判断依据-amp-amp"><span class="toc-number">4.2.</span> <span class="toc-text">命令执行的判断依据 ;  &amp;&amp;  ||</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#不考虑指令相关性的连续指令下达-cmd-cmd"><span class="toc-number">4.2.1.</span> <span class="toc-text">不考虑指令相关性的连续指令下达 cmd;cmd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（指令回传值）-与-amp-amp-或"><span class="toc-number">4.2.2.</span> <span class="toc-text">$? （指令回传值） 与 &amp;&amp; 或 ||</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管线命令-pipe"><span class="toc-number">5.</span> <span class="toc-text">管线命令(pipe)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#撷取命令-cut-grep"><span class="toc-number">5.1.</span> <span class="toc-text">撷取命令 cut grep</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cut"><span class="toc-number">5.1.1.</span> <span class="toc-text">cut</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#grep"><span class="toc-number">5.1.2.</span> <span class="toc-text">grep</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序命令-sort-wc-uniq"><span class="toc-number">5.2.</span> <span class="toc-text">排序命令 sort wc uniq</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sort"><span class="toc-number">5.2.1.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uniq"><span class="toc-number">5.2.2.</span> <span class="toc-text">uniq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wc"><span class="toc-number">5.2.3.</span> <span class="toc-text">wc</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双重导向tee"><span class="toc-number">5.3.</span> <span class="toc-text">双重导向tee</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符转换命令-tr-col-join-paste-expand"><span class="toc-number">5.4.</span> <span class="toc-text">字符转换命令 tr, col, join, paste, expand</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tr"><span class="toc-number">5.4.1.</span> <span class="toc-text">tr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#col"><span class="toc-number">5.4.2.</span> <span class="toc-text">col</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分区命令-split"><span class="toc-number">5.5.</span> <span class="toc-text">分区命令 split</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数代换-xargs-后面貌似不能用alias"><span class="toc-number">5.6.</span> <span class="toc-text">参数代换 xargs(后面貌似不能用alias)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#减号-“-“-的用途"><span class="toc-number">5.7.</span> <span class="toc-text">减号 “ - “ 的用途</span></a></li></ol></li></ol></div></div><div class="post-content"><p>[TOC]</p>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>/etc/shells记录系统所有shell</p>
<h2 id="Bash-shell-功能"><a href="#Bash-shell-功能" class="headerlink" title="Bash shell 功能"></a>Bash shell 功能</h2><h3 id="命令编修能力"><a href="#命令编修能力" class="headerlink" title="命令编修能力"></a>命令编修能力</h3><blockquote>
<p>默认指令记忆功能可以达到1000个<br>记录位置~/.bash_history(当前指令用户指令在内存中,登出后才记录到文件此内)</p>
</blockquote>
<ul>
<li>命令与文件实例功能(tab补全)</li>
<li>命令别名设置功能</li>
<li>工作控制/前景背景控制</li>
<li>程序化脚本shell script</li>
<li>万用字符(*)</li>
</ul>
<a id="more"></a>
<h3 id="type指令"><a href="#type指令" class="headerlink" title="type指令"></a>type指令</h3><p>type 这个指令我们可以知道每个指令是否为 bash 的内置指令。 此外，type只能查找可执行文件.</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ <span class="keyword">type</span> [-tpa] <span class="keyword">name</span></span><br><span class="line">选项与参数：</span><br><span class="line">    ：不加任何选项与参数时，<span class="keyword">type</span> 会显示出 <span class="keyword">name</span> 是外部指令还是 bash 内置指令</span><br><span class="line">-t  ：当加入 -t 参数时，<span class="keyword">type</span> 会将 <span class="keyword">name</span> 以下面这些字眼显示出他的意义：</span><br><span class="line">      <span class="keyword">file</span>    ：表示为外部指令；</span><br><span class="line">      <span class="keyword">alias</span>   ：表示该指令为命令别名所设置的名称；</span><br><span class="line">      builtin ：表示该指令为 bash 内置的指令功能；</span><br><span class="line">-p  ：如果后面接的 <span class="keyword">name</span> 为外部指令时，才会显示完整文件名；</span><br><span class="line">-a  ：会由 PATH 变量定义的路径中，将所有含 <span class="keyword">name</span> 的指令都列出来，包含 <span class="keyword">alias</span></span><br></pre></td></tr></table></figure>
<h3 id="快速编辑"><a href="#快速编辑" class="headerlink" title="快速编辑"></a>快速编辑</h3><ul>
<li><p>反斜杠( \ )<br>命令输入太长需要换行,利用反斜杠( \ )[Enter]开启下一行,而不执行命令.<br><strong>注意: [Enter] 按键是紧接着反斜线 （ \ ）</strong></p>
</li>
<li><p>快捷键</p>
</li>
</ul>
<table><br>    <tr><br>        <th>组合键</th><br>        <th>功能与示范</th><br>    </tr><br>    <tr><br>        <td>[ctrl]+u/[ctrl]+k</td><br>        <td>分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k） </td><br>    </tr><br>    <tr><br>        <td>[ctrl]+a/[ctrl]+e</td><br>        <td>分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e） </td><br>    </tr><br>    <tr><br>        <td>Ctrl + C</td><br>        <td>终止目前命令</td><br>    </tr><br>    <tr><br>        <td>Ctrl + D</td><br>        <td>输入结束(EOF),例如:邮件结束的时候</td><br>    </tr><br>    <tr><br>        <td>Ctrl + M</td><br>        <td>就是Enter</td><br>    </tr><br>    <tr><br>        <td>Ctrl + S</td><br>        <td>暂停屏幕输出</td><br>    </tr><br>    <tr><br>        <td>Ctrl + Q</td><br>        <td>恢复屏幕输出</td><br>    </tr><br>    <tr><br>        <td>Ctrl + U</td><br>        <td>在提示字符下，将整列命令删除</td><br>    </tr><br>    <tr><br>        <td>Ctrl + Z</td><br>        <td>“暂停”目前的命令 配合fg/bg/jobs命令使用</td><br>    </tr><br></table>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="echo-指令"><a href="#echo-指令" class="headerlink" title="echo 指令"></a>echo 指令</h4><p>显示变量内容,”-e”选项可以格式化打印内容</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>echo <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<h4 id="变量设置规则"><a href="#变量设置规则" class="headerlink" title="变量设置规则"></a>变量设置规则</h4><ol>
<li>变量与变量内容以一个”=”来连接.<br> <code>myname=Windus</code></li>
<li><p>等号两边不能直接接空白符.</p>
 <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#错误</span></span><br><span class="line"><span class="attr">myname</span>= Windus</span><br><span class="line"><span class="attr">myname</span>=Windus L</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量内容若有空白符可使用双引号或单引号将变量内容结合起来.  </p>
 <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#双引号内特殊字符可保持原本特性,如:"$"等</span></span><br><span class="line"><span class="keyword">var</span>=<span class="string">"lang is $LANG"</span></span><br><span class="line">echo $<span class="keyword">var</span><span class="function"> --&gt;</span> lang <span class="keyword">is</span> UTF8</span><br><span class="line"></span><br><span class="line"><span class="comment">#单引号内的特殊字符仅为一般字符(纯文本)</span></span><br><span class="line"><span class="keyword">var</span>=<span class="string">'lang is $LANG'</span></span><br><span class="line">echo $<span class="keyword">var</span><span class="function"> --&gt;</span> lang <span class="keyword">is</span> $LANG</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量名称只能是英文字母与数字,但开头字符不能是数字.</p>
</li>
<li><p>可用跳脱字符” \ “,将特殊符号变成一般符号。(如： [Enter], $, \, 空白字符等）  </p>
<p> <code>myname=Windus\ L</code></p>
</li>
<li><p>在一串指令的执行中，还需要借由其他额外的指令所提供的信息时，可以使用反单引号“<code>指令</code>”或 “$（指令） </p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">version=$（uname -r）</span><br><span class="line">echo <span class="variable">$version</span> --&gt; <span class="number">3.10</span>.<span class="number">0</span>-<span class="number">229</span><span class="selector-class">.el7</span><span class="selector-class">.x86_64</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若该变量为扩增变量内容时，则可用 “\$变量名称” 或 ${变量} 累加内容</p>
 <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="string">"$PATH"</span><span class="symbol">:/home/bin</span></span><br><span class="line">或</span><br><span class="line">PATH=<span class="variable">$&#123;</span>PATH&#125;<span class="symbol">:/home/bin</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量<br> <code>export PATH</code></p>
</li>
<li><p>通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断 （纯粹依照使用者兴趣与嗜好,在 Linux 默认的情况中，使用{大写的字母}来设置的变量一般为系统内定需要的变量）</p>
</li>
<li>取消变量用unset<br><code>unset myname</code></li>
</ol>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><ul>
<li><p>env命令<br>  查看所有环境变量</p>
<ul>
<li>HOME 使用者主文件夹变量, ~就会读取此变量</li>
<li>SHELL 目前环境使用的SHELL程序(Linux默认:/bin/bash)</li>
<li>HISTSIZE 历史命令记录笔数</li>
<li>MAIL 当前用户邮箱文件</li>
<li>PATH 可执行文件搜寻的路径(目录与目录中间:分隔).由于搜寻顺序依据PATH变量内目录顺序,所以目录顺序也是重要的.</li>
<li>LANG 语系数据</li>
<li><p>RANDOM 随机数变量(/dev/random),内容介于0~32767之间.</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#想要获取指定范围内的数,使用delcare声名数值类型</span></span><br><span class="line">[dmtsai@study ~]$ <span class="built_in">declare</span> -i number=<span class="variable">$RANDOM</span>*10/32768 ; </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$number</span></span><br><span class="line">8   &lt;== 此时会随机取出 0~9 之间的数值喔！</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>set命令<br>  查看所有变量(含环境变量与自定变量)</p>
<ul>
<li><p>PS1 提示字符的设置</p>
  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\d</span> ：可显示出“星期 月 日”的日期格式，如：<span class="string">"Mon Feb 2"</span></span><br><span class="line"><span class="string">\H</span> ：完整的主机名称。举例来说，鸟哥的练习机为“study.centos.vbird”</span><br><span class="line"><span class="string">\h</span> ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为“study”后面省略</span><br><span class="line"><span class="string">\t</span> ：显示时间，为 <span class="number">24</span> 小时格式的“HH:MM:SS”</span><br><span class="line"><span class="string">\T</span> ：显示时间，为 <span class="number">12</span> 小时格式的“HH:MM:SS”</span><br><span class="line"><span class="string">\A</span> ：显示时间，为 <span class="number">24</span> 小时格式的“HH:MM”</span><br><span class="line"><span class="string">\@</span> ：显示时间，为 <span class="number">12</span> 小时格式的“am/pm”样式</span><br><span class="line"><span class="string">\u</span> ：目前使用者的帐号名称，如“dmtsai”；</span><br><span class="line"><span class="string">\v</span> ：BASH 的版本信息，如鸟哥的测试主机版本为 <span class="number">4.2</span>.<span class="number">46</span>（<span class="number">1</span>）-release，仅取“<span class="number">4.2</span>”显示</span><br><span class="line"><span class="string">\w</span> ：完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以 ~ 取代；</span><br><span class="line"><span class="string">\W</span> ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。</span><br><span class="line"><span class="string">\#</span> ：下达的第几个指令。</span><br><span class="line"><span class="string">\$</span> ：提示字符，如果是 root 时，提示字符为 <span class="comment"># ，否则就是 $</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>- \$ 本shell的PID  
    `echo $$`
- ? 上个指令的回传值
    执行某些指令时， 这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令， 则会回传一个 0 值,如果执行过程发生错误,就会传回错误代码.一般以非0代码取代.
</code></pre><ul>
<li><p>export命令<br>  当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是一个称为程序识别码，被称为 PID 的就是。 接下来你在这个 bash 下面所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了.<br>  <img src="/2018/03/06/Linux/Linux的Bash/QQ20180307-115110@2x.png" alt="程序相关性示意图"></p>
<p>  子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自订变量.所以你在原本 bash 的自订变量在进入了子程序后就会消失不见， 一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！<br>此时,把自定变量变成环境变量就变得很有必要了:<br><code>export 变量名称</code></p>
</li>
</ul>
<p>如果export后面不加变量名称,就会将系统所有变量列出来,等同于set命令.</p>
<h4 id="语系变量"><a href="#语系变量" class="headerlink" title="语系变量"></a>语系变量</h4><ul>
<li><p>查看Linux支持的语系</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ locale -a</span><br><span class="line">....（前面省略）....</span><br><span class="line">zh_TW</span><br><span class="line">zh_TW<span class="selector-class">.big5</span>     &lt;==大五码的中文编码</span><br><span class="line">zh_TW.euctw</span><br><span class="line">zh_TW<span class="selector-class">.utf8</span>     &lt;==万国码的中文编码</span><br><span class="line">zu_ZA</span><br><span class="line">zu_ZA.iso88591</span><br><span class="line">zu_ZA.utf8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>修改Linux语系</p>
  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">locale  &lt;==后面不加任何选项与参数即可！</span><br><span class="line">LANG=en_US                   &lt;==主语言的环境</span><br><span class="line">LC_CTYPE=<span class="string">"en_US"</span>             &lt;==字符（文字）辨识的编码</span><br><span class="line">LC_NUMERIC=<span class="string">"en_US"</span>           &lt;==数字系统的显示讯息</span><br><span class="line">LC_TIME=<span class="string">"en_US"</span>              &lt;==时间系统的显示数据</span><br><span class="line">LC_COLLATE=<span class="string">"en_US"</span>           &lt;==字串的比较与排序等</span><br><span class="line">LC_MONETARY=<span class="string">"en_US"</span>          &lt;==币值格式的显示等</span><br><span class="line">LC_MESSAGES=<span class="string">"en_US"</span>          &lt;==讯息显示的内容，如功能表、错误讯息等</span><br><span class="line">LC_ALL=                      &lt;==整体语系的环境</span><br><span class="line">....（后面省略）....</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>可以逐一设置每个与语系有关的变量数据,可也以直接设置LANG或LC_ALL(其它语系变量会被这两个变量所取代).

系统默认语系文件是: **/etc/locale.conf**
</code></pre><h4 id="变量范围"><a href="#变量范围" class="headerlink" title="变量范围"></a>变量范围</h4><p>环境变量可以被子程序引用的原理:</p>
<ol>
<li>当启动一个shell,系统会分配一个记忆区给shell使用,使此内存内的变量,即环境变量可让子程序使用.</li>
<li>若父程序用export功能,将自定变量内容写到上述内存区块当中(环境变量).</li>
<li>当载入另一个shell时(亦启动一个子程序,离开原本父程序),子程序可以将父shell的环境变量所在记忆区导入自己的环境变量区块当中.</li>
</ol>
<h4 id="变量键盘读取-阵列与宣告"><a href="#变量键盘读取-阵列与宣告" class="headerlink" title="变量键盘读取/阵列与宣告"></a>变量键盘读取/阵列与宣告</h4><ul>
<li><p>read命令<br>  程序执行的过程当中，会等待使用者输入 “yes/no” 之类的讯息,和使用者对谈时使用此命令.</p>
  <figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]<span class="symbol">$</span> read [-pt] <span class="keyword">variable</span></span><br><span class="line">选项与参数：</span><br><span class="line">-p  ：后面可以接提示字符！</span><br><span class="line">-t  ：后面可以接等待的“秒数！”这个比较有趣～不会一直等待使用者啦！</span><br></pre></td></tr></table></figure>
</li>
<li><p>declare/typeset<br>  declare 或 typeset 是一样的功能，就是在“宣告变量的类型.</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ <span class="keyword">declare</span> [-aixr] <span class="keyword">variable</span></span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：将后面名为 <span class="keyword">variable</span> 的变量定义成为阵列 （<span class="built_in">array</span>） 类型</span><br><span class="line">-i  ：将后面名为 <span class="keyword">variable</span> 的变量定义成为整数数字 （<span class="built_in">integer</span>） 类型</span><br><span class="line">-x  ：用法与 <span class="keyword">export</span> 一样，就是将后面的 <span class="keyword">variable</span> 变成环境变量；</span><br><span class="line">-r  ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset</span><br><span class="line">-p	 : 仅列出变量类型</span><br><span class="line"></span><br><span class="line">范例一：让变量 <span class="keyword">sum</span> 进行 <span class="number">100</span>+<span class="number">300</span>+<span class="number">50</span> 的加总结果</span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">sum</span>=<span class="number">100</span>+<span class="number">300</span>+<span class="number">50</span></span><br><span class="line">[dmtsai@study ~]$ echo $&#123;<span class="keyword">sum</span>&#125;</span><br><span class="line"><span class="number">100</span>+<span class="number">300</span>+<span class="number">50</span>  &lt;==咦！怎么没有帮我计算加总？因为这是文字体态的变量属性啊！</span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">declare</span> -i <span class="keyword">sum</span>=<span class="number">100</span>+<span class="number">300</span>+<span class="number">50</span></span><br><span class="line">[dmtsai@study ~]$ echo $&#123;<span class="keyword">sum</span>&#125;</span><br><span class="line"><span class="number">450</span>         &lt;==瞭乎？？</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>注意: bash环境下,变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。 所以上述第一个执行的结果才会出现那个情况的；<br>bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0； </p>
</blockquote>
<h4 id="变量内容删除-取代-替换"><a href="#变量内容删除-取代-替换" class="headerlink" title="变量内容删除/取代/替换"></a>变量内容删除/取代/替换</h4><hr>
<p>暂时跳过</p>
<hr>
<h3 id="系统限制关系-ulimit"><a href="#系统限制关系-ulimit" class="headerlink" title="系统限制关系 ulimit"></a>系统限制关系 ulimit</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ ulimit [-SHacdfltu] [配额]</span><br><span class="line">选项与参数：</span><br><span class="line">-<span class="ruby">H  ：hard limit ，严格的设置，必定不能超过这个设置的数值；</span></span><br><span class="line"><span class="ruby">-S  ：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。</span></span><br><span class="line"><span class="ruby">      在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 <span class="number">80</span> 而 hard </span></span><br><span class="line"><span class="ruby">      设置为 <span class="number">100</span>，那么你可以使用到 <span class="number">90</span> （因为没有超过 <span class="number">100</span>），但介于 <span class="number">80</span>~<span class="number">100</span> 之间时，</span></span><br><span class="line"><span class="ruby">      系统会有警告讯息通知你！</span></span><br><span class="line"><span class="ruby">-a  ：后面不接任何选项与参数，可列出所有的限制额度；</span></span><br><span class="line"><span class="ruby">-c  ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用），</span></span><br><span class="line"><span class="ruby">      这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量。</span></span><br><span class="line"><span class="ruby">-f  ：此 shell 可以创建的最大文件大小（一般可能设置为 <span class="number">2</span>GB）单位为 KBytes</span></span><br><span class="line"><span class="ruby">-d  ：程序可使用的最大断裂内存（segment）容量；</span></span><br><span class="line"><span class="ruby">-l  ：可用于锁定 （lock） 的内存量</span></span><br><span class="line"><span class="ruby">-t  ：可使用的最大 CPU 时间 （单位为秒）</span></span><br><span class="line"><span class="ruby">-u  ：单一使用者可以使用的最大程序（process）数量。</span></span><br><span class="line"><span class="ruby">-n &lt;文件数目&gt;：指定同一时间最多可开启的文件数；</span></span><br></pre></td></tr></table></figure>
<h3 id="命令别名与历史命令"><a href="#命令别名与历史命令" class="headerlink" title="命令别名与历史命令"></a>命令别名与历史命令</h3><h4 id="别名设置-alias-unalias"><a href="#别名设置-alias-unalias" class="headerlink" title="别名设置 alias / unalias"></a>别名设置 alias / unalias</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置别名</span></span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">alias</span> lm='<span class="keyword">ls</span> -al | more</span><br><span class="line"><span class="comment">#取消别名</span></span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">unalias</span> lm</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置别名,在机器重启后将丢失,如果想永久存在,需要写在~/.bash_profile文件内</p>
</blockquote>
<h4 id="历史命令-history"><a href="#历史命令-history" class="headerlink" title="历史命令 history"></a>历史命令 history</h4><p>历史命令记录在~/.bash_history文件中,记录的数量由HISTFILESIZE环境变量决定.</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ history [-raw] histfiles</span><br><span class="line">选项与参数：</span><br><span class="line">n   ：数字，意思是“要列出最近的 n 笔命令列表”的意思！</span><br><span class="line">-c  ：将目前的 <span class="keyword">shell</span><span class="bash"> 中的所有 <span class="built_in">history</span> 内容全部消除</span></span><br><span class="line"><span class="bash">-a  ：将目前新增的 <span class="built_in">history</span> 指令新增入 histfiles 中，若没有加 histfiles ，</span></span><br><span class="line"><span class="bash">      则默认写入 ~/.bash_history</span></span><br><span class="line"><span class="bash">-r  ：将 histfiles 的内容读到目前这个 shell 的 <span class="built_in">history</span> 记忆中；</span></span><br><span class="line"><span class="bash">-w  ：将目前的 <span class="built_in">history</span> 记忆内容写入 histfiles 中！</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>历史命令的使用:</p>
  <figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ !</span><br><span class="line">选项与参数：</span><br><span class="line">number  ：执行第几笔指令的意思；</span><br><span class="line">command ：由最近的指令向前搜寻“指令串开头为 command”的那个指令，并执行；</span><br><span class="line">!!      ：就是执行上一个指令（相当于按↑按键后，按 Enter）</span><br></pre></td></tr></table></figure>
</li>
<li><p>同一帐号同时多次登陆的history写入问题</p>
<p>  因为这些 bash 在同时以同一个身份登陆， 因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到登出时才会更新记录文件，所以，最后登出的那个 bash 才会是最后写入的数据。如此一来其他 bash 的指令操作就不会被记录下来了 （其实有被记录，只是被后来的最后一个 bash 所覆盖更新了） 。</p>
</li>
<li><p>历史命令时间问题<br>  历史命令还有一个问题，那就是无法记录指令下达的时间。由于这 1000 笔历史命令是依序记录的， 但是并没有记录时间，所以在查询方面会有一些不方便。其实可以通过~/.bash_logout 来进行 history 的记录，并加上 date 来增加时间参数.</p>
</li>
</ul>
<h2 id="Bash-Shell操作环境"><a href="#Bash-Shell操作环境" class="headerlink" title="Bash Shell操作环境"></a>Bash Shell操作环境</h2><h3 id="Bash-进站欢迎信息-etc-issue-etc-motd"><a href="#Bash-进站欢迎信息-etc-issue-etc-motd" class="headerlink" title="Bash 进站欢迎信息 /etc/issue  /etc/motd"></a>Bash 进站欢迎信息 /etc/issue  /etc/motd</h3><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">issue 内的各代码意义:</span><br><span class="line">	<span class="string">\d</span> 本地端时间的日期；</span><br><span class="line">	<span class="string">\l</span> 显示第几个终端机接口；</span><br><span class="line">	<span class="string">\m</span> 显示硬件的等级 （i386/i486/i586/i686...）；</span><br><span class="line">	<span class="string">\n</span> 显示主机的网络名称；</span><br><span class="line">	<span class="string">\O</span> 显示 domain name；</span><br><span class="line">	<span class="string">\r</span> 操作系统的版本 （相当于 uname -r）</span><br><span class="line">	<span class="string">\t</span> 显示本地端时间的时间；</span><br><span class="line">	<span class="string">\S</span> 操作系统的名称；</span><br><span class="line">	<span class="string">\v</span> 操作系统的版本</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当我们使用 telnet 连接到主机时，主机的登陆画面就会显示 /etc/issue.net 而不是 /etc/issue<br>/etc/motd 里面显示的则是文字信息</p>
</blockquote>
<h3 id="bash环境配置文件"><a href="#bash环境配置文件" class="headerlink" title="bash环境配置文件"></a>bash环境配置文件</h3><h4 id="login与non-login-Shell"><a href="#login与non-login-Shell" class="headerlink" title="login与non-login Shell"></a>login与non-login Shell</h4><ul>
<li><p>login shell：取得 bash 时需要完整的登陆流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登陆，需要输入使用者的帐号与密码，此时取得的 bash 就称为“ login shell ”</p>
</li>
<li><p>non-login shell：取得 bash 接口的方法不需要重复登陆的举动，举例来说，（1）你以 X window 登陆 Linux 后， 再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入帐号与密码，那个 bash 的环境就称为 non-login shell了。（2）你在原本的 bash 环境下再次下达 bash 这个指令，同样的也没有输入帐号密码， 那第二个 bash （子程序） 也是 non-login shell 。</p>
</li>
</ul>
<blockquote>
<p>这两个Shell，读取的配置文件数据并不一样.</p>
</blockquote>
<h4 id="etc-profile-login-Shell读取"><a href="#etc-profile-login-Shell读取" class="headerlink" title="/etc/profile (login Shell读取)"></a>/etc/profile (login Shell读取)</h4><p>这个配置文件可以利用使用者的识别码 （UID） 来决定很多重要的变量数据， 也是每个使用者登陆取得 bash 时一定会读取的配置文件.所以设置全局环境就要改这个文件!</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">主要变量:</span><br><span class="line">PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；</span><br><span class="line">MAIL：依据帐号设置好使用者的 mailbox 到 /var/spool/mail/帐号名；</span><br><span class="line">USER：根据使用者的帐号设置此一变量内容；</span><br><span class="line">HOSTNAME：依据主机的 hostname 指令决定此一变量内容；</span><br><span class="line">HISTSIZE：历史命令记录笔数。CentOS 7.x 设置为<span class="number"> 1000 </span>；</span><br><span class="line">umask：包括 root 默认为<span class="number"> 022 </span>而一般用户为<span class="number"> 002 </span>等！</span><br></pre></td></tr></table></figure>
<blockquote>
<p>/etc/profile 还会调用外部的设置数据,主要有如下:</p>
</blockquote>
<ul>
<li><p>/etc/profile.d/*.sh<br>  “这个目录内的众多文件！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使用者能够具有 r 的权限， 那么该文件就会被 /etc/profile 调用进来。在 CentOS 7.x 中，这个目录下面的文件规范了 bash 操作接口的颜色、 语系、ll 与 ls 指令的命令别名、vi 的命令别名、which 的命令别名等等。如果你需要帮所有使用者设置一些共享的命令别名时， 可以在这个目录下面自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可！</p>
</li>
<li><p>/etc/locale.conf<br>  这个文件是由 /etc/profile.d/lang.sh 调用进来的！这也是我们决定 bash 默认使用何种语系的重要配置文件！ 文件里最重要的就是 LANG/LC_ALL 这些个变量的设置！</p>
</li>
<li><p>/usr/share/bash-completion/completions/*<br>  这个目录下除前面谈过 [tab] 命令补齐、文件名补齐之外，还可以进行指令的选项/参数补齐功能！那就是从这个目录里面找到相对应的指令来处理的！ 其实这个目录下面的内容是由 /etc/profile.d/bash_completion.sh 这个文件载入的啦！</p>
</li>
</ul>
<h4 id="bash-profile-login-Shell读取"><a href="#bash-profile-login-Shell读取" class="headerlink" title="~/.bash_profile (login Shell读取)"></a>~/.bash_profile (login Shell读取)</h4><p>bash 在读完了整体环境设置的 /etc/profile 并借此调用其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. ~/.bash_profile</span><br><span class="line"><span class="number">2</span>. ~/.bash_login</span><br><span class="line"><span class="number">3</span>. ~/.profile</span><br></pre></td></tr></table></figure>
<p>其实 bash 的 login shell 设置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 ~/.bash_profile 存在，那么其他两个文件不论有无存在，都不会被读取。 如果 ~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思。 会有这么多的文件，其实是因应其他 shell 转换过来的使用者的习惯而已。</p>
<p><img src="/2018/03/06/Linux/Linux的Bash/QQ20180315-174127@2x.png" alt="shell 读取流程"></p>
<h4 id="source-读入环境配置文件指令"><a href="#source-读入环境配置文件指令" class="headerlink" title="source 读入环境配置文件指令"></a>source 读入环境配置文件指令</h4><p>由于 /etc/profile 与 ~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以， 如果你将自己的偏好设置写入上述的文件后，通常都是得登出再登陆后，该设置才会生效。利用这个指令可以直接生效!</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ <span class="keyword">source</span> 配置文件文件名</span><br><span class="line"></span><br><span class="line">范例：将主文件夹的 ~/.bashrc 的设置读入目前的 bash 环境中</span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">source</span> ~/.bashrc  &lt;==下面这两个指令是一样的！</span><br><span class="line">[dmtsai@study ~]$  .  ~/.bashrc</span><br></pre></td></tr></table></figure>
<h4 id="bashrc-（non-login-shell-读取）"><a href="#bashrc-（non-login-shell-读取）" class="headerlink" title="~/.bashrc （non-login shell 读取）"></a>~/.bashrc （non-login shell 读取）</h4><p>CentOS 7.x 还会主动的调用 /etc/bashrc 这个文件<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/etc/bashrc文件记录内容</span><br><span class="line"><span class="bullet">1. </span>依据不同的 UID 规范出 umask 的值；</span><br><span class="line"><span class="bullet">2. </span>依据不同的 UID 规范出提示字符 （就是 PS1 变量）；</span><br><span class="line"><span class="bullet">3. </span>调用 /etc/profile.d/*.sh 的设置</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>/etc/bashrc文件是Red Hat系统特有的,如果此文件丢失,可以复制 /etc/skel/.bashrc 到你的主文件夹.</p>
</blockquote>
<h3 id="终端机环境设置-stty-set"><a href="#终端机环境设置-stty-set" class="headerlink" title="终端机环境设置 stty , set"></a>终端机环境设置 stty , set</h3><h4 id="stty命令"><a href="#stty命令" class="headerlink" title="stty命令"></a>stty命令</h4><p>查阅目前的一些按键内容</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ stty [-a]</span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：将目前所有的 stty 参数列出来；</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出所有的按键与按键内容</span></span><br><span class="line">[dmtsai@study ~]$ stty -a</span><br><span class="line">speed <span class="number">38400</span> baud; rows <span class="number">20</span>; columns <span class="number">90</span>; <span class="attr">line</span> = <span class="number">0</span>;</span><br><span class="line"><span class="attr">intr</span> = ^C; <span class="attr">quit</span> = ^\; <span class="attr">erase</span> = ^?; <span class="attr">kill</span> = ^U; <span class="attr">eof</span> = ^D; <span class="attr">eol</span> = &lt;undef&gt;; <span class="attr">eol2</span> = &lt;undef&gt;;</span><br><span class="line"><span class="attr">swtch</span> = &lt;undef&gt;; <span class="attr">start</span> = ^Q; <span class="attr">stop</span> = ^S; <span class="attr">susp</span> = ^Z; <span class="attr">rprnt</span> = ^R; <span class="attr">werase</span> = ^W; <span class="attr">lnext</span> = ^V;</span><br><span class="line"><span class="attr">flush</span> = ^O; <span class="attr">min</span> = <span class="number">1</span>; <span class="attr">time</span> = <span class="number">0</span>;</span><br><span class="line">....（以下省略）....</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置按键</span></span><br><span class="line">[dmtsai@study ~]$ stty erase ^h</span><br><span class="line"></span><br><span class="line">意义:</span><br><span class="line">intr  : 送出一个 interrupt （中断） 的讯号给目前正在 执行的程序 （就是终止啰！）；</span><br><span class="line">quit  : 送出一个 quit 的讯号给目前正在执行的程序；</span><br><span class="line">erase : 向后删除字符，</span><br><span class="line">kill  : 删除在目前命令行上的所有文字；</span><br><span class="line">eof   : End of file 的意思，代表“结束输入”。</span><br><span class="line">start : 在某个程序停止后，重新启动他的 output</span><br><span class="line">stop  : 停止目前屏幕的输出；</span><br><span class="line">susp  : 送出一个 terminal stop 的讯号给正在 run 的程序。</span><br></pre></td></tr></table></figure>
<h4 id="set命令"><a href="#set命令" class="headerlink" title="set命令"></a>set命令</h4><hr>
<p>暂无</p>
<hr>
<h3 id="万用字符与特殊符号"><a href="#万用字符与特殊符号" class="headerlink" title="万用字符与特殊符号"></a>万用字符与特殊符号</h3><p>万用字符:</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*	代表“ <span class="number">0</span> 个到无穷多个”任意字符</span><br><span class="line">?	代表“一定有一个”任意字符</span><br><span class="line"><span class="string">[]</span>	同样代表“一定有一个在括号内”的字符（非任意字符）。例如 <span class="string">[abcd]</span> 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”</span><br><span class="line"></span><br><span class="line"><span class="string">[-]</span>	若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 <span class="string">[0-9]</span> 代表 <span class="number">0</span> 到 <span class="number">9</span> 之间的所有数字，因为数字的语系编码是连续的！</span><br><span class="line"></span><br><span class="line"><span class="string">[^]</span>	若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”，例如 <span class="string">[^abc]</span> 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</span><br></pre></td></tr></table></figure>
<p>特殊字符:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#	注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</span></span><br><span class="line">\	跳脱符号：将“特殊字符或万用字符”还原成一般字符</span><br><span class="line">|	管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；</span><br><span class="line">;	连续指令下达分隔符号：连续性命令的界定 （注意<span class="symbol">:</span>与管线命令并不相同）</span><br><span class="line">~	使用者的主文件夹</span><br><span class="line"><span class="variable">$	</span>取用变量前置字符：亦即是变量之前需要加的变量取代值</span><br><span class="line">&amp;	工作控制 （job control）：将指令变成背景下工作</span><br><span class="line">!	逻辑运算意义上的“非” <span class="keyword">not</span> 的意思！</span><br><span class="line">/	目录符号：路径分隔的符号</span><br><span class="line">&gt;, &gt;&gt;	数据流重导向：输出导向，分别是“取代”与“累加”</span><br><span class="line">&lt;, &lt;&lt;	数据流重导向：输入导向 </span><br><span class="line"><span class="string">''</span>	单引号，不具有变量置换的功能 （<span class="variable">$ </span>变为纯文本）</span><br><span class="line"><span class="string">""</span>	具有变量置换的功能！ （<span class="variable">$ </span>可保留相关功能）</span><br><span class="line">``	两个“ ` ”中间为可以先执行的指令，亦可使用 <span class="variable">$（</span> ）</span><br><span class="line">()	在中间为子 shell 的起始与结束</span><br><span class="line">&#123;&#125;	在中间为命令区块的组合！</span><br></pre></td></tr></table></figure>
<h2 id="数据流重导向"><a href="#数据流重导向" class="headerlink" title="数据流重导向"></a>数据流重导向</h2><h3 id="数据流输入-输出"><a href="#数据流输入-输出" class="headerlink" title="数据流输入/输出"></a>数据流输入/输出</h3><p><strong><em>标准输出</em></strong>:指的是“指令执行所回传的正确的讯息”<br><strong><em>标准错误输出</em></strong>:“ 指令执行失败后，所回传的错误讯息”  </p>
<blockquote>
<p>标准输入　　（stdin） ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；<br>标准输出　　（stdout）：代码为 1 ，使用 &gt; 或 &gt;&gt; ；<br>标准错误输出（stderr）：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</p>
</blockquote>
<h4 id="dev-null-垃圾桶黑洞设备与特殊写法"><a href="#dev-null-垃圾桶黑洞设备与特殊写法" class="headerlink" title="/dev/null 垃圾桶黑洞设备与特殊写法"></a>/dev/null 垃圾桶黑洞设备与特殊写法</h4><p>/dev/null 可以吃掉任何导向这个设备的信息 </p>
<h4 id="2-gt-amp-amp-gt"><a href="#2-gt-amp-amp-gt" class="headerlink" title="2&gt;&amp; | &amp;&gt;"></a>2&gt;&amp; | &amp;&gt;</h4><pre><code><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将指令的数据全部写入名为 list 的文件中(包括错误信息)</span></span><br><span class="line">[dmtsai<span class="meta">@study</span> ~]$ <span class="keyword">find</span> /home -name .bashrc &gt; <span class="keyword">list</span> <span class="number">2</span>&gt;&amp;<span class="number">1</span>    </span><br><span class="line">[dmtsai<span class="meta">@study</span> ~]$ <span class="keyword">find</span> /home -name .bashrc &amp;&gt; <span class="keyword">list</span></span><br></pre></td></tr></table></figure>
</code></pre><h4 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#利用 cat 指令来创建一个文件的简单流程</span><br><span class="line">[dmtsai@study ~]$ cat &gt; catfile</span><br><span class="line">testing</span><br><span class="line">cat file test</span><br><span class="line">&lt;==这里按下 [ctrl]+d 来离开</span><br><span class="line"></span><br><span class="line">[dmtsai@study ~]$ cat catfile</span><br><span class="line">testing</span><br><span class="line">cat file test</span><br><span class="line"></span><br><span class="line">#用 stdin 取代键盘的输入以创建新文件的简单流程</span><br><span class="line">[dmtsai@study ~]$ cat &gt; catfile &lt; ~/.bashrc</span><br><span class="line">[dmtsai@study ~]$ ll catfile ~/.bashrc</span><br><span class="line"># 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！</span><br><span class="line">-rw-r--r--. 1 dmtsai dmtsai 231 Mar  6 06:06 /home/dmtsai/.bashrc</span><br><span class="line">-rw-rw-r--. 1 dmtsai dmtsai 231 Jul  9 18:58 catfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#用 cat 直接将输入的讯息输出到 catfile 中， 且当由键盘输入 eof 时，该次输入就结束</span><br><span class="line">[dmtsai@study ~]$ cat &gt; catfile &lt;&lt; "eof"</span><br><span class="line">&gt; This is a test.</span><br><span class="line">&gt; OK now stop</span><br><span class="line">&gt; eof  &lt;==输入这关键字，立刻就结束而不需要输入 [ctrl]+d</span><br><span class="line"></span><br><span class="line">[dmtsai@study ~]$ cat catfile</span><br><span class="line">This is a test.</span><br><span class="line">OK now stop     &lt;==只有这两行，不会存在关键字那一行！</span><br></pre></td></tr></table></figure>
<h3 id="命令执行的判断依据-amp-amp"><a href="#命令执行的判断依据-amp-amp" class="headerlink" title="命令执行的判断依据 ;  &amp;&amp;  ||"></a>命令执行的判断依据 ;  &amp;&amp;  ||</h3><h4 id="不考虑指令相关性的连续指令下达-cmd-cmd"><a href="#不考虑指令相关性的连续指令下达-cmd-cmd" class="headerlink" title="不考虑指令相关性的连续指令下达 cmd;cmd"></a>不考虑指令相关性的连续指令下达 cmd;cmd</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="meta">@study</span> ~]# <span class="keyword">sync</span>; <span class="keyword">sync</span>; shutdown -h now</span><br></pre></td></tr></table></figure>
<h4 id="（指令回传值）-与-amp-amp-或"><a href="#（指令回传值）-与-amp-amp-或" class="headerlink" title="$? （指令回传值） 与 &amp;&amp; 或 ||"></a>$? （指令回传值） 与 &amp;&amp; 或 ||</h4><p>若前一个指令执行的结果为正确，在 Linux 下面会回传一个 $? = 0 的值</p>
<table><br>    <tr><br>        <th>指令</th><br>        <th>说明</th><br>    </tr><br>    <tr><br>        <td>cmd1 &amp;&amp; cmd2</td><br>        <td><br>        1. 若 cmd1 执行完毕且正确执行（$?=0），则开始执行 cmd2。<br><br>        2. 若 cmd1 执行完毕且为错误 （$?≠0），则 cmd2 不执行。</td><br>    </tr><br>    <tr><br>        <td>cmd1 || cmd2</td><br>        <td><br>        1. 若 cmd1 执行完毕且正确执行（$?=0），则 cmd2 不执行。<br><br>        2. 若 cmd1 执行完毕且为错误 （$?≠0），则开始执行 cmd2。</td><br>    </tr><br></table>

<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ <span class="keyword">ls</span> /tmp/<span class="keyword">abc</span> || <span class="built_in">mkdir</span> /tmp/<span class="keyword">abc</span> &amp;&amp; touch /tmp/<span class="keyword">abc</span>/hehe</span><br></pre></td></tr></table></figure>
<p>Linux 下面的指令都是由左往右执行,上面执行结果:<br><em>情况一:</em><br>（1）若 /tmp/abc 不存在故回传 $?≠0，则<br>（2）因为 || 遇到非为 0 的 \$? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc 会成功进行，所以回传 \$?=0<br>（3）因为 &amp;&amp; 遇到 \$?=0 故会执行 touch /tmp/abc/hehe，最终 hehe 就被创建了；</p>
<p><em>情况二:</em><br>（1）若 /tmp/abc 存在故回传 $?=0，则<br>（2）因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故<br>（3）因为 &amp;&amp; 遇到 \$?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。</p>
<p><img src="/2018/03/06/Linux/Linux的Bash/QQ20180316-134233@2x.png" alt="指令执行关系示意图"></p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls /tmp/vbirding || <span class="built_in">echo</span> "<span class="keyword">not</span> <span class="keyword">exist</span>" &amp;&amp; <span class="built_in">echo</span> "<span class="keyword">exist</span>”</span><br><span class="line">#返回结果:</span><br><span class="line"><span class="keyword">not</span> <span class="keyword">exist</span></span><br><span class="line"><span class="keyword">exist</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于指令是一个接着一个去执行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错(如上面例子).<br>一般来说，假设判断式有三个，也就是：<br>command1 &amp;&amp; command2 || command3</p>
</blockquote>
<h2 id="管线命令-pipe"><a href="#管线命令-pipe" class="headerlink" title="管线命令(pipe)"></a>管线命令(pipe)</h2><p><strong>管线命令使用的是“ | ”这个界定符号！ 另外，管线命令与“连续下达命令”是不一样！</strong><br><strong>管线命令“ | ”仅能处理经由前面一个指令传来的正确信息，也就是 standard output 的信息，对于 stdandard error 并没有直接处理的能力.</strong><br><strong>每个管线后面接的第一个数据必定是“指令”喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以是为“管线命令”</strong></p>
<h3 id="撷取命令-cut-grep"><a href="#撷取命令-cut-grep" class="headerlink" title="撷取命令 cut grep"></a>撷取命令 cut grep</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>将一段讯息的某一段给他“切”出来～ 处理的讯息是以“行”为单位</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>cut -d<span class="string">'分隔字符'</span> -f fields &lt;==用于有特定分隔字符</span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>cut -c 字符区间            &lt;==用于排列整齐的讯息</span><br><span class="line">选项与参数：</span><br><span class="line">-d  ：后面接分隔字符。与 -f 一起使用；</span><br><span class="line">-f  ：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；</span><br><span class="line">-c  ：以字符 （characters） 的单位取出固定字符区间；</span><br><span class="line"></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>echo <span class="variable">$&#123;</span>PATH&#125; | cut -d <span class="string">':'</span> -f <span class="number">5</span> <span class="comment">#显示切割后的第5个</span></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>echo <span class="variable">$&#123;</span>PATH&#125; | cut -d <span class="string">':'</span> -f <span class="number">3</span>,<span class="number">5</span> <span class="comment">#显示切割后的3-5个</span></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>echo <span class="variable">$&#123;</span>PATH&#125; | cut -d <span class="string">':'</span> -f <span class="number">3</span>- <span class="comment">#显示切割后的3到最后一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将 export 输出的讯息，取得第 12 字符以后的所有字串</span></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>export</span><br><span class="line">declare -x HISTCONTROL=<span class="string">"ignoredups"</span></span><br><span class="line">declare -x HISTSIZE=<span class="string">"1000"</span></span><br><span class="line">declare -x HOME=<span class="string">"/home/dmtsai"</span></span><br><span class="line">declare -x HOSTNAME=<span class="string">"study.centos.vbird"</span></span><br><span class="line">.....（其他省略）.....</span><br><span class="line"><span class="comment"># 注意看，每个数据都是排列整齐的输出！如果我们不想要“ declare -x ”时，就得这么做：</span></span><br><span class="line"></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>export | cut -c <span class="number">12</span>-</span><br><span class="line">HISTCONTROL=<span class="string">"ignoredups"</span></span><br><span class="line">HISTSIZE=<span class="string">"1000"</span></span><br><span class="line">HOME=<span class="string">"/home/dmtsai"</span></span><br><span class="line">HOSTNAME=<span class="string">"study.centos.vbird"</span></span><br><span class="line">.....（其他省略）.....</span><br></pre></td></tr></table></figure>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ grep [-acinv] [--color=auto] '搜寻字串' filename</span><br><span class="line">选项与参数：</span><br><span class="line">-<span class="ruby">a ：将 binary 文件以 text 文件的方式搜寻数据</span></span><br><span class="line"><span class="ruby">-c ：计算找到 <span class="string">'搜寻字串'</span> 的次数</span></span><br><span class="line"><span class="ruby">-i ：忽略大小写的不同，所以大小写视为相同</span></span><br><span class="line"><span class="ruby">-n ：顺便输出行号</span></span><br><span class="line"><span class="ruby">-v ：反向选择，亦即显示出没有 <span class="string">'搜寻字串'</span> 内容的那一行！</span></span><br><span class="line"><span class="ruby">--color=auto ：可以将找到的关键字部分加上颜色的显示喔！</span></span><br><span class="line"><span class="ruby">-A : 后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；</span></span><br><span class="line"><span class="ruby">-B : 后面可加数字，为 before 的意思，除了列出该行外，前面的 n 行也列出来；</span></span><br></pre></td></tr></table></figure>
<h3 id="排序命令-sort-wc-uniq"><a href="#排序命令-sort-wc-uniq" class="headerlink" title="排序命令 sort wc uniq"></a>排序命令 sort wc uniq</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>sort [-fbMnrtuk] [file <span class="keyword">or</span> stdin]</span><br><span class="line">选项与参数：</span><br><span class="line">-f  ：忽略大小写的差异，例如 A 与 a 视为编码相同；</span><br><span class="line">-b  ：忽略最前面的空白字符部分；</span><br><span class="line">-M  ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；</span><br><span class="line">-n  ：使用“纯数字”进行排序（默认是以文字体态来排序的）；</span><br><span class="line">-r  ：反向排序；</span><br><span class="line">-u  ：就是 uniq ，相同的数据中，仅出现一行代表；</span><br><span class="line">-t  ：分隔符号，默认是用 [tab] 键来分隔；</span><br><span class="line">-k  ：以那个区间 （field） 来进行排序的意思</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？</span></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>cat /etc/passwd | sort -t <span class="string">':'</span> -k <span class="number">3</span></span><br><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span><span class="number">0</span><span class="symbol">:</span><span class="number">0</span><span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span></span><br><span class="line"><span class="symbol">dmtsai:</span><span class="symbol">x:</span><span class="number">1000</span><span class="symbol">:</span><span class="number">1000</span><span class="symbol">:dmtsai</span><span class="symbol">:/home/dmtsai</span><span class="symbol">:/bin/bash</span></span><br><span class="line"><span class="symbol">alex:</span><span class="symbol">x:</span><span class="number">1001</span><span class="symbol">:</span><span class="number">1002</span><span class="symbol">:</span><span class="symbol">:/home/alex</span><span class="symbol">:/bin/bash</span></span><br><span class="line"><span class="symbol">arod:</span><span class="symbol">x:</span><span class="number">1002</span><span class="symbol">:</span><span class="number">1003</span><span class="symbol">:</span><span class="symbol">:/home/arod</span><span class="symbol">:/bin/bash</span></span><br><span class="line"><span class="comment"># 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～</span></span><br><span class="line"><span class="comment"># 如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：</span></span><br><span class="line"><span class="comment"># cat /etc/passwd | sort -t ':' -k 3 -n</span></span><br><span class="line"><span class="comment"># 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</span></span><br></pre></td></tr></table></figure>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>重复的数据仅列出一个显示</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ uni<span class="string">q [-ic]</span></span><br><span class="line">选项与参数：</span><br><span class="line">-i  ：忽略大小写字符的不同；</span><br><span class="line">-c  ：进行计数</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；</span></span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">last</span> | cut -d <span class="string">' '</span> -f1 | <span class="keyword">sort</span> | uniq</span><br><span class="line"></span><br><span class="line"><span class="comment">#承上,继续显示每个帐号登录次数</span></span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">last</span> | cut -d <span class="string">' '</span> -f1 | <span class="keyword">sort</span> | uniq -c</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">      <span class="number">6</span> （unknown</span><br><span class="line">     <span class="number">47</span> dmtsai</span><br><span class="line">      <span class="number">4</span> reboot</span><br><span class="line">      <span class="number">7</span> root</span><br><span class="line">      <span class="number">1</span> wtmp</span><br></pre></td></tr></table></figure>
<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>wc [-lwm]</span><br><span class="line">选项与参数：</span><br><span class="line">-l  ：仅列出行；</span><br><span class="line">-w  ：仅列出多少字（英文单字）；</span><br><span class="line">-m  ：多少字符；</span><br><span class="line"></span><br><span class="line"><span class="comment">#/etc/man_db.conf 里面到底有多少相关字、行、字符数？</span></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>cat /etc/man_db.conf | wc</span><br><span class="line">    <span class="number">131</span>     <span class="number">723</span>    <span class="number">5171</span></span><br><span class="line"><span class="comment"># 输出的三个数字中，分别代表： “行、字数、字符数</span></span><br></pre></td></tr></table></figure>
<h3 id="双重导向tee"><a href="#双重导向tee" class="headerlink" title="双重导向tee"></a>双重导向tee</h3><p>可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理.<br><img src="/2018/03/06/Linux/Linux的Bash/QQ20180319-161532@2x.png" alt="tee工作流程示意图"></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ tee [-a] file</span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：以累加 （append） 的方式，将数据加入 file 当中！</span><br><span class="line"></span><br><span class="line">[dmtsai@study ~]$ ls -l /home <span class="params">| tee ~/homefile |</span> more</span><br><span class="line"><span class="comment"># 将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！</span></span><br><span class="line"></span><br><span class="line">[dmtsai@study ~]$ ls -l / <span class="params">| tee -a ~/homefile |</span> more</span><br><span class="line"><span class="comment"># 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。</span></span><br></pre></td></tr></table></figure>
<h3 id="字符转换命令-tr-col-join-paste-expand"><a href="#字符转换命令-tr-col-join-paste-expand" class="headerlink" title="字符转换命令 tr, col, join, paste, expand"></a>字符转换命令 tr, col, join, paste, expand</h3><h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ <span class="keyword">tr</span> [-ds] SET1 ...</span><br><span class="line">选项与参数：</span><br><span class="line">-d  ：删除讯息当中的 SET1 这个字串；</span><br><span class="line">-<span class="keyword">s</span>  ：取代掉重复的字符！</span><br><span class="line"></span><br><span class="line"><span class="comment">#将 last 输出的讯息中，所有的小写变成大写字符：</span></span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">last</span> | <span class="keyword">tr</span> <span class="string">'[a-z]'</span> <span class="string">'[A-Z]'</span></span><br><span class="line"><span class="comment"># 不加单引号也是可以执行的，如：“ last | tr [a-z] [A-Z] ”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将 /etc/passwd 输出的讯息中，将冒号 （:） 删除</span></span><br><span class="line">[dmtsai@study ~]$ cat /etc/passwd | <span class="keyword">tr</span> -d <span class="string">':'</span></span><br></pre></td></tr></table></figure>
<h4 id="col"><a href="#col" class="headerlink" title="col"></a>col</h4><p>用来简单的处理将 [tab] 按键取代成为空白键.(<strong><em>还有其它用途???</em></strong>)</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ <span class="keyword">col</span> [-xb]</span><br><span class="line">选项与参数：</span><br><span class="line">-<span class="keyword">x</span>  ：将 <span class="keyword">tab</span> 键转换成对等的空白键</span><br><span class="line"></span><br><span class="line">#利用 <span class="keyword">cat</span> -A 显示出所有特殊按键，最后以 <span class="keyword">col</span> 将 [<span class="keyword">tab</span>] 转成空白</span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">cat</span> -A /etc/man_db.<span class="keyword">conf</span>  &lt;==此时会看到很多 ^I 的符号，那就是 <span class="keyword">tab</span></span><br><span class="line">[dmtsai@study ~]$ <span class="keyword">cat</span> /etc/man_db.<span class="keyword">conf</span> | <span class="keyword">col</span> -<span class="keyword">x</span> | <span class="keyword">cat</span> -A | more</span><br></pre></td></tr></table></figure>
<h3 id="分区命令-split"><a href="#分区命令-split" class="headerlink" title="分区命令 split"></a>分区命令 split</h3><p>如果有文件太大，导致一些携带式设备无法复制的问题，split 可以将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ split [-bl] file PREFIX</span><br><span class="line">选项与参数：</span><br><span class="line">-b  ：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；</span><br><span class="line">-l  ：以行数来进行分区。</span><br><span class="line">PREFIX ：代表前置字符的意思，可作为分区文件的前导文字。</span><br></pre></td></tr></table></figure>
<p><code>范例一</code>：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ cd /tmp; split -b 300k /etc/services services</span><br><span class="line">[dmtsai@study tmp]$ ll -k services*</span><br><span class="line">-rw-rw-r--.<span class="number"> 1 </span>dmtsai dmtsai<span class="number"> 307200 </span>Jul <span class="number"> 9 </span>22:52 servicesaa</span><br><span class="line">-rw-rw-r--.<span class="number"> 1 </span>dmtsai dmtsai<span class="number"> 307200 </span>Jul <span class="number"> 9 </span>22:52 servicesab</span><br><span class="line">-rw-rw-r--.<span class="number"> 1 </span>dmtsai dmtsai <span class="number"> 55893 </span>Jul <span class="number"> 9 </span>22:52 servicesac</span><br><span class="line"><span class="comment"># 那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa, xxxab, xxxac 等方式来创建小文件的！</span></span><br></pre></td></tr></table></figure>
<p><code>“范例二</code>：如何将上面的三个小文件合成一个文件，文件名为 servicesback</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用数据流重导向合成文件</span></span><br><span class="line">[dmtsai@study tmp]$ cat services* <span class="meta">&gt;&gt; </span>servicesback</span><br></pre></td></tr></table></figure>
<p><code>范例三</code>：使用 ls -al / 输出的信息中，每十行记录成一个文件</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study tmp]$ ls -al / | split -l<span class="number"> 10 </span>- lsroot</span><br><span class="line">[dmtsai@study tmp]$ wc -l lsroot*</span><br><span class="line"> <span class="number"> 10 </span>lsrootaa</span><br><span class="line"> <span class="number"> 10 </span>lsrootab</span><br><span class="line">  <span class="number"> 4 </span>lsrootac</span><br><span class="line"> <span class="number"> 24 </span>total</span><br><span class="line"><span class="comment"># 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</span></span><br></pre></td></tr></table></figure>
<h3 id="参数代换-xargs-后面貌似不能用alias"><a href="#参数代换-xargs-后面貌似不能用alias" class="headerlink" title="参数代换 xargs(后面貌似不能用alias)"></a>参数代换 xargs(后面貌似不能用alias)</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ xargs [-0epn] command</span><br><span class="line">选项与参数：</span><br><span class="line">-<span class="ruby"><span class="number">0</span>  ：如果输入的 stdin 含有特殊字符，例如 <span class="string">`, \, 空白键等等字符时，这个 -0 参数</span></span></span><br><span class="line"><span class="ruby">      可以将他还原成一般字符。这个参数可以用于特殊状态！</span></span><br><span class="line"><span class="ruby">-e  ：这个是 EOF （<span class="keyword">end</span> of file） 的意思。后面可以接一个字符串，当 xargs 分析到这个字串时，就会停止继续工作！</span></span><br><span class="line"><span class="ruby">-p  ：在执行每个指令的 argument 时，都会询问使用者的意思；</span></span><br><span class="line"><span class="ruby">-n  ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。</span></span><br><span class="line"><span class="ruby">当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！</span></span><br></pre></td></tr></table></figure>
<p><code>范例一</code>：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来.</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>id root</span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）   </span><br><span class="line"><span class="comment"># 这个 id 指令可以查询使用者的 UID/GID 等信息</span></span><br><span class="line"></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>id <span class="variable">$(</span>cut -d <span class="string">':'</span> -f <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！</span></span><br><span class="line"><span class="comment"># 所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！</span></span><br><span class="line"></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>cut -d <span class="string">':'</span> -f <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | id</span><br><span class="line">uid=<span class="number">1000</span> (dmtsai) gid=<span class="number">1000</span> (dmtsai) groups=<span class="number">1000</span> (dmtsai),<span class="number">10</span>(wheel)</span><br><span class="line"><span class="comment"># 因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！</span></span><br><span class="line"></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>cut -d <span class="string">':'</span> -f <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs id</span><br><span class="line"><span class="comment"># 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但id 就接受 1 个参数！</span></span><br><span class="line"></span><br><span class="line">[dmtsai<span class="variable">@study</span> ~]<span class="variable">$ </span>cut -d <span class="string">':'</span> -f <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -n <span class="number">1</span> id</span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">uid=<span class="number">1</span>（bin） gid=<span class="number">1</span>（bin） groups=<span class="number">1</span>（bin）</span><br><span class="line">uid=<span class="number">2</span>（daemon） gid=<span class="number">2</span>（daemon） groups=<span class="number">2</span>（daemon）</span><br><span class="line"><span class="comment"># 通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</span></span><br></pre></td></tr></table></figure>
<p><code>范例二</code>：同上，但是每次执行 id 时，都要询问使用者是否动作？</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ cut -d <span class="string">':'</span> -f <span class="number">1</span> /etc/passwd | head -n <span class="number">3</span> | xargs -p -n <span class="number">1</span> id</span><br><span class="line">id root ?...y</span><br><span class="line">uid=<span class="number">0</span>（root） gid=<span class="number">0</span>（root） groups=<span class="number">0</span>（root）</span><br><span class="line">id bin ?...y</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"># 呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</span><br></pre></td></tr></table></figure>
<p><code>范例三</code>：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai<span class="symbol">@study</span> ~]$ cut -d <span class="string">':'</span> -f <span class="number">1</span> /etc/passwd | xargs -e<span class="string">'sync'</span> -n <span class="number">1</span> id</span><br><span class="line"><span class="meta"># 仔细与上面的案例做比较。也同时注意，那个 -e<span class="string">'sync'</span> 是连在一起的，中间没有空白键。</span></span><br><span class="line"><span class="meta"># 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e<span class="string">'sync'</span> 后，则分析到 sync 这个字串时，</span></span><br><span class="line"><span class="meta"># 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</span></span><br></pre></td></tr></table></figure>
<p><strong><em>很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！</em></strong></p>
<p><code>范例四</code>：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ find /usr/sbin -perm /7000 | xargs ls -l</span><br><span class="line">-rwx--s--x.<span class="number"> 1 </span>root lock     <span class="number"> 11208 </span>Jun<span class="number"> 10 </span><span class="number"> 2014 </span>/usr/sbin/lockdev</span><br><span class="line">-rwsr-xr-x.<span class="number"> 1 </span>root root    <span class="number"> 113400 </span>Mar <span class="number"> 6 </span>12:17 /usr/sbin/mount.nfs</span><br><span class="line">-rwxr-sr-x.<span class="number"> 1 </span>root root     <span class="number"> 11208 </span>Mar <span class="number"> 6 </span>11:05 /usr/sbin/netreport</span><br><span class="line">.....（下面省略）.....</span><br><span class="line"><span class="comment"># 也可以使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！</span></span><br></pre></td></tr></table></figure>
<h3 id="减号-“-“-的用途"><a href="#减号-“-“-的用途" class="headerlink" title="减号 “ - “ 的用途"></a>减号 “ - “ 的用途</h3><p>管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 “-“ 来替代.</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="symbol">@study</span> ~]<span class="meta"># mkdir /tmp/homeback</span></span><br><span class="line">[root<span class="symbol">@study</span> ~]<span class="meta"># tar -cvf - /home | tar -xvf - -C /tmp/homeback</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面这个例子是：“将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - ”。后面的这个 - 则是取用前一个指令的 stdout， 因此，我们就不需要使用 filename 了</p>
</blockquote>
</div><iframe src="/donate/?AliPayQR=/img/20180324_233651.jpg&amp;WeChatQR=/img/20180324_233908.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>风尘</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2018/03/06/Linux/Linux的Bash/">http://fcwalkers.com/2018/03/06/Linux/Linux的Bash/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a>许可协议。转载请注明出处！</li></ul></div><br><div class="tags"><a href="/tags/Linux/">Linux</a><a href="/tags/Linux学习笔记/">Linux学习笔记</a></div><div class="post-nav"><a class="pre" href="/2018/03/21/Linux/Linux正则与文件格式化/">Linux正则与文件格式化</a><a class="next" href="/2018/03/02/Linux/文件压缩:打包:备份/">文件压缩/打包/备份</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'true' == true ? true : false;
var verify = 'true' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'DT0c6B3N0f8LSeaMCR4T8tAS-gzGzoHsz',
  appKey:'lFs9R36F1tvTYeFptG8h2azk',
  placeholder:'请留下你脚印..',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/心情随笔/">心情随笔</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/自娱自乐/">自娱自乐</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/芬芳年华/">芬芳年华</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件开发/">软件开发</a><span class="category-list-count">30</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/音乐/" style="font-size: 15px;">音乐</a> <a href="/tags/GIT/" style="font-size: 15px;">GIT</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Linux学习笔记/" style="font-size: 15px;">Linux学习笔记</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/NodeJs/" style="font-size: 15px;">NodeJs</a> <a href="/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/tags/React学习笔记/" style="font-size: 15px;">React学习笔记</a> <a href="/tags/输入法/" style="font-size: 15px;">输入法</a> <a href="/tags/五笔/" style="font-size: 15px;">五笔</a> <a href="/tags/狗狗/" style="font-size: 15px;">狗狗</a> <a href="/tags/手机/" style="font-size: 15px;">手机</a> <a href="/tags/骑行/" style="font-size: 15px;">骑行</a> <a href="/tags/旅游/" style="font-size: 15px;">旅游</a> <a href="/tags/北戴河/" style="font-size: 15px;">北戴河</a> <a href="/tags/大海/" style="font-size: 15px;">大海</a> <a href="/tags/MV/" style="font-size: 15px;">MV</a> <a href="/tags/翻唱/" style="font-size: 15px;">翻唱</a> <a href="/tags/GIT学习笔记/" style="font-size: 15px;">GIT学习笔记</a> <a href="/tags/汽车/" style="font-size: 15px;">汽车</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/学习笔记/" style="font-size: 15px;">学习笔记</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/MacOS/" style="font-size: 15px;">MacOS</a> <a href="/tags/Properties/" style="font-size: 15px;">Properties</a> <a href="/tags/xhEditor/" style="font-size: 15px;">xhEditor</a> <a href="/tags/struts2/" style="font-size: 15px;">struts2</a> <a href="/tags/Oracle/" style="font-size: 15px;">Oracle</a> <a href="/tags/存储过程/" style="font-size: 15px;">存储过程</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/浏览器/" style="font-size: 15px;">浏览器</a> <a href="/tags/BOM/" style="font-size: 15px;">BOM</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/全文检索/" style="font-size: 15px;">全文检索</a> <a href="/tags/Sphinx/" style="font-size: 15px;">Sphinx</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/13/tech_stack/CSS cursor/">CSS cursor</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/05/blog/小米耍猴第8季/">小米耍猴第8季</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/01/blog/不以成败论英雄/">不以成败论英雄</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/24/blog/迟来的驾照/">迟来的驾照</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/03/blog/圈圈/">圈圈</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/18/tech_stack/全文检索Sphinx之索引独立配置文件/">全文检索Sphinx—多索引配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/29/GIT/GIT学习笔记/">GIT学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/Linux/vim编辑器/">vim编辑器</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/21/Linux/Linux正则与文件格式化/">Linux正则与文件格式化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/Linux/Linux的Bash/">Linux的Bash</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-handshake-o"> 友情链接</i></div><ul></ul><a href="http://xinshushu.com/blog/" title="欣叔博客" target="_blank">欣叔博客</a></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 我的收藏</i></div><ul></ul><a class="fa fa-laptop" href="https://leancloud.cn" title="LeanCloud" target="_blank">LeanCloud</a><ul></ul><a class="fa fa-user-circle-o" href="https://www.foreverblog.cn" title="十年之约" target="_blank">十年之约</a><ul></ul><a class="fa fa-github" href="https://github.com/WindusL" title="GitHub" target="_blank">GitHub</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2013-2018 <a href="/." rel="nofollow">风尘.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a><a rel="nofollow" target="_blank" href="http://www.miibeian.gov.cn">京ICP备18034717号</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" color="0,0,0" opacity="0.5" zIndex="-2" count="50" src="//cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>