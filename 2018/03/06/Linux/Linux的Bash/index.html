<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.6" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.6">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32_32.ico?v=6.0.6">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_32_32.ico?v=6.0.6">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.6" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.0.6',
    sidebar: {"display":"hide","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Shell/etc/shells记录系统所有shell Bash shell 功能命令编修能力 默认指令记忆功能可以达到1000个记录位置~/.bash_history(当前指令用户指令在内存中,登出后才记录到文件此内)   命令与文件实例功能(tab补全) 命令别名设置功能 工作控制/前景背景控制 程序化脚本shell script 万用字符(*)  type指令type 这个指令我们可以知道每">
<meta name="keywords" content="学习笔记,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux的Bash">
<meta property="og:url" content="http://fcwalkers.com/2018/03/06/Linux/Linux的Bash/index.html">
<meta property="og:site_name" content="风尘">
<meta property="og:description" content="Shell/etc/shells记录系统所有shell Bash shell 功能命令编修能力 默认指令记忆功能可以达到1000个记录位置~/.bash_history(当前指令用户指令在内存中,登出后才记录到文件此内)   命令与文件实例功能(tab补全) 命令别名设置功能 工作控制/前景背景控制 程序化脚本shell script 万用字符(*)  type指令type 这个指令我们可以知道每">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-03-23T17:22:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux的Bash">
<meta name="twitter:description" content="Shell/etc/shells记录系统所有shell Bash shell 功能命令编修能力 默认指令记忆功能可以达到1000个记录位置~/.bash_history(当前指令用户指令在内存中,登出后才记录到文件此内)   命令与文件实例功能(tab补全) 命令别名设置功能 工作控制/前景背景控制 程序化脚本shell script 万用字符(*)  type指令type 这个指令我们可以知道每">






  <link rel="canonical" href="http://fcwalkers.com/2018/03/06/Linux/Linux的Bash/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux的Bash | 风尘</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  

  <div class="container  page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> 

<div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">风尘</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">每个人的心里都有一扇窗!</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
          
  <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
</li>

      
        
        
          
  <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
</li>

      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>


  



 </div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/WindusL" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://fcwalkers.com/2018/03/06/Linux/Linux的Bash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Windus">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="风尘">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Linux的Bash</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-06T17:34:02+08:00">2018-03-06</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/软件开发/" itemprop="url" rel="index"><span itemprop="name">软件开发</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>/etc/shells记录系统所有shell</p>
<h2 id="Bash-shell-功能"><a href="#Bash-shell-功能" class="headerlink" title="Bash shell 功能"></a>Bash shell 功能</h2><h3 id="命令编修能力"><a href="#命令编修能力" class="headerlink" title="命令编修能力"></a>命令编修能力</h3><blockquote>
<p>默认指令记忆功能可以达到1000个<br>记录位置~/.bash_history(当前指令用户指令在内存中,登出后才记录到文件此内)</p>
</blockquote>
<ul>
<li>命令与文件实例功能(tab补全)</li>
<li>命令别名设置功能</li>
<li>工作控制/前景背景控制</li>
<li>程序化脚本shell script</li>
<li>万用字符(*)</li>
</ul>
<h3 id="type指令"><a href="#type指令" class="headerlink" title="type指令"></a>type指令</h3><p>type 这个指令我们可以知道每个指令是否为 bash 的内置指令。 此外，type只能查找可执行文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ type [-tpa] name</span><br><span class="line">选项与参数：</span><br><span class="line">    ：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令</span><br><span class="line">-t  ：当加入 -t 参数时，type 会将 name 以下面这些字眼显示出他的意义：</span><br><span class="line">      file    ：表示为外部指令；</span><br><span class="line">      alias   ：表示该指令为命令别名所设置的名称；</span><br><span class="line">      builtin ：表示该指令为 bash 内置的指令功能；</span><br><span class="line">-p  ：如果后面接的 name 为外部指令时，才会显示完整文件名；</span><br><span class="line">-a  ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias</span><br></pre></td></tr></table></figure>
<h3 id="快速编辑"><a href="#快速编辑" class="headerlink" title="快速编辑"></a>快速编辑</h3><ul>
<li><p>反斜杠( \ )<br>命令输入太长需要换行,利用反斜杠( \ )[Enter]开启下一行,而不执行命令.<br><strong>注意: [Enter] 按键是紧接着反斜线 （ \ ）</strong></p>
</li>
<li><p>快捷键</p>
</li>
</ul>
<table><br>    <tr><br>        <th>组合键</th><br>        <th>功能与示范</th><br>    </tr><br>    <tr><br>        <td>[ctrl]+u/[ctrl]+k</td><br>        <td>分别是从光标处向前删除指令串 （[ctrl]+u） 及向后删除指令串 （[ctrl]+k） </td><br>    </tr><br>    <tr><br>        <td>[ctrl]+a/[ctrl]+e</td><br>        <td>分别是让光标移动到整个指令串的最前面 （[ctrl]+a） 或最后面 （[ctrl]+e） </td><br>    </tr><br>    <tr><br>        <td>Ctrl + C</td><br>        <td>终止目前命令</td><br>    </tr><br>    <tr><br>        <td>Ctrl + D</td><br>        <td>输入结束(EOF),例如:邮件结束的时候</td><br>    </tr><br>    <tr><br>        <td>Ctrl + M</td><br>        <td>就是Enter</td><br>    </tr><br>    <tr><br>        <td>Ctrl + S</td><br>        <td>暂停屏幕输出</td><br>    </tr><br>    <tr><br>        <td>Ctrl + Q</td><br>        <td>恢复屏幕输出</td><br>    </tr><br>    <tr><br>        <td>Ctrl + U</td><br>        <td>在提示字符下，将整列命令删除</td><br>    </tr><br>    <tr><br>        <td>Ctrl + Z</td><br>        <td>“暂停”目前的命令 配合fg/bg/jobs命令使用</td><br>    </tr><br></table>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li>echo 指令<br>显示变量内容,”-e”选项可以格式化打印内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[dmtsai@study ~]$ echo $PATH</span><br></pre></td></tr></table></figure>
<ul>
<li><p>变量设置规则</p>
<ol>
<li>变量与变量内容以一个”=”来连接.<br> <code>myname=Windus</code></li>
<li><p>等号两边不能直接接空白符.</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#错误</span><br><span class="line">myname= Windus</span><br><span class="line">myname=Windus L</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<pre><code>3. 变量内容若有空白符可使用双引号或单引号将变量内容结合起来.  

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">	#双引号内特殊字符可保持原本特性,如:&quot;$&quot;等</span><br><span class="line">	var=&quot;lang is $LANG&quot;</span><br><span class="line">	echo $var --&gt; lang is UTF8</span><br><span class="line">	</span><br><span class="line">	#单引号内的特殊字符仅为一般字符(纯文本)</span><br><span class="line">	var=&apos;lang is $LANG&apos;</span><br><span class="line">	echo $var --&gt; lang is $LANG</span><br><span class="line">	```  </span><br><span class="line"></span><br><span class="line">4. 变量名称只能是英文字母与数字,但开头字符不能是数字.</span><br><span class="line">5. 可用跳脱字符&quot; \\ &quot;,将特殊符号变成一般符号。(如： [Enter], $, \, 空白字符等）  </span><br><span class="line">	`myname=Windus\ L`</span><br><span class="line">6. 在一串指令的执行中，还需要借由其他额外的指令所提供的信息时，可以使用反单引号“`指令`”或 “$（指令）</span><br></pre></td></tr></table></figure>

    version=$（uname -r）
    echo $version --&gt; 3.10.0-229.el7.x86_64
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">7. 若该变量为扩增变量内容时，则可用 &quot;\$变量名称&quot; 或 $&#123;变量&#125; 累加内容</span><br></pre></td></tr></table></figure>

    PATH=&quot;$PATH&quot;:/home/bin
    或
    PATH=${PATH}:/home/bin
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">		</span><br><span class="line">	8. 若该变量需要在其他子程序执行，则需要以 export 来使变量变成环境变量</span><br><span class="line">		`export PATH`</span><br><span class="line">		</span><br><span class="line">	9. 通常大写字符为系统默认变量，自行设置变量可以使用小写字符，方便判断 （纯粹依照使用者兴趣与嗜好,在 Linux 默认的情况中，使用&#123;大写的字母&#125;来设置的变量一般为系统内定需要的变量）</span><br><span class="line">	10. 取消变量用unset</span><br><span class="line">		`unset myname`</span><br><span class="line"></span><br><span class="line">#### 环境变量</span><br><span class="line">- env命令  </span><br><span class="line">	查看所有环境变量</span><br><span class="line">	- HOME 使用者主文件夹变量, ~就会读取此变量</span><br><span class="line">	- SHELL 目前环境使用的SHELL程序(Linux默认:/bin/bash)</span><br><span class="line">	- HISTSIZE 历史命令记录笔数</span><br><span class="line">	- MAIL 当前用户邮箱文件</span><br><span class="line">	- PATH 可执行文件搜寻的路径(目录与目录中间:分隔).由于搜寻顺序依据PATH变量内目录顺序,所以目录顺序也是重要的.</span><br><span class="line">	- LANG 语系数据</span><br><span class="line">	- RANDOM 随机数变量(/dev/random),内容介于0~32767之间.</span><br></pre></td></tr></table></figure>

    #想要获取指定范围内的数,使用delcare声名数值类型
    [dmtsai@study ~]$ declare -i number=$RANDOM*10/32768 ; 
    echo $number
    8   &lt;== 此时会随机取出 0~9 之间的数值喔！
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- set命令</span><br><span class="line">	查看所有变量(含环境变量与自定变量)</span><br><span class="line">	- PS1 提示字符的设置</span><br></pre></td></tr></table></figure>

    \d ：可显示出“星期 月 日”的日期格式，如：&quot;Mon Feb 2&quot;
    \H ：完整的主机名称。举例来说，鸟哥的练习机为“study.centos.vbird”
    \h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为“study”后面省略
    \t ：显示时间，为 24 小时格式的“HH:MM:SS”
    \T ：显示时间，为 12 小时格式的“HH:MM:SS”
    \A ：显示时间，为 24 小时格式的“HH:MM”
    \@ ：显示时间，为 12 小时格式的“am/pm”样式
    \u ：目前使用者的帐号名称，如“dmtsai”；
    \v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46（1）-release，仅取“4.2”显示
    \w ：完整的工作目录名称，由根目录写起的目录名称。但主文件夹会以 ~ 取代；
    \W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
    \# ：下达的第几个指令。
    \$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">		</span><br><span class="line">	- \$ 本shell的PID  </span><br><span class="line">		`echo $$`</span><br><span class="line">	- ? 上个指令的回传值</span><br><span class="line">		执行某些指令时， 这些指令都会回传一个执行后的代码。一般来说，如果成功的执行该指令， 则会回传一个 0 值,如果执行过程发生错误,就会传回错误代码.一般以非0代码取代.</span><br><span class="line">		</span><br><span class="line">- export命令  </span><br><span class="line">	当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，这个程序的识别使用的是一个称为程序识别码，被称为 PID 的就是。 接下来你在这个 bash 下面所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子程序了.</span><br><span class="line">	![程序相关性示意图](img/QQ20180307-115110@2x.png)</span><br><span class="line"></span><br><span class="line">	子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自订变量.所以你在原本 bash 的自订变量在进入了子程序后就会消失不见， 一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！</span><br><span class="line">此时,把自定变量变成环境变量就变得很有必要了:</span><br><span class="line">`export 变量名称`</span><br><span class="line"></span><br><span class="line">如果export后面不加变量名称,就会将系统所有变量列出来,等同于set命令.</span><br><span class="line"></span><br><span class="line">#### 语系变量</span><br><span class="line">- 查看Linux支持的语系</span><br></pre></td></tr></table></figure>

[dmtsai@study ~]$ locale -a
....（前面省略）....
zh_TW
zh_TW.big5     &lt;==大五码的中文编码
zh_TW.euctw
zh_TW.utf8     &lt;==万国码的中文编码
zu_ZA
zu_ZA.iso88591
zu_ZA.utf8
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">- 修改Linux语系</span><br></pre></td></tr></table></figure>

locale  &lt;==后面不加任何选项与参数即可！
LANG=en_US                   &lt;==主语言的环境
LC_CTYPE=&quot;en_US&quot;             &lt;==字符（文字）辨识的编码
LC_NUMERIC=&quot;en_US&quot;           &lt;==数字系统的显示讯息
LC_TIME=&quot;en_US&quot;              &lt;==时间系统的显示数据
LC_COLLATE=&quot;en_US&quot;           &lt;==字串的比较与排序等
LC_MONETARY=&quot;en_US&quot;          &lt;==币值格式的显示等
LC_MESSAGES=&quot;en_US&quot;          &lt;==讯息显示的内容，如功能表、错误讯息等
LC_ALL=                      &lt;==整体语系的环境
....（后面省略）....
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">	可以逐一设置每个与语系有关的变量数据,可也以直接设置LANG或LC_ALL(其它语系变量会被这两个变量所取代).</span><br><span class="line">	</span><br><span class="line">	系统默认语系文件是: **/etc/locale.conf**</span><br><span class="line"></span><br><span class="line">#### 变量范围</span><br><span class="line">环境变量可以被子程序引用的原理:</span><br><span class="line">1. 当启动一个shell,系统会分配一个记忆区给shell使用,使此内存内的变量,即环境变量可让子程序使用.</span><br><span class="line">2. 若父程序用export功能,将自定变量内容写到上述内存区块当中(环境变量).</span><br><span class="line">3. 当载入另一个shell时(亦启动一个子程序,离开原本父程序),子程序可以将父shell的环境变量所在记忆区导入自己的环境变量区块当中.</span><br><span class="line"></span><br><span class="line">#### 变量键盘读取/阵列与宣告</span><br><span class="line">- read命令</span><br><span class="line">	程序执行的过程当中，会等待使用者输入 &quot;yes/no&quot; 之类的讯息,和使用者对谈时使用此命令.</span><br></pre></td></tr></table></figure>

[dmtsai@study ~]$ read [-pt] variable
选项与参数：
-p  ：后面可以接提示字符！
-t  ：后面可以接等待的“秒数！”这个比较有趣～不会一直等待使用者啦！
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- declare/typeset</span><br><span class="line">	declare 或 typeset 是一样的功能，就是在“宣告变量的类型.</span><br></pre></td></tr></table></figure>

[dmtsai@study ~]$ declare [-aixr] variable
选项与参数：
-a  ：将后面名为 variable 的变量定义成为阵列 （array） 类型
-i  ：将后面名为 variable 的变量定义成为整数数字 （integer） 类型
-x  ：用法与 export 一样，就是将后面的 variable 变成环境变量；
-r  ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset
-p     : 仅列出变量类型

范例一：让变量 sum 进行 100+300+50 的加总结果
[dmtsai@study ~]$ sum=100+300+50
[dmtsai@study ~]$ echo ${sum}
100+300+50  &lt;==咦！怎么没有帮我计算加总？因为这是文字体态的变量属性啊！
[dmtsai@study ~]$ declare -i sum=100+300+50
[dmtsai@study ~]$ echo ${sum}
450         &lt;==瞭乎？？
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">	&gt; 注意 : bash环境下,变量类型默认为“字串”，所以若不指定变量类型，则 1+2 为一个“字串”而不是“计算式”。 所以上述第一个执行的结果才会出现那个情况的；</span><br><span class="line">bash 环境中的数值运算，默认最多仅能到达整数形态，所以 1/3 结果是 0； </span><br><span class="line"></span><br><span class="line">#### 变量内容删除/取代/替换</span><br><span class="line">***</span><br><span class="line">暂时跳过</span><br><span class="line">***</span><br><span class="line">	</span><br><span class="line">### 系统限制关系 ulimit</span><br></pre></td></tr></table></figure>
</code></pre><p>[dmtsai@study ~]$ ulimit [-SHacdfltu] [配额]<br>选项与参数：<br>-H  ：hard limit ，严格的设置，必定不能超过这个设置的数值；<br>-S  ：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告讯息。<br>      在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 80 而 hard<br>      设置为 100，那么你可以使用到 90 （因为没有超过 100），但介于 80~100 之间时，<br>      系统会有警告讯息通知你！<br>-a  ：后面不接任何选项与参数，可列出所有的限制额度；<br>-c  ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用），<br>      这种文件就被称为核心文件（core file）。此为限制每个核心文件的最大容量。<br>-f  ：此 shell 可以创建的最大文件大小（一般可能设置为 2GB）单位为 KBytes<br>-d  ：程序可使用的最大断裂内存（segment）容量；<br>-l  ：可用于锁定 （lock） 的内存量<br>-t  ：可使用的最大 CPU 时间 （单位为秒）<br>-u  ：单一使用者可以使用的最大程序（process）数量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 命令别名与历史命令</span><br><span class="line">#### 别名设置 alias / unalias</span><br></pre></td></tr></table></figure></p>
<p>#设置别名<br>[dmtsai@study ~]$ alias lm=’ls -al | more</p>
<p>#取消别名<br>[dmtsai@study ~]$ unalias lm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 设置别名,在机器重启后将丢失,如果想永久存在,需要写在~/.bash_profile文件内</span><br><span class="line"></span><br><span class="line">#### 历史命令 history</span><br><span class="line">历史命令记录在~/.bash_history文件中,记录的数量由HISTFILESIZE环境变量决定.</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ history [-raw] histfiles<br>选项与参数：<br>n   ：数字，意思是“要列出最近的 n 笔命令列表”的意思！<br>-c  ：将目前的 shell 中的所有 history 内容全部消除<br>-a  ：将目前新增的 history 指令新增入 histfiles 中，若没有加 histfiles ，<br>      则默认写入 ~/.bash_history<br>-r  ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中；<br>-w  ：将目前的 history 记忆内容写入 histfiles 中！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 历史命令的使用:</span><br></pre></td></tr></table></figure></p>
<pre><code>[dmtsai@study ~]$ !
选项与参数：
number  ：执行第几笔指令的意思；
command ：由最近的指令向前搜寻“指令串开头为 command”的那个指令，并执行；
!!      ：就是执行上一个指令（相当于按↑按键后，按 Enter）
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 同一帐号同时多次登陆的history写入问题</span><br><span class="line"></span><br><span class="line">	因为这些 bash 在同时以同一个身份登陆， 因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到登出时才会更新记录文件，所以，最后登出的那个 bash 才会是最后写入的数据。如此一来其他 bash 的指令操作就不会被记录下来了 （其实有被记录，只是被后来的最后一个 bash 所覆盖更新了） 。</span><br><span class="line"></span><br><span class="line">- 历史命令时间问题</span><br><span class="line">	历史命令还有一个问题，那就是无法记录指令下达的时间。由于这 1000 笔历史命令是依序记录的， 但是并没有记录时间，所以在查询方面会有一些不方便。其实可以通过~/.bash_logout 来进行 history 的记录，并加上 date 来增加时间参数.</span><br><span class="line"></span><br><span class="line">## Bash Shell操作环境</span><br><span class="line"></span><br><span class="line">### Bash 进站欢迎信息 /etc/issue  /etc/motd</span><br></pre></td></tr></table></figure>
</code></pre><p>issue 内的各代码意义:<br>    \d 本地端时间的日期；<br>    \l 显示第几个终端机接口；<br>    \m 显示硬件的等级 （i386/i486/i586/i686…）；<br>    \n 显示主机的网络名称；<br>    \O 显示 domain name；<br>    \r 操作系统的版本 （相当于 uname -r）<br>    \t 显示本地端时间的时间；<br>    \S 操作系统的名称；<br>    \v 操作系统的版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 当我们使用 telnet 连接到主机时，主机的登陆画面就会显示 /etc/issue.net 而不是 /etc/issue</span><br><span class="line">&gt; /etc/motd 里面显示的则是文字信息</span><br><span class="line"></span><br><span class="line">### bash环境配置文件</span><br><span class="line">#### login与non-login Shell</span><br><span class="line">- login shell：取得 bash 时需要完整的登陆流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 登陆，需要输入使用者的帐号与密码，此时取得的 bash 就称为“ login shell ”</span><br><span class="line"></span><br><span class="line">- non-login shell：取得 bash 接口的方法不需要重复登陆的举动，举例来说，（1）你以 X window 登陆 Linux 后， 再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入帐号与密码，那个 bash 的环境就称为 non-login shell了。（2）你在原本的 bash 环境下再次下达 bash 这个指令，同样的也没有输入帐号密码， 那第二个 bash （子程序） 也是 non-login shell 。</span><br><span class="line"></span><br><span class="line">&gt; 这两个Shell，读取的配置文件数据并不一样.</span><br><span class="line"></span><br><span class="line">#### /etc/profile (login Shell读取)</span><br><span class="line">这个配置文件可以利用使用者的识别码 （UID） 来决定很多重要的变量数据， 也是每个使用者登陆取得 bash 时一定会读取的配置文件.所以设置全局环境就要改这个文件!</span><br></pre></td></tr></table></figure></p>
<p>主要变量:<br>PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；<br>MAIL：依据帐号设置好使用者的 mailbox 到 /var/spool/mail/帐号名；<br>USER：根据使用者的帐号设置此一变量内容；<br>HOSTNAME：依据主机的 hostname 指令决定此一变量内容；<br>HISTSIZE：历史命令记录笔数。CentOS 7.x 设置为 1000 ；<br>umask：包括 root 默认为 022 而一般用户为 002 等！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; /etc/profile 还会调用外部的设置数据,主要有如下:</span><br><span class="line"></span><br><span class="line">- /etc/profile.d/*.sh</span><br><span class="line">	“这个目录内的众多文件！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，使用者能够具有 r 的权限， 那么该文件就会被 /etc/profile 调用进来。在 CentOS 7.x 中，这个目录下面的文件规范了 bash 操作接口的颜色、 语系、ll 与 ls 指令的命令别名、vi 的命令别名、which 的命令别名等等。如果你需要帮所有使用者设置一些共享的命令别名时， 可以在这个目录下面自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可！</span><br><span class="line"></span><br><span class="line">- /etc/locale.conf</span><br><span class="line">	这个文件是由 /etc/profile.d/lang.sh 调用进来的！这也是我们决定 bash 默认使用何种语系的重要配置文件！ 文件里最重要的就是 LANG/LC_ALL 这些个变量的设置！</span><br><span class="line"></span><br><span class="line">- /usr/share/bash-completion/completions/*</span><br><span class="line">	这个目录下除前面谈过 [tab] 命令补齐、文件名补齐之外，还可以进行指令的选项/参数补齐功能！那就是从这个目录里面找到相对应的指令来处理的！ 其实这个目录下面的内容是由 /etc/profile.d/bash_completion.sh 这个文件载入的啦！</span><br><span class="line"></span><br><span class="line">#### ~/.bash_profile (login Shell读取)</span><br><span class="line">bash 在读完了整体环境设置的 /etc/profile 并借此调用其他配置文件后，接下来则是会读取使用者的个人配置文件。 在 login shell 的 bash 环境中，所读取的个人偏好配置文件其实主要有三个，依序分别是：</span><br></pre></td></tr></table></figure></p>
<ol>
<li>~/.bash_profile</li>
<li>~/.bash_login</li>
<li>~/.profile<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其实 bash 的 login shell 设置只会读取上面三个文件的其中一个， 而读取的顺序则是依照上面的顺序。也就是说，如果 ~/.bash_profile 存在，那么其他两个文件不论有无存在，都不会被读取。 如果 ~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思。 会有这么多的文件，其实是因应其他 shell 转换过来的使用者的习惯而已。</span><br><span class="line"></span><br><span class="line">![shell 读取流程](img/QQ20180315-174127@2x.png)</span><br><span class="line"></span><br><span class="line">#### source 读入环境配置文件指令</span><br><span class="line">由于 /etc/profile 与 ~/.bash_profile 都是在取得 login shell 的时候才会读取的配置文件，所以， 如果你将自己的偏好设置写入上述的文件后，通常都是得登出再登陆后，该设置才会生效。利用这个指令可以直接生效!</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>[dmtsai@study ~]$ source 配置文件文件名</p>
<p>范例：将主文件夹的 ~/.bashrc 的设置读入目前的 bash 环境中<br>[dmtsai@study ~]$ source ~/.bashrc  &lt;==下面这两个指令是一样的！<br>[dmtsai@study ~]$  .  ~/.bashrc<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### ~/.bashrc （non-login shell 读取）</span><br><span class="line">CentOS 7.x 还会主动的调用 /etc/bashrc 这个文件</span><br></pre></td></tr></table></figure></p>
<p>/etc/bashrc文件记录内容</p>
<ol>
<li>依据不同的 UID 规范出 umask 的值；</li>
<li>依据不同的 UID 规范出提示字符 （就是 PS1 变量）；</li>
<li>调用 /etc/profile.d/*.sh 的设置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; /etc/bashrc文件是Red Hat系统特有的,如果此文件丢失,可以复制 /etc/skel/.bashrc 到你的主文件夹.</span><br><span class="line"></span><br><span class="line">### 终端机环境设置 stty , set</span><br><span class="line">#### stty命令 </span><br><span class="line">查阅目前的一些按键内容</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>[dmtsai@study ~]$ stty [-a]<br>选项与参数：<br>-a  ：将目前所有的 stty 参数列出来；</p>
<p>#列出所有的按键与按键内容<br>[dmtsai@study ~]$ stty -a<br>speed 38400 baud; rows 20; columns 90; line = 0;<br>intr = ^C; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>;<br>swtch = <undef>; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V;<br>flush = ^O; min = 1; time = 0;<br>….（以下省略）….</undef></undef></undef></p>
<p>#设置按键<br>[dmtsai@study ~]$ stty erase ^h</p>
<p>意义:<br>intr  : 送出一个 interrupt （中断） 的讯号给目前正在 执行的程序 （就是终止啰！）；<br>quit  : 送出一个 quit 的讯号给目前正在执行的程序；<br>erase : 向后删除字符，<br>kill  : 删除在目前命令行上的所有文字；<br>eof   : End of file 的意思，代表“结束输入”。<br>start : 在某个程序停止后，重新启动他的 output<br>stop  : 停止目前屏幕的输出；<br>susp  : 送出一个 terminal stop 的讯号给正在 run 的程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### set命令</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">暂无</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 万用字符与特殊符号</span><br><span class="line">万用字符:</span><br></pre></td></tr></table></figure></p>
<ul>
<li>代表“ 0 个到无穷多个”任意字符<br>?    代表“一定有一个”任意字符<br>[]    同样代表“一定有一个在括号内”的字符（非任意字符）。例如 [abcd] 代表“一定有一个字符， 可能是 a, b, c, d 这四个任何一个”</li>
</ul>
<p>[-]    若有减号在中括号内时，代表“在编码顺序内的所有字符”。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</p>
<p>[^]    若中括号内的第一个字符为指数符号 （^） ，那表示“反向选择”，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">特殊字符:</span><br></pre></td></tr></table></figure></p>
<h1 id="注解符号：这个最常被使用在-script-当中，视为说明！在后的数据均不执行"><a href="#注解符号：这个最常被使用在-script-当中，视为说明！在后的数据均不执行" class="headerlink" title="注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行"></a>注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</h1><p>\    跳脱符号：将“特殊字符或万用字符”还原成一般字符<br>|    管线 （pipe）：分隔两个管线命令的界定（后两节介绍）；<br>;    连续指令下达分隔符号：连续性命令的界定 （注意:与管线命令并不相同）<br>~    使用者的主文件夹<br>$    取用变量前置字符：亦即是变量之前需要加的变量取代值<br>&amp;    工作控制 （job control）：将指令变成背景下工作<br>!    逻辑运算意义上的“非” not 的意思！<br>/    目录符号：路径分隔的符号</p>
<blockquote>
<p>, &gt;&gt;    数据流重导向：输出导向，分别是“取代”与“累加”<br>&lt;, &lt;&lt;    数据流重导向：输入导向<br>‘’    单引号，不具有变量置换的功能 （$ 变为纯文本）<br>“”    具有变量置换的功能！ （$ 可保留相关功能）<br><code></code>    两个“ ` ”中间为可以先执行的指令，亦可使用 $（ ）<br>()    在中间为子 shell 的起始与结束<br>{}    在中间为命令区块的组合！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">## 数据流重导向</span><br><span class="line">### 数据流输入/输出</span><br><span class="line">***标准输出***:指的是“指令执行所回传的正确的讯息”  </span><br><span class="line">***标准错误输出***:“ 指令执行失败后，所回传的错误讯息”  </span><br><span class="line"></span><br><span class="line">&gt; 标准输入　　（stdin） ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；  </span><br><span class="line">&gt; 标准输出　　（stdout）：代码为 1 ，使用 &gt; 或 &gt;&gt; ；  </span><br><span class="line">&gt; 标准错误输出（stderr）：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</span><br><span class="line"></span><br><span class="line">#### /dev/null 垃圾桶黑洞设备与特殊写法</span><br><span class="line">/dev/null 可以吃掉任何导向这个设备的信息 </span><br><span class="line"></span><br><span class="line">#### 2&gt;&amp; | &amp;&gt;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<pre><code>#将指令的数据全部写入名为 list 的文件中(包括错误信息)
[dmtsai@study ~]$ find /home -name .bashrc &gt; list 2&gt;&amp;1    
[dmtsai@study ~]$ find /home -name .bashrc &amp;&gt; list        
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 标准输入</span><br></pre></td></tr></table></figure>
</code></pre><p>#利用 cat 指令来创建一个文件的简单流程<br>[dmtsai@study ~]$ cat &gt; catfile<br>testing<br>cat file test<br>&lt;==这里按下 [ctrl]+d 来离开</p>
<p>[dmtsai@study ~]$ cat catfile<br>testing<br>cat file test</p>
<p>#用 stdin 取代键盘的输入以创建新文件的简单流程<br>[dmtsai@study ~]$ cat &gt; catfile &lt; ~/.bashrc<br>[dmtsai@study ~]$ ll catfile ~/.bashrc</p>
<h1 id="注意看，这两个文件的大小会一模一样！几乎像是使用-cp-来复制一般！"><a href="#注意看，这两个文件的大小会一模一样！几乎像是使用-cp-来复制一般！" class="headerlink" title="注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！"></a>注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！</h1><p>-rw-r–r–. 1 dmtsai dmtsai 231 Mar  6 06:06 /home/dmtsai/.bashrc<br>-rw-rw-r–. 1 dmtsai dmtsai 231 Jul  9 18:58 catfile</p>
<p>#用 cat 直接将输入的讯息输出到 catfile 中， 且当由键盘输入 eof 时，该次输入就结束<br>[dmtsai@study ~]$ cat &gt; catfile &lt;&lt; “eof”</p>
<blockquote>
<p>This is a test.<br>OK now stop<br>eof  &lt;==输入这关键字，立刻就结束而不需要输入 [ctrl]+d</p>
</blockquote>
<p>[dmtsai@study ~]$ cat catfile<br>This is a test.<br>OK now stop     &lt;==只有这两行，不会存在关键字那一行！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 命令执行的判断依据 ;  &amp;&amp;  ||</span><br><span class="line">#### 不考虑指令相关性的连续指令下达 cmd;cmd</span><br></pre></td></tr></table></figure></p>
<p>[root@study ~]# sync; sync; shutdown -h now<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### $? （指令回传值） 与 &amp;&amp; 或 ||</span><br><span class="line">若前一个指令执行的结果为正确，在 Linux 下面会回传一个 $? = 0 的值</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">		&lt;th&gt;指令&lt;/th&gt;</span><br><span class="line">		&lt;th&gt;说明&lt;/th&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">		&lt;td&gt;cmd1 &amp;&amp; cmd2&lt;/td&gt;</span><br><span class="line">		&lt;td&gt;</span><br><span class="line">		1. 若 cmd1 执行完毕且正确执行（$?=0），则开始执行 cmd2。&lt;br/&gt;  </span><br><span class="line">		2. 若 cmd1 执行完毕且为错误 （$?≠0），则 cmd2 不执行。&lt;/td&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">		&lt;td&gt;cmd1 || cmd2&lt;/td&gt;</span><br><span class="line">		&lt;td&gt;</span><br><span class="line">		1. 若 cmd1 执行完毕且正确执行（$?=0），则 cmd2 不执行。&lt;br/&gt;  </span><br><span class="line">		2. 若 cmd1 执行完毕且为错误 （$?≠0），则开始执行 cmd2。&lt;/td&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Linux 下面的指令都是由左往右执行,上面执行结果:  </span><br><span class="line">*情况一:*  </span><br><span class="line">（1）若 /tmp/abc 不存在故回传 $?≠0，则  </span><br><span class="line">（2）因为 || 遇到非为 0 的 \$? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc 会成功进行，所以回传 \$?=0   </span><br><span class="line">（3）因为 &amp;&amp; 遇到 \$?=0 故会执行 touch /tmp/abc/hehe，最终 hehe 就被创建了；</span><br><span class="line"></span><br><span class="line">*情况二:*  </span><br><span class="line">（1）若 /tmp/abc 存在故回传 $?=0，则  </span><br><span class="line">（2）因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故   </span><br><span class="line">（3）因为 &amp;&amp; 遇到 \$?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。</span><br><span class="line"></span><br><span class="line">![指令执行关系示意图](img/QQ20180316-134233@2x.png)</span><br></pre></td></tr></table></figure></p>
<p>ls /tmp/vbirding || echo “not exist” &amp;&amp; echo “exist”</p>
<p>#返回结果:<br>not exist<br>exist<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 由于指令是一个接着一个去执行的，因此，如果真要使用判断， 那么这个 &amp;&amp; 与 || 的顺序就不能搞错(如上面例子).  </span><br><span class="line">&gt; 一般来说，假设判断式有三个，也就是：  </span><br><span class="line">&gt; command1 &amp;&amp; command2 || command3</span><br><span class="line"></span><br><span class="line">## 管线命令(pipe)</span><br><span class="line">**管线命令使用的是“ | ”这个界定符号！ 另外，管线命令与“连续下达命令”是不一样！**   </span><br><span class="line">**管线命令“ | ”仅能处理经由前面一个指令传来的正确信息，也就是 standard output 的信息，对于 stdandard error 并没有直接处理的能力.**  </span><br><span class="line">**每个管线后面接的第一个数据必定是“指令”喔！而且这个指令必须要能够接受 standard input 的数据才行，这样的指令才可以是为“管线命令”**</span><br><span class="line"></span><br><span class="line">### 撷取命令 cut grep</span><br><span class="line">#### cut</span><br><span class="line">将一段讯息的某一段给他“切”出来～ 处理的讯息是以“行”为单位</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ cut -d’分隔字符’ -f fields &lt;==用于有特定分隔字符<br>[dmtsai@study ~]$ cut -c 字符区间            &lt;==用于排列整齐的讯息<br>选项与参数：<br>-d  ：后面接分隔字符。与 -f 一起使用；<br>-f  ：依据 -d 的分隔字符将一段讯息分区成为数段，用 -f 取出第几段的意思；<br>-c  ：以字符 （characters） 的单位取出固定字符区间；</p>
<p>[dmtsai@study ~]$ echo ${PATH} | cut -d ‘:’ -f 5 #显示切割后的第5个<br>[dmtsai@study ~]$ echo ${PATH} | cut -d ‘:’ -f 3,5 #显示切割后的3-5个<br>[dmtsai@study ~]$ echo ${PATH} | cut -d ‘:’ -f 3- #显示切割后的3到最后一个</p>
<p>#将 export 输出的讯息，取得第 12 字符以后的所有字串<br>[dmtsai@study ~]$ export<br>declare -x HISTCONTROL=”ignoredups”<br>declare -x HISTSIZE=”1000”<br>declare -x HOME=”/home/dmtsai”<br>declare -x HOSTNAME=”study.centos.vbird”<br>…..（其他省略）…..</p>
<h1 id="注意看，每个数据都是排列整齐的输出！如果我们不想要“-declare-x-”时，就得这么做："><a href="#注意看，每个数据都是排列整齐的输出！如果我们不想要“-declare-x-”时，就得这么做：" class="headerlink" title="注意看，每个数据都是排列整齐的输出！如果我们不想要“ declare -x ”时，就得这么做："></a>注意看，每个数据都是排列整齐的输出！如果我们不想要“ declare -x ”时，就得这么做：</h1><p>[dmtsai@study ~]$ export | cut -c 12-<br>HISTCONTROL=”ignoredups”<br>HISTSIZE=”1000”<br>HOME=”/home/dmtsai”<br>HOSTNAME=”study.centos.vbird”<br>…..（其他省略）…..<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### grep</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ grep [-acinv] [–color=auto] ‘搜寻字串’ filename<br>选项与参数：<br>-a ：将 binary 文件以 text 文件的方式搜寻数据<br>-c ：计算找到 ‘搜寻字串’ 的次数<br>-i ：忽略大小写的不同，所以大小写视为相同<br>-n ：顺便输出行号<br>-v ：反向选择，亦即显示出没有 ‘搜寻字串’ 内容的那一行！<br>–color=auto ：可以将找到的关键字部分加上颜色的显示喔！<br>-A : 后面可加数字，为 after 的意思，除了列出该行外，后续的 n 行也列出来；<br>-B : 后面可加数字，为 before 的意思，除了列出该行外，前面的 n 行也列出来；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 排序命令 sort wc uniq</span><br><span class="line">#### sort</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ sort [-fbMnrtuk] [file or stdin]<br>选项与参数：<br>-f  ：忽略大小写的差异，例如 A 与 a 视为编码相同；<br>-b  ：忽略最前面的空白字符部分；<br>-M  ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；<br>-n  ：使用“纯数字”进行排序（默认是以文字体态来排序的）；<br>-r  ：反向排序；<br>-u  ：就是 uniq ，相同的数据中，仅出现一行代表；<br>-t  ：分隔符号，默认是用 [tab] 键来分隔；<br>-k  ：以那个区间 （field） 来进行排序的意思</p>
<p>#/etc/passwd 内容是以 : 来分隔的，我想以第三栏来排序，该如何？<br>[dmtsai@study ~]$ cat /etc/passwd | sort -t ‘:’ -k 3<br>root:x:0:0:root:/root:/bin/bash<br>dmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bash<br>alex:x:1001:1002::/home/alex:/bin/bash<br>arod:x:1002:1003::/home/arod:/bin/bash</p>
<h1 id="看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～"><a href="#看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～" class="headerlink" title="看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～"></a>看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～</h1><h1 id="如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序："><a href="#如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：" class="headerlink" title="如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序："></a>如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：</h1><h1 id="cat-etc-passwd-sort-t-‘-’-k-3-n"><a href="#cat-etc-passwd-sort-t-‘-’-k-3-n" class="headerlink" title="cat /etc/passwd | sort -t ‘:’ -k 3 -n"></a>cat /etc/passwd | sort -t ‘:’ -k 3 -n</h1><h1 id="这样才行啊！用那个-n-来告知-sort-以数字来排序啊！"><a href="#这样才行啊！用那个-n-来告知-sort-以数字来排序啊！" class="headerlink" title="这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！"></a>这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### uniq</span><br><span class="line">重复的数据仅列出一个显示</span><br></pre></td></tr></table></figure>
<p>[dmtsai@study ~]$ uniq [-ic]<br>选项与参数：<br>-i  ：忽略大小写字符的不同；<br>-c  ：进行计数</p>
<p>#使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；<br>[dmtsai@study ~]$ last | cut -d ‘ ‘ -f1 | sort | uniq</p>
<p>#承上,继续显示每个帐号登录次数<br>[dmtsai@study ~]$ last | cut -d ‘ ‘ -f1 | sort | uniq -c<br>      1<br>      6 （unknown<br>     47 dmtsai<br>      4 reboot<br>      7 root<br>      1 wtmp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### wc</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ wc [-lwm]<br>选项与参数：<br>-l  ：仅列出行；<br>-w  ：仅列出多少字（英文单字）；<br>-m  ：多少字符；</p>
<p>#/etc/man_db.conf 里面到底有多少相关字、行、字符数？<br>[dmtsai@study ~]$ cat /etc/man_db.conf | wc<br>    131     723    5171</p>
<h1 id="输出的三个数字中，分别代表：-“行、字数、字符数"><a href="#输出的三个数字中，分别代表：-“行、字数、字符数" class="headerlink" title="输出的三个数字中，分别代表： “行、字数、字符数"></a>输出的三个数字中，分别代表： “行、字数、字符数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 双重导向tee</span><br><span class="line">可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理.</span><br><span class="line">![tee工作流程示意图](img/QQ20180319-161532@2x.png)</span><br></pre></td></tr></table></figure>
<p>[dmtsai@study ~]$ tee [-a] file<br>选项与参数：<br>-a  ：以累加 （append） 的方式，将数据加入 file 当中！</p>
<p>[dmtsai@study ~]$ ls -l /home | tee ~/homefile | more</p>
<h1 id="将-ls-的数据存一份到-homefile-，同时屏幕也有输出讯息！"><a href="#将-ls-的数据存一份到-homefile-，同时屏幕也有输出讯息！" class="headerlink" title="将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！"></a>将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！</h1><p>[dmtsai@study ~]$ ls -l / | tee -a ~/homefile | more</p>
<h1 id="要注意！-tee-后接的文件会被覆盖，若加上-a-这个选项则能将讯息累加。"><a href="#要注意！-tee-后接的文件会被覆盖，若加上-a-这个选项则能将讯息累加。" class="headerlink" title="要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。"></a>要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 字符转换命令 tr, col, join, paste, expand</span><br><span class="line">#### tr </span><br><span class="line">tr 可以用来删除一段讯息当中的文字，或者是进行文字讯息的替换！</span><br></pre></td></tr></table></figure>
<p>[dmtsai@study ~]$ tr [-ds] SET1 …<br>选项与参数：<br>-d  ：删除讯息当中的 SET1 这个字串；<br>-s  ：取代掉重复的字符！</p>
<p>#将 last 输出的讯息中，所有的小写变成大写字符：<br>[dmtsai@study ~]$ last | tr ‘[a-z]’ ‘[A-Z]’</p>
<h1 id="不加单引号也是可以执行的，如：“-last-tr-a-z-A-Z-”"><a href="#不加单引号也是可以执行的，如：“-last-tr-a-z-A-Z-”" class="headerlink" title="不加单引号也是可以执行的，如：“ last | tr [a-z] [A-Z] ”"></a>不加单引号也是可以执行的，如：“ last | tr [a-z] [A-Z] ”</h1><p>#将 /etc/passwd 输出的讯息中，将冒号 （:） 删除<br>[dmtsai@study ~]$ cat /etc/passwd | tr -d ‘:’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### col </span><br><span class="line">用来简单的处理将 [tab] 按键取代成为空白键.(***还有其它用途???***)</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ col [-xb]<br>选项与参数：<br>-x  ：将 tab 键转换成对等的空白键</p>
<p>#利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白<br>[dmtsai@study ~]$ cat -A /etc/man_db.conf  &lt;==此时会看到很多 ^I 的符号，那就是 tab<br>[dmtsai@study ~]$ cat /etc/man_db.conf | col -x | cat -A | more<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 分区命令 split</span><br><span class="line">如果有文件太大，导致一些携带式设备无法复制的问题，split 可以将一个大文件，依据文件大小或行数来分区，就可以将大文件分区成为小文件了</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ split [-bl] file PREFIX<br>选项与参数：<br>-b  ：后面可接欲分区成的文件大小，可加单位，例如 b, k, m 等；<br>-l  ：以行数来进行分区。<br>PREFIX ：代表前置字符的意思，可作为分区文件的前导文字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`范例一`：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ cd /tmp; split -b 300k /etc/services services<br>[dmtsai@study tmp]$ ll -k services*<br>-rw-rw-r–. 1 dmtsai dmtsai 307200 Jul  9 22:52 servicesaa<br>-rw-rw-r–. 1 dmtsai dmtsai 307200 Jul  9 22:52 servicesab<br>-rw-rw-r–. 1 dmtsai dmtsai  55893 Jul  9 22:52 servicesac</p>
<h1 id="那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa-xxxab-xxxac-等方式来创建小文件的！"><a href="#那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa-xxxab-xxxac-等方式来创建小文件的！" class="headerlink" title="那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa, xxxab, xxxac 等方式来创建小文件的！"></a>那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa, xxxab, xxxac 等方式来创建小文件的！</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`“范例二`：如何将上面的三个小文件合成一个文件，文件名为 servicesback</span><br></pre></td></tr></table></figure>
<p>#用数据流重导向合成文件<br>[dmtsai@study tmp]$ cat services* &gt;&gt; servicesback<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`范例三`：使用 ls -al / 输出的信息中，每十行记录成一个文件</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study tmp]$ ls -al / | split -l 10 - lsroot<br>[dmtsai@study tmp]$ wc -l lsroot*<br>  10 lsrootaa<br>  10 lsrootab<br>   4 lsrootac<br>  24 total</p>
<h1 id="重点在那个-啦！一般来说，如果需要-stdout-stdin-时，但偏偏又没有文件，有的只是-时，那么那个-就会被当成-stdin-或-stdout-～"><a href="#重点在那个-啦！一般来说，如果需要-stdout-stdin-时，但偏偏又没有文件，有的只是-时，那么那个-就会被当成-stdin-或-stdout-～" class="headerlink" title="重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～"></a>重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 参数代换 xargs</span><br></pre></td></tr></table></figure>
<p>[dmtsai@study ~]$ xargs [-0epn] command<br>选项与参数：<br>-0  ：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数<br>      可以将他还原成一般字符。这个参数可以用于特殊状态！<br>-e  ：这个是 EOF （end of file） 的意思。后面可以接一个字符串，当 xargs 分析到这个字串时，就会停止继续工作！<br>-p  ：在执行每个指令的 argument 时，都会询问使用者的意思；<br>-n  ：后面接次数，每次 command 指令执行时，要使用几个参数的意思。<br>当 xargs 后面没有接任何的指令时，默认是以 echo 来进行输出喔！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`范例一`：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来.</span><br></pre></td></tr></table></figure></p>
<p>[dmtsai@study ~]$ id root<br>uid=0（root） gid=0（root） groups=0（root）   </p>
<h1 id="这个-id-指令可以查询使用者的-UID-GID-等信息"><a href="#这个-id-指令可以查询使用者的-UID-GID-等信息" class="headerlink" title="这个 id 指令可以查询使用者的 UID/GID 等信息"></a>这个 id 指令可以查询使用者的 UID/GID 等信息</h1><p>[dmtsai@study ~]$ id $(cut -d ‘:’ -f 1 /etc/passwd | head -n 3)</p>
<h1 id="虽然使用-（cmd）-可以预先取得参数，但可惜的是，-id-这个指令“仅”能接受一个参数而已！"><a href="#虽然使用-（cmd）-可以预先取得参数，但可惜的是，-id-这个指令“仅”能接受一个参数而已！" class="headerlink" title="虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！"></a>虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！</h1><h1 id="所以上述的这个指令执行会出现错误！根本不会显示用户的-ID-啊！"><a href="#所以上述的这个指令执行会出现错误！根本不会显示用户的-ID-啊！" class="headerlink" title="所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！"></a>所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！</h1><p>[dmtsai@study ~]$ cut -d ‘:’ -f 1 /etc/passwd | head -n 3 | id<br>uid=1000 (dmtsai) gid=1000 (dmtsai) groups=1000 (dmtsai),10(wheel)</p>
<h1 id="因为-id-并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行-id！"><a href="#因为-id-并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行-id！" class="headerlink" title="因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！"></a>因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！</h1><p>[dmtsai@study ~]$ cut -d ‘:’ -f 1 /etc/passwd | head -n 3 | xargs id</p>
<h1 id="依旧会出现错误！这是因为-xargs-一口气将全部的数据通通丢给-id-处理～但id-就接受-1-个参数！"><a href="#依旧会出现错误！这是因为-xargs-一口气将全部的数据通通丢给-id-处理～但id-就接受-1-个参数！" class="headerlink" title="依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但id 就接受 1 个参数！"></a>依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但id 就接受 1 个参数！</h1><p>[dmtsai@study ~]$ cut -d ‘:’ -f 1 /etc/passwd | head -n 3 | xargs -n 1 id<br>uid=0（root） gid=0（root） groups=0（root）<br>uid=1（bin） gid=1（bin） groups=1（bin）<br>uid=2（daemon） gid=2（daemon） groups=2（daemon）</p>
<h1 id="通过-n-来处理，一次给予一个参数，因此上述的结果就-OK-正常的显示啰！"><a href="#通过-n-来处理，一次给予一个参数，因此上述的结果就-OK-正常的显示啰！" class="headerlink" title="通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！"></a>通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`范例二`：同上，但是每次执行 id 时，都要询问使用者是否动作？</span><br></pre></td></tr></table></figure>
<p>[dmtsai@study ~]$ cut -d ‘:’ -f 1 /etc/passwd | head -n 3 | xargs -p -n 1 id<br>id root ?…y<br>uid=0（root） gid=0（root） groups=0（root）<br>id bin ?…y<br>…..（下面省略）…..</p>
<h1 id="呵呵！这个-p-的选项可以让使用者的使用过程中，被询问到每个指令是否执行！"><a href="#呵呵！这个-p-的选项可以让使用者的使用过程中，被询问到每个指令是否执行！" class="headerlink" title="呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！"></a>呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`范例三`：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串</span><br></pre></td></tr></table></figure>
<p>[dmtsai@study ~]$ cut -d ‘:’ -f 1 /etc/passwd | xargs -e’sync’ -n 1 id</p>
<h1 id="仔细与上面的案例做比较。也同时注意，那个-e’sync’-是连在一起的，中间没有空白键。"><a href="#仔细与上面的案例做比较。也同时注意，那个-e’sync’-是连在一起的，中间没有空白键。" class="headerlink" title="仔细与上面的案例做比较。也同时注意，那个 -e’sync’ 是连在一起的，中间没有空白键。"></a>仔细与上面的案例做比较。也同时注意，那个 -e’sync’ 是连在一起的，中间没有空白键。</h1><h1 id="上个例子当中，第六个参数是-sync-啊，那么我们下达-e’sync’-后，则分析到-sync-这个字串时，"><a href="#上个例子当中，第六个参数是-sync-啊，那么我们下达-e’sync’-后，则分析到-sync-这个字串时，" class="headerlink" title="上个例子当中，第六个参数是 sync 啊，那么我们下达 -e’sync’ 后，则分析到 sync 这个字串时，"></a>上个例子当中，第六个参数是 sync 啊，那么我们下达 -e’sync’ 后，则分析到 sync 这个字串时，</h1><h1 id="后面的其他-stdin-的内容就会被-xargs-舍弃掉了！"><a href="#后面的其他-stdin-的内容就会被-xargs-舍弃掉了！" class="headerlink" title="后面的其他 stdin 的内容就会被 xargs 舍弃掉了！"></a>后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">***很多指令其实并不支持管线命令，因此我们可以通过 xargs 来提供该指令引用 standard input 之用！***</span><br><span class="line"></span><br><span class="line">`范例四`：找出 /usr/sbin 下面具有特殊权限的文件名，并使用 ls -l 列出详细属性</span><br></pre></td></tr></table></figure>
<p>[dmtsai@study ~]$ find /usr/sbin -perm /7000 | xargs ls -l<br>-rwx–s–x. 1 root lock      11208 Jun 10  2014 /usr/sbin/lockdev<br>-rwsr-xr-x. 1 root root     113400 Mar  6 12:17 /usr/sbin/mount.nfs<br>-rwxr-sr-x. 1 root root      11208 Mar  6 11:05 /usr/sbin/netreport<br>…..（下面省略）…..</p>
<h1 id="也可以使用“-ls-l-（find-usr-sbin-perm-7000）-”来处理这个范例！"><a href="#也可以使用“-ls-l-（find-usr-sbin-perm-7000）-”来处理这个范例！" class="headerlink" title="也可以使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！"></a>也可以使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 减号 &quot; - &quot; 的用途</span><br><span class="line">管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ， 某些指令需要用到文件名称 （例如 tar） 来进行处理时，该 stdin 与 stdout 可以利用减号 &quot;-&quot; 来替代.</span><br></pre></td></tr></table></figure>
<p>[root@study ~]# mkdir /tmp/homeback<br>[root@study ~]# tar -cvf - /home | tar -xvf - -C /tmp/homeback<br><code>`</code></p>
<blockquote>
<p>上面这个例子是：“将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是传送到 stdout； 经过管线后，将 tar -cvf - /home 传送给后面的 tar -xvf - ”。后面的这个 - 则是取用前一个指令的 stdout， 因此，我们就不需要使用 filename 了</p>
</blockquote>

      
    </div>

    

    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Windus</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://fcwalkers.com/2018/03/06/Linux/Linux的Bash/" title="Linux的Bash">http://fcwalkers.com/2018/03/06/Linux/Linux的Bash/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/学习笔记/" rel="tag"># 学习笔记</a>
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/02/Linux/文件压缩:打包:备份/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/21/Linux/Linux正则与文件格式化/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": false,
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpeg"
                alt="Windus" />
            
              <p class="site-author-name" itemprop="name">Windus</p>
              <p class="site-description motion-element" itemprop="description">每个人的心里都有一扇窗!</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/WindusL" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank" rel="external nofollow">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell"><span class="nav-number">1.</span> <span class="nav-text">Shell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bash-shell-功能"><span class="nav-number">2.</span> <span class="nav-text">Bash shell 功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命令编修能力"><span class="nav-number">2.1.</span> <span class="nav-text">命令编修能力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type指令"><span class="nav-number">2.2.</span> <span class="nav-text">type指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速编辑"><span class="nav-number">2.3.</span> <span class="nav-text">快速编辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-number">2.4.</span> <span class="nav-text">变量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注解符号：这个最常被使用在-script-当中，视为说明！在后的数据均不执行"><span class="nav-number"></span> <span class="nav-text">注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不执行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注意看，这两个文件的大小会一模一样！几乎像是使用-cp-来复制一般！"><span class="nav-number"></span> <span class="nav-text">注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#注意看，每个数据都是排列整齐的输出！如果我们不想要“-declare-x-”时，就得这么做："><span class="nav-number"></span> <span class="nav-text">注意看，每个数据都是排列整齐的输出！如果我们不想要“ declare -x ”时，就得这么做：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～"><span class="nav-number"></span> <span class="nav-text">看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序："><span class="nav-number"></span> <span class="nav-text">如果是以文字体态来排序的话，原本就会是这样，想要使用数字排序：</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cat-etc-passwd-sort-t-‘-’-k-3-n"><span class="nav-number"></span> <span class="nav-text">cat /etc/passwd | sort -t ‘:’ -k 3 -n</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#这样才行啊！用那个-n-来告知-sort-以数字来排序啊！"><span class="nav-number"></span> <span class="nav-text">这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#输出的三个数字中，分别代表：-“行、字数、字符数"><span class="nav-number"></span> <span class="nav-text">输出的三个数字中，分别代表： “行、字数、字符数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#将-ls-的数据存一份到-homefile-，同时屏幕也有输出讯息！"><span class="nav-number"></span> <span class="nav-text">将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出讯息！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#要注意！-tee-后接的文件会被覆盖，若加上-a-这个选项则能将讯息累加。"><span class="nav-number"></span> <span class="nav-text">要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将讯息累加。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#不加单引号也是可以执行的，如：“-last-tr-a-z-A-Z-”"><span class="nav-number"></span> <span class="nav-text">不加单引号也是可以执行的，如：“ last | tr [a-z] [A-Z] ”</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa-xxxab-xxxac-等方式来创建小文件的！"><span class="nav-number"></span> <span class="nav-text">那个文件名可以随意取的啦！我们只要写上前导文字，小文件就会以xxxaa, xxxab, xxxac 等方式来创建小文件的！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#重点在那个-啦！一般来说，如果需要-stdout-stdin-时，但偏偏又没有文件，有的只是-时，那么那个-就会被当成-stdin-或-stdout-～"><span class="nav-number"></span> <span class="nav-text">重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#这个-id-指令可以查询使用者的-UID-GID-等信息"><span class="nav-number"></span> <span class="nav-text">这个 id 指令可以查询使用者的 UID/GID 等信息</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#虽然使用-（cmd）-可以预先取得参数，但可惜的是，-id-这个指令“仅”能接受一个参数而已！"><span class="nav-number"></span> <span class="nav-text">虽然使用 $（cmd） 可以预先取得参数，但可惜的是， id 这个指令“仅”能接受一个参数而已！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#所以上述的这个指令执行会出现错误！根本不会显示用户的-ID-啊！"><span class="nav-number"></span> <span class="nav-text">所以上述的这个指令执行会出现错误！根本不会显示用户的 ID 啊！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#因为-id-并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行-id！"><span class="nav-number"></span> <span class="nav-text">因为 id 并不是管线命令，因此在上面这个指令执行后，前面的东西通通不见！只会执行 id！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#依旧会出现错误！这是因为-xargs-一口气将全部的数据通通丢给-id-处理～但id-就接受-1-个参数！"><span class="nav-number"></span> <span class="nav-text">依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但id 就接受 1 个参数！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通过-n-来处理，一次给予一个参数，因此上述的结果就-OK-正常的显示啰！"><span class="nav-number"></span> <span class="nav-text">通过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#呵呵！这个-p-的选项可以让使用者的使用过程中，被询问到每个指令是否执行！"><span class="nav-number"></span> <span class="nav-text">呵呵！这个 -p 的选项可以让使用者的使用过程中，被询问到每个指令是否执行！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#仔细与上面的案例做比较。也同时注意，那个-e’sync’-是连在一起的，中间没有空白键。"><span class="nav-number"></span> <span class="nav-text">仔细与上面的案例做比较。也同时注意，那个 -e’sync’ 是连在一起的，中间没有空白键。</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#上个例子当中，第六个参数是-sync-啊，那么我们下达-e’sync’-后，则分析到-sync-这个字串时，"><span class="nav-number"></span> <span class="nav-text">上个例子当中，第六个参数是 sync 啊，那么我们下达 -e’sync’ 后，则分析到 sync 这个字串时，</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后面的其他-stdin-的内容就会被-xargs-舍弃掉了！"><span class="nav-number"></span> <span class="nav-text">后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#也可以使用“-ls-l-（find-usr-sbin-perm-7000）-”来处理这个范例！"><span class="nav-number"></span> <span class="nav-text">也可以使用“ ls -l $（find /usr/sbin -perm /7000） ”来处理这个范例！</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate"> 
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">风尘</span>

  

  
</div>


  










        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.6"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.6"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.6"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.6"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.6"></script>



  



	





  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  
  

  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=6.0.6"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=6.0.6"></script>


  

  

</body>
</html>
