<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风尘</title>
  
  <subtitle>每个人的心里都有一扇窗!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fcwalkers.com/"/>
  <updated>2022-05-09T02:08:34.586Z</updated>
  <id>http://fcwalkers.com/</id>
  
  <author>
    <name>风尘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vim编辑器进阶学习(二)</title>
    <link href="http://fcwalkers.com/2022/03/23/Linux/vim%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
    <id>http://fcwalkers.com/2022/03/23/Linux/vim编辑器进阶学习(二)/</id>
    <published>2022-03-22T16:00:00.000Z</published>
    <updated>2022-05-09T02:08:34.586Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h2><p><code>VIM</code>有十种寄存器，通过<code>:reg</code> 命令可以显示寄存器内容，通过<code>&quot; + 寄存器名称 + 命令</code>可以将内容放入寄存器或取出。</p><ul><li><p><strong>未命名寄存器（<code>&quot;</code>）</strong></p><p><code>VIM</code>会将删除指令（<code>d</code>、<code>c</code>、<code>s</code>、<code>x</code>）和复制指令（<code>y</code>） 的文本放入该寄存器中,每次指令执行内容会覆盖上次放入内容。</p></li><li><p><strong>编号寄存器（<code>0-9</code>）</strong></p><p><code>VIM</code> 将剪切和删除指令（除了<code>x</code>指令）的文本放入该寄存器中。<code>0</code> 号寄存器存储最近复制指令的文本，<code>1</code>号寄存器存储最近删除指令的文本（手动指定寄存器情况除外）,每成功执行一次指令<code>VIM</code>将前一个内容从<code>1</code> 号寄存器转移到<code>2</code> 号寄存器，<code>2</code> 号到<code>3</code>号，依此类推，<code>9</code> 号寄存器上一次内容将丢弃。</p></li><li><p><strong>小文本删除寄存器（<code>-</code>）</strong></p><p><code>VIM</code> 将删除小于一行的文本放入该寄存器中（如<code>x</code> 指令，手动指定寄存器情况除外）。</p></li><li><p><strong>命名寄存器（<code>a~z</code> 或 <code>A~Z</code>）</strong></p><p>完全由用户指定内容的寄存器，使用小写字母可以替换对应命名寄存器的内容（如：<code>&quot;ayy</code>指令），使用大写字母可以追加对应命名寄存器的内容（如：<code>&quot;Ayy</code>指令）,当<code>cpoptions</code> 标志位指定<code>&gt;</code></p></li><li><p><strong>只读寄存器（<code>.</code>、<code>%</code>、<code>:</code>）</strong></p><p><code>.</code>存储最近插入的文本寄存器，可以通过<code>c</code> 指令重复上一次操作。<code>%</code>存储当前文件名。<code>:</code>存储最近执行的命令。</p></li><li><p><strong>交换文件寄存器（<code>#</code>）</strong></p><p>存储了当前窗口交换文件的名字。这个寄存器也是只读的，主要是为了一个插件改变它之后再恢复它。</p></li><li><p><strong>表达式寄存器（<code>=</code>）</strong></p><p>存储<code>VIM</code> 表达式的寄存器，普通模式可以通过指令<code>&quot;=</code>进行存储，插入模式可以通过<code>&lt;C-r&gt; =</code>指令存储。更多参考文档<code>:h expression</code>。</p></li><li><p><strong>选择寄存器（<code>*</code>、<code>+</code>）</strong></p><p><code>GUI</code>系统剪切板寄存器，当剪切板无效或无法工作时将使用<strong>未命名寄存器</strong>代替。<code>X11</code> 提供了<code>PRIMARY</code>, <code>SECONDARY</code>, 和 <code>CLIPBOARD</code> 三种寄存器，其中<code>vim</code> 仅实现了<code>PRIMARY</code> 和 <code>CLIPBOARD</code>分别使用<code>*</code>和<code>+</code>表示。</p></li><li><p><strong>黑洞寄存器（<code>_</code>）</strong></p><p>该寄存器功能和<code>/dev/null</code>设备类似，写入这个寄存器的内容将消失，可以用来删除文本。如使用指令<code>&quot;_dd</code> 删除当前行。</p></li><li><p><strong>上次搜索寄存器</strong></p><p>存储最近一次搜索的内容，这个被使用于<code>n</code> 指令和<code>hlsearch</code> 指令。</p></li></ul><h2 id="宏macro"><a class="markdownIt-Anchor" href="#宏macro"></a> 宏（Macro)</h2><p>可以通过宏录制一组命令，然后重复执行。宏命令也存储在<code>vim</code> 寄存器中，并且必须在<code>normal</code> 模式下使用。</p><ul><li><p><strong>录制宏</strong></p><p>通过命令<code>q + 寄存器名称（0-9a-zA-Z&quot;）</code>开始录制。如：<code>qa</code>命令开始录制一个宏并存储在命名寄存器<code>a</code> 中，此时<code>vim</code> 左下方将显示<code>recording @a</code>。</p><pre class="highlight"><code class="vim"># 将下列每行文本中间隔字母转为大写my name <span class="hljs-keyword">is</span> lili!how old are you!what <span class="hljs-keyword">do</span> you do!-------------------------------------------<span class="hljs-number">1</span>、录制宏到 q 寄存器 `qq` recording @q ...<span class="hljs-number">2</span>、执行替换命令：gU 转大写字母命令 <span class="hljs-keyword">l</span> 向右移动光标 <span class="hljs-keyword">ws</span> 表示跳转到下一个单词(<span class="hljs-keyword">vim</span>-easymotion 插件) <span class="hljs-keyword">j</span> 向下移动光标 <span class="hljs-number">0</span> 回到行首<span class="hljs-number">0</span>gUlwsgUlwsgUlwsgUlj0-------------------------------------------# 新文本内容My Name Is Lili!how old are you!what <span class="hljs-keyword">do</span> you do!</code></pre></li><li><p><strong>停止宏录制</strong></p><p>开始一个宏命令录制后，可以按<code>q</code> 键停止宏录制。</p></li><li><p><strong>宏的使用</strong></p><p>录制好的宏可以通过<code>[数字] + @ + 寄存器名称（0-9a-zA-Z&quot;）</code>执行。<code>@</code>符号前可以加数字表示执行次数，如执行两次上面录制的宏<code>2@q</code>。</p><pre class="highlight"><code class="vim"># 执行两次录制的宏后文本内容My Name Is Lili!How Old Are You!What Do You Do!</code></pre><p>上面命令也可替换成<code>[数字] + @@</code> 命令表示重复执行前一个宏。如：<code>2@@</code>命令可以达到上面一样效果。</p><p>宏命令也可以通过<code>:normal</code>命令执行，如<code>:normal @q</code> 表示执行宏<code>q</code>。</p><blockquote><p>由于宏命令同样存储在<code>vim</code> 寄存器中，因此也可以利用寄存器特性对宏命令进行修改和追加，如<code>qQ</code> 命令就可以对宏<code>q</code> 进行命令追加。也可以直接修改寄存器内容对宏命令进行修改。</p></blockquote></li></ul><h2 id="文本对象text-objects"><a class="markdownIt-Anchor" href="#文本对象text-objects"></a> 文本对象（Text Objects）</h2><ul><li><p><strong>文本对象类型</strong></p><p>单词（<code>w</code>)、句子（<code>s</code>）、段落（<code>p</code>）</p><p><strong>区间对象：</strong></p><p><code>[</code>、<code>]</code>、<code>&#123;</code>、<code>&#125;</code>、<code>(</code>、<code>)</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&quot;</code>、<code>'</code>、<font color="red">`</font>、<code>t（tag 标签块)</code>、<code>b|B（block 块）</code></p></li><li><p><strong>文本对象范围</strong></p><p>inner(<code>i</code>)：不包含空格</p><p>around(<code>a</code>)：包含空格</p></li><li><p><strong>文本对象命令</strong></p><p><code>[number]&lt;command&gt;[Text Object]</code></p><p><strong>number</strong> 命令执行次数</p><p><strong>command 选项：</strong></p><ul><li><p>删除 <strong>delete(<code>d</code>)</strong></p></li><li><p>改变 <strong>change(<code>c</code>)</strong></p></li><li><p>复制 <strong>yank(<code>y</code>)</strong></p></li></ul></li><li><p><strong>示例</strong></p><p>i. 选择单词</p><p>文本：<code>Good morning everyone !</code></p><p><code>viw</code> 结果 <em style="background:red">Good</em> morning everyone !</p><p><code>vaw</code> 结果 <em style="background:red">Good </em>morning everyone !</p><p>ii. 删除单词</p><p><code>diw</code> 结果 <s>Good</s> morning everyone !<br><code>2daw</code> 结果 <s>Good morning</s>everyone !　（试试<code>2diw</code> 执行结果）</p><p>iii. 区块操作</p><p>文本：<code>[Good morning everyone !]</code></p><p><code>vi[</code> 结果 [<em style="background:red">Good morning everyone !</em>]</p><p>iv. 标签操作</p><p>文本：<code>&lt;div&gt;Good morning everyone !&lt;/div&gt;</code></p><p><code>vit</code> 结果 &lt;div&gt;<em style="background:red">Good morning everyone !</em>&lt;/div&gt;</p><blockquote><p>更多操作参考文档 <code>:h text-objects</code></p></blockquote></li></ul><h2 id="标记-marks"><a class="markdownIt-Anchor" href="#标记-marks"></a> 标记 marks</h2><h2 id="折叠"><a class="markdownIt-Anchor" href="#折叠"></a> 折叠</h2><h2 id="搜索与替换"><a class="markdownIt-Anchor" href="#搜索与替换"></a> 搜索与替换</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;寄存器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#寄存器&quot;&gt;&lt;/a&gt; 寄存器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;VIM&lt;/code&gt;有十种寄存器，通过&lt;code&gt;:reg&lt;/code&gt; 命令可以显示寄存器内容，通
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习笔记" scheme="http://fcwalkers.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="http://fcwalkers.com/tags/Linux/"/>
    
      <category term="Linux学习笔记" scheme="http://fcwalkers.com/tags/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="vim" scheme="http://fcwalkers.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议—TCP 传输控制协议</title>
    <link href="http://fcwalkers.com/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/"/>
    <id>http://fcwalkers.com/2021/12/16/network/TCPIP协议—TCP传输控制协议/</id>
    <published>2021-12-15T16:00:00.000Z</published>
    <updated>2022-07-26T03:02:26.688Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>尽管<code>TCP</code>和<code>UDP</code>使用相同的网络层，<code>TCP</code>却向应用层提供了与<code>UDP</code>完全不同的服务。</p><p><strong><code>TCP</code>提供了一种面向连接、可靠的字节流服务</strong> 。</p><p><strong>面向连接</strong> 意味着两个使用<code>TCP</code>的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个<code>TCP</code>连接。这一过程与打电话很相似，先拨号振铃，等待对方摘机说“喂”，然后才说明是谁。</p><p><strong>字节流服务</strong> 这种设计方案的结果是，没有由<code>TCP</code>自动插入的记录标志或消息边界。一个记录标志对应着一个应用程序的写范围指示。如，应用程序在一端写入<code>10</code>字节，随后写入<code>20</code>字节，最后写入<code>50</code>字节。在连接的另一端的应用程序是不知道每次写入的字节是多少，它可能会以每次<code>20</code>字节，分四次读入这<code>80</code>字节或以其他的一些方式读入。因此，每个端点独立选择自己的读和写大小。</p><blockquote><p><code>TCP</code>对字节流的内容不作任何解释。 <code>TCP</code>不知道传输的数据字节流是二进制数据，还是<code>ASCII</code>字符、<code>EBCDIC</code>字符或者其他类型数据。对字节流的解释由<code>TCP</code>连接双方的应用层解释。</p><p>这种对字节流的处理方式与<code>Unix</code>操作系统对文件的处理方式很相似。<code>Unix</code>的内核对一个应用读或写的内容不作任何解释，而是交给应用程序处理。对<code>Unix</code>的内核来说，它无法区分一个二进制文件与一个文本文件。</p></blockquote><p><strong>可靠性</strong> ：</p><ul><li>应用数据被分割成<code>TCP</code>认为最适合发送的数据块。这和<code>UDP</code>完全不同，应用程序产生的数据报长度将保持不变。由<code>TCP</code>传递给<code>IP</code>的信息单位称为报文段或段（<code>segment</code>）。</li><li>当<code>TCP</code>发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li><li>当<code>TCP</code>收到发自<code>TCP</code>连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。</li><li><code>TCP</code>将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错， <code>TCP</code>将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。</li><li><code>TCP</code>报文段作为<code>IP</code>数据报来传输，而<code>IP</code>数据报的到达可能会失序，因此<code>TCP</code>报文段的到达也可能会失序。如果必要，<code>TCP</code>将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。</li><li><code>IP</code>数据报会发生重复，<code>TCP</code>的接收端必须丢弃重复的数据。</li><li><code>TCP</code>还能提供流量控制。<code>TCP</code>连接的每一方都有固定大小的缓冲空间。<code>TCP</code>的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。</li></ul><h3 id="tcp-首部"><a class="markdownIt-Anchor" href="#tcp-首部"></a> TCP 首部</h3><p><code>TCP</code>数据被封装在一个<code>IP</code>数据报中，如下图：</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/TCP数据在IP数据报中封装.gif" alt="TCP数据在IP数据报中封装" style="max-width:60%;"><span class="image-caption">TCP数据在IP数据报中封装</span><p><code>TCP</code>首部数据格式如下图：</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/TCP首部.gif" alt="TCP首部" style="max-width:60%;"><span class="image-caption">TCP首部</span><p><strong>源端口</strong> 和 <strong>目的端口号</strong> 字段，用于寻找发端和收端应用进程。这两个值加上<code>IP</code>首部中的源端<code>IP</code>地址和目的端<code>IP</code>地址唯一确定一个<code>TCP</code>连接。</p><blockquote><p>一个<code>IP</code>地址和一个端口号也称为一个套接字（<code>socket</code>）。这个术语出现在最早的<code>TCP</code>规范（<code>RFC793</code>）中，后来它也作为表示伯克利版的编程接口。</p><p>每个<code>TCP</code>连接由一对套接字（<code>socket pair</code>）(包含客户<code>IP</code>地址、客户端口号、服务器<code>IP</code>地址和服务器端口号的四元组 )组成，可唯一确定互联网络中每个<code>TCP</code>连接的双方。</p></blockquote><p><strong>序号</strong> 字段，<code>TCP</code>是面向字节流的，在一个<code>TCP</code>连接中，传送的字节流中的每个字节都被顺序编号。序号是<code>32bit</code>无符号数，序号到达<code>2^32-1</code>后从<code>0</code>开始。该字段标识从<code>TCP</code>发端向收端发送的数据字节流中的第一个字节的序号。</p><blockquote><p>当建立一个新的连接时， <code>SYN</code>标志被打开值为<code>1</code>。序列号字段包含此主机为此连接选择的 <strong>初始序号（Initial Sequence Number，ISN）</strong> 。该主机要发送数据的第一个字节序号为这个<code>ISN</code>加<code>1</code>，因为<code>SYN</code>标志消耗了一个序号。</p><p><code>RFC 793</code>中指出<code>ISN</code>被绑定在一个（可能是虚假的）<code>32</code>位时钟上，其低位大约每<code>4</code>微秒递增一次。直到超过<code>2^32</code>后又从<code>0</code>开始，这个周期大概是<code>4.55</code>小时。所以，如果<code>TCP Segment</code>  <strong>段最大寿命（Maximum Segment Lifetime，MSL）</strong> 即在网络上的存活时间不超过  <code>4.55</code>小时，那么就不会用到重复的<code>ISN</code>。</p></blockquote><p><strong>确认序号</strong> 字段，包含发送确认的一端所期望收到的下一个序号，即应当是上次已成功收到数据字节序号加<code>1</code>。只有<code>ACK</code>标志为<code>1</code>时该字段才有效。</p><blockquote><p>发送<code>ACK</code>无需任何代价，因为<code>32bit</code>的确认序号字段和<code>ACK</code>标志一样，总是<code>TCP</code>首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， <code>ACK</code>标志也总是被设置为<code>1</code>。</p></blockquote><p><code>TCP</code>为应用层提供 <strong>全双工服务</strong> 。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p><blockquote><p><strong>全双工</strong> ： 指可以同时（瞬时）进行信号的双向传输（<code>A→B</code>且<code>B→A</code>）。指<code>A→B</code>的同时<code>B→A</code>，是瞬时同步的。</p><p><strong>半双工</strong> ：指一个时间内只有一个方向的信号传输（<code>A→B</code>或<code>B→A</code>）。</p></blockquote><p><strong>长度</strong> 字段，首部中<code>32 bit</code>的数目。占<code>4bit</code>，因此最大值为<code>1111</code>，十进制表示为<code>15</code>，所以以<code>TCP</code>首部最大字节为<code>15*(32/8)=60</code>字节。</p><p><strong>标志</strong> 比特字段，当前，为<code>TCP</code>头部定义了<code>8</code>个位字段，一些老的实现只实现了它们中的最后<code>6</code>位，它们可同时被设置为<code>1</code>，具体如下：</p><p><code>CWR</code> 拥塞窗口减少（发送方降低它的发送速率）</p><p><code>ECE</code> ECN回显（发送收到了一个更早的的拥塞通告）</p><p><code>URG</code> 紧急指针（<code>urgent pointer</code>）有效</p><p><code>ACK</code> 确认序号有效。</p><p><code>PSH</code> 接收方应该尽快将这个报文段交给应用层。</p><p><code>RST</code> 重建连接。</p><p><code>SYN</code> 同步序号用来发起一个连接。</p><p><code>FIN</code> 发端完成发送任务。</p><p><strong>窗口大小</strong> 字段，<code>TCP</code>的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端真正期望接收的字节。窗口大小占<code>16bit</code>，因此窗口大小最大字节为<code>2^16-1=65535</code>字节。</p><p><strong>检验和</strong> 字段，覆盖了整个<code>TCP</code>报文段（<code>TCP</code>首部+数据）。这是一个强制性字段，由发端计算和存储，并由收端进行验证。计算方法与<code>UDP</code>类似，使用一个伪首部。</p><p><strong>紧急指针</strong> 字段，只有当<code>URG</code>被设置（即值为<code>1</code>时），该字段才生效。它是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</p><p><strong>选项</strong> 字段，长度可变，最长可达<code>4</code>字节。</p><blockquote><p><code>TCP</code>最初只规定了一种选项，即 <strong>最大报文段长度（Maximum Segment Szie，MSS）</strong> 。<code>MSS</code>是每一个<code>TCP</code>报文段中的数据字段的最大长度。数据字段加上<code>TCP</code>首部才等于整个的<code>TCP</code>报文段。所以<code>MSS</code>并不是整个<code>TCP</code>报文段的最大长度，而是<code>TCP</code>报文段长度减去<code>TCP</code>首部长度”。</p></blockquote><h3 id="tcp-连接的建立与终止"><a class="markdownIt-Anchor" href="#tcp-连接的建立与终止"></a> TCP 连接的建立与终止</h3><p>使用<code>telnet</code>命令建立一个<code>TCP</code>连接：</p><pre class="highlight"><code class="bash">$ telnet 192.168.1.134 13101 discard <span class="hljs-comment"># discard 是一个服务类似于 Linux 中 /dev/null 作用，用于 tcp/ip 测试</span>Trying 192.168.1.134..Connected to 192.168.1.134.Escape character is <span class="hljs-string">'^]'</span>.^]            <span class="hljs-comment"># 进入 telnet 命令行</span>telnet&gt; quit  <span class="hljs-comment"># 退出 telnet</span>Connection closed.-----------------------------------------------<span class="hljs-comment"># tcpdump 命令监控</span>$ tcpdump78: 192.168.31.62.54258 &gt; 39.106.86.134.13101: S , seq 3984939603, win 65535, length 074: 39.106.86.134.13101 &gt; 192.168.31.62.54258: S , seq 2131422913, ack 3984939604, win 28960, length 066: 192.168.31.62.54258 &gt; 39.106.86.134.13101: . , ack 1, win 2058, length 0144: 39.106.86.134.13101 &gt; 192.168.31.62.54258: P , seq 1:79, ack 1, length 7866: 192.168.31.62.54258 &gt; 39.106.86.134.13101: . , ack 79, win 2057, length 0</code></pre><p>对于<code>TCP</code>段，每行输出格式如下：</p><p><strong>源 &gt; 目的 : 标志</strong></p><p>其中标志代表<code>TCP</code>首部<code>6</code>个标志中的<code>4</code>个，字符含义如下：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">标志</th></tr></thead><tbody><tr><td style="text-align:center">S</td><td style="text-align:center">SYN</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">FIN</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">RST</td></tr><tr><td style="text-align:center">P</td><td style="text-align:center">PSH</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">表示以上四个标志比特均置 0</td></tr></tbody></table><blockquote><p>上表中四个标志比特中的多个可能同时出现在一个报文段中，但通常一次只见到一个。</p><p><code>TCP</code>首部中的其他两个标志比特—<code>ACK</code> 和<code>URG</code>—<code>tcpdump</code>将作特殊显示。</p></blockquote><p>第一行中，<code>seq</code>表示序号，<code>ack</code>表示确认序号，<code>win</code>表示窗口通告大小，<code>length</code>表示发送数据长度（上例中没有发送任何数据所以为<code>0</code>）。</p><p><em><strong>为什么，第三行，<code>ack</code>值为<code>1</code>，而不是前一个<code>seq+1</code>？</strong></em></p><p>是因为<code>tcpdump</code>命令默认显示相对序号值，如果想强制显示绝对序列值可以加上<code>-S</code>选项。</p><p>第四行，序号为<code>1:79</code>，表示 <strong>开始序号:结尾序号(不包含)</strong>， 。这种格式只在相对序号模式下显示，结尾序号值为 <strong>开始序号+length</strong> 的和，这样显示方便看出数据的长度。因为是不包含关系，所以它就的第五行确认序号<code>ack</code>，也是下一次的请求序号。</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/TCP链接断开.gif" alt="状态机与连接、传输数据、断开连接" style="max-width:80%;"><span class="image-caption">状态机与连接、传输数据、断开连接</span><p>如上图，建立一个链接需要 <strong>三次握手</strong> ，因为通信双方要相互通知对方自己的初始化序号，作为以后数据通信序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p><p>断开一个链接需要 <strong>四次挥手</strong> ，这是由<code>TCP</code>的半关闭（<code>half-close</code>）造成的。一个<code>TCP</code>连接是全双工，因此每个方向必须单独地进行关闭。只不过，有一方是被动的。</p><blockquote><p>当一端收到一个<code>FIN</code>只意味着在这一方向上没有数据流动。一个<code>TCP</code>连接在收到一个<code>FIN</code>后仍能发送数据。而这对利用半关闭的应用来说是可能的，尽管在实际应用中只有很少的<code>TCP</code>应用程序这样做。</p></blockquote><p>为了使用这个特性，编程接口必须为应用程序提供一种方式来说明 “ <em><strong>我已经完成了数据传送，因此发送一个文件结束（<code>FIN</code>）给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束（<code>FIN</code>）</strong></em> ”。</p><p>如果应用程序不调用<code>close</code>而调用<code>shutdown</code>，且第二个参数值为<code>1</code>，则<code>socket</code>接口支持半关闭。</p><p>典型的例子是<code>Unix</code>中的<code>rsh</code>命令，它将完成在另一个系统上执行一个命令。它的操作很简单，就是将输入的指令复制给<code>TCP</code>连接，并将结果从<code>TCP</code>链接中复制给标准输出。当输入指令后，<code>rsh</code>客户端执行半关闭，并继续接收来自<code>TCP</code>另一端的数据直到结束。</p><h3 id="状态机转换解释"><a class="markdownIt-Anchor" href="#状态机转换解释"></a> 状态机转换解释</h3><p><strong>建立链接三次握手：</strong></p><hr><ul><li><p><code>CLOSED</code></p><p>起点，当超时或连接关闭时进入该状态。它并不是一个真正状态，而是这个状态图的假想起点和终点。</p></li><li><p><code>LISTEN</code></p><p>服务器等待连接的状态，服务器进入该状态后开始监听客户发送的连接请求。这被称为“被动打开”。</p></li><li><p><code>SYN_SENT</code></p><p>当第一次握手时，客户启动一个连接。客户调用<code>connect()</code>，并向服务器发送一个<code>SYN</code>消息，然后进入该状态，等待服务器的确认。如果服务器不能被连接，它将进入<code>CLOSED</code>状态。</p></li><li><p><code>SYN_RCVD</code></p><p>第二次握手时发生，服务器从客户接收<code>SYN</code>，服务器从<code>LISTEN</code>进入该状态。然后向客户发送一个<code>SYN + ACK</code>。</p><blockquote><p>状态图还描述一种情况，当客户发送一个<code>SYN</code>，并且从服务器接收了一个<code>SYN</code>请求。也就是，同时发起两个连接请求（ <strong>同时打开</strong> ），这时客户状态将从<code>SYN_SENT</code>状态转换到<code>SYN_RCVD</code>状态。同时打开与正常连接建立过程相比，需要增加一个报文段，因此会变成四次握手。</p></blockquote></li><li><p><code>ESTABLISHED</code></p><p>在第三次握手阶段，客户从服务器接收<code>SYN + ACK</code>后，它将发送一个<code>ACK</code>确认给服务器，客户进入<code>ESTABLISHED</code>状态，指示客户已经准备好。但是<code>TCP</code>需要两端都做好传输数据准备，因此在服务器接收到客户的<code>ACK</code>后从<code>SYN_RCVD</code>状态进入<code>ESTABLISHED</code>状态。此时就可以后续的数据传输了。</p></li></ul><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/TCP建立链接状态转换图.gif" alt="TCP建立链接状态转换图" style="max-width:60%;"><span class="image-caption">TCP建立链接状态转换图</span><p>如上图，建立连接一系列状态变化：</p><ul><li><p><strong>客户</strong> 和 <strong>服务器</strong> 初始状态是<mark>CLOSED</mark>。</p></li><li><p>程序调用<code>UNIX “listen()”</code>将触发 “被动打开动作”，这个状态转换不触发任何响应。<strong>服务器</strong> 进入<mark>LISTEN</mark>状态。</p></li><li><p>当要建立一个<code>TCP</code>链接时，客户程序调用<code>UNIX “connect()”</code>，这个事件被称为“主动打开”。这个转换将向 <strong>服务器</strong> 传送一个<code>SYN</code>信息。<strong>客户</strong> 进入<mark>SYN_SENT</mark>状态。</p></li><li><p>当 <code>SYN</code>信息被 <strong>服务器</strong> 接收后，它会向 <strong>客户</strong> 发送<code>SYN + ACK</code>信息。<strong>服务器</strong> 进入<mark>SYN_RCVD</mark>状态。</p></li><li><p>当<code>SYN + ACK</code>被 <strong>客户</strong> 接收，它会向 <strong>服务器</strong> 发送一个<code>ACK</code>信息。<strong>客户</strong> 进入<mark>ESTABLISHED</mark>状态。</p><blockquote><p>客户完成，客户可以发送和接收数据消息。</p></blockquote></li><li><p>最后，当<code>ACK</code>被 <strong>服务器</strong> 接收后，<strong>服务器</strong> 进入<mark>ESTABLISHED</mark>状态。</p><blockquote><p>服务器完成，服务器也可以发送和接收消息。</p></blockquote></li></ul><br><p><strong>断开链接四次挥手</strong>：</p><hr><ul><li><p><code>FIN_WAIT_1</code></p><p>第一次挥手，客户执行主动关闭，就会从<code>ESTABLISHED</code>进入该状态。然后发送一个<code>FIN</code>信息。</p></li><li><p><code>CLOSE_WAIT</code></p><p>第二次挥手，接收客户发送来的<code>FIN</code>，同时发送出<code>ACK</code>，此时服务器进入该状态。</p></li><li><p><code>FIN_WAIT_2</code></p><p>客户接收到服务器的<code>ACK</code>消息，客户进入该状态。</p></li><li><p><code>LAST_ACK</code></p><p>第三次挥手，服务器发起一个关闭请求，并从<code>CLOSE_WAIT</code>状态进入该状态。</p></li><li><p><code>TIME_WAIT</code></p><p>第四次挥手，客户端完成它自己发起的关闭请求后，接收了服务器发送的<code>FIN</code>，然后响应了<code>ACK</code>后从<code>FIN_WAIT_2</code>进入该状态。</p><p><strong>通过状态图，可以看出还有两种状态可以进入该状态：</strong></p><ol><li><p><code>CLOSING</code>进入</p><p>同时关闭时，当客户和服务器都收到<code>ACK</code>时，会进入该状态。</p></li><li><p><code>FIN_WAIT_1</code>进入</p><p>客户执行主动关闭，已经发送了<code>FIN</code>并且等待<code>ACK</code>；此时服务端也发起了一个主动关闭，并且发送了<code>FIN</code>。客户端收到了前一个<code>ACK</code>，也收到了服务器<code>FIN</code>，并且发送了<code>ACK</code>。此时进入该状态。</p><blockquote><p>该状态转换与进入<code>CLOSING</code>接收<code>FIN</code>与<code>ACK</code>顺序不一样。</p></blockquote></li></ol></li><li><p><code>CLOSING</code></p><p>当客户与服务器同时发起一个关闭请求（ <strong>同时关闭</strong> ）， 两边都在等待接收到对方发给自己的<code>ACK</code>之前收到对方的<code>FIN</code>，此时两边都进入<code>CLOSING</code>状态。</p></li><li><p><code>2MSL</code></p><p><code>TIME_WAIT</code>状态也称为<code>2MSL</code>，每个实现必须选择一个值作为 <strong>报文段最大生存时间（Maximum Segment Lifetime，MSL）</strong>  ，它是任何报文段被丢弃前在网络内的最长时间。</p><blockquote><p><code>RFC 793[Postel 1981c]</code>指出<code>MSL</code>为<code>2</code>分钟。然而，实现中的常用值是<code>30</code>秒，<code>1</code>分钟或<code>2</code>分钟。</p></blockquote><p>对于一个具体实现给定的<code>MSL</code>值，处理原则是：当一个<code>TCP</code>执行主动关闭时，并发送最后一个<code>ACK</code>，该连接必须保持<code>TIME_WAIT</code>状态为两倍的<code>MSL</code>。这样可以让<code>TCP</code>再次发送最后的<code>ACK</code>以防这个<code>ACK</code>丢失（另一端超时并重发最后的<code>FIN</code>）。</p><blockquote><p>这种<code>2MSL</code>等待的另一种影响是，<code>socket</code>定义的双向连接（客户<code>IP</code>、客户端口、服务器<code>IP</code>、服务器端口）在<code>2MSL</code>等待结束前不能被重新使用。大多数<code>TCP</code>实现强加了更严格的限制，在<code>2MSL</code>等待期间，<code>Socket</code>中使用的本地端口默认情况下不能再被使用。</p><p>某些实现和<code>API</code>提供了一种避开该限制的方法，使用<code>Socket API</code>时可以指定<code>SO_REUSEADDR</code>选项。它允许调用者对处于<code>2MSL</code>等待的本地端口进行赋值。但<code>TCP</code>原则上仍将避免使用仍处于<code>2MSL</code>连接中的端口。</p></blockquote><p>客户执行主动关闭并进入<code>TIME_WAIT</code>是正常的。服务器通常执行被动关闭，不会进入<code>TIME_WAIT</code>状态。如果终止一个客户程序，并立即重新启动这个客户程序，则这个新客户程序将不能重用相同的本地端口。这不会带来什么问题，因为客户使用临时本地端口，而并不关心这个临时端口号是什么。</p><p>然而，对于服务器，情况就有所不同，因为服务器使用熟知端口。如果我们终止一个已经建立连接的服务器程序，并试图立即重新启动这个服务器程序，服务器程序将不能把它的这个熟知端口赋值给它的端点，因为那个端口是处于<code>2MSL</code>连接的一部分。在重新启动服务器程序前，它需要在<code>1 ~ 4</code>分钟。</p><p><em><strong>如果我们试图从其他主机来建立这个连接会如何？</strong></em></p><p>首先我们必须在<code>sun</code>服务器上以<code>-A</code>标记来重新启动服务器程序，因为它需要的端口还处于<code>2MSL</code>等待连接的一部分。</p><pre class="highlight"><code class="bash">[root@study ~]<span class="hljs-comment"># sock -A -s 6666</span></code></pre><p>接着，在<code>2MSL</code>等待结束前，我们在另一台主机上启动客户程序：</p><pre class="highlight"><code class="bash">[root@study ~]<span class="hljs-comment"># sock -b1098 sun 6666</span>connected on 38.106.86.134.1098 to 38.106.86.133.6666</code></pre><p>结果连接成功了！这违反了<code>TCP</code>规范，但被大多数的伯克利版实现所支持。这些实现允许一个新的连接请求到达仍处于<code>TIME_WAIT</code>状态的连接，只要新的序号大于该连接前一个替身的最后序号。</p></li></ul><h4 id="tcp-端口号"><a class="markdownIt-Anchor" href="#tcp-端口号"></a> TCP 端口号</h4><pre class="highlight"><code class="bash"><span class="hljs-comment"># 查看 TCP 所有连接信息</span>[root@study ~]netstat -antActive |nternet c ゚nneCti ゚ns (SerVerS and established)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp   0      O      :::22         :::★            LISTEN</code></pre><p><code>:::22</code>表示本地地址是全<code>0</code>地址，这种表示法也称为<code>通配符地址</code>，使用的端口号是<code>22</code>。这意味着一个针对<code>22</code>号端口的连接进入请求（即一个<code>SYN</code>）会被任何本地接口接受。</p><blockquote><p>如果主机是多宿主的,我们可以为本地IP地址指定一个单一的地址(主机IP地址中的一个地址),并且只有被该接口接收到的连接才能够被接受。</p></blockquote><p><code>:::*</code>表示外部地址是一个通配符地址与端口号。此处节点状态是<code>LISTEN</code>，正在等待一个连接到来，因此外部地址与端口号尚不知晓。</p><p>此时，在主机<code>10.0.0.3</code>上启动两个<code>SSH</code>连接，再次查看连接状态，此时两个连接的状态为<code>ESTABLISHED</code>，由于外部端口号不同，所以并不冲突。</p><pre class="highlight"><code class="bash">[root@study ~] netstat -antActive |nternet c ゚nneCti ゚ns (SerVerS and established)Proto Recv-Q Send-Q Local Address Foreign Address Statetcp   0      O      :::22         :::★            LISTENtcp   0      O      10.0.0.1:22   10.0.0.3:16140  ESTABLISHEDtcp   0      O      10.0.0.1:22   10.0.0.3:16137  ESTABLISHED</code></pre><h3 id="数据传输"><a class="markdownIt-Anchor" href="#数据传输"></a> 数据传输</h3><p><code>TCP</code>通常需要处理两类数据，一类是成块数据（如：<code>FTP</code>、<code>电子邮件</code>），一类是交互数据（如<code>Telnet</code>、<code>Rlogin</code>）。按分组数量计算，两类数据各占一半；按照字节计算比例约为<code>9:1</code>。这是因为成块数据的报文段基本上都是满长度（通常为<code>512</code>字节数据），而交互数据则小的多（通常小于<code>10</code>个字节）。<code>TCP</code>需要同时处理这两类数据，但使用的处理算法则有所不同。</p><h4 id="交互式输入"><a class="markdownIt-Anchor" href="#交互式输入"></a> 交互式输入</h4><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/交互式按键回显.gif" alt="TCP数据交互式按键回显" style="max-width:60%;"><span class="image-caption">TCP数据交互式按键回显</span><p>上图是一个<code>Rlogin</code>连接上键入一个交互命令时所产生的数据流。注意到通常每一个交互按键都会产生一个数据分组，也就是说，每次从客户传到服务器的是一个字节的按键（而不是每次一行）。并且，<code>Rlogin</code> 需要远程服务器回显客户键入的字符，这样就会产生<code>4</code> 个报文段：</p><ol><li>来自客户的交互按键。</li><li>来自服务器的按键确认。</li><li>来自服务器的按键回显。</li><li>来自客户的按键回显确认。</li></ol><blockquote><p><code>Rlogin</code> 每次总是从客户发送一个字节到服务器，<code>Telnet</code> 则有一个选项允许客户发送一行到服务器，通过这个选项可以减少网络负载。<code>BDS/386</code> 通过设置一个<code>Rlogin</code>连接的<code>TOS</code>来获得最小时延。</p></blockquote><h5 id="时延的确认"><a class="markdownIt-Anchor" href="#时延的确认"></a> 时延的确认</h5><p>通常可以将<code>Rlogin</code>报文段<code>2</code>和<code>3</code>进行合并，将按键确认和按键回显一起发送，这种合并的技术称为<strong>时延的确认</strong>。<code>TCP</code> 在接收到数据时并不立即发送<code>ACK</code>，它会推迟发送以便将<code>ACK</code>与需要沿该方向发送的数据一起发送（这种现象有时也称为数据稍带<code>ACK</code>）。</p><blockquote><p>绝大多数实现采用的时延为<code>200ms</code>，也就是说，<code>TCP</code>将以最大<code>200ms</code> 的时延等待是否有数据一起发送。</p></blockquote><p>观察下图客户接到数据和发送<code>ACK</code>之间的时间差，就会发现它们似乎是随机的：123.5、65.6、109.0。而发送<code>ACK</code>的实际时间（从 0 开始）：139.9、539.3、940.1（用星号标出），这些时间差则是<code>200ms</code>整数倍。出现这两种现象的原因是<code>TCP</code>使用了一个<code>200ms</code>定时器，该定时器以相对内核引导的<code>200ms</code>固定时间溢出；由于要确认的数据是随机到达的（16.4、474.3、831.1 等），所以<code>TCP</code>在内核的<code>200ms</code> 定时器的下一次溢出时得到通知可能是将来的<code>1~200ms</code>中的任何时刻。</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/时延的确认.gif" alt="时延的确认" style="max-width:60%;"><span class="image-caption">时延的确认</span><blockquote><p><code>Host Requirements RFC</code>声明<code>TCP</code>需要实现一个经受时延的<code>ACK</code>，但时延必须小于<code>500ms</code>。</p></blockquote><h5 id="nagle-算法"><a class="markdownIt-Anchor" href="#nagle-算法"></a> Nagle 算法</h5><p>在一个<code>Rlogin</code>连接上客户一般每次发送一个字节到服务器，这就产生了一些<code>41</code>字节长的分组（<code>20</code>字节的<code>IP</code>首部、<code>20</code>字节的<code>TCP</code>首部和<code>1</code>个字节的数据）。在局域网上，这些小分组（被称为微小分组(<code>tinygram</code>)）通常不会引起麻烦，因为局域网一般不会出现拥塞。但在广域网上，则会增加拥塞出现的可能。</p><p>一种简单和友好的方法就是采用<code>RFC 896 [Nagle 1984]</code>中所建议的<code>Nagle</code>算法。 <strong>该算法要求一个<code>TCP</code>连接上最多只能有一个未被确认的未完成的小分组，在该分组的确认到达之前不能发送其他的小分组。<code>TCP</code>收集这些少量的分组，并在确认到来时以一个分组的方式发出去。</strong> 该算法的优越之处在于它是自适应的（即确认到达得越快，数据也就发送的越快），在希望减少微小分组数目的低速广域网上，则会发送更少的分组。</p><blockquote><p>从上图中可以看出，在以太网上一个字节被发送、确认和回显的平均往返时间约为<code>16ms</code>（16.5、16.3、16.5），因此每秒大约传送<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1000</mn><mi mathvariant="normal">/</mi><mn>16</mn><mo>=</mo><mn>62.5</mn></mrow><annotation encoding="application/x-tex">1000/16=62.5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">/</span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">2</span><span class="mord">.</span><span class="mord">5</span></span></span></span>个字符。为了产生比这个速度更快的数据，我们每秒键入的字符必须多于<code>60</code>个，这表明在局域网环境下两个主机之间发送数据时很少使用这个算法。</p></blockquote><p>当往返时间（<code>RTT</code>）增加时，如在下图，通过一个广域网传输，情况就会发生变化。首先注意到从<code>slip</code>到<code>远程服务器</code>不存在经受时延的<code>ACK</code>，这是因为在时延定时器溢出之前总是有数据等待发送。其次，从左到右待发数据长度是不同的，分别为<code>1</code>、<code>1</code>、<code>2</code>、<code>1</code>、<code>2</code>，<code>2</code>、<code>3</code>、<code>1</code>和<code>3</code>个字节，这是因为客户只有收到前一个数据的确认后才发送已经收集的数据。通过使用<code>Nagle</code>算法，发送<code>16</code>个字节的数据客户端只需要使用<code>9</code>个报文段，而不再使用<code>16</code>个。</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/广域网rlogin数据传输.gif" alt="广域网 rlogin 数据传输" style="max-width:60%;"><span class="image-caption">广域网 rlogin 数据传输</span><blockquote><p>报文段<code>14</code>和<code>15</code>看起来似乎与<code>Nagle</code>算法相违背，但是通过观察其序号发现，确认序号是<code>54</code>，因此报文段<code>14</code>是报文段<code>12</code>中确认的应答。客户在发送该报文段之前，接收到了来自服务器的报文段<code>13</code>，报文段<code>15</code>中包含了对序号为<code>56</code>的报文段<code>13</code>的确认。因此即使从客户到服务器有两个连续返回的报文段，客户也是遵守<code>Nagle</code>算法的。</p></blockquote><p>上图中，报文段<code>12</code>不包含任何数据，因此可以假定这是一个时延的<code>ACK</code>。服务器当时一定非常忙，因此无法在服务器定时溢出前及时处理所收到的字符。</p><h5 id="关闭-nagle-算法"><a class="markdownIt-Anchor" href="#关闭-nagle-算法"></a> 关闭 Nagle 算法</h5><p>在一些实时性要求比较高的场景下，采用了<code>Nagle</code>算法会让用户感觉到时延，所以我们可以选择关闭<code>Nagle</code>算法。</p><p>在一个交互注册过程中键入终端一个特殊功能键<code>F1</code>，这个功能键通常会产生三个字节的字符序列：一个转义字符、一个左括号<code>[</code>和一个<code>M</code>。如果<code>TCP</code>每次只得到一个字符它可能会发送序列中的第一个字符，然后缓存其他字符并等待。但当服务器接收到该字符后，它并不发送确认，而是继续等待接收序列中的其他字符。因此会经常触发服务器的时延确认算法，对于交互用户而言，这将产生明显的时延。</p><blockquote><p><code>Socket API</code>可以使用<code>TCP_NODELAY</code>选项来关闭<code>Nagle</code>算法。<br><code>Host Requirements RFC</code>声明<code>TCP</code>必须实现<code>Nagle</code>算法，但必须为应用提供一种方法来关闭该算法在某个连接上执行。</p></blockquote><h4 id="成块数据"><a class="markdownIt-Anchor" href="#成块数据"></a> 成块数据</h4><p>与<code>TFTP</code>使用了停止等待协议（<em>数据发送方在发送下一个数据块之前需要等待接收已发送数据的确认</em>）不同，<code>TCP</code>使用的被称为 <strong>滑动窗口协议</strong> 的另一种形式的流量控制方法。该协议允许发送方在停止并待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/成块数据传输.gif" alt="成块数据传输" style="max-width:60%;"><span class="image-caption">成块数据传输</span><p>上图，是从客户单向传输<code>8</code>个<code>1024</code>个字节的数据到服务器，其中服务器作为一个 <strong><code>sink(吸收)</code>服务器</strong> (从网络上读取并丢弃数据)。其中图<code>1</code>、<code>2</code>、<code>3</code>分别展示了三种不同情况。</p><p><strong>图<code>1</code>：</strong></p><ul><li><p>前三个报文段显示了每一端的<code>MSS</code>值。</p></li><li><p>发送方首先发送了三个数据报文(<code>4~6</code>)，下一个报文段(<code>7</code>)仅确认了前两个报文段，这可以从其确认序号为<code>2049</code>而不是<code>3073</code>可以看出来。</p><blockquote><p><strong>报文段(<code>7</code>)确认序号是<code>2049</code>而不是<code>3073</code>的原因是：</strong> 当一个分组到达时，它首先被设备驱动程序的中断服务例程处理，然后放入<code>IP</code>的输入队列中。报文段(<code>4</code>、<code>5</code>、<code>6</code>)依次到达并按接收顺序放到<code>IP</code>输入队列。<code>IP</code>将以同样顺序交给<code>TCP</code>。</p><p><code>TCP</code>处理报文段(<code>4</code>)时，该连接被标记为一个产生时延的确认。<code>TCP</code>处理下一报文段(<code>5</code>)，由于<code>TCP</code>现在有两个未完成的报文段需要确认，因此产生一个序号为<code>2049</code>的<code>ACK</code>(<code>7</code>)，并清除该连接产生的经受时延的确认标志。</p><p><code>TCP</code>处理下一报文段(<code>6</code>)，而连接又被标志为产生一个经受时延的确认。在报文段(<code>9</code>)到来之前，由于时延定时器溢出，因此产生一个序号<code>3073</code>的<code>ACK</code>(<code>8</code>)。</p><p>报文段(<code>8</code>)中的窗口大小为<code>3072</code>，表明<code>TCP</code>的接收缓存还有<code>1024</code>个字节的数据等待被应用程序读取。</p></blockquote></li><li><p>报文段(<code>11~16</code>)说明了通常使用“隔一个报文段确认”的策略。其传输与报文段(<code>4~8</code>)相同。</p><blockquote><p>报文段(<code>7</code>、<code>14</code>、<code>16</code>)的<code>ACK</code>确认了两个收到的报文段。这是因为使用<code>TCP</code>滑动窗口协议时，接收方不必确认每一个收到的分组。</p><p>在<code>TCP</code>中，<code>ACK</code>是累积的，它表示接收方已经收到了一直到确认序号减<code>1</code>的所有字节。</p></blockquote></li></ul><p><strong>图<code>2</code>：</strong></p><p>通过<code>tcpdump</code>看到的<code>TCP</code>动态活动情况，依赖于很多无法控制的因素：发送方的<code>TCP</code>实现、接收方的<code>TCP</code>实现、接收进程读取数据（依赖于操作系统的调度）和网络的动态性（如以太网冲突和退避等）。对于<code>TCP</code>而言没有单一的、正确的方法来交换给定数量的数据。</p><p>图<code>2</code>是相同主机在不同时间传送同样数据时的时间线，一些情况发生了变化：</p><p>这一次接收方没有再发送一个<code>3073</code>的<code>ACK</code>，而是等待并发送<code>4097</code>的<code>ACK</code>，接收方仅发送了<code>4</code>个<code>ACK</code>(报文段<code>7</code>、<code>10</code>、<code>12</code>和<code>15</code>)，其中三个确认了<code>2048</code>字节，另一个确认了<code>1024</code>字节。最后<code>1024</code>字节数据的<code>ACK</code>出现在报文段<code>17</code>中，它与<code>FIN</code>的<code>ACK</code>一道发送。</p><p><strong>图<code>3</code>：</strong></p><p>这次情况是从一个快的发送到到一个慢的接收方，它的动态活动情况又有所不同：</p><p>发送方发送<code>4</code>个背靠背的数据报文段去填充接收方的窗口，然后停下来等待一个<code>ACK</code>。接收方发送<code>ACK</code>(报文段<code>8</code>)，但通告其窗口大小为<code>0</code>，这说明接收方已收到所有数据，但这些数据都在接收方的<code>TCP</code>缓存区，因为应用程序还没有机会读取到这些数据。另一个<code>ACK</code>(称为窗口更新)，在<code>17.4ms</code>后发送，表明接收方现在可以接收另外的<code>4096</code>字节。虽然这看起来像一个<code>ACK</code>，但由于它并不确认任何新数据，只是用来增加窗口的左右边沿，因此被称为窗口更新。</p><p>发送方发送最后<code>4</code>个报文段(<code>10~13</code>)，再次填充接收方的窗口，报文段(<code>13</code>)包括了两个比特标志<code>PUSH</code>、<code>FIN</code>。随后又从接收方传来另外两个<code>ACK</code>，它们确认了最后的<code>4096</code>字节数据（从<code>4097</code>到<code>8192</code>字节）和<code>FIN</code>。</p><h5 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h5><p><code>TCP</code>连接每一端都可以收发数据，连接的收发数据量是通过一组 <strong>窗口结构</strong> 来维护的。每个<code>TCP</code>活动连接的两端都维护一个 <strong>发送窗口结构</strong> 和 <strong>接收窗口结构</strong>。</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/滑动窗口.gif" alt="滑动窗口" style="max-width:70%;"><span class="image-caption">滑动窗口</span><p><em><strong><code>TCP</code>以字节（而非包）为单位维护其窗口结构。</strong></em> 以发送窗口为例，发送<code>11</code>个字节的数据，详细传输流程见下图：</p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/滑动窗口流量控制.gif" alt="滑动窗口流量控制" style="max-width:70%;"><span class="image-caption">滑动窗口流量控制</span><ul><li>报文段(<code>1-3</code>)是双方建立连接，接收方的窗口通告是<code>3</code>，说明发送方的发送窗口大小为<code>3</code>，<code>MSS</code>值为<code>1</code>，说明每段报文大小为<code>1</code>字节。</li><li>报文段(<code>4-6</code>)，连续发送三段报文填满发送窗口，每段报文大小为<code>1</code>字节（<code>MSS</code>值所决定）,注意的是报文段(<code>6</code>)发送中丢失。</li><li>报文段(<code>7</code>)确认接收了序号为<code>4</code>以前的数据（即字节<code>1</code>和<code>2</code>），并通告窗口大小为<code>6</code>字节。<blockquote><p>由于窗口大小从之前<code>3</code>字节变成现在的<code>6</code>字节，使得窗口可发送数据量增大，即窗口右边界右移，这种现象称为 <strong>窗口打开</strong>。</p></blockquote></li><li>报文段(<code>8-12</code>)连续发送<code>5</code>个报文段满发送窗口，由于报文段(<code>6</code>)丢失，接收端未返回确认接收报文，所以继续占用发送窗口<code>1</code>字节大小。</li><li>报文段(<code>13</code>)是报文段(<code>6</code>)的重传计时器超时触发的重传。报文段(<code>14</code>)确认接收了报文段序号为<code>10</code>以前的数据，并通告窗口大小为<code>1</code>字节。<blockquote><p>由于窗口大小从之前<code>6</code>字节变成现在的<code>1</code>字节，使得窗口可发送数据量变小，即窗口右边界向左移，这种现在称为 <strong>窗口收缩</strong>。</p><p><code>RFC1122</code>强烈反对这么做，但<code>TCP</code>必须能够处理它。</p></blockquote></li><li>报文段(<code>15</code>)发送<code>1</code>字节数据填满发送窗口，报文段(<code>16</code>)确认接收该报文并通告窗口大小为<code>0</code>字节。<blockquote><p>当通告窗大小为<code>0</code>时，称之为 <strong>零窗口</strong>。此时发送端不能再发送新数据，而是启动一个 <strong>持续计时器</strong> 用于主动发送零窗口探测报文段。</p><p>当接收商重新获得可用空间时，会给发送端传输一个 <strong>窗口更新</strong> 告知其可继续发送数据。如果在持续计时器超时前都未收到窗口更新，发送方会主动发送零窗口探测报文段（携带<code>1</code>字节数据）。这种设计可以防止死锁的发生。</p><p><code>RFC1122</code>建议在一个<code>RTO</code>之后发送第一个窗口探测，随后以指数时间间隔发送。</p></blockquote></li><li>报文段(<code>17</code>)在发送窗口更新过程中丢失，报文段(<code>18</code>)持续计时器超时并且没有收到窗口更新，因此主动发送零窗口探测报文段。</li><li>报文段(<code>19</code>)返回窗口更新，通告大小为<code>2</code>字节，报文段(<code>20-21</code>)填满发送窗口，报文段(<code>22</code>)确认收到序号<code>13</code>之前的数据。<blockquote><p>当已发送数据得到<code>ACK</code>确认时，窗口会减小，即左边界右移，这种现象称为 <strong>窗口关闭</strong>。</p></blockquote></li></ul><p>接收端也维护一个窗口结构，但比发送端窗口简单。该窗口结构记录了已接收并确认的数据，以及它能够接收的最大序列号，保证其接收数据的正确性。</p><h5 id="糊涂窗口组合症"><a class="markdownIt-Anchor" href="#糊涂窗口组合症"></a> 糊涂窗口组合症</h5><p>基于窗口流量控制机制，尤其是不使用大小固定的报文段的情况，可能会出现称为 <strong>糊涂窗口综合症(<code>Silly Window Syndrome，SWS</code>)</strong> 的缺陷。当出现该问题时，交换的数据段大小不是满长度的报文段，而是一些较小的数据段。由于每个报文段中有用的数据相对于头部信息的比例较小，因此耗费的资源也更多，相应的传输效率也更低。<br><code>TCP</code>两端都可能导致<code>SWS</code>的出现：接收方可以通告一个小的窗口（而不是一直等到有大的窗口时才通告），而发送方也可以发送少量的数据（而不是等待其他的数据以便发送一个大的报文段）。可以在任何一端采取措施避免出来：</p><ol><li>对于接收方来说，不应通告小窗口。<code>RFC1122</code>描述的接收算法中，接收方不通告一个比当前窗口大的窗口（可以为<code>0</code>），除非窗口可以增加一个报文段大小（即接收端的<code>MSS</code>）或者可以增加接收方缓存空间的一半。</li><li>对于发送方来说，不应发送小的报文段，而且需由<code>Nagle</code>算法控制何时发送。<br>a) 可以发送一个满长度的报文段。<br>b) 可以发送至少是接收方通告窗口大小一半的报文段。<br>c) 可以发送任何数据并且不希望接收<code>ACK</code>（即没有未经确认的在传数据）或者该连接禁用<code>Nagle</code>算法。</li></ol><h3 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h3><p>当路由器在单位时间内接收到的数据量多于其可发送的数据量时，它就需要把多余的部分存储起来。假如这种情况持续，最终存储资源将会耗尽，路由器因此只能丢弃部分数据。路由器因无法处理高速率到达的流量而被迫丢弃数据信息的现象称为 <strong>拥塞</strong> 。</p><blockquote><p>出现拥塞情况若不采取对策，网络性能将大受影响以致瘫痪。为避免或者在一定程序上缓解这种状况，<code>TCP</code>通信的每一方实行拥塞控制。不同的<code>TCP</code>版本（包括运行<code>TCP/IP</code>协议栈的操作系统）采取的规程和行为有所差异。</p></blockquote><p>根据接收方剩余缓存空间大小，在<code>TCP</code>头部设置了通告窗口大小字段，该数值是<code>TCP</code>发送方调节发送速率的依据。当接收速率或网络传输速率过慢时，需要降低发送速率。为实现上述操作在发送端引入一个窗口控制变量，确保发送窗口大小不超过接收端接收能力和网络传输能力，即<code>TCP</code>发送端的发送速率等于接收速率和传输速率两者中较小值。</p><p>反应网络传输能力的变量称为 <strong>拥塞窗口（congestion window，cwnd）</strong>，通告窗口记作<code>awnd</code>，因此发送端实际（可用）窗口<code>W</code>值为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>a</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W=min(cwnd, awnd)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span></span></p><p>根据上述等式，<code>TCP</code>发送端发送的数据中，还没有收到<code>ACK</code>回复的数据量不能多于<code>W</code>。这种已经发出但还未经确认的数据量大小有时称为 <strong>在外数据值（flight size）</strong> ，它总是小于等于<code>W</code>。</p><blockquote><p>拥塞窗口(<code>cwnd</code>)维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些，但只要网络出现拥塞，拥塞窗口就减少一些。</p><p>判断出现网络拥塞的依据：没有按时收到应当到达的确认报文（即发生超时重传）。</p><p>发送方将拥塞窗口作为发送窗口(<code>swnd</code>)，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">swnd = cwnd</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span></span></span></span></p></blockquote><p>拥塞控制主要算法有， <strong>慢启动</strong> 、 <strong>拥塞避免</strong> 、 <strong>快重传</strong> 、 <strong>快恢复</strong> 算法。</p><p>其中慢启动和拥塞避免算法的切换是通过维护一个 <strong>慢启动阈值（slow start threshold，ssthresh）</strong> 变量进行控制的。</p><ul><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&lt;</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd &lt; ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时，使用慢启动算法。</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd = ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时，即可使用慢启动算法，也可使用拥塞避免算法。</li><li>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>&gt;</mo><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">cwnd &gt; ssthresh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span></span></span></span> 时，停止使用慢启动算法而改用拥塞避免算法。</li></ul><p>慢启动的初始阈值可以任意设定（如<code>awnd</code>或更大），这会使用<code>TCP</code>总是以慢启动状态开始传输。当有重传情况发生，无论是超时重传还是快速重传，<code>ssthresh</code>值自动按下面方式更新：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi mathvariant="normal">在</mi><mi mathvariant="normal">外</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">值</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ssthresh = max(在外数据值/2, 2*SMSS)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">外</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">值</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>微软最近的<code>TCP/IP</code>协议栈中，上述等式变为： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>s</mi><mi>t</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo separator="true">,</mo><mi>a</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo separator="true">,</mo><mn>2</mn><mo>∗</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ssthresh = max(min(cwnd, awnd)/2, 2*SMSS)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">)</span><span class="mord">/</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span></p></blockquote><p>当一个新的<code>TCP</code>连接建立或检测到由重传超时(<code>RTO</code>)导致的丢包时，需要执行慢启动。<code>TCP</code>发送端长时间处于空闲状态也可能调用慢启动算法。</p><p><code>TCP</code>以发送一定数目的数据段开始慢启动（在<code>SYN</code>交换之后），称为 <strong>初始窗口（Initial Window，IW）</strong> 。<code>IW</code>初始值设为一个<code>SMSS</code>，但在<code>RFC5681</code>中设为一个稍大的值，公式如下：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>W</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mn>2</mn><mo>∗</mo><mo stretchy="false">(</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo stretchy="false">)</mo><mspace width="1em"><mi mathvariant="normal">且</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">于</mi><mn>2</mn><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">段</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">当</mi><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo>&gt;</mo><mn>2190</mn><mi mathvariant="normal">字</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">）</mi></mspace></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mn>3</mn><mo>∗</mo><mo stretchy="false">(</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo stretchy="false">)</mo><mspace width="1em"><mi mathvariant="normal">且</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">于</mi><mn>3</mn><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">段</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">当</mi><mn>2190</mn><mo>≧</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo>&gt;</mo><mn>1095</mn><mi mathvariant="normal">字</mi><mi mathvariant="normal">节</mi><mi mathvariant="normal">）</mi></mspace></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mn>4</mn><mo>∗</mo><mo stretchy="false">(</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo stretchy="false">)</mo><mspace width="1em"><mi mathvariant="normal">且</mi><mi mathvariant="normal">小</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">等</mi><mi mathvariant="normal">于</mi><mn>4</mn><mi mathvariant="normal">个</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">段</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">）</mi></mspace></mrow></mstyle></mtd></mtr></mtable></mstyle></mtd></mtr></mtable><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">IW =\begin{Bmatrix}\begin{aligned}&amp;2*(SMSS)\quad 且小于等于2个数据段（当 SMSS &gt; 2190 字节） \\&amp;3*(SMSS)\quad 且小于等于3个数据段（当 2190 \geqq SMSS &gt; 1095 字节） \\&amp;4*(SMSS)\quad 且小于等于4个数据段（其他） \\\end{aligned}\end{Bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.0000000000000004em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000013em;"><span style="top:-4.5em;"><span class="pstrut" style="height:4.5em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.5em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-3em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span><span style="top:-1.4999999999999991em;"><span class="pstrut" style="height:2.84em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span><span class="mord">2</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">当</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">9</span><span class="mord">0</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span><span class="mord">3</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">当</span><span class="mord">2</span><span class="mord">1</span><span class="mord">9</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel amsrm">≧</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">9</span><span class="mord">5</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">小</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">于</span><span class="mord">4</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">段</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">）</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0000000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎭</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎬</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><img src="/2021/12/16/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TCP%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE/拥塞控制算法.gif" alt="拥塞控制算法" style="max-width:90%;"><span class="image-caption">拥塞控制算法</span><p>上图为<code>TCP</code>拥塞控制算法使用的模拟，其中 <strong>传输轮次</strong> 就是指发送给接收方发送报文段后，接收方发回相应的确认报文段。一个传输轮次所经历的时间其实就是往返时间(<code>RTT</code>)，注意的是往返时间并非是恒定的数值，使用传输轮次就是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个报文段的确认。</p><p>为简单起见，只讨论 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>W</mi><mo>=</mo><mn>1</mn><mtext> </mtext><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">IW = 1 \, SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> 的情况。<code>TCP</code>连接初始的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><mi>d</mi><mo>=</mo><mn>1</mn><mtext> </mtext><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">cwnd=1 \, SMSS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，意味着初始可用窗口<code>W</code>也为<code>1 SMSS</code>。<code>ssthreash</code>初始值设置为<code>16</code>：</p><ul><li><p>数据传输开始，使用慢启动算法，每一轮次窗口(<code>W</code>)大小呈指数增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mo>=</mo><msup><mn>2</mn><mi>k</mi></msup><mi mathvariant="normal">，</mi><mi mathvariant="normal">即</mi><mtext> </mtext><mi>k</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>W</mi></mrow><annotation encoding="application/x-tex">W = 2^k，即 \, k=log_2W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>。当第<code>4</code>轮时窗口大小增大到<code>16</code>达到慢启动阈值，开始使用拥塞避免算法。</p></li><li><p><code>TCP</code>进入拥塞避免阶段，窗口大小每次增长值近似等于成功传输的数据段大小(大小加<code>1</code>)。这种呈线性增长方式与慢启动相比缓慢许多，当第<code>12</code>轮窗口大小增大到<code>24</code>时，发生重传计时器超时现象判断可能出现了拥塞。</p><blockquote><p>更准确地说，每接收一个新的<code>ACK</code>后，<code>cwnd</code>会做以更新：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>w</mi><mi>n</mi><msub><mi>d</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>c</mi><mi>w</mi><mi>n</mi><msub><mi>d</mi><mi>t</mi></msub><mo>+</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mo>∗</mo><mi>S</mi><mi>M</mi><mi>S</mi><mi>S</mi><mi mathvariant="normal">/</mi><mi>c</mi><mi>w</mi><mi>n</mi><msub><mi>d</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">cwnd_{t+1} = cwnd_t+SMSS*SMSS/cwnd_t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">/</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p></blockquote></li><li><p>当<code>TCP</code>判断出现了拥塞后，会将窗口大小重新减小为初始值（即<code>1</code>)，以达到慢启动的目的，将<code>ssthresh</code>值减小到当前窗口大小的一半（即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>24</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">24/2=12</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span></span></span></span>）。</p></li><li><p><code>TCP</code>继续重复上述步骤，使用慢启动算法直至窗口大小达到慢启动阈值(<code>12</code>)，切换使用拥塞避免算法，直到出现拥塞。</p><blockquote><p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。发送方把拥塞窗口<code>cwnd</code>又设置为最小值<code>1</code>，并错误的启动慢开始算法，因而降低了传输效率。</p><p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。所谓的快重传是指，在接收端收到一个擒的报文段时，<code>TCP</code>立即需要产生一个重复的<code>ACK</code>并且这个<code>ACK</code>不应该被延迟发送。该重复的<code>ACK</code>的目的在于让对方知道收到一个失序的报文段，并告诉对方自己希望收到的序号。当发送方连续收到<code>3</code>个或以上的重复<code>ACK</code>时就重传丢失的数据报文段，而无需等待超时定时器溢出。</p></blockquote></li><li><p>第<code>21</code>轮次时，发生报文段丢失，当发送方收到<code>3</code>个重复的确认时，就进行快重传。</p><blockquote><p>当接收方收到快速重传的报文段后，不再执行慢启动算法，而是将<code>ssthresh</code>值设置为当前窗口的一半，设置<code>cwnd</code>值为<code>ssthresh</code>加上<code>3</code>倍报文段大小(这么做的原因是<code>TCP</code>认为既然发送方收到<code>3</code>个重复的确认，就表明<code>3</code>个数据报文段已经离开网络，因此可以适当将拥塞窗口扩大<code>3</code>个报文段大小)，然后继续执行拥避免算法。这个操作就是快恢复算法。</p></blockquote></li><li><p>第<code>22</code>轮次中，<code>ssthresh</code>值变为<code>8</code>，<code>cwnd</code>为<code>11</code>，继续使用拥塞避免算法线性增长拥塞窗口发送报文段。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;尽管&lt;code&gt;TCP&lt;/code&gt;和&lt;code&gt;UDP&lt;/code&gt;使用相同的网络层，&lt;code&gt;TCP&lt;/code&gt;却向应用层提供了与&lt;code&gt;UDP&lt;/code&gt;完全不同的服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;TCP&lt;/code
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="TCP" scheme="http://fcwalkers.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议 — TFTP 与 BOOTP 协议</title>
    <link href="http://fcwalkers.com/2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://fcwalkers.com/2021/12/14/network/TCPIP协议—TFTP与BOOTP协议/</id>
    <published>2021-12-13T16:00:00.000Z</published>
    <updated>2022-05-18T07:56:15.493Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="tftp-协议"><a class="markdownIt-Anchor" href="#tftp-协议"></a> TFTP 协议</h3><p><strong>简单文件传送协议（Trivial File Transfer Protocol，TFTP）</strong>，最初用于无盘系统（通常是无盘系统或者X终端）。与<code>FTP</code>协议不同，为了更简单、小巧，<code>TFTP</code>被设计使用<code>UDP</code>。<code>TFTP</code>(及其所需的<code>UDP</code>、<code>IP</code>和设备驱动程序)可以装入只读存储器。</p><h4 id="协议"><a class="markdownIt-Anchor" href="#协议"></a> 协议</h4><p>客户和服务器之间的每次交换开始时，客户请求服务器读取或写入一个文件。请求报文格式如下：</p><img src="/2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/TFTP报文格式.gif" alt="5种TFTP报文格式" style="max-width:60%;"><span class="image-caption">5种TFTP报文格式</span><p><strong>操作码</strong> 字段，读请求<code>RRQ</code>，操作码为<code>1</code>；写请求<code>WRQ</code>，操作码为<code>2</code>。</p><p><strong>文件名</strong> 字段，表示客户要读取或写入的位于服务器上的文件。文件字段以<code>0</code>字节作为结束。</p><p><strong>模式</strong> 字段，一个<code>ASCII</code>码串，同样以<code>0</code>字节结束。<code>netascii</code>表示数据以成行的<code>ASCII</code>码字符组成，以两个字节—回车符跟换行符（<code>CR/LF</code>）作为结束符，默认使用该模式；<code>octet</code>表示将数据看作<code>8bit</code>一组的字节流而不作任何解释。</p><p><strong>块编号</strong> 字段，每个数据分组包含一个块编号字段，它以后要在确认分组中使用。</p><blockquote><p>当<code>TFTP</code>客户需要发送一个读请求说明要读的文件名和文件模式 (<code>mode</code>)。如果这个文件能被这个客户读取，<code>TFTP</code>服务器就返回一个块编号为<code>1</code>的数据分组。<code>TFTP</code>客户又发送一个块编号为<code>1</code>的<code>ACK</code>。<code>TFTP</code>服务器随后发送块编号为<code>2</code>的数据。<code>TFTP</code>客户发回块编号为<code>2</code>的<code>ACK</code>。重复这个过程直到这个文件传送完。除了最后一个数据分组可含有不足<code>512</code>字节的数据，其他每个数据分组均含有<code>512</code>字节的数据。当<code>TFTP</code>客户收到一个不足<code>512</code>字节的数据分组，就知道它收到最后一个数据分组。</p><p>在写请求的情况下， <code>TFTP</code> 客户发送<code>WRQ</code>指明文件名和模式。如果该文件能被 该客户写，<code>TFTP</code>服务器就返回块编号为<code>0</code>的<code>ACK</code>包。该客户就将文件的头<code>512</code>字节以块编号为<code>1</code>发出。服务器则返回块编号为<code>1</code>的<code>ACK</code>。</p></blockquote><p>这种类型的数据传输称为<strong>停止等待协议</strong>。它只用在一些简单的协议，（如<code>TFTP</code>，在任一时刻外部网络中只有一个数据包处于传输中，并且任一方每接收到一个包，就要又发送一个新的包来作为回复，一直到文件传输完毕）。<code>TCP</code>提供了不同形式的确认，能提供更高的系统吞吐量。<code>TFTP</code>的优点在于实现的简单而不是高的系统吞吐量。</p><p>最后一种<code>TFTP</code>报文类型是差错报文，它的操作码为<code>5</code>。它用于服务器不能处理读请求或写请求的情况。在文件传输过程中的读和写差错也会导致传送这种报文，接着停止传输。<strong>差错编号</strong> 字段给出一个数字的差错码，跟着是一个<code>ASCII</code>表示的 <strong>差错报文</strong> 字段，可能包含额外的操作系统说明的信息。</p><blockquote><p>既然<code>TFTP</code>使用不可靠的<code>UDP</code>，<code>TFTP</code>就必须处理分组丢失和分组重复。分组丢失可通过发送方的超时与重传机制解决，在原先的<a href="https://zh.wikipedia.org/wiki/TFTP">TFTP</a>（<a href="https://tools.ietf.org/html/rfc783">RFC 783</a>）版本里这会引起一个叫 <strong><a href="https://zh.wikipedia.org/wiki/%E9%AD%94%E8%A1%93%E6%96%B0%E6%89%8B%E7%97%87%E5%80%99%E7%BE%A4">魔术新手综合症（Sorcerer’s Apprentice Syndrome，SAS）</a></strong> 问题，在第二版的TFTP（<a href="https://tools.ietf.org/html/rfc1350">RFC 1350</a>）被修正，说明里指出只有第一个ACK会被承认并引发下一个资料区块的传送，同一份资料的ACK将被直接忽略。</p></blockquote><h4 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h4><p><code>TFTP</code>分组中并不提供用户名和口令，这是它的一个特征（即，“安全漏洞”）。由于<code>TFTP</code>是设计用于系统引导过程进程，它不可能提供用户名和口令。</p><p>这一特性被许多解密高手用于获取<code>Unix</code>口令文件的复制，然后来猜测用户口令。为防止这种类型的访问，目前大多数<code>TFTP</code>服务器提供了一个选项来限制只能访问特定目录下的文件（<code>Unix</code>系统中通常是 <code>/tftpboot</code> ）。这个目录中只包含无盘系统进行系统引导时所需的文件。</p><p>对其他的安全性， <code>Unix</code>系统下的<code>TFTP</code>服务器通常将它的用户<code>ID</code>和组<code>ID</code>设置为不会赋给任何真正用户的值。这只允许访问具有读或写属性的文件。</p><h3 id="bootp-协议"><a class="markdownIt-Anchor" href="#bootp-协议"></a> BOOTP 协议</h3><p><strong>引导程序协议（Bootstrap Protocol，BOOTP）</strong> ，基于<code>IP/UDP</code>协议，也称自举协议，是<code>DHCP</code>协议的前身。用于无盘工作站的局域网中，可以让无盘工作站从一个中心服务器上获得<code>IP</code>地址。</p><p>在进行系统引导时，能够通过<code>RARP</code>来获取它的<code>IP</code>地址，但是会有两个问题：</p><ul><li><code>IP</code>地址是返回的唯一结果。</li><li><code>RARP</code>使用链路层广播，所以它的请求不会被路由器转发，迫使每个网络都要设置一个<code>RARP</code>服务器。</li></ul><p><code>BOOTP</code>使用<code>UDP</code>，且通常需与<code>TFTP</code>协同工作，用于无盘系统进行系统引导的替代方法。</p><h4 id="分组格式"><a class="markdownIt-Anchor" href="#分组格式"></a> 分组格式</h4><p><code>BOOTP</code>请求和应答均被封装在<code>UDP</code>数据报中，如下：</p><img src="/2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/BOOTP分组格式.gif" alt="BOOTP 分组格式" style="max-width:60%;"><span class="image-caption">BOOTP 分组格式</span><p>下图是一个长度为<code>300</code>字节的<code>BOOTP</code>请求和应答格式：</p><img src="/2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/BOOTP请求和应答的格式.gif" alt="BOOTP 请求和应答的格式" style="max-width:60%;"><span class="image-caption">BOOTP 请求和应答的格式</span><p><strong>操作码</strong> 字段，请求为<code>1</code>；应答为<code>2</code>。</p><p><strong>硬件类型</strong> 字段，<code>1</code>表示<code>10Mb/s</code>的以太网，与<code>ARP</code>请求或应答含义相同。</p><p><strong>硬件地址长度</strong> 字段，同样地与<code>ARP</code>一样为<code>6</code>字节。</p><p><strong>跳数</strong> 字段，由客户设置为<code>0</code>，也可以被一个代理服务器设置。</p><p><strong>事务标识</strong> 字段，由客户设置，并由服务器返回的<code>32bit</code>整数。客户用对请求和应答进行匹配。对每个请求客户应该将该字段设置为一个随机数。 <code>0</code>表示该客户忽略这个字段。</p><p><strong>秒数</strong> 字段，客户开始进行引导时，将该字段设置一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户请求，这意味着主服务器没有启动。</p><p><strong>客户 IP 地址</strong> 字段，如果客户已经知道了自身的<code>IP</code>地址，它将写入该字段。否则，将该字段置为<code>0</code>。</p><p><strong>你的 IP 地址</strong> 字段，如果客户不知道自身的<code>IP</code>地址时，服务器将该客户的<code>IP</code>地址写入该字段。</p><p><strong>服务器 IP 地址</strong> 字段，由服务器填写。</p><p><strong>网关 IP 地址</strong> 字段，如果使用了某个代理服务器，则该代理服务器填写该字段。</p><p><strong>客户主机硬件地址</strong> 字段，客户必须在该设置它的硬件地址，尽管这个值与以太网数据帧头的值相同。<code>UDP</code>数据报中也设置了这个字段，使任何接收这个数据报的用户进程（如：<code>BOOTP</code>服务器）很容易使用它。</p><p><strong>服务器主机名</strong> 字段，是一个以空值终止的字符串，由服务器选则性地填写。</p><p><strong>引导文件名</strong> 字段，由服务器填写的，用于系统引导的文件名及其所在位置的路径全名。</p><p><strong>特定厂商信息</strong> 字段，用于对<code>BOOTP</code>进行不同的扩展。</p><p><code>RFC 1533 [Alexander and Droms 1993]</code> 定义了这个区域的格式，这个区域含有服务器返回客户的可选信息。如果有信息要提供，这个区域的前<code>4</code>个字节被设置为<code>IP</code>地址<code>99.130.83.99</code>。这可称作 <strong>魔术甜饼</strong> (<code>magic cookie</code>)，表示该区域内包含信息。其余部分是一个条目表，格式如下：</p><img src="/2021/12/14/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94TFTP%E4%B8%8EBOOTP%E5%8D%8F%E8%AE%AE/特定厂商格式.gif" alt="特定厂商格式" style="max-width:60%;"><span class="image-caption">特定厂商格式</span><p>每个条目开始是一个<code>1</code>字节的标志字段，其中的两个条目仅有标志字段：标志为<code>0</code>的条目作为填充字节（为使后面的条目有更好的字节边界），标志为<code>255</code>的条目表示结尾条目。第一个结尾条目后剩余的字节都应设置为这个数值（<code>255</code>）。除了这两个<code>1</code>字节的条目，其他的条目还包含一个单字节的长度字段，后面是相应的信息。</p><p><strong>子网掩码</strong> 条目和 <strong>时间值</strong> 条目都是定长条目，因为它们的值总是占<code>4</code>个字节。时间偏移值是从<code>1900年1月1日0时</code>以来的秒数（<code>UTC</code>）。</p><p><strong>网关</strong> 条目是变长条目。长度通常是<code>4</code>的倍数，这个值是一个或多个供客户使用的网关（路由器）的<code>IP</code>地址。返回的第一个必须是首选的网关。</p><blockquote><p><code>RFC 1533</code> 还定义了其他<code>14</code>个条目。其中最重要的可能是<code>DNS</code>名字服务器的<code>IP</code>地址条目，条目的值为 <code>6</code>。其他的条目包括打印服务器、时间服务器等的<code>IP</code>地址。详细情况可参考<code>RFC</code>文档。</p><p>厂商说明区域的大小被限制为<code>64</code>字节。这对某些应用是个约束。一个新的称为 **动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）**已经出现，但它不是替代<code>BOOTP</code>的。<code>DHCP</code>将这个区域的长度扩展到<code>312</code>字节，它在<code>RFC 1541 [Droms 1993]</code> 中定义。</p></blockquote><h4 id="端口号"><a class="markdownIt-Anchor" href="#端口号"></a> 端口号</h4><p><code>BOOTP</code>有两个熟知的端口，服务器<code>67</code>，客户<code>68</code>。这意味着<code>BOOTP</code> 客户不会选择未用的临时端口，而只用端口<code>68</code>。选择两个端口而不是仅选择一个端口因为<code>BOOTP</code>务器的应答可以进行广播（但通常是不用广播的）。</p><p>如果服务器的应答是通过广播传送的，同时客户又选择未用的临时端口，那么这些广播也能被其他的主机中碰巧使用相同临时端口的应用进程接收到。因此，采用随机端口（即临时端口）对广播来说是一个不好的选择。</p><p>如果客户也使用服务器的知名端口（<code>67</code>）作为它的端口，那么网络内的所有服务器会被唤醒来查看每个广播应答（如果所有的服务器都被唤醒，它们将检查操作码，如果是一个应答而不是请求，就不作处理）。因此可以让所有的客户使用与服务器知名端口不同的同一知名端口。</p><p>如果多个客户同时进行系统引导，并且服务器广播所有应答，这样每个客户都会收到其他客户的应答。客户可以通过<code>BOOTP</code>首部中的事务标识字段来确认应答是否与请求匹配，或者可以通过检查返回的客户硬件地址加以区分。</p><h4 id="bootp-服务器设计"><a class="markdownIt-Anchor" href="#bootp-服务器设计"></a> BOOTP 服务器设计</h4><p><code>BOOTP</code>客户通常固化在无盘系统只读存储器中，因此了解<code>BOOTP</code>服务器的实现将更有意义。</p><p><code>BOOTP</code>服务器将从它的熟知端口号<code>67</code>读取<code>UDP</code>数据报，没有特别的需要。这与必须要读取以太网帧类型字段<code>RARP</code>请求的<code>RARP</code>服务器不同。<code>BOOTP</code>协议通过将客户的硬件地址放入<code>BOOTP</code>分组中，使得服务器很容易获取客户硬件地址。</p><blockquote><p>这里出现了一个有趣的问题： <code>TFTP</code>服务器如何能将一个响应直接送回<code>BOOTP</code> 客户？这个响应是一个<code>UDP</code>数据报，而服务器知道该客户的<code>IP</code>地址（可能通过读取服务器上的配置文件）。由于客户端不知道自己的<code>IP</code>地址，因此无法应答<code>ARP</code>请求，因此服务器上的<code>ARP</code>无法找到客户的硬件地址。（这就是<code>RFC951</code>中被称作 &quot;<code>chicken and egg</code>&quot;的问题）</p></blockquote><p>对于上面问题，有两种解决方案：</p><p>第一种是服务器发送一个<code>IOCTL(2)</code>请求给内核，为该客户在<code>ARP</code>高速缓存中设置一个条目（这就是命令<code>arp -s</code>的工作），所以当服务器发送<code>UDP</code>数据报时，服务器<code>ARP</code>模块将会在<code>ARP</code>高速缓存中发现客户<code>IP</code>地址。服务器一直这么做直到它知道客户的硬件地址和<code>IP</code>地址。</p><p>第二种是服务器广播这个<code>BOOTP</code>应答而不是直接将应答发回该客户，通常期望网络广播越少越好，因此这种解决方案应该只在服务器无法在它的<code>ARP</code>高速缓存设置一个条目的情况下使用。通常只有拥有超级用户权限才能在<code>ARP</code>高速缓存设置一个条目，如果没有这种权限就只能广播<code>BOOTP</code>应答。</p><blockquote><p>当一个客户使用<code>BOOTP</code>（操作码为<code>1</code>）进行系统引导时，引导请求通常是采用链路层广播， <code>IP</code>首部中的目的<code>IP</code>地址为<code>255.255.255.255</code>（受限的广播）。源<code>IP</code>地址通常是<code>0.0.0.0</code>，因为此时客户还不知道它本身的<code>IP</code>地址。</p></blockquote><h4 id="bootp-穿越路由"><a class="markdownIt-Anchor" href="#bootp-穿越路由"></a> BOOTP 穿越路由</h4><p>绝大多数路由器厂商的产品都支持<code>BOOTP</code>协议，所以能够被路由器转发。这个功能主要用于无盘路由器，因为如果一个带磁盘的多用户系统被用作路由器，它就能够自己运行<code>BOOTP</code>服务器。</p><blockquote><p>常用的<code>Unix BOOTP</code>服务器支持这种中继模式（<code>relay mode</code>）。</p><p>如果在这个物理网络内运行一个<code>BOOTP</code>服务器，通常没有必要将<code>BOOTP</code>请求转发到在另外网络中的另一个服务器。</p></blockquote><p>当路由器（也称作“<code>BOOTP</code> 中继代理”）在服务器的熟知端口（<code>67</code>）接收到<code>BOOTP</code>请求时，中继代理将<code>IP</code>地址填入收到<code>BOOTP</code>请求中的“ <strong>网关IP地址</strong> 字段”，然后将该请求发送到真正的<code>BOOTP</code>服务器（由中继代<br>理填入网关字段的地址是收到的<code>BOOTP</code>请求接口的<code>IP</code>地址）。中继代理还将跳数字段值加<code>1</code>（这是为防止请求被无限地在网络内转发。 <code>RFC951</code>认为如果跳数值到达<code>3</code>就可以丢弃该请求）。</p><p>发出的请求是一个单播的数据报（与发起的客户的请求是广播的相反），它能按照一定的路由通过其他的路由器到达真正的<code>BOOTP</code>服务器。真正的<code>BOOTP</code>服务器收到这个请求后，产生<code>BOOTP</code>应答，并将它发回中继代理，而不是请求的客户。既然请求网关字段不为零，真正的<code>BOOTP</code>服务器知道这个请求是经过转发的。中继代理收到应答后将它发给请求的客户。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;tftp-协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tftp-协议&quot;&gt;&lt;/a&gt; TFTP 协议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简单文件传送协议（Trivial File Transfer Proto
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="TFTP" scheme="http://fcwalkers.com/tags/TFTP/"/>
    
      <category term="BOOTP" scheme="http://fcwalkers.com/tags/BOOTP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议 — DNS 域名系统</title>
    <link href="http://fcwalkers.com/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/"/>
    <id>http://fcwalkers.com/2021/11/18/network/TCPIP协议—DNS域名系统/</id>
    <published>2021-11-17T16:00:00.000Z</published>
    <updated>2021-12-14T02:02:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>域名系统也叫 <strong>域名解析（Domain name resolution，DNS）</strong> 是一种用于<code>TCP/IP</code>应用程序的分布式数据库，它提供主机名字和<code>IP</code>地址间的转换及有关电子邮件的选路信息。</p><blockquote><p>分布式的意思是，在<code>Internet</code>上的单个站点不能拥有所有信息，。每个站点（如大学中的系、校园、公司或公司中的部门）保留它自己的信息数据库，并运行一个服务器程序供<code>Internet</code>上的其他系统（客户程序）查询。 <code>DNS</code>提供了允许服务器和客户程序相互通信的协议。</p></blockquote><p>对<code>DNS</code>的访问是通过一个地址解析器（<code>resolver</code>）来完成的，在<code>Unix</code>主机中该解析器主要通过两个函数<code>gethostbyname(3)</code>和<code>gethostbyaddr(3)</code>来访问的。前者接收主机名字返回<code>IP</code>地址，后者接收<code>IP</code>地址寻找主机名字。</p><blockquote><p>解析器并不像<code>TCP/IP</code>协议那样是操作系统的内核，而是应用程序的一部分。在一个应用程序打开一个<code>TCP</code>连接或使用<code>UDP</code>发送一个数据报之前，必须将一个主机名转换成为一个<code>IP</code>地址，操作系统内核中的<code>TCP/IP</code>协议簇对<code>DNS</code>一点都不知道。</p></blockquote><h3 id="dns-基础"><a class="markdownIt-Anchor" href="#dns-基础"></a> DNS 基础</h3><p><code>DNS</code>的名字空间和<code>Unix</code>文件系统具有相似的层次结构，每个节点（圆圈）有一个最多<code>63</code>个字符长的标签。这棵树的根是一个空标签的特殊节点，标签不区分大小写。树上的任何节点的域名是从该节点开始到根节点的标签列表，使用<code>.</code>符号分割。域名树上的不同节点可以使用相同标签，但是每个节点在域名树上必须有一个唯一的域名。</p><p><strong>完全限定域名（Full Qualified Domain Name，FQDN）</strong> ,也叫 <strong>绝对域名</strong> 。它指定在域名系统树层次结构中的确切位置，它指定了所有域的级别（包括顶级域和根区域）。一个完全限定域名是没有歧义的，只有一种方式去解释它。通常它由一个主机名和最少一个更高级域标签并通过<code>.</code>分割符组成，并且以顶级域结束。</p><blockquote><p>域名系统的根域名（顶级域）未命名的，它是通过在域名系统层次结构中有一个空标签来表示。而完全限定名以顶级域结尾，因此如果不完全限定域名以两个以上标签组成，则可以认为它是完全限定域名；或者某些情况要求完全限定域名以<code>.</code>符号结尾。如<code>.tuc.noao.edu.</code>。</p></blockquote><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS层次组织.gif" alt="DNS 层次组织" style="max-width:60%;"><span class="image-caption">DNS 层次组织</span><p><strong>顶级域名被分为三个部分</strong>：</p><ul><li><code>arpa</code>是一个特殊域，用于地址到名字的映射。</li><li>普通域，<code>7</code>个三字符。通常只有<code>.gov</code>、<code>.mil</code>仅限于美国使用。</li><li>国家域，依据<code>ISO 3166</code>国家代码的两字符。</li></ul><blockquote><p><code>DNS</code>通过 <strong>网络信息中心</strong> <code>NIC</code>分配顶级域和委派其他指定地区域的授权机构。</p><p>一个独立管理的<code>DNS</code>子树称为一个区域 (<code>zone</code> )。一个常见的区域是一个二级域，如<code>noao.edu</code>。许多二级域将它们的区域划分成更小的区域。例如，大学可能根据不同的系来划分区域，公司可能根据不同的部门来划分区域。</p><p>一旦一个区域的授权机构被委派后，由它负责向该区域提供多个名字服务器。当一个新系统加入到一个区域中时，该区域的<code>DNS</code>管理者为该新系统申请一个域名和一个<code>IP</code>地址，并将它们加到名字服务器的数据库中。这就是授权机构存在的必要性。</p></blockquote><p>一个名字服务器负责一个或多个区域。一个区域的管理者必须为该区域提供一个主名字服务器和至少一个辅助名字服务器。主、辅名字服务器必须是独立和冗余的，以便当某个名字服务器发生故障时不会影响该区域的名字服务。</p><p>主、辅名字服务器的主要区别在于主名字服务器从磁盘文件中调入该区域的所有信息，而辅名字服务器则从主服务器调入所有信息。我们将辅名字服务器从主服务器调入信息称为区域传送。</p><blockquote><p>当一个新主机加入一个区域时，区域管理者将适当的信息（最少包括名字和<code>IP</code>地址）加入到运行在主名字服务器上的一个磁盘文件中，然后通知主名字服务器重新调入它的配置文件。辅名字服务器定时（通常是每隔<code>3</code>小时）向主名字服务器询问是否有新数据。如果有新数据，则通过区域传送方式获得新数据。</p></blockquote><p>当名字服务器没有请求信息时，它必须联系另一个名字服务器。然而并不是每个名字服务器如何联系其他名字服务器，但是每个名字服务器必须知道怎么联系根名字服务器。</p><blockquote><p><code>1993</code>年<code>4</code>月时有<code>8</code>个根名字服务器，所有的主名字服务器都必须知道根服务器的<code>IP</code>地址（这些<code>IP</code>地址在主名字服务器的配置文件中，主服务器必须知道根服务器的<code>IP</code>地址，而不是它们的域名）。</p><p>根服务器则知道所有二级域中的每个授权名字服务器的名字和位置（<code>IP</code>地址）。<em><strong>正在处理请求的名字服务器与根服务器联系，根服务器告诉它与另一个名字服务器联系。</strong></em></p></blockquote><p><code>DNS</code>的一个基本特性是使用超高速缓存。即当一个名字服务器收到有关映射的信息（主机名字到<code>IP</code>地址）时，它会将该信息存放在高速缓存中。这样若以后遇到相同的映射请求，就能直接使用缓存中的结果而无需通过其他服务器查询。</p><h3 id="dns-报文"><a class="markdownIt-Anchor" href="#dns-报文"></a> DNS 报文</h3><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS报文格式.gif" alt="DNS 报文格式" style="max-width:60%;"><span class="image-caption">DNS 报文格式</span><p><code>DNS</code>定义了一个用于查询和响应的报文格式（如上图）。报文由<code>12</code>字节首部和<code>4</code>个可变字段组成。</p><p><strong>标识</strong> 字段，由客户程序设置，并由服务器返回结果，客户程序通过它来确定响应与查询是否匹配。</p><p><strong>标志</strong> 字段，占<code>16bit</code>被分为多个子字段，如下：</p><ul><li><code>QR</code>字段，<code>0</code>表示查询，<code>1</code>表示响应。占<code>1bit</code>。</li><li><code>opcode</code>字段，<code>0</code>表示标准查询，<code>1</code>表示反向查询，<code>2</code>表示服务器状态请求。点<code>4bit</code>。</li><li><code>AA</code>字段，权威回答。如果查询结果由管理域名的域名服务器而不是缓存服务器提供的，则称为权威回答。</li><li><code>TC</code>字段，表示“可截断的”。使用<code>UDP</code>时，当其值为<code>1</code>时，总长度超过512字节，只返回前512个字节，这时 DNS就需要使用TCP重发原来的查询请求。</li><li><code>RD</code>字段，表示“期望递归”。该比特在一个查询中设置，并在响应中返回。这个标志告诉名字服务器必须处理这个查询，也称为一个<strong>递归查询</strong>。如果该位为<code>0</code>，且被请求的名字服务器没有一个权威回答，它就返回一个能解答该查询的其他名字服务器列表，这称为<strong>迭代查询</strong>。</li><li><code>RA</code>字段，表示“可用递归”。如果名字服务器支持递归查询，则在响应中将该比特设置为<code>1</code>。</li><li><code>zero</code>字段，必须为<code>0</code>。</li><li><code>rcode</code>字段，返回码。<code>0</code>表示没有差错，<code>3</code>表示名字差错。名字差错只能从一个权威的名字服务器上返回，它表示指定的域名在查询中不存在。</li></ul><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS报文标志字段.gif" alt="DNS 报文标志字段" style="max-width:60%;"><span class="image-caption">DNS 报文标志字段</span><p>随后的四个<code>16bit</code>字段说明最后四个变长字段中包含的条目数。对于查询报文，问题数通常是<code>1</code>，而其他三项则均为<code>0</code>。类似地，对于应答报文，回答数至少是<code>1</code>，剩下的两项可以是<code>0</code>或非<code>0</code>。</p><h4 id="查询问题"><a class="markdownIt-Anchor" href="#查询问题"></a> 查询问题</h4><p>问题部分中，通常只有一个问题，每个问题的格式如下：</p><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS查询报文中问题格式.gif" alt="DNS 查询报文中问题格式" style="max-width:60%;"><span class="image-caption">DNS 查询报文中问题格式</span><p><strong>查询名</strong>字段，要查找的名字，它是一个或多个标签的序列。每个标签以首字节的计数值来说明随后标签的字节长度，名字最后以字节为<code>0</code>结束，长度为<code>0</code>的标签是根标签。因为标签最大长度为<code>63</code>，所以计数字节的值必须是<code>0 ~ 63</code>的数。该字段无需以整<code>32bit</code>边界结束，即无需填充字节。</p><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/域名存储.gif" alt="blog.fcwalkers.com 域名存储格式" style="max-width:60%;"><span class="image-caption">blog.fcwalkers.com 域名存储格式</span><p><strong>查询类型</strong>字段，每个问题有一个查询类型，并且每个响应（也叫一个 <strong>资源记录</strong> ）也有一个类型。</p><p>常见的查询类型如下：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">数值</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">1</td><td style="text-align:center">传回一个<code>32bit</code>的<code>IPv4</code>地址，最常用于映射主机名称到<code>IP</code>地址。正向查询</td></tr><tr><td style="text-align:center">AAAA</td><td style="text-align:center">28</td><td style="text-align:center">传回一个<code>128bit</code>的<code>IPv6</code>地址，最常用于映射主机名称到<code>IP</code>地址。正向查询</td></tr><tr><td style="text-align:center">CNAME</td><td style="text-align:center">5</td><td style="text-align:center">一个主机名字的别名，域名系统将会继续尝试查找新的名字（将域名指向另外一个域名<code>canonical name</code>）。</td></tr><tr><td style="text-align:center">NS</td><td style="text-align:center">2</td><td style="text-align:center">委托<code>DNS</code>区域使用已提供的权威名字服务器（<code>Name server</code>）。</td></tr><tr><td style="text-align:center">MX</td><td style="text-align:center">15</td><td style="text-align:center">将一个域名映射到该域名的邮件传输代理（<strong>Message Transfer Agents，MTA</strong>）列表。</td></tr><tr><td style="text-align:center">SRV</td><td style="text-align:center">33</td><td style="text-align:center"><mark>服务定位记录，被新式协议使用而避免产生特定协议的记录</mark>。</td></tr><tr><td style="text-align:center">PTR</td><td style="text-align:center">12</td><td style="text-align:center">由<code>IP</code>到域名的查询，反向查询。</td></tr><tr><td style="text-align:center">TXT</td><td style="text-align:center">16</td><td style="text-align:center">最初用于DNS记录中的任意人类可读文本。然而，自20世纪90年代初以来，这种记录更多地携带机器可读的数据，如随机加密等。一般做一些验证记录时会使用此项如：做SPF（反垃圾邮件）记录。</td></tr><tr><td style="text-align:center">SOA</td><td style="text-align:center">6</td><td style="text-align:center">指定<code>DNS</code>域的权威信息，包括主要名称服务器、域名管理员邮箱地址、域名序列号和与刷新区域几个相关的计时器。</td></tr><tr><td style="text-align:center">AXFR</td><td style="text-align:center">252</td><td style="text-align:center">将整个区域文件从主要名称服务器传输到次要名称服务器</td></tr><tr><td style="text-align:center">*（或 ANY）</td><td style="text-align:center">255</td><td style="text-align:center">返回名称服务器已知的所有类型的所有记录</td></tr></tbody></table><p><strong>查询类</strong> 字段，值通常是<code>1</code>表示互联网地址（某些站点也支持其他非 I P地址）。</p><h4 id="响应资源记录"><a class="markdownIt-Anchor" href="#响应资源记录"></a> 响应资源记录</h4><p><code>DNS</code>最后三个字段 <strong>回答</strong> 、 <strong>授权</strong>、 <strong>附加信息</strong> 字段均采用一种称为资源记录（ <strong>Resource Record，RR</strong> ）的相同格式。如下图：</p><img src="/2021/11/18/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/DNS资源记录格式.gif" alt="DNS 资源记录格式" style="max-width:60%;"><span class="image-caption">DNS 资源记录格式</span><p><strong>域名</strong> 字段是下面资源数据的名字，它的格式与前面 <strong>查询名</strong> 字段格式相同。</p><p><strong>类型</strong> 字段，指定一个<code>RR</code>类型码，它与前面查询类型值相同。</p><p><strong>类</strong> 字段，值通常是<code>1</code>表示互联网地址（某些站点也支持其他非 I P地址）。</p><p><strong>生存时间</strong> 字段，<code>RR</code>被客户端缓存的秒数，通常是<code>2</code>天。</p><p><strong>资源数据长度</strong> 字段，说明了资源数据的数量。</p><p><strong>资源数据</strong> 字段，该数据的格式依赖于类型字段的值。对于类型<code>1</code>（A记录）资源数据是<code>4</code>字节的<code>IP</code>数据。</p><h3 id="dns-反向查询"><a class="markdownIt-Anchor" href="#dns-反向查询"></a> DNS 反向查询</h3><p><code>DNS</code>反向查询是查询域名系统来确定<code>IP</code>地址关联的域名的技术，即给定一个<code>IP</code>地址返回该地址对应的域名。反向<code>DNS</code>查询的过程使用<code>PRT</code>记录，互联网的反向<code>DNS</code>数据库根植于<code>.arpa</code>顶级域名。</p><blockquote><p>协议<code>[rfc:1912 RFC1912年]</code>建议，每一个互联网可访问的主机都应该有一个名字”和“每一个IP地址都应该有一个匹配 PTR 记录”，但这并不是一个<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E6%A0%87%E5%87%86">互联网标准</a> 强制要求，所以并不是每一个IP地址都有一个反向记录。</p></blockquote><p>反向查找<code>IPv4</code>地址时使用一个特殊的域名<code>in-addr.arpa</code>。在上面树形图中<code>IP</code>地址为<code>140.252.13.33</code>，在<code>DNS</code>树中结点<code>in-addr.arpa</code>的下一级必须是该<code>IP</code>地址的第一字节<code>140</code>，再下一级是<code>252</code>，依此类推。</p><blockquote><p>需要注意的是<code>DNS</code>名字是由<code>DNS</code>树底部向上书写的，所以<code>IP</code>地址<code>140.252.13.33</code>，它的<code>DNS</code>名字是<code>33.13.252.140.in-addr.arpa</code>。</p><p>必须写出<code>4</code>字节的<code>IP</code>地址，因为授权的代表是基于网络号： <code>A</code>类地址是第一字节， <code>B</code>类地址是第一、二字节，<code>C</code>类地址则是第一、二、三字节。</p></blockquote><p>反向查找<code>IPv6</code>地址时，使用一个特殊域名<code>ip6.arpa</code>（以前是<code>ip6.int</code>）。<code>IPv6</code>地址，以十六进制数字表示为子域。</p><h3 id="高速缓存"><a class="markdownIt-Anchor" href="#高速缓存"></a> 高速缓存</h3><p>为了减少<code>Internet</code>上<code>DNS</code>的通信量，所有的名字服务器均使用高速缓存。在标准的<code>Unix</code>实现中，高速缓存是由名字服务器而不是由名字解析器维护的。由于解析器是每个应用程序的一部分，并且应用程序又不可能总处于工作状态，因此将缓存放入整个系统运行期间都存在的程序(名称服务器)中是有意义的。这使缓存对于使用这个服务器的任何应用都是有效的。站点上任何使用该名字服务器的主机也可以共享服务器缓存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;域名系统也叫 &lt;strong&gt;域名解析（Domain name resolution，DNS）&lt;/strong&gt; 是一种用于&lt;code&gt;TCP/IP&lt;/code&gt;应用程序的分布式数据库，它提供主机名字和&lt;code&gt;IP&lt;/code&gt;地址间的转换及有
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="DNS" scheme="http://fcwalkers.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议—UDP 用户数据报协议</title>
    <link href="http://fcwalkers.com/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/"/>
    <id>http://fcwalkers.com/2021/11/05/network/TPCIP协议－UDP用户数据报协议/</id>
    <published>2021-11-04T16:00:00.000Z</published>
    <updated>2021-12-16T02:32:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p><code>UDP</code>（<strong>User Datagram Protocol</strong>）是一个简单的面向数据报的运输层协议，进程的每个输出操作都正好产生一个<code>UDP</code>数据报并组装成一个待发送的<code>IP</code>数据报。这与面向流字符的协议不同，如<code>TCP</code>，应用程序产生的全部数据与真正发送的单个<code>IP</code>数据报可能没有什么联系。</p><p><code>UDP</code>不提供可靠性，它把应用程序传给<code>IP</code>层的数据发送出去，但是并不保证它们能到达目的地。</p><h3 id="udp-首部"><a class="markdownIt-Anchor" href="#udp-首部"></a> UDP 首部</h3><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/UDP首部.gif" style="max-width:60%;"><p><code>UDP</code>首部字段：</p><p><strong>端口号</strong> 表示发送进程和接收进程。</p><p><strong>UDP 长度</strong> 表示<code>UDP</code>首部和<code>UDP</code>数据的字节长度。最小值为<code>8</code>字节（可以发送<code>0</code>字节数据报），<code>IP</code>数据报指的是数据报全长，因此<code>UDP</code>数据报长度是全长减去<code>IP</code>数据报首部长度。</p><p><strong>检验和</strong> 检验和覆盖<code>UDP</code>首部和<code>UDP</code>数据。它与<code>IP</code>首部检验和只覆盖<code>IP</code>首部不同。并且它的检验和是可选的。如果发送端没有计算检验和而接收端检测到检验和有差错，那么<code>UDP</code>数据报就要被悄悄地丢弃。不产生任何差错报文（当<code>IP</code>层检测到<code>IP</code>首部检验和有差错时也这样做）。</p><p>计算方法与<code>IP</code>首部检验和类似，不同之处有：</p><ul><li><p><code>UDP</code> 数据报长度可以为奇数字节，但是检验和算法是把若干个<code>16bit</code>字相加。解决方法是必要时在最后增加填充字节<code>0</code>，这只是为了检验和的计算（也就是说，可能增加的填充字节不被传送）。</p></li><li><p><code>UDP</code>数据报<code>TCP</code>段都包含一个<code>12</code>字节长度的伪首部，它是为了计算检验和设置的。伪首部包含<code>IP</code>首部一些字段。其目的是让<code>UDP</code>两次检查数据是否已经正确到达目的地。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/UDP伪首部.gif" alt="UDP 伪首部" style="max-width:60%;"><span class="image-caption">UDP 伪首部</span></li></ul><p>上图是一个奇数字节长度的<code>UDP</code>数据报，因而在计算检验和时需要在尾部加上 “ <strong>填充字节（0）</strong> ”；</p><p><strong>UDP 长度</strong> 字段在检验和计算中出现两次。</p><p>如果检验和计算结果为<code>0</code>，则存入的值全为<code>1</code>（65535），这在二进制反码计算中是等效的。如果传送的检验和为<code>0</code>，说明发送端没有计算检验和。</p><blockquote><p>尽管<code>UDP</code>检验和是可选的，但是它们应该总是在用。在单个局域网中关闭检验和可能是可以被接受的，但是在数据报通过路由器时，通过对链路层数据帧进行循环冗余检验（如以太网或令牌环数据帧）可以检测到大多数的差错，导致传输失败。路由器中也存在软件和硬件差错，以致于修改数据报中的数据。如果关闭端到端的<code>UDP</code>检验和功能，那么这些差错在<code>UDP</code>数据报中就不能被检测出来。一些数据链路层协议（如<code>SLIP</code>）没有任何形式的数据链路检验和。</p><p><code>Host Requirements RFC</code>声明，<code>UDP</code>检验和选项在默认条件下是打开的。它还声明，如果发送端已经计算了检验和，那么接收端必须检验接收到的检验和（如接收到检验和不为<code>0</code>）。但是，许多系统没有遵守这一点，只是在出口检验和选项被打开时才验证接收到的检验和。</p></blockquote><h3 id="ip-分片"><a class="markdownIt-Anchor" href="#ip-分片"></a> IP 分片</h3><p>物理网络层一般要限制每次发送数据帧的最大长度，任何时候<code>IP</code>层接收到一份要发送的数据报时，它先要判断向本地哪个接口发送数据（选路），并查询该接口获得其<code>MTU</code>；<code>IP</code>把<code>MTU</code>与数据报长度进行比较，如果需要则进行分片。分片可以发生在原始发送端主机上，也可以发生在中间路由器上。</p><p>把一份<code>IP</code>数据报分片以后，只有到达目的地才进行重新组装（<mark>这里的重新组装与其他网络协议要求在“下一跳”就进行重新组装不同</mark>）。重新组装由目的<code>IP</code>层来完成，其目的是使分片和重新组装过程对运输层（<code>TCP</code>和<code>UDP</code>）是透明的。</p><blockquote><p>已经分片过的数据报有可能会再次进行分片（可能不止一次）。<code>IP</code>首部中包含的数据为分片和重新组装提供了足够的信息。</p></blockquote><img src="https://blog.fcwalkers.com/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/IP%E9%A6%96%E9%83%A8.png" alt="IP首部" style="max-height:300px"><span class="image-caption">IP首部</span><p><code>IP</code>首部分片字段如上图：</p><p><strong>标识</strong> 字段，每份<code>IP</code>数据报标识字段包含一个唯一值，该值在数据报分片时被复制到每个片中。</p><p><strong>标志</strong> 字段，目前只有两位有意义：</p><ul><li><p>第一位 没有被使用</p></li><li><p>第二位 <code>DF</code>（dont’t fragment），当<code>DF=1</code>时<code>IP</code>将不对数据报进行分片。</p></li><li><p>第三位 <code>MF</code>（more fragment），当<code>MF=1</code>时表示还有更多分片，只有最后一个分片该位置<code>0</code>。</p></li></ul><p><strong>片偏移</strong> 字段，指该片偏移原始数据报开始处的位置。</p><p><em>当数据报被分片后，每个片的总长度字段值要改为该片的长度值。</em></p><blockquote><p><code>UDP</code>即使只丢失一片数据也要重传整个数据报。为什么会发生这种情况呢？</p><p>因为<code>IP</code>层本身没有超时重传的机制——由更高层来负责超时和重传，<code>TCP</code>有超时和重传机制，但<code>UDP</code>没有，一些<code>UDP</code>应用程序本身也执行超时和重传。</p><p>当来自<code>TCP</code>报文段的某一片丢失后，<code>TCP</code>在超时后会重发整个<code>TCP</code>报文段，该报文段对应于一份<code>IP</code>数据报。没有办法只重传数据报中的一个数据报片。事实上，如果对数据报分片的是中间路由器，而不是起始端系统，那么起始端系统就无法知道数据报是如何被分片的。就这个原因，经常要避免分片。</p></blockquote><h3 id="icmp-不可达差错"><a class="markdownIt-Anchor" href="#icmp-不可达差错"></a> ICMP 不可达差错</h3><p>发生<code>ICMP</code>不可达差错的另一种情况，是当路由器收到一份需要分片的数据报，而在<code>IP</code>首部又设置了不分片（<code>DF</code>）的标志比特。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/ICMP分片不可达.gif" alt="需要分片但又设置不分片标志比特时的ICMP不可达差错报文格式" style="max-width:60%;"><span class="image-caption">需要分片但又设置不分片标志比特时的ICMP不可达差错报文格式</span><p>注意报文中的 <strong>下一跳网络的MTU</strong> 字段，如果路由器没有提供这种新的<code>ICMP</code>差错报文格式，那么该字段设置为<code>0</code>。</p><blockquote><p>新版的路由器需求<code>RFC [Almquist 1993]</code>声明，在发生这种<code>ICMP</code>不可达差错时，路由器必须生成这种新格式的报文。</p></blockquote><h3 id="路径-mtu-发现"><a class="markdownIt-Anchor" href="#路径-mtu-发现"></a> 路径 MTU 发现</h3><h4 id="traceroute-确定路径-mtu"><a class="markdownIt-Anchor" href="#traceroute-确定路径-mtu"></a> traceroute 确定路径 MTU</h4><h4 id="采用-udp-的路径-mtu-发现"><a class="markdownIt-Anchor" href="#采用-udp-的路径-mtu-发现"></a> 采用 UDP 的路径 MTU 发现</h4><h3 id="udp-数据报最大长度"><a class="markdownIt-Anchor" href="#udp-数据报最大长度"></a> UDP 数据报最大长度</h3><p><code>IP</code>数据报最大长度是<code>65535</code>字节，这是由<code>IP</code>首部<code>16bit</code>总长度字段决定的。除去<code>20</code>字节的<code>IP</code>首部和<code>8</code>字节的<code>UDP</code>首部，<code>UDP</code>数据报中用户数据的最大长度为<code>65507</code>字节。但是大多数实现所提供的长度比这个值小。</p><p><strong>限制因素</strong>：</p><ul><li><p>应用程序可能受到其程序接口的限制。如，<code>socket API</code>提供了一个可供应用程序调用的函数，以设置接收和发送缓存的长度，这个长度与应用程序可以读写的最大<code>UDP</code>数据报的长度直接相关。现在大部分系统默认都提供了可读写大于<code>8192</code>字节的<code>UDP</code>数据报（使用这个默认值是因为<code>8192</code>是<code>NFS</code>读写用户数据数的默认值）。</p></li><li><p><code>TCP/IP</code>内核实现的限制。可能存在一些实现特性（或差错），使<code>IP</code>数据报长度小于<code>65535</code>字节。</p><blockquote><p>由于<code>IP</code>能够发送或接收特定长度的数据报并不意味着接收应用程序可以读取该长度的数据。因此，<code>UDP</code>编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？</p><p>不幸的是，该问题的答案取决于编程接口和实现。</p></blockquote></li></ul><h3 id="icmp-源站抑制差错"><a class="markdownIt-Anchor" href="#icmp-源站抑制差错"></a> ICMP 源站抑制差错</h3><p>当一个系统（主机或路由器）接收数据报的速度比其处理速度快，<mark>可能</mark>产生这个差错。之所以是可能这个词是因为即使一个系统已经没有缓存并丢弃数据报，也不要求它一定要发送源站抑制报文。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/ICMP源站抑制差错报文.gif" alt="ICMP 源站抑制差错报文" style="max-width:60%;"><span class="image-caption">ICMP 源站抑制差错报文</span><p><code>RFC 1009 [Braden and Postel 1987]</code>要求路由器在没有缓存时产生源站抑制差错报文，但是新的<code>Router Requirements RFC [Almquist 1993]</code>对此作了修改，提出路由器不应该产生源站抑制差错报文。由于源站抑制要消耗网络带宽，且对于拥塞来说是一种无效而不公平的调整，因此现在人们对于源站抑制差错的态度是不支持的。</p><h3 id="广播和多播"><a class="markdownIt-Anchor" href="#广播和多播"></a> 广播和多播</h3><p><code>IP</code>地址总共有三种：单播地址、多播地址和广播地址。其中广播地址和多播地址仅应用于<code>UDP</code>，它们对需将报文同时传往多个接收者的应用来说十分重要。</p><p><code>TCP</code>是一个面向连接的协议，它意味着分别运行于两主机（由<code>IP</code>地址确定）内的两进程（由端口号确定）间存在一条连接。</p><p>通常每个以太网帧仅发往单个目的主机，目的地址指明单个接收接口，因而称为单播(<code>unicast</code>)。在这种方式下，任意两个主机的通信不会干扰网内其他主机（可能引起争夺共享信道的情况除外）。</p><p>有时一个主机要向网上的所有其他主机发送帧，这就是广播(<code>broadcast</code>)。通过<code>ARP</code>和<code>RARP</code>可以看到这一过程。</p><p>多播(<code>multicast</code>) 处于单播和广播之间，帧仅传送给属于多播组的多个主机。</p><blockquote><p>大多数的网卡经过配置都能接收目的地址为多播地址或某些子网多播地址的帧。对于以太网，当地址中最高字节的最低位设置为<code>1</code>时表示该地址是一个多播地址，用十六进制可表示为<code>01:00:00:00:00:00</code>（以太网广播地址<code>ff:ff:ff:ff:ff:ff</code>可看作是以太网多播地址的特例）。</p></blockquote><p>使用广播的问题在于它增加了对广播数据不感兴趣主机的处理负荷。多播的出现减少了对应用不感兴趣主机的处理负荷。使用多播，主机可加入一个或多个多播组。这样，网卡将获悉该主机属于哪个多播组，然后仅接收主机所在多播组的那些多播帧。</p><h4 id="广播"><a class="markdownIt-Anchor" href="#广播"></a> 广播</h4><p>下表为广播地址划分，其中<code>-1</code>表示所有比特位全为<code>1</code>；<code>0</code>表示所有比特位全为<code>0</code>；<code>netid</code>、<code>subnetid</code>表示不全为<code>0</code>或<code>1</code>的对应字段。</p><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">子网号</th><th style="text-align:center">主机号</th><th style="text-align:center">源端</th><th style="text-align:center">目的端</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">-1</td><td style="text-align:center"></td><td style="text-align:center">-1</td><td style="text-align:center">不可能</td><td style="text-align:center">OK</td><td style="text-align:center">受限制广播（永远不被转发）</td></tr><tr><td style="text-align:center">netid</td><td style="text-align:center"></td><td style="text-align:center">-1</td><td style="text-align:center">不可能</td><td style="text-align:center">OK</td><td style="text-align:center">以网络为目的向<code>netid</code>广播</td></tr><tr><td style="text-align:center">netid</td><td style="text-align:center">subnetid</td><td style="text-align:center">-1</td><td style="text-align:center">不可能</td><td style="text-align:center">OK</td><td style="text-align:center">以子网为目的向<code>netid</code>、<code>subnetid</code>广播</td></tr><tr><td style="text-align:center">netid</td><td style="text-align:center">-1</td><td style="text-align:center">-1</td><td style="text-align:center">不可能</td><td style="text-align:center">OK</td><td style="text-align:center">以所有子网为目的向<code>netid</code>广播</td></tr></tbody></table><p><strong>受限制广播</strong> 地址是<code>255.255.255.255</code>，该地址用于主机配置过程中<code>IP</code>数据报的目的地址，此时主机可能不知道它所在的网络掩码，甚至连它的<code>IP</code>地址也不知道（如主机启动过程中）。</p><blockquote><p>在任何情况下，路由器都不转发目的地址为受限的广播地址的数据报，这样的数据报仅出现在本地网络中。</p></blockquote><p><strong>指向网络的广播</strong> 地址是主机号全为<code>1</code>的地址。<code>A</code>类网络广播地址为<code>netid.255.255.255</code>，其中<code>netid</code>为<code>A</code>类网络的网络号。</p><blockquote><p>一个路由器必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</p></blockquote><p><strong>指向子网的广播</strong> 地址为主机号全为<code>1</code>且具有特定子网号(<code>subnetid</code>)的地址。作为子网直接广播地址的<code>IP</code>地址需要了解子网的掩码。</p><p>如路由器收到发往<code>128.1.2.255</code>的数据报，当<code>B</code>类网络<code>128.1</code>的子网掩码为<code>255.255.255.0</code>时，该地址就是指向子网的广播地址；但如果该子网的掩码为<code>255.255.254.0</code>，该地址就不是指向子网的广播地址。</p><pre class="highlight"><code class>  子网掩码：255.255.255.0                        子网掩码：255.255.254.0  |  V  10000000 00000001 00000010 11111111          10000000 00000001 00000010 11111111&amp; 11111111 11111111 11111111 00000000        &amp; 11111111 11111111 11111110 00000000—————————————————————————————————————        —————————————————————————————————————  10000000 00000001 00000010 00000000          10000000 00000001 00000011 00000000  128      1        2        0                 128      1        3        0</code></pre><p>计算结果如上，当子网的掩码为<code>255.255.254.0</code>时，<code>IP</code>地址为<code>128.1.3.0</code>其中子网地址为<code>3</code>，所以地址<code>128.1.2.255</code>就不是指向子网<code>2</code>的广播地址了。</p><p><strong>指向所有子网的广播</strong> 地址为子网号全为<code>1</code>，主机号也全为<code>1</code>的地址。指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开。</p><p>如子网掩码为<code>255.255.255.0</code>，那么<code>IP</code>地址<code>128.1.255.255</code>是一个指向所有子网的广播地址。</p><blockquote><p>通过子网掩码<code>255.255.255.0</code>可以获得主机与子网号的分界线，即<code>0</code>表示的最后<code>8bit</code>是主机号；而通过<code>128</code>可以知道是<code>B</code>类地址，所以前<code>16bit</code>是由<code>2bit</code>前缀<code>10</code>和<code>14bit</code>网络号组成，所以接下来<code>8bit</code>则表示子网号。根据指向所有子网的广播地址划分规则就可以写出该<code>IP</code>地址，即最后<code>16bit</code>的子网号和主机号均为<code>1</code>即<code>255</code>，即最终<code>IP</code>地址为<code>128.1.255.255</code>。</p></blockquote><p>如果网络没有划分子网，这就是一个指向网络的广播。</p><p><code>RFC 922</code>要求将一个指向所有子网的广播传送给所有子网，但当前的路由器没有这么做。因为一个因错误配置而没有子网掩码的主机会把它的本地广播传送到所有子网。</p><p>如<code>IP</code>地址为<code>128.1.2.3</code>的主机没有设置子网掩码，它的广播地址在正常情况下的默认值是<code>128.1.255.255</code>。但如果子网掩码被设置为<code>255.255.255.0</code>，那么由错误配置的主机发出的广播将指向所有的子网。</p><blockquote><p><code>B</code>类地址<code>128</code>的默认子网掩码是<code>255.255.0.0</code>，此时<code>128.1.255.255</code>广播地址就是一个<strong>指向网络的广播</strong>；当子网掩码被错误设置为<code>255.255.255.0</code>时，该广播地址就变成了<strong>指向所有子网的广播</strong>。</p></blockquote><h4 id="多播"><a class="markdownIt-Anchor" href="#多播"></a> 多播</h4><p><code>IP</code>多播提供两类服务：</p><ul><li>向多个目的地址传送数据。如交互式会议系统和向多个接收者分发邮件或新闻。如果不采用多播，目前这些应用大多采用<code>TCP</code>来完成（向每个目的地址传送一个单独的数据复制）。然而，即使使用多播，某些应用可能继续采用<code>TCP</code>来保证它的可靠性。</li><li>客户对服务器的请求。如，无盘工作站需要确定启动引导服务器。目前，这项服务是通过广播来提供的，但是使用多播可降低不提供这项服务主机的负担。</li></ul><p>能够接收发往一个特定多播组地址数据的主机集合称为主机组 (<code>host group</code>)。一个主机组可跨越多个网络。主机组中成员可随时加入或离开主机组。主机组中对主机的数量没有限制，同时不属于某一主机组的主机可以向该组发送信息。</p><blockquote><p>一些多播组地址被 <strong>互联网数字分配机构（The Internet Assigned Numbers Authority，IANA）</strong> 确定为知名地址。它们也被当作永久主机组，这和<code>TCP</code>及<code>UDP</code>中的熟知端口相似。同样，这些知名多播地址在<code>RFC</code>最新分配数字中列出。注意这些多播地址所代表的组是永久组，而它们的组成员却不是永久的。</p><p>如<code>224.0.0.1</code>代表该子网内的所有系统组；<code>224.0.0.2</code>代表该子网内的所有路由器组；<code>224.0.1.1</code>用作网络时间协议<code>NTP</code>；<code>224.0.0.9</code>用作<code>RIP-2</code>；<code>224.0.1.2</code>用作<code>SGI</code>公司的<code>dogfight</code>应用。</p></blockquote><p><strong>多播组地址到以太网地址的转换</strong>：</p><p><code>IANA</code>拥有一个以太网地址块，即高位<code>24bit</code>为<code>00:00:5e</code>（十六进制表示），该地址块所拥有的地址范围从<code>00:00:5e:00:00:00</code>到<code>00:00:5e:ff:ff:ff</code>，<code>IANA</code>将其中一半分配为多播地址。为了指明一个多播地址，任何一个以太网地址的首字节必须是<code>01</code>。所以<code>IP</code>多播相对应的以太网地址范围从<code>01:00:5e:00:00:00</code>到<code>01:00:5e:7f:ff:ff</code>。</p><p>这种地址分配将使以太网多播地址中的<code>23bit</code>与<code>IP</code>多播组号对应起来，通过将多播组号中的低位<code>23bit</code>映射到以太网地址中的低位<code>23bit</code>实现。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/以太网多播地址映射.gif" alt="D类IP地址对到以太网多播地址的映射" style="max-width:60%;"><span class="image-caption">D类IP地址对到以太网多播地址的映射</span><blockquote><p>由于多播组号中的最高<code>5bit</code>在映射过程中被忽略，因此每个以太网多播地址对应的多播组是不唯一的。<code>32</code> 个不同的多播组号被映射为一个以太网地址。见下面示例。</p></blockquote><pre class="highlight"><code class>多播地址`224.128.64.32`，十六进制表示为`e0.80.40.20`，后23位二进制表示为` 0000000 01000000 00100000；多播地址`224.0.64.32`,十六进制表示为`e0:00:40:20`，后23位二进制表示为` 0000000 00101000 00100000根据上图映射规则将其转换成以太网地址均为`01:00:5e:00:40:20`。</code></pre><p>既然地址映射是不唯一的，那么设备驱动程序或<code>IP</code>层（见下图展示了主机对由信道传送过来帧的过滤过程）就必须对数据报进行过滤。因为网卡可能接收到主机不想接收的多播数据帧。另外，如果网卡不提供足够的多播数据帧过滤功能，设备驱动程序就必须接收所有多播数据帧，然后对它们进行过滤。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/协议栈各层对收到帧的过滤过程.gif" alt="协议栈各层对收到帧的过滤过程" style="height:300px;"><span class="image-caption">协议栈各层对收到帧的过滤过程</span><p><strong>局域网网卡趋向两种处理类型</strong>：</p><ul><li>网卡根据对多播地址的散列值实行多播过滤，这意味仍会接收到不想接收的多播数据；</li><li>网卡只接收一些固定数目的多播地址，这意味着当主机想接收超过网卡预先支持多播地址以外的多播地址时，必须将网卡设置为 <strong>多播混杂(multicast promiscuous)</strong> 模式。</li></ul><p>这两种类型的网卡仍需要设备驱动程序检查收到的帧是否真是主机所需要的。</p><p>即使网卡实现了完美的多播过滤（基于<code>48bit</code>的硬件地址），由于从<code>D</code>类<code>IP</code>地址到<code>48bit</code>的硬件地址的映射不是一对一的，过滤过程仍是必要的。</p><blockquote><p>尽管存在地址映射不完美和需要硬件过滤的不足，多播仍然比广播好。</p></blockquote><p><strong>单个物理网络的多播过程</strong>：</p><p>多播进程将目的<code>IP</code>地址指明为多播地址，设备驱动程序将它转换为相应的以太网地址，然后把数据发送出去。这些接收进程必须通知它们的<code>IP</code>层，它们想接收的发往给定多播地址的数据报，并且设备驱动程序必须能够接收这些多播帧，这个过程就是 <strong>加入一个多播组</strong> 。当一个主机收到多播数据报时，它必须向属于那个多播组的每个进程均传送一个复制，因为一个主机上可能存在多个属于同一多播组的进程。</p><p><strong>单个物理网络以外的多播</strong> 需要通过路由器转发多播数据时，复杂性就增加了。需要有一个协议让多播路由器了解确定网络中属于确定多播组的任何一个主机，这个协议就是<code>Internet</code>组管理协议（<code>IGMP</code>）。</p><h3 id="igmp"><a class="markdownIt-Anchor" href="#igmp"></a> IGMP</h3><p><strong>因特网组管理协议（Internet Group Management Protocol，ICMP）</strong> ，它让一个物理网络上的所有系统知道主机当前所在的多播组。多播路由器需要这些信息以便知道多播数据报应该向哪些接口转发。</p><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/IGMP.gif" alt="IGMP报文封装在IP数据报中" style="max-width:60%;"><span class="image-caption">IGMP报文封装在IP数据报中</span><p>与<code>ICMP</code>一样，<code>IGMP</code>也被当作<code>IP</code>层的一部分，通过<code>IP</code>数据报进行传输。区别在于<code>IGMP</code>有固定长度<code>8</code>字节，没有可选数据。</p><h4 id="报文格式"><a class="markdownIt-Anchor" href="#报文格式"></a> 报文格式</h4><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/IGMP报文.gif" alt="IGMP报文格式" style="max-width:60%;"><span class="image-caption">IGMP报文格式</span><p><strong>IGMP 版本</strong> 字段，值为<code>1</code>。</p><p><strong>IGMP 类型</strong> 字段，值为<code>1</code>表明是由多播路由器发出的查询报文；值为<code>2</code>表明是主机发出的报告报文。</p><p><strong>检验和</strong> 字段，与<code>ICMG</code>协议相同。</p><p><strong>组地址</strong> 字段，为<code>D</code>类<code>IP</code>地址。在查询报文中设置为<code>0</code>；在报告报文中为要参加的组地址。</p><h4 id="加入多播组"><a class="markdownIt-Anchor" href="#加入多播组"></a> 加入多播组</h4><p>多播的基础就是一个进程的概念（操作系统执行的一个程序），该进程在一个主机的给定接口上加入了一个多播组。在一个给定接口上的多播组中的成员是动态的，它随时因进程加入和离开多播组而变化。</p><p>这里所指的进程必须以某种方式在给定的接口上加入某个多播组。进程也能离开先前加入的多播组。这些是一个支持多播主机中任何<code>API</code>所必需的部分。</p><blockquote><p>多播组中的成员是与接口相关联的，一个进程可以在多个接口上加入同一多播组。</p><p>主机必须保留一个表，此表中包含所有至少含有一个进程的多播组以及多播组中的进程数量。</p></blockquote><h4 id="igmp-报告和查询"><a class="markdownIt-Anchor" href="#igmp-报告和查询"></a> IGMP 报告和查询</h4><p>多播路由器使用<code>IGMP</code>报文来记录与该路由器相连网络中组成员的变化情况。规则如下：</p><ul><li>当第一个进程加入一个组时，主机就发送一个<code>ICMP</code>报告。如果一个主机的多个进程加入同一组，只发送一个<code>IGMP</code>报告。这个报告被发送到进程加入组所在的同一接口上。</li><li>进程离开一个组时，主机不发送 <code>IGMP</code>报告，即便是组中的最后一个进程离开。主机知道在确定的组中已不再有组成员后，在随后收到的<code>IGMP</code>查询中就不再发送报告报文。</li><li>多播路由器定时发送<code>IGMP</code>查询来了解是否还有任何主机包含有属于多播组的进程。多播路由器必须向每个接口发送一个<code>IGMP</code>查询。因为路由器希望主机对它加入的每个多播组均发回一个报告，因此<code>IGMP</code>查询报文中的组地址被设置为<code>0</code>。</li><li>主机通过发送<code>IGMP</code>报告来响应一个<code>IGMP</code>查询，对每个至少还包含一个进程的组均要发回<code>IGMP</code>报告。</li></ul><blockquote><p>使用这些查询和报告报文，多播路由器对每个接口保持一个表，表中记录接口上至少还包含一个主机的多播组。当路由器收到要转发的多播数据报时，它只将该数据报转发到（使用相应的多播链路层地址）还拥有属于那个组主机的接口上。</p></blockquote><img src="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/IGMP查询与报告.gif" alt="IGMP查询与报告" style="max-width:60%;"><span class="image-caption">IGMP查询与报告</span><p><strong>实现细节</strong>：</p><ul><li>当一个主机首次发送<code>IGMP</code>报告时，并不保证该报告被可靠接收（因为使用的<code>IP</code>交付服务）。下一报告将在间隔一段时间后发送，时间间隔由主机在<code>0</code>～<code>10</code>秒的范围内随机选择。</li><li>当一个主机收到路由器发出的查询后，并不立即响应，而是经过一定的时间间隔后才发出响应（主机必须对它参加的每个组均发送一个响应）。 <strong>既然参加同一多播组的所有主机均发送一个报告，所以可将它们的发送间隔设置为随机时延。</strong></li></ul><blockquote><p>在一个物理网络中的所有主机将收到同组其他主机发送的所有报告，因为如上图所示的报告中的目的地址是组地址。这意味着如果一个主机在等待发送报告的过程中，却收到了发自其他主机的相同报告，则该主机的响应就可以不必发送了。因为多播路由器并不关心有多少主机属于该组（甚至不关心哪些主机属于一个多播组），而只关心该组是否还至少拥有一个主机。</p></blockquote><p><strong>生存时间</strong>：</p><p>在默认情况下，待传多播数据报的<code>TTL</code>被设置为<code>1</code>，这将使多播数据报仅局限在同一子网内传送。更大的<code>TTL</code>值能被多播路由器转发。</p><blockquote><p>对发往一个多播地址的数据报从不会产生<code>ICMP</code>差错。当<code>TTL</code>值为0时，多播路由器也不产生<code>ICMP</code>“超时”差错。</p></blockquote><p>通过增加<code>TTL</code>值的方法，一个应用程序可实现对一个特定服务器的扩展环搜索 (<code>expanding ring search</code>)。第一个多播数据报以<code>TTL</code>等于<code>1</code>发送。如果没有响应，就尝试将<code>TTL</code>设置为<code>2</code>然后<code>3</code>，等等。在这种方式下，该应用能找到以跳数来度量的最近的服务器。</p><blockquote><p>从<code>224.0.0.1</code>到<code>224.0.0.255</code>的特殊地址空间用于多播范围不超过<code>1</code>的应用。不管<code>TTL</code>值是多少，多播路由器均不转发目的地址为这些地址中的任何一个地址的数据报。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UDP&lt;/code&gt;（&lt;strong&gt;User Datagram Protocol&lt;/strong&gt;）是一个简单的面向数据报的运输层协议，进程的每个输出操作都正好产生一个&lt;code&gt;UDP&lt;/code&gt;数据报并组装成一个待发送的&lt;cod
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="UDP" scheme="http://fcwalkers.com/tags/UDP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议－IP 选路</title>
    <link href="http://fcwalkers.com/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/"/>
    <id>http://fcwalkers.com/2021/10/20/network/TCPIP协议—IP选路/</id>
    <published>2021-10-19T16:00:00.000Z</published>
    <updated>2021-12-14T02:05:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="ip-选路"><a class="markdownIt-Anchor" href="#ip-选路"></a> IP 选路</h3><p><code>IP</code>层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。这区别于选路策略，它只是一组决定把哪些路由放入路由表的规则。<code>IP</code>执行选路机制，而路由守护程序则一般提供选路策略。</p><h4 id="路由表"><a class="markdownIt-Anchor" href="#路由表"></a> 路由表</h4><p>执行<code>netstat -rn</code> 命令列出路由表如下：</p><pre class="highlight"><code class="bash">$ netstat -rnrouting tablesDestination     Gateway         Flags   Ifacedefault         192.168.1.1     UG      en0127.0.0.1       127.0.0.1       UH      lo0 192.168.1.30    192.168.1.35    UGH     en0</code></pre><p>如果目的地是<code>Destination</code>字段中的值，那么网关（路由器）将把分组转发到<code>Gateway</code>所对应的地址。</p><p><code>Flags</code>标志字段：</p><ul><li>U　该路由可以使用。</li><li>G　该路由是一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的。</li><li>H　该路由是到一个主机，即目的地是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目地地址是一个网络地址（一个网络号，或网络号与子网号的组合）。</li><li>D　该路由是重定向报文创建的。</li><li>M　该路由已被重定向报文修改。</li></ul><blockquote><p><code>deafult</code>表示默认路由，<code>Host Requirements RFC</code>文档中特别说明，<code>IP</code>层必须支持多个默认路由。但是，许多实现系统并不支持这一点。</p></blockquote><p>主机路由表的复杂性取决于主机所在网络的拓扑结构：</p><ul><li>最简单的情况是主机未与任何网络相连。<code>TCP/IP</code>协议仍然能用于这样的主机，但是只能与自己本身通信，路由表只包含环回接口一项。</li><li>第二种情况是主机连接在一个局域网上，只能访问局域网上的主机。这时路由表包含两项分别是环回接口和局域网（以太网）。</li><li>如果主机能够通过单个路由器访问其他网络（如<code>Internet</code>）时，那么就进行下一步。一般情况下增加一个默认表指向该路由器。</li><li>如果要新增其他的特定的主机或网络路由，那么就进行最后一步。</li></ul><blockquote><p>如果路由表中没有默认项，而又没找到匹配项时，会有两种情况：</p><p>1）如果数据报是由本机产生的，那么就给发送该数据报的应用程序返回一个差错（主机不可达或网络不可达差错）。</p><p>2）如果是被转发的数据报，那么就给原始发送端发送一份<code>ICMP</code>主机不可达差错报文。</p></blockquote><h4 id="icmp-重定向差错"><a class="markdownIt-Anchor" href="#icmp-重定向差错"></a> ICMP 重定向差错</h4><p>当<code>IP</code>数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送<code>ICMP</code>重定向差错报文给<code>IP</code>数据报的发送端。只有当主机可以选择路由器发送分组的情况下，我们才可能看到<code>ICMP</code>重定向报文，如下图：</p><ul><li>主机发送一份数据报给<code>R2</code>，主机的默认路由表是<code>R1</code>，所以数据报先到达<code>R1</code>。</li><li><code>R1</code>收到数据报并检查它的路由表，发现<code>R2</code>是该数据报的下一站。当它把数据报发送给<code>R2</code>时，<code>R1</code>检测到它正在发送的接口与数据报到达的接口相同（即主机与两台路由所连接的<code>LAN</code>）。这样就给路由器发送重定向报文给原始发送端提供了线索。</li><li><code>R1</code>发送一份<code>ICMP</code>重定向报文给主机，告诉它以后把数据报发送给<code>R2</code>而不是<code>R1</code>。</li></ul><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/ICMP重定向示例.gif" alt="ICMP 重定向示例" style="max-width:50%;"><span class="image-caption">ICMP 重定向示例</span><blockquote><p><code>ICMP</code>重定向允许<code>TCP/IP</code>主机在进行选路时不需要具备智能特性，而把所有的智能特性放在路由器端。</p><p>主机启动时路由表中可以只有一个默认表项，通过接收重定向报文来逐步学习。</p></blockquote><h4 id="icmp-重定向报文"><a class="markdownIt-Anchor" href="#icmp-重定向报文"></a> ICMP 重定向报文</h4><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/ICMP重定向报文.gif" alt="ICMP 重定向报文" style="max-width:60%;"><span class="image-caption">ICMP 重定向报文</span><p><strong>代码</strong> 字段：</p><ul><li><code>0</code> 网络重定向</li><li><code>1</code> 主机重定向</li><li><code>2</code> 服务类型和网络重定向</li><li><code>3</code> 服务类型和主机重定向</li></ul><blockquote><p><code>ICMP</code>重定向报文的接收者必须查看三个<code>IP</code>地址：</p><p>1）导致重定向的<code>IP</code>地址（即<code>ICMP</code>重定向报文的数据，位于<code>IP</code>数据报首部）；</p><p>2）发送重定向报文的路由器的<code>IP</code>地址（包含重定向信息的<code>IP</code>数据报中的源地址）；</p><p>3）应该采用的路由器<code>IP</code>地址（在<code>ICMP</code>报文中的<code>4</code>~<code>7</code>字节）。</p><p><code>ICMP</code>只能由路由器生成，而不能由主机生成，重定向报文是为主机而不是为路由器使用的。</p></blockquote><p><u>假定多个路由共同参与一个共同参与一种选路协议，则该协议应该消除重定向需求（这就意味着路由表应该被路由守护进程或重定向修改，但不能同时修改。</u> <mark>没读懂???</mark></p><p>当一个<code>BSD</code>主机作为路由器生成<code>ICMP</code>重定向报文前必须通过下面检查：</p><ul><li><p>出接口必须等于入接口</p></li><li><p>用于传出的数据报的路由不能是已经被<code>ICMP</code>重定向创建或修改的，并且不能是路由器的默认路由。</p></li><li><p>数据报不能是源路由</p></li><li><p>内核必须被配置成可以发送重定向</p><blockquote><p>内核变量通常被命名为<code>ip_sendredirects</code>或类似名字来配置，大多数现代系统（<code>BSD</code>、<code>SunOS4.1</code>、<code>Solaris 2.x</code>、和<code>AIX 3.2.2</code>）默认都启用了这个变量，其他系统如<code>SVR4</code>默认禁用该变量。</p></blockquote></li></ul><p>当一个<code>BSD</code>主机接收一个<code>ICMP</code>重定向更新路由表之前必须通过下面检查：</p><ul><li>新的路由器必须直接与网络相连接</li><li>重定向的目的地必须是当前路由器（即当前主机）</li><li>重定向不能让主机本身作为路由器</li><li>被修改的路由必须是一个间接路由</li></ul><blockquote><p>这是为了防止路由器或主机的误操作，以及恶意用户的破坏，导致错误地修改系统路由表。</p><p>路由器应该发送的只是对主机的重定向（代码<code>1</code>或<code>3</code>），而不是对网络的重定向。</p></blockquote><h4 id="icmp-路由器发现报文"><a class="markdownIt-Anchor" href="#icmp-路由器发现报文"></a> ICMP 路由器发现报文</h4><p>到达主机或网络的路由如果不直接相连，那么必须加入路由表。常用的方法是在系统被引导启动时使用<code>route</code>命令。但是几乎没有系统愿意在初始化文件中包含<code>route</code>命令。</p><p>一些系统允许在某个文件中指定默认的路由器，如<code>/etc/defaultrouter</code>。于是在每次重新启动系统时都要在路由表中加入该默认项。</p><p>另一种新的方法是使用<code>ICMP</code>路由器通告和请求报文，允许每个正在监听的主机相应地更新它们的路由表。</p><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/ICMP通告请求报文.gif" style="max-width:60%;"><p><strong>地址数</strong> 字段，报文中所含地址的数量（路由器在一份报文中可以通告多个地址）。</p><p><strong>地址项大小</strong> 字段，每个路由器地址<code>32bit</code>字的数目，始终为<code>2</code>（<code>MAC</code>地址<code>64bit</code>除以<code>32bit</code>等于<code>2</code>）。</p><p><strong>生存时间</strong> 字段，通告地址的有效时间（秒）。</p><p><strong>路由器地址</strong> 字段，发送路由器的某个<code>IP</code>地址。</p><p><strong>优先级</strong> 字段，是一个<code>32bit</code>有符号整数，指出该<code>IP</code>地址作为默认路由器地址的优先级，这是相对于子网上的其他路由器地址而言。值越大优先级越高，值为<code>0x80000000</code>表示该地址不能作为默认路由器地址使用，默认值一般为<code>0</code>。</p><blockquote><p>当路由器启动时，它不定期随机在所有广播或多播传送接口上发送通告报文。随机传送的目的是为了减小与子网上其他路由器发生冲突的概率。一般每两次通告间隔<code>450</code>秒和<code>600</code>秒。一份给定的通告报文默认生命周期是<code>30</code>分钟。</p><p>是当路由器上的某个接口被关闭时，路由器可以在该接口上发送最后一份通告报文，并把生命周期值设为<code>0</code>。</p><p>除了定期发送主动提供的通告报文以外，路由器还要监听来自主机的请求报文，并发送路由器通告报文以响应这些请求报文。</p></blockquote><p>主机在引导期间一般发送三份路由器请求报文，每三秒钟发送一次。一旦接收到一个有效的通告报文，就停止发送请求报文。主机也监听来自相邻路由器的请求报文。这些通告报文可以改变主机的默认路由器。另外，如果没有接收到来自当前默认路由器的通告报文，那么默认路由器会超时。</p><p>只要有一般的默认路由器，该路由器就会每隔<code>10</code>分钟发送通告报文，报文的生命周期是<code>30</code>分钟。这说明主机的默认表项是不会超时的，即使错过一份或两份通告报文。</p><h3 id="动态选路协议"><a class="markdownIt-Anchor" href="#动态选路协议"></a> 动态选路协议</h3><p>上面的静态选路在配置接口时以默认方式生成路由表项（对于直接连接的接口），并通过<code>route</code>命令增加表项（通常从系统自引导程序文件），或是通过<code>ICMP</code>重定向方式生成表项（通常是在默认方式出错的情况下）。</p><p>在网络很小且与其他网络只有单个连接点且没有多余路由时（若主路由失败，可以使用备用路由），采用这种方法是可行的。如果上述三种方法均无法满足，通常使用 <strong>动态选路</strong>。</p><h4 id="动态选路"><a class="markdownIt-Anchor" href="#动态选路"></a> 动态选路</h4><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/IP层工作流程.gif" alt="IP 层工作流程" style="max-width:60%;"><span class="image-caption">IP 层工作流程</span><p>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这时就出现了动态选路。路由器上有一个 <strong>路由守护进程（routing daemon）</strong> 它运行选路协议，并与其相邻的一些路由器进行通信。路由守护程序根据它从相邻路由器接收的信息，更新内核中的路由表。</p><p>动态路由并不改变内核在<code>IP</code>层选路方式（内核搜索路由表，查找主机路由、风格路由以及默认路由的方式并没有改变），仅仅是放置路由表中的信息改变了，路由是由动态路由守护程序动态的增加或删除，而不再来自于引导程序中的route命令。</p><blockquote><p>路由守护程序将 <strong>选路策略（routing policy）</strong> 加入到系统中，选择路由并加入内核路由表中。如果守护程序发现前往同一信宿存在多条路由，那么它（以某种方法）将选择最佳路由并加入内核路由表中。如果路由守护程序发现一条链路已经断开（可能是路由器崩溃或电话线路不好），它可以删除受影响的路由或增加另一条路由以绕过该问题。</p></blockquote><p><code>Internet</code>系统中采用了许多不同的选路协议，以一组 <strong>自治系统（Autonomous System，AS）</strong> 方式组织，每个自治系统由单个实体管理。如一个公司或大学校园都可以定义为自治系统。</p><p>每个自治系统可以选择该自治系统中各个路由器之间的选路协议。这种协议我们称之为 <strong>内部网关协议（Interior Gateway Protocol，IGP）</strong> 或 <strong>域内选路协议（intradomain routing protocol）</strong> 。</p><p>常见的<code>IGP</code>协议：</p><ul><li><code>RIP（Routing Information Protoco）</code>　路由信息协议，最常用的选路协议。</li><li><code>OSPF（Open Shortest Path First）</code>　一种新的选路协议，开放最短路径优先协议，意图取代 RIP。</li><li><code>HELLO</code>　NSFNET 骨干网上使用的较早的协议，现在已经不用了。</li></ul><p><em><strong><code>RFC [Almquist 1993]</code>规定，实现任何动态选路协议的路由器必须同时支持<code>RIP</code>和<code>OSPE</code>，还可以支持其他 <code>IGP</code> 协议</strong></em></p><p><strong>外部网关协议（Exterier Gateway Protocol，EGP）</strong> 或 <strong>域内选路协议</strong> 是用于不同自治系统之间路由器的独立路由协议。</p><p>常见的<code>EGP</code>协议：</p><ul><li><code>EGP</code>　与它同名的协议。</li><li><code>BGP（Border Gateway Protocol，BGP）</code>　新的外部网关协议是当前在 NSFNET 骨干网和一些连接到骨干网的区域性网络上使用的是 <strong>边界网关协议</strong>。意在取代 EGP 协议。</li></ul><h4 id="rip"><a class="markdownIt-Anchor" href="#rip"></a> RIP</h4><p><strong>路由信息协议（Routing Information Protoco，RIP）</strong> ,它是最广为使用（也是最受攻击）的选路协议。对于 <code>RIP</code>的正式描述文件是<code>RFC 1058 [Hedrick 1988a]</code>，是该<code>RFC</code>是在该协议实现数年后才出现的。</p><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/RIP.gif" style="max-width:60%;"><p><code>RIP</code>报文包含在<code>UDP</code>数据报中，如上图：</p><p><strong>命令</strong> 字段，<code>1</code>表示请求；<code>2</code>表示应答；<code>3</code>和<code>4</code>是两个舍弃不用的命令；最后两个是非正式命令，<code>5</code>表示轮询<code>6</code>表示轮询表项。</p><blockquote><p>请求命令表示要求其他系统发送全部或部分路由表。应答命令表示包含发送者的全部或部分路由表。</p></blockquote><p><strong>版本</strong> 字段，通常为<code>1</code>。<em>第二版本 RIP 将此字段设置为 2</em></p><p>接下来是<code>20</code>字节的路由表项，其中 <strong>地址系列</strong> 字段值为<code>2</code>表示<code>IP</code>协议； <strong>32位 IP 地址</strong> 字段值是该路由的目的<code>IP</code>地址（可以是子网地址和主机地址）； <strong>度量</strong> 字段是以跳计数的路由开销值。</p><blockquote><p>一个<code>RIP</code>报文中最多可以有<code>25</code>个路由表项，上限<code>25</code>是为了保证<code>RIP</code>总报文长度为<code>20*25+4=504</code>，小于<code>512</code>字节。由于此限制，所以为了发送整个路由表，经常需要发送多个报文。</p></blockquote><p><code>RIP</code>正常运行流程如下：</p><ul><li><p><strong>初始化</strong> ，在启动一个路由守护程序时，先判断启动哪些接口，并在每个接口上发送一个请求报文，要求其他路由器发送完整路由表。在点对点链路中，该请求是发送给其他终点。如果网络支持广播，请求则以广播方式发送。目的端口号是<code>520</code>（其他路由器守护程序的端口号）。</p><blockquote><p>请求报文命令字段值为<code>1</code>，地址系列字段值为<code>0</code>，度量字段值为<code>16</code>。这是一种要求另一端完整路由表的特殊请求报文。</p></blockquote></li><li><p><strong>接收到请求</strong> ，如果请求是上面的特殊请求，那么路由器将完整路由表发送给请求者。否则，处理请求表中的每一个表项：如果有连接到指明地址的路由，则将度量设置成我们的值，否则将度量值设置为<code>16</code>（度量为<code>16</code>是一种称为“无穷大”的特殊值，它意味着没有到达目的路由），然后发回响应。</p></li><li><p><strong>接收到响应</strong> ，使响应生效，可能会更新路由表。可能会增加新表项，对已有表项进行修改，或是将已有表项删除。</p></li><li><p><strong>定期选路更新</strong> ，每过<code>30</code>秒所有或部分路由器会将完整路由表发送给相邻路由器。发送路由表可以是广播形式，或是发送点对点链路的其他终点。</p></li><li><p><strong>触发更新</strong> ，每当一条路由度量发生变化时，就对它进行更新。不需要发送完整路由表，只需要发送变化的路由表项。</p><blockquote><p>每条路由都有与之相关的定时器。如果运行<code>RIP</code>的系统发现一条路由在<code>3</code>分钟内未更新，就将该路由的度量设置成无穷大（<code>16</code>），并标注为删除。这意味着已经在<code>6</code>个<code>30</code>秒更新时间里没收到通告该路由的路由器的更新了。再过<code>60</code>秒，将从本地路由表中删除该路由，以保证该路由的失效已被传播开。</p></blockquote></li></ul><h4 id="度量"><a class="markdownIt-Anchor" href="#度量"></a> 度量</h4><p><code>RIP</code> 的度量是以跳(<code>hop</code>)计算的，直接相连的接口跳数为<code>1</code>。如下图，路由器<code>R1</code>通过发送广播到<code>N1</code>通告它与<code>N2</code>之间的跳数是<code>1</code>（发送给<code>N1</code>的广播中通告它与<code>N1</code>之间的路由是无用的）。同时也发送广播给<code>N2</code>通告它与<code>N1</code>之间的跳数为<code>1</code>。同样<code>R2</code>通告它与<code>N2</code>的度量为<code>1</code>，与<code>N3</code>的度量为<code>1</code>。</p><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/RIP度量.gif" alt="路由器和网络示例" style="max-width:60%;"><span class="image-caption">路由器和网络示例</span><p>如果相邻的路由器通告它与其他网络的跳数为<code>1</code>，那么我们就与那个网络的度量就是<code>2</code>，原因在于发送报文到达该网络必须经过那个路由器。如上图，<code>R1</code>到<code>N3</code>和<code>R2</code>到<code>N1</code>的度量均为<code>2</code>。</p><blockquote><p>由于每个路由器都发送其路由表给邻站，因此，可以判断在同一个自治系统<code>AS</code>内到每个网络的路由。如果在该<code>AS</code>内从一个路由器到一个网络有多条路由，那么路由器将选择跳数最小的路由，而忽略其他路由。</p><p>跳数的最大值是<code>15</code>，这意味着<code>RIP</code>只能用在主机间最大跳数值为<code>15</code>的<code>AS</code>内。度量为<code>16</code>表示到无路由到达该<code>IP</code>地址。</p></blockquote><h4 id="rip-缺陷"><a class="markdownIt-Anchor" href="#rip-缺陷"></a> RIP 缺陷</h4><p><code>RIP</code>没有子网地址概念。如果标准<code>B</code>类主机地址主机号不为<code>0</code>，那么<code>RIP</code>无法区分非零部分是一个子网号，还是一个主机号。有一些实现通过接收到的<code>RIP</code>信息，来使用接口的网络掩码，但这有可能出错。</p><p>其次，在路由器或链路发生故障后，通常需要几分钟甚至更长一的时间稳定下来。在这段时间里可能发生路由环路，在实现<code>RIP</code>时必须很多微妙的措施来防止路由环路的出现，使其尽快建立。</p><blockquote><p>路由环路，就是数据包不断在这个网络传输，始终到达不了目的地，导致掉线或者网络瘫痪。</p><p>在维护路由表信息的时候，如果在拓扑发生改变后，网络收敛缓慢产生了不协调或者矛盾的路由选择条目，就会发生路由环路的问题，这种条件下，路由器对无法到达的网络路由不予理睬，导致用户的数据包不停在网络上循环发送，最终造成网络资源的严重浪费。</p></blockquote><p>采用跳数作为路由度量忽略了一些其他考虑的因素。并且度量最大值是<code>15</code>，则限制了可以使用<code>RIP</code>网络的大小。</p><h4 id="rip-2"><a class="markdownIt-Anchor" href="#rip-2"></a> RIP-2</h4><p><code>RIP</code>的第二版只是对第一版进行扩充，并不改变协议本身，而是利用一些“必须为0”字段来传递一些额外信息。如果<code>RIP</code>忽略了这些“必须为0”字段，那么<code>RIP</code>和<code>RIP-2</code>可以交互操作。</p><img src="/2021/10/20/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94IP%E9%80%89%E8%B7%AF/RIP-2.gif" alt="RIP-2报文格式" style="max-width:60%;"><span class="image-caption">RIP-2报文格式</span><p><strong>路由域</strong> 字段，是这个数据报所属的路由守护程序的标识符。在<code>Unix</code>实现中，它可以是一个路由守护程序的进程号。这个字段允许管理者在一个路由器上运行多个<code>RIP</code>实例，每个实例在一个路由域内运行。</p><p><strong>路由标记</strong> 字段，是为了支持外部的网关协议而存在的，它携带一个<code>EGP</code>和<code>BGP</code>的自治系统号。</p><p><strong>子网掩码</strong> 字段，每个表项的子网掩码应该用于相应的<code>IP</code>地址上。</p><p><strong>下一站IP地址</strong> 字段，指明发往目的<code>IP</code>地址的报文该发往哪里。该字段为<code>0</code>表示发往目的地址的报文应该发给发送<code>RIP</code>报文的系统。</p><blockquote><p><code>RIP-2</code>提供了一种简单的鉴别机制，指定<code>RIP</code>报文前<code>20</code>字节表项地址系列为<code>0xffff</code>，路由标记为<code>2</code>，表项中其余<code>16</code>字节包含一个明文口令。</p><p><code>RIP-2</code>除了广播外，还支持多播，可以减少不收听<code>RIP-2</code>报文的主机负载。</p></blockquote><h4 id="ospf"><a class="markdownIt-Anchor" href="#ospf"></a> OSPF</h4><p>开放最短路径优先协议是除了<code>RIP</code>外另一个内部网关协议，它克服了<code>RIP</code>的所有限制，随着大部分厂商支持<code>OSPF</code>，在很多网络中<code>OSPF</code>将逐步取代<code>RIP</code>。</p><p>与采用距离向量（跳数）的<code>RIP</code>不同，<code>OSPF</code>是一个链路状态协议。每个路由器都根据它所收到邻站的这些距离向量来更新自己的路由表。</p><p>在一个链路协议中，路由器并不与邻站交换路由信息。它采用的是每个路由器主动的测试与其邻站相连链路的状态，将这些信息发送给它的其他邻站，而邻站将这些信息在自治系统中传播出去。每个路由器接收这些链路状态信息，并建立起完整的路由表。</p><blockquote><p>链路状态协议总是比距离向量协议收敛（路由发生变化后，稳定下来）更快。</p></blockquote><p><code>OSPF</code>不使用<code>UDP</code>而是直接使用<code>IP</code>,在<code>IP</code>首部协议字段有自己的值。</p><p><strong>特点</strong>：</p><p>1）可以对每个<code>IP</code>服务类型（<code>TOS</code>）计算各自路由集。这意味着对于任何目的，可以有多个路由表项，每个表项对应着一个<code>IP</code>服务类型。</p><p>2）每个接口被分配一个 <a href="https://baike.baidu.com/item/%E6%97%A0%E9%87%8F%E7%BA%B2/10675963"><em>无量纲</em> </a> 成本，可以通过吞吐率、往返时间、可靠性或其他性能来进行分配。可以给每个<code>IP</code>服务类型单独分配成本。</p><p>3）当对同一个目的地址存在多个相同成本的路由时，在这些路由上平均分配流量，称之为流量平衡。</p><p>4）支持子网，子网掩码与每个通告路由相连。这样就允许将一个任何类型的<code>IP</code>地址分割成多个不同大小的子网。到一个主机的路由是通过全<code>1</code>子网掩码进行通告的。默认路由是以<code>IP</code>地址为<code>0.0.0.0</code>网络掩码为全<code>0</code>进行通告的。</p><p>5）路由器之间点对点链路不需要每端都有一个<code>IP</code>地址，称之为无记号网络。这样可以节省<code>IP</code>地址。</p><p>6）采用一种简单鉴别机制。可以采用类似于<code>RIP-2</code>机制的方法指定一个明文口令。</p><p>7）采用多播，而不是广播形式，以减少不参与<code>OSPF</code>系统的负载。</p><h4 id="bgp"><a class="markdownIt-Anchor" href="#bgp"></a> BGP</h4><p>边界网关协议，是一种不同自治系统的路由器之间进行通信的外部网关协议。<code>BGP</code>是<code>ARPANET</code>所使用的老<code>EGP</code>的取代品。</p><p><code>BGP</code>系统与其他<code>BGP</code>系统之间交换网络可到达信息包括数据到达这些网络所必须经过的自治系统<code>AS</code>中的所有路径。这些信息足以构造一幅自治系统连接图。然后，可以根据连接图删除选路环，制订选路策略。</p><p>将一个自治系统中的<code>IP</code>数据报分为本地流量和通过流量。其中，本地流量是起始或终止于该自治系统的流量（即信源<code>IP</code>地址或宿信<code>IP</code>地址所指定的主机位于该自治系统中），其他流量则称为通过流量。在<code>Internet</code>中使用<code>BGP</code>的一个目的就是减少通过流量。</p><p><strong>自治系统分类</strong>：</p><ul><li><code>残桩自治系统（stub AS）</code>，与其他自治系统只有单个连接，因此只有本地流量。</li><li><code>多接口自治系统（multihomed AS）</code>，与其他自治系统有多个连接，但拒绝传送通过流量。</li><li><code>传送自治系统（transit AS）</code>，与其他自治系统有多个连接，在一些策略准则下，可以传送本地流量和通过流量。</li></ul><blockquote><p>可以将<code>Internet</code>的总拓扑结构看成是由一些残桩自治系统、多接口自治系统以及传送自治系统的任意互连。</p><p>残桩自治系统和多接口自治系统不需要使用<code>BGP</code>，它们通过运行<code>EGP</code>在自治系统之间交换可到达信息。</p></blockquote><p><code>BGP</code>允许使用基于策略的选路。由自治系统管理员制订策略，并通过配置文件将策略指定给<code>BGP</code>。制订策略并不是协议的一部分，但指定策略允许<code>BGP</code>实现在存在多个可选路径时选择路径，并控制信息的重发送。选路策略与政治、安全或经济因素有关。</p><p><code>BGP</code>使用<code>TCP</code>作为其传输层协议，两个运行<code>BGP</code>的系统之间建立一条<code>TCP</code>连接，然后交换整个<code>BGP</code>路由表。从这个时候开始，在路由表发生变化时，再发送更新信号。</p><p><code>BGP</code>是一个距离向量协议，但是与（通告到目的地址跳数的）<code>RIP</code>不同的是，<code>BGP</code>列举了到每个目的地址的路由（自治系统到达目的地址的序列号）。这样就排除了一些距离向量协议的问题。采用<code>16 bit</code>数字表示自治系统标识。</p><blockquote><p><code>BGP</code>通过定期发送<code>keepalive</code>报文给其邻站来检测<code>TCP</code>连接对端的链路或主机失败。两个报文之间的时间间隔建议值为<code>30</code>秒。应用层的<code>keepalive</code>报文与<code>TCP</code>的<code>keepalive</code>选项是独立的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;ip-选路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ip-选路&quot;&gt;&lt;/a&gt; IP 选路&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IP&lt;/code&gt;层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IP选路" scheme="http://fcwalkers.com/tags/IP%E9%80%89%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议－Ping 与 Traceroute 程序</title>
    <link href="http://fcwalkers.com/2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/"/>
    <id>http://fcwalkers.com/2021/10/15/network/TCPIP协议—Ping与Traceroute程序/</id>
    <published>2021-10-14T16:00:00.000Z</published>
    <updated>2021-12-14T02:03:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="ping-程序"><a class="markdownIt-Anchor" href="#ping-程序"></a> Ping 程序</h3><p>名字源于声纳定位，用于测试目的主机是否可达。该程序发送一份<code>ICMP</code>回显请求报文给主机，并等待返回<code>ICMP</code>回显应答。</p><p>一般来说，如果不能<code>Ping</code>到某台主机，也就不能<code>Telnet</code>或<code>FTP</code>到那台主机。</p><blockquote><p>随着<code>Internet</code>安全意识的增强，出现了提供访问控制清单的路由器和防火墙，像这样的无限定的断言就不再成立了。</p><p>一台主机的可达性可能不只取决于<code>IP</code>层是否可达，还取决于使用何种协议以及端口号。</p></blockquote><p><code>Ping</code>程序还能测出到这台主机的往返时间，表明该主机离我们有“多远”。</p><p><mark>发送回显请求的 Ping 程序为客户，被 Ping 主机称为服务器。</mark></p><p>大多数<code>TCP/IP</code>实现都在内核中直接支持<code>Ping</code>服务器，这种服务器不是一个用户进程。</p><img src="/2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/ICMP回显报文.gif" alt="ICMP 回显请求和应答报文" style="max-width:60%;"><span class="image-caption">ICMP 回显请求和应答报文</span><p>对于其他类型的<code>ICMP</code>查询报文，服务器必须响应标识符和序列号字段。另外，客户发送的选项数据必须回显。</p><blockquote><p><code>Unix</code>系统在实现<code>Ping</code>程序时是把<code>ICMP</code>报文中的标识符字段置成发送进程的<code>ID</code>号。这样即使在同一台主机上同时运行了多个<code>Ping</code>程序实例，<code>Ping</code>程序也可以识别出返回的信息。</p></blockquote><p><strong>序列号</strong> 从<code>0</code>开始，每发送一次新的回显请求就加<code>1</code>。<code>Ping</code>程序打印出返回的每个分组的序列号，允许我们查看是否有分组丢失、失序或重复。</p><h4 id="lan-输出"><a class="markdownIt-Anchor" href="#lan-输出"></a> LAN 输出</h4><p>在局域网上<code>Ping</code>程序输出结果如下：</p><pre class="highlight"><code class="bash">$ ping <span class="hljs-built_in">test</span>PING <span class="hljs-built_in">test</span> (192.168.2.80): 56 data bytes64 bytes from 192.168.2.80: icmp_seq=0 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=1 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=2 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=3 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=4 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=5 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=6 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=7 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=8 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=9 ttl=54 time=0 ms64 bytes from 192.168.2.80: icmp_seq=10 ttl=54 time=0 ms...--- www.a.shifen.com ping statistics ---10 packets transmitted, 10 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 5.709/12.672/25.952/8.467 ms</code></pre><p>当<code>ICMP</code>回显应答时，打印结果：</p><ul><li><p>目的主机<code>IP</code> 域名被解析器转换成了<code>IP</code>地址。</p></li><li><p><code>icmp_seq</code>（序列号）每次都从<code>0</code>开始逐条加<code>1</code>。</p></li><li><p><code>ttl</code>（<code>IP</code>首部中生存时间）</p></li><li><p><code>time</code>（往返时间）往返时间是当应答返回时，用当前时间减去在<code>ICMP</code>存放的请求时间计算得出。</p></li><li><p><code>packets transmitted</code> 发包数量</p></li><li><p><code>packets received</code> 接包数量</p></li><li><p><code>packet loss</code> 丢包率</p></li><li><p><code>round-trip time（RTT）</code> 往返时间的<code>min/avg/max</code>计算结果。</p></li></ul><blockquote><p>上面结果中<code>time</code>均为<code>0ms</code>，这是因为程序使用的计时器分辨率低的原因。</p><p><code>BSD/386</code>版本<code>0.9.4</code>系统只能提供<code>10ms</code>级的计时器。</p><p>通常，第<code>1</code>个往返时间值要比其他的大。这是由于目的端的硬件地址不在<code>ARP</code>高速缓存中的缘故。</p></blockquote><h4 id="wan-输出"><a class="markdownIt-Anchor" href="#wan-输出"></a> WAN 输出</h4><p>广域网上<code>Ping</code>程序输出结果会有一些不同，如下：</p><pre class="highlight"><code class="bash">$ ping www.baidu.comPING www.wshifen.com (103.235.46.39): 56 data bytes64 bytes from 103.235.46.39: icmp_seq=0 ttl=48 time=467.455 ms64 bytes from 103.235.46.39: icmp_seq=1 ttl=48 time=473.325 ms64 bytes from 103.235.46.39: icmp_seq=2 ttl=48 time=494.168 msRequest timeout <span class="hljs-keyword">for</span> icmp_seq 364 bytes from 103.235.46.39: icmp_seq=4 ttl=48 time=473.140 ms64 bytes from 103.235.46.39: icmp_seq=5 ttl=48 time=469.418 ms64 bytes from 103.235.46.39: icmp_seq=6 ttl=48 time=481.582 ms64 bytes from 103.235.46.39: icmp_seq=7 ttl=48 time=486.009 ms64 bytes from 103.235.46.39: icmp_seq=8 ttl=48 time=478.788 ms64 bytes from 103.235.46.39: icmp_seq=9 ttl=48 time=484.603 ms64 bytes from 103.235.46.39: icmp_seq=10 ttl=48 time=470.790 ms...--- www.wshifen.com ping statistics ---15 packets transmitted, 13 packets received, 13.3% packet lossround-trip min/avg/max/stddev = 467.455/481.129/494.168/9.280 ms</code></pre><p>如上，序号<code>3</code>回显请求或应答丢失。广域网中还可能出现，重复的分组（相同序号的分组被打印多次）、失序的分组（序号<code>N+1</code>在序号<code>N</code>前面打印）</p><h4 id="ip-记录路由选项"><a class="markdownIt-Anchor" href="#ip-记录路由选项"></a> IP 记录路由选项</h4><p>学习<code>IP</code>首部的时候，提到过可变部分有<code>32bit</code>的选项，<code>Ping</code>程序就提供了查看<code>IP</code>记录路由的选项<code>RR</code>。大多数<code>ping</code>命令通过<code>-R</code>选项指定该功能，它使得<code>Ping</code>程序发出的<code>IP</code>数据报中设置<code>IP</code>的<code>RR</code>选项。这样，每个处理该数据报的路由器都把它的<code>IP</code>放入选项字段中。</p><p>当数据报到达目的端时， <code>IP</code>地址清单应该复制到<code>ICMP</code>回显应答中，这样返回途中所经过的路由器地址也被加入清单中。当<code>Ping</code>程序收到回显应答时，它就打印出这份<code>IP</code>地址清单。</p><blockquote><p>这个过程看似简单，但是存在一些缺陷。因为<code>RR</code>是选项功能，中间路由器对<code>RR</code>的处理未必支持。</p><p>幸运的是，现在的大多数系统都支持这些选项功能，只是有一些系统不把<code>ICMP</code>请求中的<code>IP</code>清单复制到<code>ICMP</code>应答中。</p></blockquote><p><code>IP</code>首部长度字段只有<code>4bit</code>，因此<code>IP</code>首部只能包含<code>15</code>个<code>32bit</code>（即<code>60</code>字节）。其中固定部分长度为<code>20</code>字节，<code>RR</code>选项占<code>3</code>个字节（格式见下图），所以最多只剩下<code>37</code>个字节用来存在<code>IP</code>地址清单，也就是最多只能放<code>9</code>个<code>IP</code>地址。</p><p>除了上面提到的两个缺点外，记录路由选项工作得很好，为详细查看如何处理<code>IP</code>选项提供了一个机会。</p><img src="/2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/RR选项一般格式.gif" alt="IP 首部中 RR 选项一般格式" style="max-width:70%;"><span class="image-caption">IP 首部中 RR 选项一般格式</span><p><strong>code</strong>  字段，值为<code>7</code>指明<code>IP</code>选项类型。</p><p><strong>len</strong> 字段，<code>RR</code>选项总字节长度，一般为<code>39</code>（尽管可以为<code>RR</code>选项设置比最大长度小的长度，但是<code>Ping</code>程序总是提供<code>39</code>字节的选项字段，最多可以记录<code>9</code>个<code>IP</code>地址。由于<code>IP</code>首部中留给选项的空间有限，所以一般情况都设置成最大长度）。</p><p><strong>ptr</strong> 字段，称作指针字段。它是一个基于<code>1</code>的指针，指向存放下一个<code>IP</code>地址的位置。它的最小值为<code>4</code>，指向存放第一个<code>IP</code>地址的位置。随着每个<code>IP</code>地址存入清单， <code>ptr</code>的值分别为<code>8</code>，<code>12</code>，<code>16</code>，最大到<code>36</code>。当记录下<code>9</code>个<code>IP</code>地址后，<code>ptr</code>的值为<code>40</code>，表示清单已满。</p><blockquote><p>当路由器在清单中记录<code>IP</code>地址时，它应该记录入口地址还是出口地址？</p><p><code>RFC 791 [Postel 1981a]</code>指定路由器记录出口<code>IP</code>地址。</p><p>当原始主机（运行<code>ping</code>程序的主机）收到带有<code>RR</code>选项的<code>ICMP</code>回显应答时，它也要把它的入口<code>IP</code>地址放入清单中。</p></blockquote><p><strong><code>RR</code>选项示例：</strong></p><hr><p>在主机<code>svr4</code>上运行<code>Ping</code>程序到主机<code>slip</code>，其中有个中间路由<code>bdsi</code>将处理这个数据报。</p><pre class="highlight"><code class="bash">$ ping -R slipPING slip (140.252.13.65): 56 data bytes64 bytes from 140.252.13.65: icmp_seq=0 ttl=254 <span class="hljs-built_in">times</span>=280msRR:    bsdi (140.252.13.65)       slip (140.252.13.65)       bsdi (140.252.13.35)       svr4 (140.252.13.34)64 bytes from 140.252.13.65: icmp_seq=1 ttl=254 <span class="hljs-built_in">times</span>=280ms 64 bytes from 140.252.13.65: icmp_seq=2 ttl=254 <span class="hljs-built_in">times</span>=270ms ... 省略--- 140.252.13.65 ping statistics ---3 packets transmitted, 3 packets recieved, 0% packets lossround-trip min/avg/max = 270/276/280 ms</code></pre><p>分组经过<code>4</code>跳，每一跳把自己的出口<code>ip</code>加入<code>RR</code>清单，最后一跳<code>svr4</code>收到<code>ICMP</code>回显应答，所以把自己的入口<code>IP</code>也加入清单中。如下图：</p><img src="/2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/Ping程序记录路由选项.gif" alt="Ping 程序记录路由选项" style="max-width:70%;"><span class="image-caption">Ping 程序记录路由选项</span><hr><h3 id="traceroute-程序"><a class="markdownIt-Anchor" href="#traceroute-程序"></a> Traceroute 程序</h3><p><code>Ping</code>程序可以通过<code>RR</code>选项记录<code>IP</code>路由有三个问题：</p><ul><li>并不是所有的路由器都支持<code>RR</code>选项。</li><li>记录路由是单项的选项。发送端设置了该选项，那么接收端不得不从收到的<code>IP</code>首部中提取出所有的信息，然后全部返回给发送端。</li><li><code>IP</code>首部中留给选项的空间有限，不能存放当前大多数的路径。在<code>IP</code>首部选项字段中最多只能存放<code>9</code>个<code>IP</code>地址。</li></ul><p><code>Traceroute</code>程序可以解决上面的问题。它不需要中间路由器具备任何特殊的或可选的功能；它只需要目的端运行一个<code>UDP</code>模块，其他不需要任何特殊的服务器应用程序；</p><p><code>Traceroute</code>程序使用<code>ICMP</code>报文和<code>IP</code>首部中的<code>TTL</code>字段。<code>TTL</code>字段由发送端初始设置的一个<code>8bit</code>字段，推荐初始值为<code>64</code>。较老系统一经常初始化为<code>15</code>或<code>32</code>。一些<code>Ping</code>程序发送<code>ICMP</code>回显应答时经常把<code>TTL</code>设为最大值<code>255</code>。</p><blockquote><p>每个处理数据报的路由器都需要把<code>TTL</code>的值减<code>1</code>或减去数据报在路由器中停留的秒数。</p><p>由于大多数的路由器转发数据报的时延都小于<code>1</code>秒钟，因此<code>TTL</code>最终成为一个跳站的计数器，所</p><p>经过的每个路由器都将其值减<code>1</code>。</p><p><code>RFC 1009 [Braden and Postel 1987]</code>指出，如果路由器转发数据报的时延超过<code>1</code>秒，那么它将把<code>TTL</code>值减去所消耗的时间（秒数）。但很少有路由器这么实现。新的路由器需求文档<code>RFC [Almquist 1993]</code>为此指定它为可选择功能，允许把<code>TTL</code>看成一个跳站计数器。</p></blockquote><p><code>TTL</code>字段的目的是防止数据报在选中时无休止的在网络中流动。当路由器收到一份<code>IP</code>数据报时，如果其<code>TTL</code>值是<code>0</code>，路由器会将该数据报丢弃并给源主机发送一个<code>ICMP</code>超时信息。<code>Traceroute</code><mark>程序的关键在于包含这份 ICMP 信息的 IP 报文信源地址是该路由器的 IP 地址</mark></p><hr><p>综上所述，<code>Traceroute</code>程序的操作过程是，它发送一个<code>TTL</code>为<code>1</code>的<code>IP</code>数据报给目的主机，第一个路由器将<code>TTL</code>值减<code>1</code>后丢弃该数据报并发回一份<code>ICMP</code>超时报文，这样就得到了第一个路由器地址；然后，<code>Traceroute</code>再发送一份<code>TTL</code>为<code>2</code>的<code>IP</code>数据报，获取第二个路由器地址，依此类推，直到最终目的主机为止。</p><hr><blockquote><p>上面操作过程问题是，当目的主机接收到<code>TTL</code>为<code>1</code>的<code>IP</code>数据报时，因为已经到达目的地，所以它不会丢弃该数据报而产生一个超时<code>ICMP</code>报文。所以该方法无法判断是否已经到达目的地。</p><p>为了解决这个问题，<code>Traceroute</code>程序发送一个<code>UDP</code>数据报给目的主机，但使用一个不可能值作为端口（大于30 000），使目的主机任何一个程序都不可能使用该端口。所以，当数据报到达时，目的主机<code>UDP</code>模块将产生一个“端口不可达”错误的<code>ICMP</code>报文，通过判断这个状态就可以知道是否已经到达目的地。</p></blockquote><p><code>Traceroute</code>程序可以为发送数据报设置<code>TTL</code>字段，并非所有<code>TCP/IP</code>接口程序都支持这项功能（目前大多数系统都支持这项功能）。</p><h4 id="lan-输出-2"><a class="markdownIt-Anchor" href="#lan-输出-2"></a> LAN 输出</h4><pre class="highlight"><code class="bash">$ traceroute laniptraceroute to lanip (192.168.1.59), 64 hops max, 52 byte packets 1  lanip (192.168.1.59)  6.332 ms  5.757 ms  5.427 ms</code></pre><p>第一行，打印出域名和<code>IP</code>地址、最大<code>TTL</code>值为<code>64</code>和<code>52</code>字节数据包包括<code>IP</code>首部<code>20</code>字节、<code>UDP</code>首部<code>8</code>字节和<code>24</code>字节的用户数据（包含每发一个数据报就加 1的序列号、<code>TTL</code>和发送数据报的时间）。</p><p>从第二行起，以<code>TTL</code>开始，接下来是主机或路由器名及<code>IP</code>地址。</p><blockquote><p>对于每个<code>TTL</code>值，发送3份数据报，每收到一份<code>ICMP</code>数据报就打印其往返时间。如果在<code>5</code>秒内仍未收到任意一个数据报的响应，则打印一个<code>*</code>号，并发送下一个数据报。</p><p>往返时间是由发送主机的<code>Traceroute</code>程序计算的，它是指从<code>Traceroute</code>程序到该路由器的总往返时间。如果对每段路径的时间感兴趣，可以用<code>TTL</code>字段为<code>N + 1</code>所打印出来的时间减去<code>TTL</code>字段为<code>N</code>的时间。</p></blockquote><p>上面数据<code>TTL</code>为<code>1</code>的前<code>3</code>份<code>ICMP</code>数据报分别在<code>6.332ms</code>、<code>5.757ms</code>和<code>5.427ms</code>收到。并且由于<code>TTL</code>为字段为<code>1</code>就到达最终目的主机，因此程序就此停止。</p><h4 id="wan-输出-2"><a class="markdownIt-Anchor" href="#wan-输出-2"></a> WAN 输出</h4><pre class="highlight"><code class="bash">$ traceroute www.baidu.comtraceroute: Warning: www.baidu.com has multiple addresses; using 182.61.200.7traceroute to www.a.shifen.com (182.61.200.7), 64 hops max, 52 byte packets 1  192.168.1.1 (192.168.1.1)  19.327 ms  19.036 ms  19.118 ms 2  43.228.38.145 (43.228.38.145)  6.653 ms  6.279 ms  6.568 ms 3  10.1.14.33 (10.1.14.33)  4.085 ms  3.979 ms * 4  10.1.16.165 (10.1.16.165)  25.585 ms  25.723 ms  25.560 ms 5  103.216.40.30 (103.216.40.30)  5.586 ms  27.102 ms  25.276 ms 6  182.61.255.32 (182.61.255.32)  24.570 ms    182.61.255.40 (182.61.255.40)  6.256 ms    182.61.255.34 (182.61.255.34)  24.247 ms 7  182.61.255.47 (182.61.255.47)  6.141 ms    182.61.254.183 (182.61.254.183)  6.415 ms    182.61.254.171 (182.61.254.171)  5.069 ms 8  * * * 9  * * *10  * * *... 省略64  * * *</code></pre><h4 id="ip-源站选路选项"><a class="markdownIt-Anchor" href="#ip-源站选路选项"></a> IP 源站选路选项</h4><p>通常<code>IP</code>路由是动态的，即每个路由器都要判断数据报下面该转发到哪个路由器。应用程序对此不进行控制，通常也不关心路由。</p><p><strong>源站选路（source route）</strong> 的思想是由发送者指定路由，可以采用以下两种形式：</p><ul><li>严格源站选路，发送端指明<code>IP</code>数据报所必须采用的确切路由。如果一个路由器发现源站路由所指定的下一个路由器不在其直接连接的网络上，那么它就返回一个“源站路由失败”的<code>ICMP</code>差错报文（即<code>type</code>字段值为<code>3</code>，<code>code</code>字段值为<code>5</code>，同时<code>RTT</code>后面会跟随<code>!S</code>符号）。</li><li>宽松源站选路，发送端指明一个数据报经过的<code>IP</code>地址清单，但是数据报在清单上指明任意两个地址之间可以通过其他路由器。</li></ul><p><code>Traceroute</code>程序提供了一个查看源站选路的方法，可以在选项中指明源站路由，然后检查其运行情况。</p><blockquote><p>一些公开的<code>Traceroute</code>程序源代码包中包含指明宽松的源站选路的补丁。但是在标准版中通常并不包含此项。这些补丁的解释是 “<code>Van Jacobson</code>的原始<code>Traceroute</code>程序（1 9 8 8年春）支持该特性，但后来因为有人提出会使网关崩溃而将此功能去除。”</p></blockquote><p>源站路由选项的格式与记录路由选项格式基本一致。不同之处是，对于源站选路，我们必须在发送<code>IP</code>数据报前填充<code>IP</code>地址清单，即对于源站选路，要为所需要的<code>IP</code>地址数分配空间并进行初始化，通常其数量小于<code>9</code>。</p><p><strong>code</strong> 字段，值分别为<code>0x83</code>（表示宽松源站选路）和<code>0x89</code>（表示严格的源站选路）。</p><p><strong>len</strong> 和 <strong>ptr</strong> 字段与记录路由选项一样。</p><p>源站路由选项的实际称呼为“源站及记录路由”（对于宽松的源站选路和严格的源站选路，分别用<code>LSRR</code>和<code>SSRR</code>表示），这是因为在数据报沿路由发送过程中，对<code>IP</code>地址清单进行了更新。其运行过程如下：</p><ul><li><p>发送主机从应用程序接收源站路由清单，将第<code>1</code>个表项去掉（它是数据报的最终目的地址），将剩余的项移到<code>1</code>个项中，并将原来的目的地址作为清单的最后一项。指针仍然指向清单的第<code>1</code>项（即，指针的值为<code>4</code>）。</p></li><li><p>每个处理数据报的路由器检查其是否为数据报的最终地址。如果不是，则正常转发数据报（在这种情况下，必须指明宽松源站选路，否则就不能接收到该数据报）。</p></li><li><p>如果该路由器是最终目的，且指针不大于路径的长度：</p><ul><li>由<code>ptr</code>所指定的清单中的下一个地址就是数据报的最终目的地址；</li><li>由外出接口（<code>outgoing interface</code>）相对应的<code>IP</code>地址取代刚才使用的源地址；</li><li>指针加4。</li></ul><p>如下图示例，主机<code>S</code>发送数据报到<code>D</code>，指定源路由为<code>R1</code>、<code>R2</code>和<code>R3</code>。<code>#</code>表示指针，其值分别为<code>4</code>、<code>8</code>、<code>12</code>和<code>16</code>。长度字段为<code>15</code>（三个<code>IP</code>地址<code>12</code>字节加上首部<code>3</code>字节）。</p></li></ul><img src="/2021/10/15/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94Ping%E4%B8%8ETraceroute%E7%A8%8B%E5%BA%8F/源站路由选项示例.gif" alt="IP 源站路由选项示例" style="max-width:70%;"><span class="image-caption">IP 源站路由选项示例</span><h4 id="traceroute-命令示例"><a class="markdownIt-Anchor" href="#traceroute-命令示例"></a> traceroute 命令示例</h4><p>使用<code>traceroute</code>命令<code>-g</code>选项，可以为宽松的源站选路指明一些中间路由器。最多可指定<code>8</code>个中间路由器（不是<code>9</code>个的原因是所有编程接口要求最后的表目是目的主机）。</p><blockquote><p>在命令行指定的路由器必须是十进制<code>IP</code>地址而不是域名，因为反向域名解析（通过<code>IP</code>地址返回域名）将域名与<code>IP</code>地址相关联，但是前向解析（即给出域名返回<code>IP</code>地址）则无法做到。在<code>DNS</code>中，前向映射和反向映射是两个独立的文件，而并非所有的管理者都同时拥有这两个文件。因此，在一个方向是工作正常而另一个方向却失败的情况并不少见。</p></blockquote><p>使用<code>traceroute</code>命令<code>-G</code>选项，可以执行严格源站选路。</p><blockquote><p>宽松选路的往返路由可能不完全相同，即从<code>A</code>到<code>B</code>的路径并不一定与从<code>B</code>到<code>A</code>的路径完全一样。</p><p>指定一个宽松的源站路由，该路由的目的端和宽松路径一样，但发送端为目的主机。如果发出路径的结果与返回路径不同，这很好地说明了在<code>Internet</code>上，选路可能是不对称的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;ping-程序&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#ping-程序&quot;&gt;&lt;/a&gt; Ping 程序&lt;/h3&gt;
&lt;p&gt;名字源于声纳定位，用于测试目的主机是否可达。该程序发送一份&lt;code&gt;ICMP&lt;/cod
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Ping" scheme="http://fcwalkers.com/tags/Ping/"/>
    
      <category term="Traceroute" scheme="http://fcwalkers.com/tags/Traceroute/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议－地址解析协议</title>
    <link href="http://fcwalkers.com/2021/09/27/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/"/>
    <id>http://fcwalkers.com/2021/09/27/network/TCPIP协议—地址解析协议/</id>
    <published>2021-09-26T16:00:00.000Z</published>
    <updated>2021-12-14T08:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="arp"><a class="markdownIt-Anchor" href="#arp"></a> ARP</h2><p>当一台主机把以太网的数据帧发送到位于同一局域网上的另一台主机时，是根据<code>48bit</code>的以太网地址来确定目的接口的，设备驱动程序从不检查<code>IP</code>数据报中的目的地<code>IP</code>地址。</p><p>地址解析为这两种不同的地址形式提供映射。 <strong>地址解析协议（Adress Resolution Protocol，ARP）</strong> 为<code>IP</code>地址到对应的硬件地址之间提供动态映射。</p><blockquote><p>ARP 高效运行的关键是由于每个主机都有一个<code>ARP</code>高速缓存，存放最近<code>Internet</code>地址到硬件地址之间的映射记录。高速缓存从被创建起，每一项的生存时间一般为<code>20</code>分钟。</p></blockquote><p><code>示例</code>：</p><pre class="highlight"><code class="bash">$ ftp bsdi <span class="hljs-comment"># 执行 ftp 命令</span>-----------后台执行步骤如下---------------------------------------1.应用程序 FTP 客户端调用函数`gethostbyname(3)`把主机名转换成 IP 地址。  这个转换过程使用`DNS`或在较小的网络使用一个静态的主机文件`/etc/hosts`。2.FTP 用得到的 IP 地址请求 TCP 建立连接。3.TCP 用 IP 地址发送一份数据报。5.如果目的主机在本网络上，IP 数据报可直达目的主机；如果在远程网络上，  通过 IP 选路函数确定下一跳路由器地址，并让它转发数据报。6.如果是以太网，则需要将 IP 地址变换成以太网地址。这就是 ARP 的功能。7.ARP 发送一份 ARP请求的以太网数据帧（包括 IP 地址和主机名）给以太网上的每个主机，这个过程叫做广播。8.目的地址主机 ARP 收到广播后，识别出发送端在寻问它的地址后，发送一个 ARP 应答（包含 IP 地址和硬件地址）。9.发送 IP 数据报到目的主机。</code></pre><blockquote><p>接口都有一个<code>48bit</code>硬件地址，通常称呼其为<code>MAC</code>地址。地址每个字节用十六进制数表示，每字节中间以<code>:</code>隔开，共有<code>2^48</code>个可能的<code>MAC</code>地址。通过<code>IEEE</code>统一分配使用，分配方式是固定一个<code>MAC</code>地址的前<code>24bit</code>，让公司自己为每个适配器生成后<code>24bit</code>。</p></blockquote><h3 id="arp-分组格式"><a class="markdownIt-Anchor" href="#arp-分组格式"></a> ARP 分组格式</h3><img src="/2021/09/27/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/ARP分组格式.gif" alt="以太网ARP请求/应答分组格式" style="max-width:80%;"><span class="image-caption">以太网ARP请求/应答分组格式</span><p><strong>源地址</strong> 和 <strong>目的地址</strong>  ，均占<code>6</code>字节，其中目的地址值是全为<code>1</code>的特殊地址表示广播地址。<mark>电缆上所有的以太网接口都要接收广播的数据帧。</mark></p><p><strong>帧类型</strong> 表示后面的数据类型。对于<code>ARP</code>请求和应答来说，该字段值均为<code>0x0806</code>。</p><p><strong>硬件类型</strong> 表示硬件地址的类型，值为<code>1</code>表示以太网地址。</p><p><strong>协议类型</strong> 表示要映射的协议地址类型，值为<code>0x0800</code>表示<code>IP</code>地址。它的值与以太网数据帧中类型字段<code>IP</code>数据报类型的值相同，这是有意设计的。</p><p><strong>硬件地址长度</strong> 和 <strong>协议地址长度</strong> ，单位为<code>字节</code>，所以对于以太网上<code>IP</code>地址的<code>ARP</code>请求和应答来说，它们的值分别为 <code>6</code>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>48</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">48/8=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mord">8</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span>）和<code>4</code>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">32/8=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>）。</p><p><strong>操作字段（op）</strong> 总共有四种操作类型：</p><ul><li>值为<code>1</code>，表示<code>ARP</code>请求。</li><li>值为<code>2</code>，表示<code>ARP</code>应答。</li><li>值为<code>3</code>，表示<code>RARP</code>请求。</li><li>值为<code>4</code>，表示<code>RARP</code>应答。</li></ul><p>这个字段是必须的，因为<code>ARP/RARP</code>的帧类型字段值是相同的。</p><p>最后四个字段有一些重复信息，如在以太网帧首部和<code>ARP</code>请求数据帧中都有 <strong>发送端硬件地址</strong> 信息。</p><blockquote><p>对于一个<code>ARP</code>请求来说，除 <strong>目的端硬件地址</strong> 外的所有其他的字段都有填充值。当系统收到一份目的端为本机的<code>ARP</code>请求报文后，它就把硬件地址填进去，然后用两个目的端地址分别替换两个发送端地址，并把操作字段置为<code>2</code>，最后把它发送回去。</p></blockquote><h3 id="arp-请求应答"><a class="markdownIt-Anchor" href="#arp-请求应答"></a> ARP 请求/应答</h3><p>当一台主机<code>bsdi</code>通过<code>telnet</code>工具发送一个简单的请求时，<code>ARP</code>的执行情况如下：</p><pre class="highlight"><code class="bash">$ arp -a <span class="hljs-comment"># 检查 ARP 高速缓存为空</span>$ telnet svr4 discard <span class="hljs-comment"># 连接 svr4</span>Trying 140.252.13.34..Connected to svr4.Escape character is <span class="hljs-string">'^]'</span>.^]            <span class="hljs-comment"># 进入 telnet 命令行</span>telnet&gt; quit  <span class="hljs-comment"># 退出 telnet</span>Connection closed.-----------------------------------------------<span class="hljs-comment"># 在 telnet 目标系统执行　tcpdump 命令监控 ARP </span>$ tcpdump -e1    0.0                  0:0:c0:6f:2d:40    ff:ff:ff:ff:ff:ff    arp    60                          arp who-has svr4 tell bsdi2.   0.002174 (0.0022)    0:0:c0:c2:9b:26    0:0:c0:6f:2d:40      arp    60                          arp reply svr4 is-at 0:0:c0:c2:9b:263.   ...省略</code></pre><p>第<code>1</code>行，源端主机<code>bsdi</code>硬件地址<code>0:0:c0:6f:2d:40</code>，目的地址表示为广播地址，电缆上所有的以太网接口都要接收这个数据帧并对它进行处理。</p><p><code>arp</code>说明此数据帧是一个<code>ARP</code>请求或应答，所以帧类型字段值是<code>0x0806</code>。</p><p><code>60</code>表示以太网数据帧长度，由于<code>ARP</code>数据帧长度都是<code>42</code>字节（帧头<code>14</code>字节包括<strong>目的地址、源地址、类型字段</strong>，<code>28</code>字节<code>ARP</code>数据），因此，第一帧都必须加入填充字符以达到以太网<code>60</code>字节的最小长度要求。</p><blockquote><p>最小长度指<code>14</code>字节的以太网帧头（包括目的地址、源地址、长度），数据字段<code>46</code>字节，不包括<code>4</code>字节以太网帧尾。</p></blockquote><p><code>arp who-has</code>表示<code>ARP</code>请求的数据帧中，目的<code>IP</code>地址是<code>svr4</code>的地址，发送端<code>IP</code>地址是<code>bsdi</code>的地址。</p><p>第<code>2</code>行，目的主机进行<code>ARP</code>应答，其目的主机<code>IP</code>是<code>bsdi(0:0:c0:6f:2d:40)</code>，<code>ARP</code>应答是直接发送到请求主机，而不是广播。</p><p><code>arp reply</code>表示应答<code>svr4</code>的地址在<code>0:0:c0:c2:9b:26</code>。</p><blockquote><p>从第<code>2</code>行开始，每行在括号中都包含与上一行的时间差（单位：秒）。</p></blockquote><hr><p>如果查询的主机已关机或不存在时，情况如下：</p><pre class="highlight"><code class="bash">$ telnet 140.252.13.36 <span class="hljs-comment"># 连接无效 IP 地址</span>Trying 140.252.13.36...telnet: Unable to connect remote host: Connection timed out.$ arp -a <span class="hljs-comment"># 检查 ARP 高速缓存</span>? (140.252.13.36) at (incomplete)----------------------------------------------------------------<span class="hljs-comment"># 在另一系统执行 tcpdump 命令</span>$ tcpdump1    0.0                   arp who-has 140.252.13.36 tell bsdi2    5.509069  (5.5091)    arp who-has 140.252.13.36 tell bsdi3    29.509745 (24.0007)   arp who-has 140.252.13.36 tell bsdi</code></pre><p><code>ARP</code>请求按照指定规则一直重发，直到时间超过<code>TCP</code>请求设置的超时时间结束，通常为<code>75</code>秒。</p><hr><h3 id="arp-高速缓存超时设置"><a class="markdownIt-Anchor" href="#arp-高速缓存超时设置"></a> ARP 高速缓存超时设置</h3><p>在<code>ARP</code>高速缓存中的表项一般都要设置超时时间，通常对完整表项的超时时间设置为<code>20</code>分钟，不完整的表项超时时间为<code>3</code>分钟。上面<code>telnet 140.252.13.36</code>示例中的表项就是不完整表项(<code>incomplete</code>)，即以太网上不存在的主机发出的的<code>ARP</code>请求。</p><blockquote><p>管理员可以通过<code>arp</code>命令把地址放入高速缓存中，而不设置超时时间。</p><p><code>Host Requirements RFC</code>表明，即使表项正在使用时超时值也应该启动，但是大多数从伯克利系统演变而来的系统没有这样做，它们在每次使用表项时重设超时时间。</p></blockquote><h3 id="arp-代理"><a class="markdownIt-Anchor" href="#arp-代理"></a> ARP 代理</h3><p>如果<code>ARP</code>请求是从一个网络主机发往另一个网络主机，那么连接这两个网络的路由器就可以回答这个请求，这个过程称作 <strong>委托 ARP 或 ARP代理</strong> 。</p><blockquote><p><strong>ARP 代理</strong> 会让<code>ARP</code>请求发送端误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。</p><p>路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。</p></blockquote><p>如下图，当子网<code>140.252.1</code>上的主机<code>gemini</code>将一份<code>IP</code>数据报要传递给<code>140.252.1.29</code>的<code>sun</code>时，会发送<code>ARP</code>请求给<code>140.252.1.29</code>。路由器<code>netb</code>识别出该<code>IP</code>地址属于它的一个拨号主机，于是把它的以太网接口地址<code>140.252.1</code>作为硬件地址来回答。</p><p>主机<code>gemini</code>通过以太网发送<code>IP</code>数据报到<code>netb</code>，<code>netb</code>通过拨号<code>SLIP</code>将数据报转发到<code>sun</code>。这个过程对所有<code>140.252.1</code>子网上的主机都是透明的，主机<code>sun</code>实际上是路由器<code>netb</code>后面配置的。</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 在主机`gemini`上执行`arp -a`命令，经过与主机`sun`通信后，</span><span class="hljs-comment"># 发现同一个子网`140.252.1`上的`netb`和`sun`的 IP 地址映射的硬件地址是相同的。</span><span class="hljs-comment"># 这通常是使用 ARP 委托的线索。</span>$ arp -anetb (140.252.1.183) at 0:80:ad:3:6a:80sun (140.252.1.29) at 0:80:ad:3:6a:80</code></pre><img src="/2021/09/27/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%8F%E8%AE%AE/ARP代理.gif" alt="ARP 代理" style="max-height:350px"><span class="image-caption">ARP 代理</span><blockquote><p>通过上图发现，<code>bsdi</code>和<code>slip</code>之间分别有一个<code>IP</code>，所以路由器<code>netb</code>下方<code>SLIP</code>链路显然缺少一个<code>IP</code>地址，这是因为路由器不需要知道拨号<code>SLIP</code>链路每一端的<code>IP</code>地址（减少了<code>IP</code>的使用）。</p><p>通过分组到达的串行线路接口来确定发送分组的拨号主机，因此对于连接到路由器的每个拨号主机不需要用唯一的<code>IP</code>地址，所有拨号主机使用同一个<code>IP</code>地址作为<code>SLIP</code>链路的目的地址。</p><p>通过<code>ifconfig</code>命令可以显示该拨号<code>SLIP</code>链路的目的地址是<code>140.252.1.183</code>。</p></blockquote><h3 id="免费-arp"><a class="markdownIt-Anchor" href="#免费-arp"></a> 免费 ARP</h3><p><strong>免费ARP（Gratuitous ARP）</strong> 包是一种特殊的<code>ARP</code>请求，它并非期待得到<code>IP</code>对应的<code>MAC</code>地址，而是当主机启动的时候，发送一个<code>Gratuitous ARP</code>请求，即请求自己的<code>IP</code>地址的<code>MAC</code>地址。</p><p>它与普通<code>ARP</code>请求报文的区别在于报文中的目标<code>IP</code>地址。普通<code>ARP</code>报文中的目标<code>IP</code>地址是其他主机的<code>IP</code>地址，而免费<code>ARP</code>的请求报文中，目标<code>IP</code>地址是自己的<code>IP</code>地址。</p><p><code>作用</code>：</p><ul><li>用于检测<code>IP</code>地址冲突。当一台主机发送了免费<code>ARP</code>请求报文后，如果收到了<code>ARP</code>响应报文，则说明网络内已经存在使用该<code>IP</code>地址的主机。</li><li>用于更新其他主机的 ARP 缓存表。当主机更换了网卡（接口卡）,而其他主机的<code>ARP</code>缓存表仍然保留着原来的<code>MAC</code>地址。这时，可以发送免费的<code>ARP</code>数据包。其他主机收到该数据包后，将更新<code>ARP</code>缓存表，将原来的<code>MAC</code>地址替换为新的<code>MAC</code>地址。</li></ul><h2 id="rarp"><a class="markdownIt-Anchor" href="#rarp"></a> RARP</h2><p><strong>逆地址解析协议（Reverse Address Resolution Protocol，RARP）</strong>,与<code>ARP</code>作用相反，用于将<code>MAC</code>地址通过读取<code>ARP</code>缓存表获取其<code>IP</code>地址。</p><p>具有本地磁盘的主机，一般通过磁盘上配置文件读取<code>IP</code>地址，但是无盘主机（如X终端或无盘工作站）则需要通过其他方法来获取<code>IP</code>地址。</p><p>网络上每个系统都具有唯一的硬件地址，它由网络接口生产厂商配置，无盘系统就可以从接口网卡读取硬件地址，再通过<code>RARP</code>协议获取<code>IP</code>地址。</p><h3 id="rarp-分组格式"><a class="markdownIt-Anchor" href="#rarp-分组格式"></a> RARP 分组格式</h3><p>与<code>ARP</code>分组格式基本一致，主要区别是<code>RARP</code>请求/应答帧类型是<code>0x8035</code>，请求操作代码是<code>3</code>,应答操作代码是<code>4</code>。</p><blockquote><p><code>RARP</code>请求以广播方式传送，而<code>RARP</code>的应答一般是单播传送。</p></blockquote><h3 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h3><ul><li>发送主机发送一个本地<code>RARP</code>广播，声明自己的<code>MAC</code>地址并请求任何收到该请求的<code>RARP</code>服务器分配一个<code>IP</code>地址；</li><li>本地网段上的<code>RARP</code>服务器收到此请求后，检查其<code>RARP</code>列表中<code>MAC</code>地址对应的<code>IP</code>地址；</li><li>如果存在，<code>RARP</code>服务器给源主机发送一个响应数据包并将该<code>IP</code>地址提供给对方主机使用；</li><li>如果不存在，<code>RARP</code>服务器对此不做任何响应；</li><li>源主机收到<code>RARP</code>服务器响应信息，就可利用得到<code>IP</code>地址进行通信；如果一直没收到<code>RARP</code>服务器响应，则表示初始化失败。</li></ul><h3 id="rarp-服务器设计"><a class="markdownIt-Anchor" href="#rarp-服务器设计"></a> RARP 服务器设计</h3><p><code>RARP</code>在原理上很简单但是实现比较复杂，由于<code>RARP</code>的请求是在硬件层上的广播，因此不能通过路由器进行转发。为了让无盘系统在<code>RARP</code>关机的状态下也能引导，通常在每个网络上都要实现多个<code>RARP</code>服务器，服务器数量增加，网络流量也随之增加。</p><p>发送<code>RARP</code>请求的无盘系统一般采用最先收到的<code>RARP</code>应答（<code>ARP</code>没有这种情况，因为只有一台主机发送<code>ARP</code>应答），另外在同一网络中不同主机可能会同时进行<code>RARP</code>应答，这样增加了以太网发生冲突的概率。</p><blockquote><p><code>RARP</code>服务器一般要为多个主机提供硬件地址到<code>IP</code>地址的映射，该映射包含在一个磁盘文件中（<code>Uinx</code>系统一般位于<code>/etc/ethers</code>目录中）。由于内核一般不读取和分析磁盘文件，因此<code>RARP</code>服务器的功能就由用户进程来提供，而不是作为内核的<code>TCP/IP</code>实现的一部分。</p><p>更为复杂的是，<code>RARP</code>请求是作为一个特殊类型的以太网帧类型（<code>0x8035</code>）来传送，这说明<code>RARP</code>服务器必须能够发送和接收这种类型的以太网数据帧。由于发送和接收这些数据帧与系统有关，因此<code>RARP</code>服务器的实现是与系统捆绑在一起的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;arp&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#arp&quot;&gt;&lt;/a&gt; ARP&lt;/h2&gt;
&lt;p&gt;当一台主机把以太网的数据帧发送到位于同一局域网上的另一台主机时，是根据&lt;code&gt;48bit&lt;/code&gt;的以太
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="ARP" scheme="http://fcwalkers.com/tags/ARP/"/>
    
      <category term="RARP" scheme="http://fcwalkers.com/tags/RARP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议－链路层</title>
    <link href="http://fcwalkers.com/2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://fcwalkers.com/2021/09/22/network/TCPIP协议—链路层/</id>
    <published>2021-09-21T16:00:00.000Z</published>
    <updated>2021-12-14T02:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p><strong>节点</strong> 链路层协议的任何设备都叫做节点。</p><p><strong>链路</strong> 沿着通信路径连接相邻节点的通信信道。</p><p>在通过特定的链路时，传输节点将数据报封装在 <strong>链路层帧</strong> 中，并将该帧传送的到链路中。</p><p><strong>链路层提供的服务</strong>：</p><ul><li><code>成帧</code> 网络层数据报经过链路传送之前，链路层协议会将其用链路层帧封装起来。一个帧由一个数据字段（存储网络层数据报）和若干字段组成，不同协议帧的结构不同。</li><li><code>链路接入</code> <strong>媒体访问控制(Medium Access Control，MAC)</strong> 协议规定了帧在链路上的传输规则。对于链路仅有一个发送方和一个接收方的点对点链路，<code>MAC</code>协议规定无论何时链路空闲，发送方都能发送帧。当多个节点共享单个广播链路时，即所谓多路访问问题，<code>MAC</code>协议用于协调多个节点帧传输。</li><li><code>可靠交付</code> 与运输层可靠交付类似，链路层的可靠交付通常是通过确认和重传取得的。通常用于容易产生高差错率的链路（如无线链路），其目的是在差错发生的链路上纠正，而不是通过运输层或应用层协议迫使进行端到端的数据重传。对于低比特差错的链路（如光纤、双绞铜线、同轴电缆），可靠交付会被认为是一种不必要的的开销，因此许多线路层协议不提供可靠交付服务。</li><li><code>差错检测和纠正</code> 当帧中的一个比特作为<code>1</code>传输时，接收方节点的链路层硬件可能不正确的将其判断成为<code>0</code>，反之亦然。这是由于信号衰减和电磁噪声导致的，因为没必要转发一个有差错的数据报，所以许多链路层协议提供一种机制来检测这样的比特差错。运输层和网络层也提供相应的检验，即检验和。链路层的检验机制通常更为复杂，并且用硬件实现。<code>纠正</code>与差错检测类似，区别在于其不但可以检测差错，而且能确定差错出现的位置，并纠正这些差错。</li></ul><blockquote><p>链路层主体是在 <strong>网络适配器（network adapter）</strong> 中实现的，网络适配器也叫 <strong>网络接口卡（Network Interface Card，NIC）</strong> 。位于网络适配器核心的是链路层控制器，该控制器通常是实现了成帧、链路接入、差错检测等服务的芯片。</p><p>部分链路层服务（如封装链路层寻址信息、激活控制器硬件、向网络层传递数据报等）运行在主机<code>CPU</code>上的软件中实现。</p><p>因此，链路层是硬件与软件的结合体，即此处是协议栈中硬件与软件交接的部分。</p></blockquote><h3 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h3><p>差错检测的准确措词是 “是否检测到差错，而非是否出了差错”，所以即使用不用差错检测比特，也还是可能有 <strong>未检出比特差错</strong> 。因此，要选择一个差错检测方案，使得这种事件发生的概率很小。然而差错检测和纠正技术越复杂（即未检出比特差错概率较小的技术），开销就越大，也就意味着需要更多的计算量。</p><h4 id="奇偶校验"><a class="markdownIt-Anchor" href="#奇偶校验"></a> 奇偶校验</h4><p>差错检测最简单的方式就是 <strong>单个奇偶校验位（parity bit）</strong> 。如下图，要发送的信息<code>D</code>有<code>d</code>比特，在偶校验方案中只需要包一个校验比特，选择它的值使得<code>d+1</code>比特中<code>1</code>的总数是偶数个，如下图中的<code>d</code>的比特<code>1</code>的个数是<code>9</code>个，因此校验比特填入<code>1</code>使得发送数据比特<code>1</code>的个数为<code>10</code>个满足比特偶校验。反之，则为奇数校验。</p><img src="/2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/偶校验.gif" alt="比特偶校验" style="max-width:60%;"><span class="image-caption">比特偶校验</span><blockquote><p>采用偶校验方案中，接收方如果发现了奇数个<code>1</code>比特，说明至少出现了一个比特差错，或者说出现了奇数个比特差错；如果出现了偶数个比特差错，这将导致一个 <em><strong>未检出比特差错</strong></em>。</p><p>如果比特差错的概率小，且比特间的差错可以被看作是独立发生的，在一个分组中多个比特同时出错的概率极小的情况下，<em><strong>单个奇偶校验位</strong></em> 可能就足够了。然而，测量表明差错经常以“突发”方式聚集在一起，而不是独立发生的。</p></blockquote><h4 id="检验和"><a class="markdownIt-Anchor" href="#检验和"></a> 检验和</h4><p>检验和方法需要相对较小的开销，如<code>TCP</code>和<code>UDP</code>中的检验和只用了<code>16bit</code>。与常用于链路层的<code>CRC</code>相比，它们提供相对软弱的差错保护。</p><p>因为运输层差错检测用软件实现，采用简单快速的检验和方法进行差错检测的方案是很重要的。而链路层的差错检测在适配器中用硬件实现，它能够更快速的执行更复杂的<code>CRC</code>操作。</p><p>更多检验和原理请参考<a href="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/#%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE-ip">[IP首部检验和计算步骤]</a></p><h4 id="循环冗余检测"><a class="markdownIt-Anchor" href="#循环冗余检测"></a> 循环冗余检测</h4><p><strong>循环冗余检测（Cyclic Redundancy Check，CRC）</strong></p><h3 id="以太网"><a class="markdownIt-Anchor" href="#以太网"></a> 以太网</h3><p>它是<code>数字设备公司</code>、<code>因特尔公司</code>和<code>Xerox公司</code>于<code>1982</code>年联合发布的一个标准，命名为 <strong>以太网（Ethernet Version 2）</strong> ，它是当今<code>TCP/IP</code>采用的主要的局域网技术。它采用一种 <strong>带冲突检测的载波侦听多路接入（Carrier Sense, Multiple Access with Collision Detection，CSMA/CD）</strong> 速率为<code>10Mb/s</code>，地址为<code>48bit</code>。</p><p>几年后， <strong>电气与电子工程师协会（Institute of Electrical and Electronics Engineers，IEEE）</strong> <code>802</code>委员会公布了一个稍有不同的标准集：</p><ul><li><p><code>802.3 标准</code> 针对整个<code>CSMA/CD</code>网络</p></li><li><p><code>802.4标准</code> 针对令牌总线网络</p></li><li><p><code>802.5标准</code> 针对令牌环网络</p></li><li><p><code>802.2标准</code> 定义上面三个标准共同特性，如<code>逻辑链路控制（LLC）</code></p></li></ul><p>其中<code>802.2标准</code>和<code>802.3标准</code>定义了一个与<code>以太网</code>不同的帧格式。详见下图：</p><h4 id="帧结构"><a class="markdownIt-Anchor" href="#帧结构"></a> 帧结构</h4><img src="/2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/以太网帧结构.gif" alt="以太网帧结构" style="max-width:80%;"><span class="image-caption">以太网帧结构</span><ul><li><p><code>802</code>标准帧格式</p><ul><li><strong>目的地址</strong> 和 <strong>源地址</strong> 字段，即硬件地址（<code>MAC</code>地址），大小为 <code>48bit（6字节）</code>（<code>802.3</code>允许使用<code>16bit</code>的地址）。</li><li><strong>长度</strong> 字段，指它后续的数据的字节长度，不包括<code>CRC</code>。</li><li><strong>目的服务访问点（ Destination Service Access Point，DSAP）</strong> 和 <strong>源服务访问点（Source Service Access Point，SSAP）</strong> 的值都设为<code>0xaa</code>。</li><li><strong>Ctrl</strong> 字段，值为<code>3</code>。</li><li><strong>org code</strong> 字段，值为<code>0</code>。</li><li><strong>类型</strong> 字段，由后续 <strong>子网接入协议（Sub-network Access Protocol，SNAP）</strong> 的首部给出。</li><li><strong>数据字段</strong> 字段，标准定义了该字段的最小长度为<code>38</code>字节，长度不够时需要在不足空间插入<code>PAD</code>填充字节。</li><li><strong>CRC</strong> 字段，帧内差错的循环冗余检测码。</li></ul></li><li><p>以太网帧格式</p><ul><li><strong>目的地址</strong> 和 <strong>源地址</strong> 字段，即硬件地址（<code>MAC</code>地址），大小为 <code>48bit（6字节）</code></li><li><strong>类型</strong> 字段，与<code>802</code>标准格式相同，但是有效长度值与<code>802</code>标准不一样，因此可以根据此来区分两种帧，即大于<code>1500</code>就是以太网，否则为<code>802.3</code>。</li><li><strong>数据字段</strong> 字段，标准定义了该字段的最小长度为<code>46</code>字节，长度不够时需要在不足空间插入<code>PAD</code>填充字节。</li><li><strong>CRC</strong> 字段，帧内差错的循环冗余检测码。</li></ul><blockquote><p><strong>前同步码</strong> ，以太网帧以一个<code>8</code>字节的前同步码（Preamble）字段开始。前<code>7</code>字节值都是<code>10101010</code>，用于“唤醒”接收适配器，并且将它们的时钟和发送方的时钟同步。</p><p><em>为什么要同步时钟呢？因为发送适配器不会以精确的速率传输帧，总会有一些漂移，但是局域网上的其他适配器不会预先知道这种漂移，因此，接收适配器只需要通过锁定前同步码前<code>7</code>字节比特，就能够锁定发送适配器时钟</em>；</p><p>最后一个字节值为<code>10101011</code>，最后两比特<code>11</code>是警告适配器“重要的内容”就要到来了。</p></blockquote></li></ul><h3 id="slip"><a class="markdownIt-Anchor" href="#slip"></a> SLIP</h3><p><strong>串行线路 IP（Serial Line IP，SLIP）</strong>，是一种在串行线路上对<code>IP</code>数据报进行简单封装的方法，适用于家庭中每台计算机几乎都有的<code>RS-232</code>串行端口和高速调制解调器接入<code>Internet</code>。它是一种广泛使用的协议。</p><h4 id="帧结构-2"><a class="markdownIt-Anchor" href="#帧结构-2"></a> 帧结构</h4><img src="/2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/SLIP帧结构.gif" alt="SLIP帧结构" style="max-width:80%;"><span class="image-caption">SLIP帧结构</span><ul><li><code>IP</code>数据报以一个称作<code>END（0xc0）</code>的特殊字符结束。同时，为了防止数据报到来前的线路噪声被当成数据报内容，大多数实现的开始处也传入一个<code>END</code>字符（<em>这样前一个错误报文交给上层后，发现内容毫无意义而被丢弃</em>）。</li><li>如果<code>IP</code>报文中的某个字符为<code>END</code>，那么就要连续传输两个字节<code>0xdb</code>和<code>0xdc</code>来取代它。<code>0xdb</code>字符被称作是<code>SLIP</code>的<code>ESC</code>字符，它的值与<code>ASCII</code>中的<code>ESC（0x1b）</code>字符不同。</li><li>如果<code>IP</code>报文中某个字符为<code>SLIP</code>的<code>ESC</code>字符，那么就要连续传输两个字节<code>0xdb</code>和<code>0xdd</code>来取代它。</li></ul><h4 id="缺陷"><a class="markdownIt-Anchor" href="#缺陷"></a> 缺陷</h4><ul><li>每一端必须知道对方的<code>IP</code>地址，没办法把本端的地址通知给另一端。</li><li>数据帧中没有类型字段，如果一条串行线路用于<code>SLIP</code>，那么它不能同时使用其他协议。</li><li>没有在数据帧上加检验和，如果发生错误只能通过上层协议来发现（新型调制解调器可以发现和纠正错误报文）。</li></ul><h4 id="压缩"><a class="markdownIt-Anchor" href="#压缩"></a> 压缩</h4><p>由于串行线路的速率通常较低（<code>19200b/s</code>或更低)，而且通信经常是交互式的（如Telnet），因此<code>SLIP</code>线路上有许多小的<code>TCP</code>分组进行交换。通常为了传输<code>1</code>个字节的数据需要<code>20</code>个字节<code>IP</code>首部和<code>20</code>个字节的<code>TCP</code>首部，总数超过<code>40</code>个字节。</p><p>基于上面性能上的缺陷，提出了一个压缩的<code>SLIP</code>协议，即<code>CSLIP</code>。它一般能把上面<code>40</code>个字节压缩到<code>3</code>到<code>5</code>个字节，大大缩短了交互响应时间。</p><p>大多数<code>SLIP</code>产品都支持<code>CSLIP</code>。</p><p><strong>SLIP接口标志</strong>：</p><ul><li><code>LINK0</code>表示一个允许压缩的<code>SLIP</code>数据</li><li><code>LINK1</code>表示如果从另一端收到一份压缩报文就允许使用<code>CSLIP</code>。</li><li><code>LINK2</code>所有外出的<code>ICMP</code>报文都被丢弃。</li></ul><h3 id="ppp"><a class="markdownIt-Anchor" href="#ppp"></a> PPP</h3><p><strong>点对点协议（Point to Point Protocol，PPP）</strong> ，修改了<code>SLIP</code>协议中所有的缺陷。<code>PPP</code>包括以下三个部分：</p><ul><li>在串行链路上封装<code>IP</code>数据报的方法。</li><li>建立、配置及测试数据链路的 <strong>链路控制协议（Link Control Protocol，LCP）</strong> 它允许双方进行协商，以确定不同选项。</li><li>针对不同网络层协议的 <strong>网络控制协议（Network Control Protocol，NCP）</strong> 体系。如<code>IP NCP</code>允许双方协商是否对报文首部进行压缩，类似于<code>CSLIP</code>。</li></ul><h4 id="帧结构-3"><a class="markdownIt-Anchor" href="#帧结构-3"></a> 帧结构</h4><img src="/2021/09/22/network/TCPIP%E5%8D%8F%E8%AE%AE%E2%80%94%E9%93%BE%E8%B7%AF%E5%B1%82/PPP帧结构.gif" alt="PPP帧结构" style="max-width:80%;"><span class="image-caption">PPP帧结构</span><ul><li>每一帧都以<code>0x7e</code>开始和结束。</li><li><strong>地址</strong> 字段，值始终为<code>0xff</code>。</li><li><strong>控制</strong> 字段，值始终为<code>0x03</code>。</li><li><strong>协议</strong> 字段，类似以太网中类型字符功能。</li><li><strong>CRC</strong> 字段，循环冗余检验码。</li></ul><blockquote><p>当标志字符<code>0x7e</code>出现在 <strong>信息</strong> 字段时，需要对它进行转义。在同步链路中通过一种称作 <strong>比特填充（bit stuffing）</strong> 的硬件技术实现；</p><p>在异步链路中，特殊字符<code>0x7d</code>用作转义字符，后面紧接着的字符的第<code>6</code>比特要取其补码（<code>注意：此处的补码为 “求补” [&quot;补码&quot;跟&quot;求补&quot;不总是一回事，求补，求余，全集的补是空集，空集的补是全集，1的补是0，0的补是1]---解释来源网络</code>）：</p><ul><li><p>当遇到<code>0x7e</code>时，需要连续传递两个字符<code>0x7d</code>和<code>0x7e</code>，然后将<code>0x7e</code>的第<code>6</code>比特转换成其补码，即<code>1111110</code>转为<code>1011110</code>，所以最终传递的两个字符为<code>0x7d</code>和<code>0x5e</code>。</p></li><li><p>当遇到<code>0x7d</code>时，也需要进行转义，原理同上，即最终传递两个字符为<code>0x7d</code>和<code>0x5d</code>。</p></li><li><p>默认情况下，需要对<code>ASCII</code>的<code>32</code>个控制字符（排除空格控制字符）进行转义。如<code>0x01</code>，这时将其第<code>6</code>个比特取补码后变为<code>1</code>，即<code>000001</code>转换为<code>100001</code>，所以最终传递两个字符为<code>0x7d</code>和<code>0x21</code>。</p><p>这样做的原因是防止它们出现在双方主机的串行接口驱动程序或调制解调器中，因为有时它们会把这些控制字符解释成特殊的含义。</p></li></ul></blockquote><p>与<code>SLIP</code>类似，<code>PPP</code>也常用于低速的串行链路，因此可以利用链路控制协议，大多数产品通过协商可以省略标志符和地址字段，并且把协议字段由<code>2</code>个字节减少到<code>1</code>个字节。</p><p>使用<code>IP</code>网络控制协议，大多数可以通过协商采用<code>Van Jacobson</code>报文首部压缩方法（对应<code>CSLIP</code>）减小<code>IP</code>的<code>TCP</code>首部长度。</p><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h4><ul><li>支持在单根串行线路上运行多种协议，不只是<code>IP</code>协议。</li><li>每一帧都有循环冗余检测。</li><li>使用<code>IP</code>网络控制协议，通信双方可以进行<code>IP</code>地址的动态协商。</li><li>与<code>CSLIP</code>类似，对<code>TCP</code>和<code>IP</code>报文首部进行压缩。</li><li>链路控制协议可以对多个数据链路选项进行设置。</li></ul><p>实现这些优点的代价是在每一帧的首部增加 3个字节，当建立链路时要发送几帧协商数据，以及更为复杂的实现。</p><h3 id="环回接口"><a class="markdownIt-Anchor" href="#环回接口"></a> 环回接口</h3><p><strong>环回接口（Loopback Interface，lo）</strong> ，是路由器上的一个逻辑虚拟接口。大多数产品都支持环回接口，以允许运行在同一台主机的客户和服务程序进行<code>TCP/IP</code>通信。</p><p><code>A</code>类网络号<code>127</code>就是为其预留的，通常把<code>IP</code>地址<code>127.0.0.1</code>分配给这个接口，子网掩码一般建议设为<code>255.255.255.255</code>，并命名为<code>localhost</code>。一个传给环回接口的<code>IP</code>数据报不能在任何网络上出现。</p><p>当传输层检测到目的地端的地址是环回地址，可以省略传输层和网络层的所有逻辑操作。但大多数产品还是照样完成传输层和网络层的所有过程，只是当<code>IP</code>数据报离开网络层时把它返回自己；</p><p>当目的地址是广播地址或多播地址时，<code>IP</code>数据报会复制一份传给环回地址，然后发送到以太网上。</p><h4 id="创建原因"><a class="markdownIt-Anchor" href="#创建原因"></a> 创建原因</h4><ul><li>环回接口有一个特性，除非设备瘫痪，否则其状态一直是<code>up</code>。基于这个特性，用来建立比物理接口更稳定的路由邻居来保证邻居关系不会中断。</li><li>用来作为<code>Router-ID</code>，相当于一台路由器的身份证号，在一个指定的范围内只能标识一台设备，不能有重复。稳定可靠，可以节省地址。</li><li>用于网络连通性测试创建并配置好环回接口之后，它的地址是能被<code>ping</code>或<code>telnet</code>的，这就可以被用来测试网络的连通性。</li><li>用于虚拟隧道连接在建立<code>IPSec</code>或<code>GRE</code>之类的虚拟隧道时，使用<code>loopback</code>接口可以保证整个隧道的稳定性。</li></ul><blockquote><p>BSD系统定义了变量<code>useloopback</code>，并初始化为<code>1</code>。如果值为<code>0</code>，以太网驱动程序就会把本地分组送到网络，而不是送到环回接口上。它能否工作取决于所使用的以太网口卡和设备驱动程序。</p></blockquote><h3 id="mtu"><a class="markdownIt-Anchor" href="#mtu"></a> MTU</h3><p>以太网和<code>802.3</code>对数据帧的长度最大限制为<code>1500</code>和<code>1492</code>字节，链路层的这个特性称作， <strong>最大传输单元（MTU)</strong> 。</p><p>如果<code>IP</code>层传输的数据报长度超过<code>MTU</code>，那么<code>IP</code>层就需要进行切片分组成若干片，并且每片都小于<code>MTU</code>。</p><p>当两台主机通信需要经过多个网络时，那么每个网络的链路层可能有不同的<code>MTU</code>。此时重要的不是两台主机的<code>MTU</code>，而是路径中的最小<code>MTU</code>，它被称作 <strong>路径MTU</strong> 。</p><blockquote><p>两台主机之间的路径<code>MTU</code>不一定是个常数。它取决于当时所选择的路由。而选路不一定是对称的（从<code>A</code>到<code>B</code>的路由可能与从<code>B</code>到<code>A</code>的路由不同），因此路径<code>MTU</code>在两个方向上不一定是一致的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;节点&lt;/strong&gt; 链路层协议的任何设备都叫做节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链路&lt;/str
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="以太网" scheme="http://fcwalkers.com/tags/%E4%BB%A5%E5%A4%AA%E7%BD%91/"/>
    
      <category term="SLIP" scheme="http://fcwalkers.com/tags/SLIP/"/>
    
      <category term="PPP" scheme="http://fcwalkers.com/tags/PPP/"/>
    
      <category term="环回接口" scheme="http://fcwalkers.com/tags/%E7%8E%AF%E5%9B%9E%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议－网络层</title>
    <link href="http://fcwalkers.com/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://fcwalkers.com/2021/09/01/network/TCPIP协议－网络层/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2022-03-15T09:40:35.005Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="路由器"><a class="markdownIt-Anchor" href="#路由器"></a> 路由器</h3><ul><li><strong>转发</strong> 当一个分组到达某路由器输入链路接口时，该路由器须将该分组移动到适当的输出链路接口的路由器本地动作。转发发生的尺度很短，因此通常用硬件来实现。它是 <strong>数据平面</strong> 唯一实现的功能。</li><li><strong>路由选择</strong>  当分组从发送方流向接收方时，网络层必须决定这些分组所采用的路由和路径。计算这些路径的算法被称为<strong>路由选择算法</strong>。路由选择发生的时间尺度长，因此通常用软件来实现，它是 <strong>控制平面</strong> 实现的功能。</li><li><strong>路由表</strong>  每台网络路由器内存中都有一个路由表，当收到一份数据报时，路由器检查分组首部一个或多个字段值，用于在其路由表中索引，然后进行转发分组。路由表中包含以下信息：<ul><li><strong>目的 IP 地址</strong> 它可以是一个完整的主机地址，也可以是一个网络地址。由该表中的标志字段指定。</li><li><strong>下一跳（下一站）路由器的 IP 地址</strong> 指在一个可以直接相连网络上的路由器，可以转发的数据报。下一跳路由器不是最终目的，但它可以把传送它的数据报转发到最终目的地。</li><li><strong>标志</strong> 其中一个标志指明目的<code>IP</code>地址是网络地址还是主机地址；另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口。</li><li><strong>为数据报的传输指定一个网络接口</strong></li></ul></li></ul><h4 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h4><p>当收到一份数据报进行转发时，它先要搜索路由表。当数据报来自某个网络接口时，<code>IP</code>首部先检查目的<code>IP</code>是否为本机<code>IP</code>地址之一或者广播<code>IP</code>地址。如果是，数据报被发送到由<code>IP</code>首部协议字段所指定的协议模块进行处理。反之，如果<code>IP</code>层被设置为路由器功能，那么就对数据报进行转发，否则数据报被丢弃。</p><p><code>IP</code>路由选择是逐跳进行的，<code>IP</code>并不知道到达目的地的完整路径。所有<code>IP</code>路由选择只为数据报传输提供下一站路由器的<code>IP</code>地址。它假定下一站路由器比发送数据报的主机更接近目的地，且下一站路由器与该主机是直接相连的。</p><p><code>IP</code>路由选择步骤：</p><ol><li>搜索路由表，寻找与目的<code>IP</code>完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接网络接口（取决于标志字段的值）。</li><li>搜索路由表，寻找与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接网络接口（取决于标志字段的值）。网络上的所有主机可以通过这个表目进行寻径，这种搜索网络的匹配方法必须考虑可能的子网掩码。</li><li>搜索路由表，寻找标记为“默认（default）”的表目，如果找到，则把报文发送给该表目指定的下一站路由器。</li><li>如果上面步骤都没有成功，该数据报不能被发送。如果该数据报来自本机，则会向应用程序返回一个“主机或网络不可达”错误。</li></ol><blockquote><p>为网络指定一个路由器，而不必为每个主机指定一个，这是<code>IP</code>路由选择的一个基本特性。这样可以极大缩小路由表的规模，比如 <code>Internet</code> 上路由器只有几千个表目，而不会超过100万个。</p></blockquote><h3 id="网际协议-ip"><a class="markdownIt-Anchor" href="#网际协议-ip"></a> 网际协议－IP</h3><p><code>IP</code>是<code>TCP/IP</code>协议族中最为核心的协议。所有<code>TCP</code>、<code>UDP</code>、<code>ICMP</code>和<code>IGMP</code>数据都以<code>IP</code>数据报格式传输。</p><p>它不能保证<code>IP</code>数据报能成功地到达目的地。 <code>IP</code>仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区， <code>IP</code>有一个简单的错误处理算法：丢弃该数据报，然后发送 <code>ICMP</code>消息报给信源端。</p><p>它是无连接的，不维护任何数据报文的后续状态信息。每个数据报相互独立，因此<code>IP</code>数据报可以不按顺序接收。当一个端向另一端发送两个数据报（<code>A</code>和<code>B</code>），每个数据报都是独立进行路由选择，可能选择不同线路，所以<code>B</code>可能在<code>A</code>之前到达。</p><h4 id="ip首部"><a class="markdownIt-Anchor" href="#ip首部"></a> IP首部</h4><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/IP首部.png" alt="IP首部" style="max-height:300px"><span class="image-caption">IP首部</span><p>最高位在左边，记为<code>0bit</code>; 最低位在右边，记为<code>31bit</code>。</p><p><code>4</code>个字节的<code>32bit</code>的值以下面次序输出：</p><p>​首先，<code>0~7bit</code>;  其次<code>8~15bit</code>; 然后<code>16~23bit</code>; 最后<code>24~31bit</code>。</p><blockquote><p><code>TCP/IP</code>首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作<strong>网络字节序（big endian）</strong>。</p><p>以其他形式存储的二进制整数的机器（如<code>little endian</code>），必须在传输数据之前把首部转换成网络字节序。</p></blockquote><p>目前协议 <strong>版本(Ver)</strong> 号是<code>4</code>，因此有时<code>IP</code>也被称为<code>IPv4</code>。</p><p><strong>首部长度(IHL)</strong> 指的是首部占用<code>32bit</code>的数目，普通<code>IP</code>该字段的值为<code>5</code>行（固定部分），每行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">32/8=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 字节 ，因此首部长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mo>∗</mo><mn>4</mn><mo>=</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">5*4=20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span></span></span></span> 个字节。如果有选项部分，由于首部长度为<code>4bit</code>，所以最大值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>4</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">2^4-1=15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span> 行（即取值范围 0-15），所以首部最大长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>15</mn><mo>∗</mo><mn>4</mn><mo>=</mo><mn>60</mn></mrow><annotation encoding="application/x-tex">15*4=60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span></span></span></span> 字节。</p><p><strong>服务类型（TOS,Type Of Service）</strong>，字段包括</p><ul><li><p>一个<code>3bit</code>的优先权子字段（现在已被废弃），默认值<code>000</code>。</p></li><li><p><code>4bit</code>的<code>TOS</code>子字段，分别代表（最小时延、最大吞吐量、最高可靠性、最小费用），只能置其中<code>1bit</code>为<code>1</code>，如果均为<code>0</code>，那么就意味着一般服务。</p></li></ul><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">最小延时</th><th style="text-align:center">最大吞吐量</th><th style="text-align:center">最高可靠性</th><th style="text-align:center">最小费用</th><th style="text-align:center">16进制值</th></tr></thead><tbody><tr><td style="text-align:center">Telnet/Rlogin</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">FTP</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">控制</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">数据</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x08</td></tr><tr><td style="text-align:center">任意块数据</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x08</td></tr><tr><td style="text-align:center">TFTP</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">SMTP</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">命令阶段</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">数据阶段</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x08</td></tr><tr><td style="text-align:center">DNS</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">UDP查询</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x10</td></tr><tr><td style="text-align:center">TCP查询</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x00</td></tr><tr><td style="text-align:center">区域查询</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x08</td></tr><tr><td style="text-align:center">IMCP</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">差错</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x00</td></tr><tr><td style="text-align:center">查询</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x00</td></tr><tr><td style="text-align:center">任何IGP</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0x04</td></tr><tr><td style="text-align:center">SNMP</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0x04</td></tr><tr><td style="text-align:center">BOOTP</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0x00</td></tr><tr><td style="text-align:center">NNTP</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0x02</td></tr></tbody></table><ul><li><code>1bit</code>的未用位（必须置0）</li></ul><blockquote><p>以<code>Telnet/Rlogin</code>应用为例，因为这两个应用主要用于传输少量交互数据，所以要求最小传输时延。其<code>TOS</code>最终值为<code>000,1000,0</code>，换算成十六进制为<code>0x10</code>。</p><p>现在大多数<code>TCP/IP</code>实现都不支持<code>TOS</code>特性，但自<code>4.3BSD Reno</code>以后新版本系统都对它进行了设置。另外，新路由协议<code>OSPE</code>和<code>IS-IS</code>都能根据这些字段进行路由决策。</p><p>由于大多数实现都不使用<code>TOS</code>字段，因此像<code>SLIP</code>这种排队机制自己来判断和处理，驱动程序先查看协议段（确定是否是一个<code>TCP</code>段），然后检查<code>TCP</code>信源和信宿的端口号，以判断是否是一个交互服务。</p></blockquote><p><strong>总长度(Total Length)</strong> 字段指整个<code>IP</code>数据报长度，以字节为单位。利用<strong>首部长度</strong>和<strong>总长度</strong>字段，就可以知道<code>IP</code>数据报中数据内容的起始位置和长度。由于该字段长度为<code>16bit</code>，所以<code>IP</code>数据报最大长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>1</mn><mo>=</mo><mn>65</mn><mo separator="true">,</mo><mn>535</mn></mrow><annotation encoding="application/x-tex">2^{16}-1=65,535</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">3</span><span class="mord">5</span></span></span></span> 即，65,535字节。也就是<strong>最大传输单元（Maximum Transmission Unit，MTU）</strong> 为65,535字节。</p><blockquote><p>尽管可以传输最大<code>65,535</code>字节的数据报，但大多数链路层都会对它进行分片。而且主机也要求不能接收超过<code>576</code>字节的数据报。类似<code>UDP</code>的应用，它们限制用户数据报长度为<code>512</code>字节，小于<code>576</code>字节。</p><p>事实上现在大多数的实现（特别是那些支持网络的文件系统<code>NFS</code>的实现）允许超过<code>8192</code>字节的<code>IP</code>数据报。</p></blockquote><p><strong>标识(Identification)</strong> 字段，唯一的标识主机发送的每一分数据报。通常每发送一份报文它的值就会加<code>1</code>。</p><blockquote><p><code>RFC 791 [Postel 1981a]</code>认为标识字段应该由让<code>IP</code>发送数据报的上层来选择。假设有两个连续的<code>IP</code>数据报，其中一个是由<code>TCP</code>生成的，而另一个是由<code>UDP</code>生成的，那么它们可能具有相同的标识字段。尽管这也可以照常工作（由重组算法来处理），但是在大多数从伯克利派生出来的系统中，每发送一个<code>IP</code>数据报，<code>IP</code>层都要把一个内核变量的值加<code>1</code>，不管交给<code>IP</code>的数据来自哪一层。内核变量的初始值根据系统引导时的时间来设置。</p></blockquote><p><strong>TTL(time-to-live)</strong> 生存时间字段，设置了数据报可以经过的最多路由器数，指定了数据报的生存时间。初始值由源主机设置（通常为<code>32</code>或<code>64</code>）,经过一个处理它的路由器该值减<code>1</code>，当该值为<code>0</code>时，数据报被丢弃,并发送<code>ICMP</code>报文通知源主机。</p><p><strong>首部检验和(Header Checksum)</strong> 字段，根据<code>IP</code>首部计算的检验和码，它不对首部后面的数据进行计算。</p><p><code>ICMP</code>、<code>IGMP</code>、<code>UDP</code>和<code>TCP</code>在它们各自的首部中均含有首部检验和码。</p><blockquote><p>为了计算一份数据报的<code>IP</code>检验和，首先将检验和字段置为<code>0</code>。然后，将首部中的数据按每<code>16bit</code>一块分成若干块（每块包含16位的原因是检验和正好是16位，这样便于将计算结果填充到对应的16位字段），对首部中每个<code>16bit</code>求和（注意当高位溢出时，需要低位回卷）后取反（即<code>0</code>变成<code>1</code>,<code>1</code>变成<code>0</code>）结果并存储到检验和字段中。</p><p>第二种计算方法是，先将各字段二进制数据先取反，再求和。</p></blockquote><p><code>抓包数据</code>：</p><pre class="highlight"><code class>Internet protocol Version 4, src: 192.168.0.109(192.168.0.109), Dst: 224.0.0.252(224.0.0.252)Version: 4Header length: 20bytesDifferentiated Service field: 0x00 Total length: 71Identification: 0x1fd6 (8150)Flags: 0x00Fragment offset: 0Time to live: 1Protocol: UDP (17)Header checksum: 0xf7be [correct][Good: True][Bad: False]Souce: 192.168.0.109Destination: 224.0.0.252</code></pre><p>结合上面抓包数据，发送方检验和计算步骤见下图：</p><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/IP首部检验和计算步骤.gif" alt="IP首部检验和计算步骤" style="max-width:70%"><span class="image-caption">IP首部检验和计算步骤</span><blockquote><p>检验和求和前，首先将各字段各进制数值转换成二进制数值。如<code>首部长度(Header length)</code>数据报值为<code>20bytes</code>，先将其转换成十进制值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mi mathvariant="normal">/</mi><mn>8</mn><mo>=</mo><mn>4</mn><mo separator="true">,</mo><mn>20</mn><mi mathvariant="normal">/</mi><mn>4</mn><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">32/8=4,20/4=5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord">/</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord">/</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>(行)，然后再将<code>5</code>转成二进制<code>101</code>，由于首部长度占<code>4bit</code>，所以不足位补<code>0</code>，即<code>0101</code>。</p><p>求和时，当最高位需要进位时，进位被回卷到最低位。如上图虚线框结果，最高位<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">1+1=10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，只保留数值<code>0</code>，数值<code>1</code>回卷到最低位，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>+</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">0+0+1=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，其中<code>1</code>就是高位回卷的数值。</p></blockquote><p>接收方校验数据步骤和发送方类似，区别在于接收方不再将检验和字段置为<code>0</code>，而是发送方计算好的值<code>0xf7be</code>即<code>1111011110111110</code>，所以接收方最终计算结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0000100001000001</mn><mo>+</mo><mn>1111011110111110</mn><mo>=</mo><mn>1111111111111111</mn></mrow><annotation encoding="application/x-tex">0000100001000001+1111011110111110=1111111111111111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>。如果结果每个比特位不全是<code>1</code>，那么<code>IP</code>将丢弃收到的数据报，但是不生成差错报文，由上层去发现丢失的数据报并进行重传。</p><p>最后一个字段是<strong>可选字段</strong>，目前这些选项定义如下：</p><ul><li>安全和处理限制（用于军事领域，参见<a href="https://datatracker.ietf.org/doc/html/rfc1108">RFC 1108[Kent 1991]</a>)</li><li>记录路径（让每个路由器都记录下它的<code>IP</code>地址）</li><li>时间戳（让每个路由器都记录下它的<code>IP</code>地址和时间）</li><li>宽松源站选路（为数据指定一系列必须经过的<code>IP</code>地址）</li><li>严格源站选路（与宽松源站选路类似，但是要求只能经过指定的<code>IP</code>地址，不能经过其他地址）</li></ul><h4 id="ipv4编址"><a class="markdownIt-Anchor" href="#ipv4编址"></a> IPv4编址</h4><p>一台主机通常只有一条链路连接的网络，当主机中<code>IP</code>想发送一个数据报时，它就在该链路上发送。而路由器的任务是从链路上接收数据报，并从其它链路上转发出去，所以路由器必须拥有两条以上的链路。</p><p>主机、路由器与物理链路之间的边界叫作<strong>接口</strong>。<code>IP</code>要求每台主机和路由器都拥有自己的<code>IP</code>地址。</p><blockquote><p>一个<code>IP</code>地址与一个接口关联，而不是与包括该接口的主机或路由器相关联。</p></blockquote><p><strong>子网</strong> 具有相同的前半部分地址的一组<code>IP</code>地址，可以利用地址的前半部分划分组。在一个<code>IP</code>网络中划分子网使我们能将一个单一的大型网络，分成若干个较小的网络。</p><p>这样做原因是<code>A</code>类、<code>B</code>类地址为主机分配了太多的空间，在一个网络内一般不会存在如此多主机，同时子网的存在，使得外部路由器只需要知道通往子网的<code>IP</code>地址路径即可，再由子网去寻找具体子网<code>IP</code>地址即可；从而不需要知道所有子网下的<code>IP</code>地址路径，可以缩减路由表的规模。基于以上原因<code>IP</code>允许划分更小的网络，称为<strong>子网</strong>。</p><blockquote><p>大多数子网都是<code>B</code>类地址，也可以用于<code>C</code>类地址，很少出现在<code>A</code>类地址因为<code>A</code>类地址本身就很少。但是，大多数<code>A</code>类地址都是进行子网划分的。</p></blockquote><p>现在所有主机都要求支持子网编址，子网编址不再把<code>IP</code>地址看成单纯的的 <strong>网络号</strong> 和 <strong>主机号</strong> 组成，而是把主机号再分成一个 <strong>子网号</strong> 和 <strong>主机号</strong> 。</p><p>主机除了<code>IP</code>地址外，还需要知道有多少比特留给了子网号和主机号，这个问题通过<strong>子网掩码</strong> 来解决。子网掩码也是一个<code>32bit</code>的值，其中<code>网络号</code>和<code>子网号</code>（<em>如果存在，不设置子网掩码情况下，即采用默认子网掩码时，子网号不存在</em>）的值均为<code>1</code>，<code>主机号</code>值为<code>0</code>。</p><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/子网B.gif" alt="两种B类地址子网掩码" style="max-width:60%;"><span class="image-caption">两种B类地址子网掩码</span><blockquote><p>如果知道本机<code>IP</code>地址，就可以知道地址分类(A、B或C类)，也就知道网络号和子网号之间的分界线。而根据子网掩码可知道子网号和主机号之间的分界线。</p></blockquote><pre class="highlight"><code class>假设主机地址：140.252.1.1（B类地址），子网掩码：255.255.255.0（8bit子网号，8bit主机号）- 当目的地址是：140.252.4.5，可知B类网络号相同（均为140.252），子网号不同(分别为1和4)- 当目的地址是：140.252.1.22，可知B类网络号相同（均为140.252），子网号相同（均为1），主机号不同（分别为1和22）- 当目的地址是：192.43.235.6（C类地址），可知网络号不同，因此不需要进一步比较了给定两个 IP 地址和子网掩码后，IP 路由选择功能一直进行这样的比较。</code></pre><p><code>子网掩码</code>通过<strong>无类别域间路由选择（Classless Inter-Domain Routing，CIDR）</strong> 分配策略分配地址，它是一个按位，基于前缀的用于解释<code>IP</code>地址的标准。当使用子网寻址时，<code>32bit</code>的<code>IP</code>被划分为两部分，并且也具点分有十进制数形式<code>a.b.c.d/x</code>，其中<code>x</code>表示地址的第一部分即最左侧开始的比特数，叫做<strong>前缀</strong>，该部分定义了子网地址。</p><pre class="highlight"><code class>如上例，IP地址为：140.252.1.1，子网掩码：255.255.255.0使用 CIDR 子网掩码表示为 140.252.1.1/24|| 转换为二进制V                    24bit11111111 11111111 11111111 000000000255      255      255      0所以子网掩码为：255.255.255.0|| 与 IP 按位与计算V　 11111111 11111111 11111111 000000000 子网掩码&amp;　10001100 11111100 00000001 000000001 IP——————————————————————————————————————————　 10001100 11111100 00000001 000000000   140      252      1        0   结果为：140.252.1.0　其表达的含义为该 IP 地址 140.252.1.1 属于 140.252.1.0 这个网络，其主机号为 1，即这个网络中编号为 1 的主机。</code></pre><p>子网掩码一定是配合<code>IP</code>地址来使用的。对于常用网络<code>A</code>、<code>B</code>、<code>C</code> 类<code>IP</code>地址其默认子网掩码（<mark>缺省子网掩码即未划分子网，对应的网络号的位都置1，主机号都置0</mark>）的二进制与十进制对应关系见下表：</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">子网掩码（二进制）</th><th style="text-align:center">子网掩码十进制:</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">11111111 00000000 00000000 00000000</td><td style="text-align:center">255.0.0.0</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">11111111 11111111 00000000 00000000</td><td style="text-align:center">255.255.0.0</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">11111111 11111111 11111111 00000000</td><td style="text-align:center">255.255.255.0</td></tr></tbody></table><p><strong>特殊的 IP 地址</strong> ：</p><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">子网号</th><th style="text-align:center">主机号</th><th style="text-align:center">源端</th><th style="text-align:center">目的端</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">0</td><td style="text-align:center">OK</td><td style="text-align:center">不可能</td><td style="text-align:center">网络上的主机</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center">主机号</td><td style="text-align:center">OK</td><td style="text-align:center">不可能</td><td style="text-align:center">网络上的特定主机</td></tr></tbody></table><p><a href="/2021/11/05/network/TPCIP%E5%8D%8F%E8%AE%AE%EF%BC%8DUDP%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE/#%E5%B9%BF%E6%92%AD">注：更多特殊IP地址参考广播地址</a></p><h3 id="icmp"><a class="markdownIt-Anchor" href="#icmp"></a> ICMP</h3><p><strong>因特网控制报文协议（Internet Control Message Protocol，ICMP）</strong> ，它用于网际协议<code>IP</code>中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决。</p><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/IP数据报ICMP.gif" alt="ICMP 封装在 IP 数据报内部" style="max-height:90px"><span class="image-caption">ICMP 封装在 IP 数据报内部</span><p><code>ICMP</code>依靠<code>IP</code>来完成它的任务，它是<code>IP</code>的主要部分。它一般不用于在两点间传输数据。它通常不由网络程序直接使用，除了<code>ping</code> 和<code>traceroute</code> 这两个特别的程序。</p><h4 id="报文格式"><a class="markdownIt-Anchor" href="#报文格式"></a> 报文格式</h4><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP报文.gif" alt="ICMP 报文" style="max-width:60%;"><span class="image-caption">ICMP 报文</span><p><code>ICMP</code>报头从<code>IP</code>报头的第<code>160bit</code>开始（<code>IP</code>首部按20字节，未使用可选部分计算）。</p><ul><li><p><strong>类型</strong> 、<strong>代码</strong></p><p>不同类型的报文由由这两个字段共同决定，当发送一份<code>ICMP</code>差错报文时，报文始终包含<code>IP</code>的首部和<code>ICMP</code>差错报文的前<code>8</code>个字节。这样，接收<code>ICMP</code>差错报文的模块就会把它与某个特定协议和用户进程联系起来。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">代码</th><th style="text-align:center">描述</th><th style="text-align:center">查询</th><th style="text-align:center">差错</th><th style="text-align:center">状态</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">回显应答（Ping应答）</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">1 和 2</td><td style="text-align:center">-</td><td style="text-align:center">保留</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">未分配</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">-</td><td style="text-align:center">目的不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">0</td><td style="text-align:center">网络不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">1</td><td style="text-align:center">主机不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">2</td><td style="text-align:center">协议不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">3</td><td style="text-align:center">端口不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">4</td><td style="text-align:center">需要进行分片但设置了不分片比特</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">5</td><td style="text-align:center">源站选路失败</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">6</td><td style="text-align:center">目的网络不认识</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">7</td><td style="text-align:center">目的主机不认识</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">8</td><td style="text-align:center">源主机被隔离</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">9</td><td style="text-align:center">目的网络被强制禁止</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">10</td><td style="text-align:center">目的主机被强制禁止</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">11</td><td style="text-align:center">对特定的TOS 网络不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">12</td><td style="text-align:center">对特定的TOS 主机不可达</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">13</td><td style="text-align:center">由于过滤，通信被强制禁止</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">14</td><td style="text-align:center">主机越权</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">15</td><td style="text-align:center">优先权终止生效</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">源端关闭（拥塞控制）</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">0</td><td style="text-align:center">对网络重定向</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">1</td><td style="text-align:center">对主机重定向</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">2</td><td style="text-align:center">基于TOS 的网络重定向</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">3</td><td style="text-align:center">基于TOS 的主机重定向</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">-</td><td style="text-align:center">备用主机地址</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">-</td><td style="text-align:center">保留</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">未分配</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">0</td><td style="text-align:center">请求回显（Ping请求）</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">0</td><td style="text-align:center">路由通告</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">0</td><td style="text-align:center">路由器的发现/选择/请求</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">0</td><td style="text-align:center">TTL 超时</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">1</td><td style="text-align:center">分片重组超时</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">0</td><td style="text-align:center">IP 报首部参数错误（坏的I P首部）</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">1</td><td style="text-align:center">丢失必要选项</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">↑</td><td style="text-align:center">2</td><td style="text-align:center">不支持的长度</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">0</td><td style="text-align:center">时间戳请求</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">0</td><td style="text-align:center">时间戳应答</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">0</td><td style="text-align:center">信息请求</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">0</td><td style="text-align:center">信息应答</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">0</td><td style="text-align:center">地址掩码请求</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">弃用</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">0</td><td style="text-align:center">地址掩码应答</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">弃用</td></tr></tbody></table></li><li><p><strong>检验和</strong></p><p>检验和字段是必须存在的字段，覆盖整<code>ICMP</code>个报文，算法与<code>IP</code>首部检验和相同。</p></li></ul><blockquote><p>不会产生<code>ICMP</code>差错报文的情况：</p><ul><li><code>ICMP</code>差错报文（但是，查询<code>ICMP</code>报文可能产生<code>ICMP</code>差错报文）</li><li>目的地址是广播地址或多播地址的<code>IP</code>数据报</li><li>链路层广播的数据报</li><li>不是<code>IP</code>分片的第一片</li><li>源地址不是单个主机的数据报（也就是说，源地址不能为零地址、环回地址、广播地址和多播地址）</li></ul><p>这些规则防止过去允许<code>ICMP</code>差错报文对广播分组响应所带来的广播风暴。</p></blockquote><h4 id="icmp-地址掩码请求与应答"><a class="markdownIt-Anchor" href="#icmp-地址掩码请求与应答"></a> ICMP 地址掩码请求与应答</h4><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP地址掩码报文.gif" alt="ICMP 地址掩码请求和应答报文" style="max-width:60%;"><span class="image-caption">ICMP 地址掩码请求和应答报文</span><p><code>ICMP</code>地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码（这一过程与<code>RARP</code>类似）。</p><p>报文中 <strong>标识符</strong> 和 <strong>序列</strong> 字段，由发送端任意指定，这些值在应答中将被返回。这样发送端就可以把应答与请求进行匹配。</p><h4 id="icmp-时间戳请求与应答"><a class="markdownIt-Anchor" href="#icmp-时间戳请求与应答"></a> ICMP 时间戳请求与应答</h4><img src="/2021/09/01/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%8D%E7%BD%91%E7%BB%9C%E5%B1%82/ICMP时间戳报文.gif" alt="ICMP 时间戳请求和应答报文" style="max-width:60%;"><span class="image-caption">ICMP 时间戳请求和应答报文</span><p>报文主要用于互联网机器之间同步时钟。返回的建议值是自午夜开始计算的毫秒数，协调的统一时间<code>UTC</code>。这种<code>ICMP</code>报文的好处是它提供了毫秒级的分辨率，而利用其他方法从别的主机获取的时间（如某些<code>UNIX</code>系统提供的<code>rdate</code>命令）只能提供秒级分辨率。</p><blockquote><p>由于返回的时间是从午夜开始计算的，因此调用者必须通过其他方法获知当时的日期，这是它的一个缺陷。</p></blockquote><p>请求端填写发起时间戳，然后发送报文。应答系统收到请求报文时填写接收时间戳，在发送应答时填写发送时间戳。但是，实际上，大多数的实现把后面两个字段都设成相同的值（提供三个字段的原因是可以让发送方分别计算发送请求的时间和发送应答的时间）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;路由器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#路由器&quot;&gt;&lt;/a&gt; 路由器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转发&lt;/strong&gt; 当一个分组到达某路由器输入链路接口时，该路由器须将该分组移动
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="IP" scheme="http://fcwalkers.com/tags/IP/"/>
    
      <category term="ICMP" scheme="http://fcwalkers.com/tags/ICMP/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议（一）</title>
    <link href="http://fcwalkers.com/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://fcwalkers.com/2021/08/23/network/TCPIP协议（一）/</id>
    <published>2021-08-22T16:00:00.000Z</published>
    <updated>2022-04-07T08:51:13.624Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="分层"><a class="markdownIt-Anchor" href="#分层"></a> 分层</h3><img src="/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/分层.png" alt="TCP/IP 分层" style="max-height:300px"><span class="image-caption">TCP/IP 分层</span><ul><li><p><strong>应用层</strong> 负责处理特定的应用程序细节。</p></li><li><p><strong>运输层</strong> 为两台主机提供端到端的通信。主要协议有<code>TCP</code> 和<code>UDP</code>。二者都使用<code>IP</code>作为网络层协议。</p><ul><li><p>TCP，为两台主机提供高可靠性的数据通信。它的工作是将应用程序交给它的数据分成合适的小块交给下面的网络层，并确认收到的分组。</p></li><li><p>UDP，为应用层提供一种简单的服务，为数据报分组从一台主机发送到另一台主机，但不能保证数据报能够到达，因此它是不可靠的。</p><blockquote><p>数据报是指从发送方传输到接收方的一个信息单元。</p></blockquote></li></ul></li><li><p><strong>网络层</strong> 处理分组在网络中的活动。主要协议有<code>IP</code>、<code>ICMP</code>以及<code>IGMP</code>。</p><ul><li><p>IP，网络层上主要协议，同时被<code>TCP</code>和<code>UDP</code>使用。一般情况下直接访问<code>IP</code>的应用程序很少见，但也是有可能存在的。</p></li><li><p>ICMP，<code>Internet</code>控制报文协议，<code>IP</code>层用它与其他主机或路由器交换错误报文和其它重要信息。</p></li><li><p>IGMP，<code>Internet</code>组管理协议，用来把一个<code>UDP</code>数据报多播到多个主机。</p><blockquote><p>从表面上看，网络层和运输层之间的区别不那么明显。为什么要把它们划分成两个不同的层次呢？</p><p>在<code>TCP/IP</code>协议族中，网络层 <code>IP</code>提供的是一种不可靠的服务。它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。<code>TCP</code>在不可靠的<code>IP</code>层，采用超时重传、发送/接收端到端的确认分组等机制，提供一种可靠的运输层。</p></blockquote></li></ul></li><li><p><strong>链路层</strong> 也叫做数据链路层或网络接口层，包括系统设备驱动程序和计算机中对应的网络接口卡，用于处理电缆（或其他传输媒介）的物理接口细节。主要协议有<code>ARP（地址解析协议）</code>和<code>RARP（逆地址解析协议）</code>，是某些网络接口使用的特殊协议，用来转换<code>IP</code>层和网络接口层使用的地址。</p></li></ul><h3 id="ip地址"><a class="markdownIt-Anchor" href="#ip地址"></a> IP地址</h3><p>互联网上每个接口必须有一个唯一的<code>IP地址</code>，长度为<code>32bit</code>。总共分为五类：</p><img src="/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/ip地址分类.png" alt="IP地址分类" style="max-height:300px"><span class="image-caption">IP地址分类</span><blockquote><p>多接口主机具有多个 <code>IP</code>地址，其中每个接口都对应一个 <code>IP</code>地址。每类<code>IP</code>地址第一个和最后一个地址无效。</p></blockquote><p><strong>A类地址</strong>，网络号占<code>7bit</code>，全世界只有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>126</mn></mrow><annotation encoding="application/x-tex">2^7-2=126</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">6</span></span></span></span> 个<code>A</code>类网络；主机号占<code>24bit</code>，因此每个<code>A</code>类网络可以连接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>16</mn><mo separator="true">,</mo><mn>777</mn><mo separator="true">,</mo><mn>214</mn></mrow><annotation encoding="application/x-tex">2^{24}-2=16,777,214</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mord">7</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span></span></span></span> 台主机。适用于大型网络中。</p><p><strong>B类地址</strong>，网络号占<code>14bit</code>，网络数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>14</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>16</mn><mo separator="true">,</mo><mn>382</mn></mrow><annotation encoding="application/x-tex">2^{14}-2=16,382</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mord">8</span><span class="mord">2</span></span></span></span> 个 ，但是<code>127</code>为保留诊断专用网络号（如<code>127.0.0.1</code>是环回地址，用于回路测试），因此全世界大约有<code>16000</code>个<code>B</code>类网络；主机号占<code>16bit</code>，每个网络可以连接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>65</mn><mo separator="true">,</mo><mn>534</mn></mrow><annotation encoding="application/x-tex">2^{16}-2=65,534</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mord">3</span><span class="mord">4</span></span></span></span> 台主机。 适用于中等规模网络。</p><p><strong>C类地址</strong>，网络号占<code>21bit</code>，网络数量为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>21</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mn>097</mn><mo separator="true">,</mo><mn>150</mn></mrow><annotation encoding="application/x-tex">2^{21}-2=2,097,150</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">9</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">5</span><span class="mord">0</span></span></span></span> 个<code>C</code>类网络；主机号占<code>8bit</code>，每个网络可以连接 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>254</mn></mrow><annotation encoding="application/x-tex">2^8-2=254</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">8</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">4</span></span></span></span> 台主机。适用于小型网络。</p><p>这些<code>IP地址</code>通常写成四个十进制的数，每个整数对应一个字节，叫做点分十进制法。可以通过第一个十进制整数的区间来区分地址种类。</p><table><thead><tr><th style="text-align:center">种类</th><th style="text-align:center">范围</th></tr></thead><tbody><tr><td style="text-align:center">A类</td><td style="text-align:center">0.0.0.0　到　127.255.255.255</td></tr><tr><td style="text-align:center">B类</td><td style="text-align:center">128.0.0.0　到　191.255.255.255</td></tr><tr><td style="text-align:center">C类</td><td style="text-align:center">192.0.0.0　到　223.255.255.255</td></tr><tr><td style="text-align:center">D类</td><td style="text-align:center">224.0.0.0　到　239.255.255.255</td></tr><tr><td style="text-align:center">E类</td><td style="text-align:center">240.0.0.0　到　247.255.255.255</td></tr></tbody></table><h3 id="端口"><a class="markdownIt-Anchor" href="#端口"></a> 端口</h3><p>Unix系统将 1~1023 之间的端口号设置为保留端口，只有具有超级用户特权的进程才能使用。大多数<code>TCP/IP</code>实现临时端口分配为 1024~5000 之间的端口号，大于 5000 为其他服务器预留的。</p><p>服务器一般都通过<code>知名</code>端口号来识别，例如：<code>FTP</code>是21，<code>SSH</code>是22，<code>Telnet</code>是23等等。</p><blockquote><p>大多数Unix系统文件<code>ect/services</code>中都包含了熟知的端口号。</p></blockquote><h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3><p>当应用程序用 <code>TCP</code>传送数据时，发送端将数据分段并送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），由此形成的信息被称为<strong>分组</strong>，分组通过网络发送到目的端系统，再被装配成初始数据。</p><blockquote><p>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起，分组交换机从它 一条入通信链路接收到达的分组并从它一条出通信链路转发分组。</p><p>最常见的分组交换机就是<strong>路由器</strong>和<strong>链路层交换机</strong>。</p></blockquote><img src="/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/数据封装.png" alt="数据封装" style="max-height:300px"><span class="image-caption">数据封装</span><p>由于<code>TCP</code>、<code>UDP</code>、<code>ICMP</code>和<code>IGMP</code>都要向<code>IP</code>传送数据，因此<code>IP</code>必须在生成的<code>IP</code>首部中加入某种标识，以表明数据属于哪一层。因此，<code>IP</code>在首部存入一个长度为<code>8bit</code>的数值，叫作协议域。</p><p><code>1</code>表示<code>ICMP</code>协议</p><p><code>2</code>表示<code>IGMP</code>协议</p><p><code>6</code>表示<code>TCP</code>协议</p><p><code>17</code>表示<code>UDP</code>协议</p><p>同样的，应用程序都可以使用<code>TCP</code>或<code>UDP</code>来传送数据，通过都用一个<code>16bit</code>的端口号来表示不同的应用程序，运输层协议在生成报文首部时将应用程序的的源端口和目标端口分别存入，作为应用程序标识符。</p><p>网络接口同样要发送和接收<code>IP</code>、<code>ARP</code>和<code>RARP</code>数据，因此也必须在以太网的帧首部加入相应标识（也是<code>16bit</code>），以指明生成数据的网络层协议。</p><blockquote><p>当主机收到一个以太网数据帧时，数据就开始由从协议栈中由底向上升，执行封装相反的操作，去掉各个协议的首部，并检查首部中的协议标识，以确定数据的上层协议，这个过程叫作<code>分用</code>。</p></blockquote><h3 id="网络数据交换"><a class="markdownIt-Anchor" href="#网络数据交换"></a> 网络数据交换</h3><h4 id="分组交换"><a class="markdownIt-Anchor" href="#分组交换"></a> 分组交换</h4><p>为了从源端系统向目标端系统发送报文，源将长报文划分为较小的数据块，称之为<strong>分组</strong>。通过通信链路和分组交换机进行传送。</p><ul><li><p>存储转发</p><p>多数分组交换机在链路输入端使用<strong>存储转发传输</strong>机制，即在交换机在传输该分组的第一个比特之前，必须先接收到整个分组，否则就要先缓存该分组的比特，直到接收完该分组全部比特后，才能向链路输出该分组。</p></li><li><p>排队</p><p>每台分组交换机有多条链路与之相连，对于每条链路，该分组交换机具有一个<strong>输出队列</strong>,它用于存储路由器准备发往那条链路的分组。当分组需要传输到某条链路，此时该链路正忙于传输其他分组，该到达分组就会进入队列等待。因此会产生一定延时。</p><blockquote><p>网络延时除了排队延时外，还包括传输过程中的所消耗的时间。</p></blockquote></li><li><p>丢包</p><p><strong>输出队列</strong>的缓存空间大小有限，当一个到达的分组发现队列已满时，到达的分组或排除的分组将被丢弃，这种现象称为<strong>丢包</strong>。</p></li><li><p>吞吐量</p><p>单位时间内处理网络请求的数量或速率。</p></li></ul><h4 id="电路交换"><a class="markdownIt-Anchor" href="#电路交换"></a> 电路交换</h4><p>在端系统通信会话期间，预留了端系统沿路径通信所需要的资源（缓存、链路传输速率）。与不预留的分组交换相比，不需要排队等待。传统的电话网络就是电路交换的典型应用。</p><p>电路交换网络中的复用：</p><ul><li><p>频分复用(FDM)</p><p>将用于传输信道的总带宽划分成若干个子频带（或称子信道）,每个子信道传输一路信号。频分复用要求总频率宽度大于各个子信道频率之和，同时为了保证各子信道中所传输的信号互不干扰，应在各子信道之间设立隔离带，保证了各路信号互不干扰。这样所有子信道传输的信号以并行的方式工作，每一路信号传输时可不考虑传输时延。</p></li><li><p>时分复用(TDM)</p><p>对一条链路，时间被划分为固定期间的帧，每个帧又被划为固定数量的时隙。当网络跨越一条链路创建一条链接时，网络在每个帧中为该链接指定一个时隙，单独为传输数据使用。</p></li></ul><img src="/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%B8%80%EF%BC%89/电路交换网络复用.png" alt="电路交换网络复用" style="max-height:300px"><span class="image-caption">电路交换网络复用</span><blockquote><p>分组交换与电路交换相比，分组交换端到端的时延是不可预测的，因此在实时服务方面有待商榷。但是它提供了比电路交换更好的带宽共享，比电路交换更简单、有效且经济。</p></blockquote><h3 id="isp"><a class="markdownIt-Anchor" href="#isp"></a> ISP</h3><p>端系统通过 <strong>因特网服务提供商(Internet Service Provider, ISP)</strong> 接入因特网，<code>ISP</code>包括本地电缆或电话公司住宅ISP、公司ISP、大学ISP、wifi接入的ISP、蜂窝数据ISP等。</p><blockquote><p>每个<code>ISP</code>自身就是一个由多台分组交换机和多段通信链路组成的网络。因特网就是将端系统彼此互联，因此为端系统提供接入的<code>ISP</code>之间也也必须互联起来。</p><p>较低层的<code>ISP</code>通过国家、国际较高层<code>ISP</code>互联起来。较高层<code>ISP</code>是通过高速光纤链路互联的高速路由器组成。</p><p>每个<code>ISP</code>都是独立管理，通过<code>IP</code>协议，遵从相应的命名和地址规则。</p></blockquote><h3 id="物理媒体"><a class="markdownIt-Anchor" href="#物理媒体"></a> 物理媒体</h3><p>一个比特从一个端系统开始传输，通过一系列路由器和链路，到达另一个端系统。这个比特当从源到目的地传输时，通过一系列“发射器—接收器”对，通过跨越一种<strong>物理媒体</strong>传播电磁波或光脉冲来发送该比特。</p><p><code>分类</code>：</p><ul><li><strong>导引型媒体</strong> 电波沿着固体媒体前行。如：光缆、双绞铜线、同轴电缆</li><li><strong>非导引型媒体</strong> 电波在空气或外层空间传播。如：无线局域网、数字卫星频道。</li></ul><h4 id="双绞铜线"><a class="markdownIt-Anchor" href="#双绞铜线"></a> 双绞铜线</h4><p>由两根绝缘的铜线组成，每根大约1mm粗，以规则螺旋状绞合起来以减少临近的双绞线的电气干扰。通常许多双绞线捆扎在一起形成一根电缆，并在这这些双绞线外面涂上防护层。它是最便宜且最常用的导引型传输媒体，一般用于电话网、局域网中。目前局域网中的双绞线数据速率从<code>10Mbps</code>到<code>10Gbps</code>，所能达到的速率取决于线的粗细以及传输方和接收方的距离。</p><blockquote><p>双绞线也常用于住宅网络接入，家庭的 DSL 调制解调器得到数字后，将其转换为高频音，以通过电话线传输给本地中心局。因此，家庭电话同时承载了数据和传统的电话信号，它们用不同的频率进行编码。</p></blockquote><h4 id="同轴电缆"><a class="markdownIt-Anchor" href="#同轴电缆"></a> 同轴电缆</h4><p>与双绞线类似，同轴电缆由两个铜导体组成，但这两个铜导体是同心的而不是并行的。借助这种结构及特殊的绝缘体和保护层，同轴电缆能够到达较高的的数据传输速率。通常用于电视线路中。与电缆调制解调器（光猫）结合起来，形成电缆接入网能够达到数十<code>Mbps</code>的因特网速率。</p><h4 id="光纤"><a class="markdownIt-Anchor" href="#光纤"></a> 光纤</h4><p>一种细而柔软的、能够引导光脉冲的媒体。每个脉冲表示一个比特，一根光纤能够支持高达，数十甚至数百<code>Gbps</code>的速率。它们不受电磁干扰，<code>100km</code>的光缆信号衰减极低，并且很难窃听。这些特性使光纤成为跨海链路等长途导引型媒体。</p><h4 id="路地无线电信道"><a class="markdownIt-Anchor" href="#路地无线电信道"></a> 路地无线电信道</h4><p>无线电信道中承载电磁频谱中的信号，它不需要物理线路，并具有穿透墙壁、提供与移动用户长距离承载信号的能力。</p><p><code>分类</code>：</p><ul><li>一类运行在<code>1</code>到<code>2</code>米的很短距离。</li><li>第二类运行在局域，通常在十到几百米。</li><li>第三类运行在广域，跨越数万米。</li></ul><h4 id="卫星无线通道"><a class="markdownIt-Anchor" href="#卫星无线通道"></a> 卫星无线通道</h4><p>一颗通信卫星连接地球上的两个或多个微波发射器/接收器，它们被称为地面站。该卫星在一个频段上接收传输，使用一个转发器再生信号，并在另一个频率上发射信号。</p><p><code>分类</code>：</p><ul><li><strong>同步卫星</strong> 永久停留在地球上方的相同点，从地面站到卫星再回到地面站的巨大距离的信号传播，延时仅为<code>280ms</code>，传输速率确能达到数百<code>Mbps</code>。常用于无法使用<code>DSL</code>或电缆因特网接入的区域。</li><li><strong>近地轨道卫星</strong> 放置的非常靠近地球，并且不是永久停留在地球上面的一个点的卫星。它们围绕地球旋转，彼此之间可进行通信。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;分层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分层&quot;&gt;&lt;/a&gt; 分层&lt;/h3&gt;
&lt;img src=&quot;/2021/08/23/network/TCPIP%E5%8D%8F%E8%AE%AE%EF%BC%88
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="TCP/IP" scheme="http://fcwalkers.com/tags/TCP-IP/"/>
    
      <category term="网络" scheme="http://fcwalkers.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP学习笔记" scheme="http://fcwalkers.com/tags/TCP-IP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构-图</title>
    <link href="http://fcwalkers.com/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>http://fcwalkers.com/2021/04/26/algorithm/数据结构-图/</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2021-08-26T06:46:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="图的定义"><a class="markdownIt-Anchor" href="#图的定义"></a> 图的定义</h3><p>在图中的数据元素称之为<code>顶点(Vertex)</code>;任意两顶点之间可能存在关系，顶点间的关系叫做<code>边(Edge)</code>。在图结构中不允许没有顶点，因此<code>图(Graph)</code>是由顶点的有穷非空集合和顶点之间边的集合组成的数据结构，通常表示为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>V</mi><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(V,E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> ,G 表示一个图，V 表示顶点集合，E 表示边集合。</p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210426153932729.png" alt="图1|图2"><span class="image-caption">图1|图2</span></p><h4 id="无向图"><a class="markdownIt-Anchor" href="#无向图"></a> 无向图</h4><p>若顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">V_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">V_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之间的边没有方向，则称这条边为<code>无向边</code>，用无序偶对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V_A,V_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 来表示。当一个图中任意两顶点间的边都是无向边时，则称该图为<code>无向图</code>。</p><p>如图1，由于没有方向顶点 A 和 B 的边可以表示 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(A,B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span></span></span></span>，也可以写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(B,A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span>。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">图</mi><mi mathvariant="normal">：</mi><msub><mi>G</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mn>1</mn></msub><mo separator="true">,</mo><mo stretchy="false">{</mo><msub><mi>E</mi><mn>1</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">图：G_1=(V_1,\{E_1\})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">图</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">顶</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">：</mi><msub><mi>V</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">顶点集合：V_1=\{A,B,C,D\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">}</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">边</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">：</mi><msub><mi>E</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>A</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">边集合：E_1=\{(A,B),(A,C),(A,D),(B,C),(B,D)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p><ul><li><p><strong>顶点与边的关系</strong></p><p>如果边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal">′</mo></msup><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">(v,v&#x27;) \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> ，则称顶点 v 和 v’ 相邻接，即两顶点相关联。和顶点相关联的边的数量，称之为顶点的<code>度</code>，记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">TD(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>。</p><blockquote><p>如图1，A 和 B 相联接，互为邻接点，顶点 A 的度为 3。</p><p>通过观察发现图的边数，其实是各个顶点度数和的一半，多出的一半是因为重复记了两次。</p></blockquote></li></ul><h4 id="有向图"><a class="markdownIt-Anchor" href="#有向图"></a> 有向图</h4><p>若顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">V_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">V_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 之间的边有方向，则称这条边为<code>有向边</code>（也称为<code>弧</code>)，用有序偶对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><msub><mi>V</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>V</mi><mi>B</mi></msub><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;V_A,V_B&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span> 来表示，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>A</mi></msub></mrow><annotation encoding="application/x-tex">V_A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 称为弧尾 (<code>Tail</code>)，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>V</mi><mi>B</mi></msub></mrow><annotation encoding="application/x-tex">V_B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 称为弧头 (<code>Head</code>)。</p><p>当一个图中任意两顶点间的边都是有向边时，则称该图为<code>有向图</code>。</p><p>如图2，A 和 B 的边表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;A,B&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>，注意不能写成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;B,A&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span>。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">图</mi><mi mathvariant="normal">：</mi><msub><mi>G</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>V</mi><mn>2</mn></msub><mo separator="true">,</mo><mo stretchy="false">{</mo><msub><mi>E</mi><mn>2</mn></msub><mo stretchy="false">}</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">图：G_2=(V_2,\{E_2\})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">图</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mclose">)</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">顶</mi><mi mathvariant="normal">点</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">：</mi><msub><mi>V</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">顶点集合：V_1=\{A,B,C,D\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">顶</span><span class="mord cjk_fallback">点</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">}</span></span></span></span></span></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">边</mi><mi mathvariant="normal">集</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">：</mi><msub><mi>E</mi><mn>1</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo>&gt;</mo><mo separator="true">,</mo><mo>&lt;</mo><mi>A</mi><mo separator="true">,</mo><mi>C</mi><mo>&gt;</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>C</mi><mo separator="true">,</mo><mi>B</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>B</mi><mo separator="true">,</mo><mi>D</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">边集合：E_1=\{&lt;A,B&gt;,&lt;A,C&gt;,(C,B),(B,D)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">边</span><span class="mord cjk_fallback">集</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">：</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></span></p><ul><li><p><strong>顶点与边的关系</strong></p><p>如果边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>&lt;</mo><mi>v</mi><mo separator="true">,</mo><msup><mi>v</mi><mo mathvariant="normal">′</mo></msup><mo>&gt;</mo><mo>∈</mo><mi>E</mi></mrow><annotation encoding="application/x-tex">&lt;v,v&#x27;&gt; \in E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span> ，则称顶点 v 邻接到顶点 v’。以顶点 v 为尾的边数量，称之为顶点的<code>出度</code>，记录  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ID(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>  ;  反之以顶点 v 为头的边的数量，称之为顶点的<code>入度</code>，记录 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mi>D</mi><mo stretchy="false">(</mo><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">OD(v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>。</p><blockquote><p>如图2，顶点 B 的入度为 2 (从 A 到 B，从 C 到 B) ，出度为 1 (从 B 到 D)，所以顶点 B 的度为 2+1 = 3。</p><p>通过观察发现该图的边数与图的入度或出度数相等。</p></blockquote></li></ul><h3 id="图的存储"><a class="markdownIt-Anchor" href="#图的存储"></a> 图的存储</h3><h4 id="邻接矩阵"><a class="markdownIt-Anchor" href="#邻接矩阵"></a> 邻接矩阵</h4><p>图的邻接矩阵存储方式，采用两个数组来表示图。一个一维数组存储顶点信息，一个二维数组存储边信息。</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>c</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">若</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mo>∈</mo><mi>E</mi><mi mathvariant="normal">或</mi><mo>&lt;</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>j</mi></msub><mo>&gt;</mo><mo>∈</mo><mi>E</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">反</mi><mi mathvariant="normal">之</mi></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">arc[i][j]=\begin{cases} 1,若(v_i,v_j)\in E 或 &lt;v_i,v_j&gt; \in E \\0,反之\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">若</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">或</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">反</span><span class="mord cjk_fallback">之</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li><strong>根据图1的无向图，得到如下：</strong></li></ul><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210426194907500.png" alt="图3"><span class="image-caption">图3</span></p><blockquote><p>矩阵的对角线值都为 0，因为不存在顶点到自身的边。</p><p>由于是无向图，所以边是对称的，即 A 到 B 存在边，意味着 B 到 A 也存在边，值为1。所以无向图的边数组矩阵是一个对称矩阵。</p></blockquote><p><strong>根据图3可得到的信息有：</strong></p><p>1）可以判断任意两点是否存在边，即值为1有边，值为0无边。</p><p>2）顶点的度就是该顶点的第 i 行（或第 i 列）的元素之和。</p><p>3）顶点的邻接点，就是将第 i 行元素描述一遍，<code>arc[i][j]</code>为1就是邻接点。</p><ul><li><p><strong>根据图2有向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210426195002314.png" alt="图4"><span class="image-caption">图4</span></p></li></ul><blockquote><p>矩阵的对角线仍然为 0。</p><p>由于是有向图，所以矩阵不再对称，即 A 到 B 存值为 1，而 B 到 A 值为 0。</p></blockquote><p><strong>根据图4可得到的信息有：</strong></p><p>1）顶点的出度值正好为顶点所在行的各数之和 。</p><p>2）顶点的入度值正好为顶点所在列的各数之和。</p><p>3）同无向图一样判断任意两点是否存在边，即值为 1 有边，值为 0 无边。</p><h4 id="邻接表"><a class="markdownIt-Anchor" href="#邻接表"></a> 邻接表</h4><p>邻接矩阵存储图的问题在于，当存储边数相较顶点来说较少的图时，邻接矩阵大多数值均为 0，此时这种结构浪费了大量存储空间。</p><p>针对顺序结构存在预先分配内存可能造成存储空间浪费问题，可以采用链式存储结构。这种数组与链表相结合的存储方法称为邻接表。</p><p><strong>邻接表的存储结构如下：</strong></p><p>​1）顶点用一个一维数组存储，数组中每个数据的元素内还需要存储指向第一个邻接点的指针，以便查找该顶点的边信息。</p><p>​2）每个顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的所有邻接点构成一个线性表，由于邻接点数量不确定，所以采用间链表存储。无向图称为顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的边表，有向图称为顶点 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的出边表。</p><ul><li><p><strong>根据图1无向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210427103510225.png" alt="图5"><span class="image-caption">图5</span></p><p>​图5中，顶点表的各个结点由 <code>data</code> 和 <code>firstedge</code> 两个域表示，其中 <code>data</code> 是数据域存，储顶点信息 ; <code>firstedge</code> 是指针域，指向边表的第一个邻接点。</p><p>​边表各结点由 <code>adjvex</code> 和 <code>next</code> 两个域组成，其中 <code>adjvex</code> 邻接点域，存储某顶点的邻接点在顶点表中的下标 ; <code>next</code> 存储指向边表中下一个结点的指针。</p><blockquote><p>如 C 顶点，与 A、B 互为邻接点，所以顶点 C 的边表中 <code>adjvex</code> 分别为 A、B 所对应的下标 0 和 1。</p></blockquote></li><li><p><strong>根据图2有向图，得到如下：</strong></p><p>与无向图类似，但由于边是有方向，所以以顶点为尾来存储边表，这样可得到出度的邻接表。</p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210427105900040.png" alt="图6"><span class="image-caption">图6</span></p><p>有时为了确定顶点的入度，可以以顶为点头来存储边表，这样可得到入度的邻接表，称之为<strong>逆邻接表</strong>。</p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210427111107678.png" alt="图7"><span class="image-caption">图7</span></p></li></ul><h4 id="十字链表"><a class="markdownIt-Anchor" href="#十字链表"></a> 十字链表</h4><p>对于有向图来说，邻接表是有缺陷的。建立出度邻接表时，想要获得入度就必须要遍历整个图，反之亦然。而十字链表法，解决了这个问题。</p><p><strong>十字链表存储结构如下：</strong></p><p>1）顶点表增加入边表头指针( <code>firstin</code>) 指向该顶点的入边表中的第一个结点 ; 出边表头指针( <code>firstout</code>)指向该顶点的出边表中的第一个结点。</p><p>2）边表增加弧的起点(<mark>出边顶点</mark>)在顶点表的坐标 (<code>tailvex</code>) 、弧的终点(<mark>入边顶点</mark>)在顶点表的坐标 (<code>headvex</code>) 和入边表指针域 (<code>headlink</code>)指向终点相同的下一条边、出边表指针域(<code>taillink</code>)指向起点相同的下一条边。</p><ul><li><p><strong>根据图2有向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210427172645472.png" alt="图8"><span class="image-caption">图8</span></p><p><strong>十字链表步骤解析：</strong></p><p>1）第一步画出邻接表，步骤完全相同， <code>firstout</code>为第一个邻接点指针，<code>headvex</code> 就是邻接表  <code>adjvex</code> 值 ; <code>taillink</code> 就是邻接表<code>next</code>值。</p><p>2）根据图2可知，顶点 <code>A</code> 没有入边所以 <code>firstin</code> 为空，用 <code>^</code> 标识。</p><p>3）顶点 <code>B</code> 第一个入边为 <code>&lt;A,B&gt;</code> 坐标为 <code>(0,1)</code> ，所以 <code>firstin</code> 指针指向图中的 <code>①</code> 。</p><p>4）因为顶点 <code>B</code> 存在第二个入边 <code>&lt;C,B&gt;</code> 坐标为 <code>(2,1)</code> ，所以入边顶点的 <code>headlink</code> 指针继续向下指向图中的 <code>②</code>。此时顶点 <code>B</code> 已经没有其他入边，所以该顶点的入边链表在此结点终止，将该结点的 <code>headlink</code> 标记为 <code>^</code>。</p><p>5）同理顶点 <code>C</code> 和 <code>D</code> 也能画出各自的入边链表，如图 <code>③</code> 、<code>④</code>。</p><blockquote><p>十字链表的优点就是把邻接表和逆邻表整合在了一起，从而更容易获得顶点的出度与入度，并且创建图的算法时间复杂度和邻接表相同。其缺点就是结构更加复杂。</p></blockquote></li></ul><h4 id="邻接多重表"><a class="markdownIt-Anchor" href="#邻接多重表"></a> 邻接多重表</h4><p>对于无向图，邻接表也存在一些问题。当关注的重点不是顶点而是边时，如图1，要删除 <code>(A,B)</code> 边，对应的邻接表需要删除下图图9灰色两个结点，比较烦琐。可以通过邻接多重表解决这个问题。</p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210428110929769.png" alt="图9"><span class="image-caption">图9</span></p><p><strong>邻接多重表存储结构：</strong></p><p>1）顶点表保持不变</p><p>2）边表增加 <code>ivex</code>、<code>ilink</code>、<code>jvex</code>、<code>jlink</code>，其中 <code>ivex</code> 和 <code>jvex</code> 是某条边的两个顶点在顶点表中的下标 ; <code>ilink</code> 指向顶点 <code>ivex</code> 的下一条边，<code>jlink</code> 指向顶点 <code>jvex</code> 的下一条边。</p><ul><li><p><strong>根据图1无向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210428143752903.png" alt="图10"><span class="image-caption">图10</span></p><p><strong>邻接多重表步骤解析：</strong></p><p>1）先画出顶点表的 4 个顶点和 5 条边。因为是无向边，所以 <code>ivex</code> 和 <code>jvex</code> 可以是两个顶点中的任意一个。如 <code>(A,B)</code> 边，无论 <code>ivex</code> 为 0 、<code>jvex</code> 为 1，还是反过来都可以，一般为了规范，通常都将 <code>ivex</code> 值与左侧顶点下标相同。</p><p>2）首先连线 <code>①②③④</code> ，就是将顶点指向一条边。</p><p>3）顶点 <code>A</code> 的  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>B</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_A,v_B)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 边的邻边有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>C</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">和</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>D</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_A,v_C)和(v_A,v_D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord cjk_fallback">和</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，因此步骤 <code>⑤</code> 中的 <code>ilink</code> 指向顶点 <code>ivex</code> 的下一条边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>C</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_A,v_C)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 坐标为 <code>(0,2)</code> 因为是无向边，所以指向的也就是边 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>C</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_C,v_A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 坐标 <code>(2,0)</code> 。</p><p>4）继续链接指向顶点 <code>jvex</code> 的 <code>jlink</code> ，即指向顶点 <code>jvex</code> 的下一条边，此处是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msub><mi>v</mi><mi>A</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mi>D</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(v_A,v_D)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 坐标为 <code>(0,3)</code> 见步骤 <code>⑥</code>。</p><p>5）同上一步，继续链接指向顶点 <code>jvex</code> 的 <code>jlink</code>，此时发现顶点 <code>jvex</code> 即顶点 <code>A</code> 不存在其他边了，所以为空，将 <code>jlink</code> 标记为 <code>^</code>。</p><p>6）顶点 <code>A</code> 链接完成，重复上述 2-5 步，继续链接顶点 <code>B</code>、<code>C</code>、<code>D</code>。</p><blockquote><p>注意 <code>ilink</code> 所指向的结点 <code>jvex</code> 一定要和它本身的 <code>ivex</code> 值相同。</p><p>由此可见，邻接多重表与邻接表的区别，仅仅是在于同一条边在邻接表中用两个结点表示，而在邻接多重表中只有一个结点。若要删除 <code>(A,B)</code> 边时，只需要将 <code>⑦</code> 的链接指向改为 <code>^</code> 即可。</p></blockquote></li></ul><h4 id="边集数组"><a class="markdownIt-Anchor" href="#边集数组"></a> 边集数组</h4><p>边集数组是由两个一维数组组成构成。一个存储顶点的信息 ; 另一个存储边信息。边数组每个数据元素由一条边的起点下标 (<code>begin</code>)、终点下标 (<code>end</code>) 和权重 (<code>weight</code>)组成，没有权重可以省略。</p><ul><li><p><strong>根据图2有向图，得到如下：</strong></p><p><img src="/2021/04/26/algorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/image-20210428154142890.png" alt="图11"><span class="image-caption">图11</span></p></li></ul><blockquote><p>边集数组是边的集合，在边集数组中要查找一个顶点的度，需要遍历整个数组，效率不高。因此它更适合对边依次进行处理的操作，而不适合对顶点的操作。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;图的定义&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#图的定义&quot;&gt;&lt;/a&gt; 图的定义&lt;/h3&gt;
&lt;p&gt;在图中的数据元素称之为&lt;code&gt;顶点(Vertex)&lt;/code&gt;;任意两顶点之间可能存在关系，顶点间的关系叫做&lt;code&gt;边(E
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习笔记" scheme="http://fcwalkers.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图" scheme="http://fcwalkers.com/tags/%E5%9B%BE/"/>
    
      <category term="数据结构" scheme="http://fcwalkers.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>六月记</title>
    <link href="http://fcwalkers.com/2020/06/04/blog/%E5%85%AD%E6%9C%88%E8%AE%B0/"/>
    <id>http://fcwalkers.com/2020/06/04/blog/六月记/</id>
    <published>2020-06-03T16:00:00.000Z</published>
    <updated>2020-06-16T07:18:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>乘风而起，浮尘而行，蹉跎莫遣韶光老！</p></blockquote><p>白驹转瞬，年过半载。突如其来的疫情打乱了全部的计划， 在当前这个经济萧条，资金动荡的大环境下，导致向来乐享天命的我多了一丝忧愁。也就是这一丝忧愁尤如我前行路上的鸣钟，在向我发出善意的警示。</p><p>以前只想着每天对生活热情满满，对工作认真严谨，未来的事儿，顺其自然就好了。然而事与愿违，顺其自然的往往都不是什么很好的结果。俗话说“人无远虑，必有近忧！”，当近忧来扰的时候，求变的欲望从心底油然而生。</p><p>鼠年貌似一直以来就是不怎么平静的年头， 今年的新冠，零八年汶川的地震都在给这个普通的生肖年一次一次的增添不寻常轨迹。但是这一年对于我来说又是一个具有特殊意义的一年，人生为数不多的大事，在这半年时间完成了两个。希望我在人生的中段也能热忱的迎接每一个挑战，而为了更好的完成我的责任与义务，我也必须改变提升自我。把现实中放了的太多口号，回归到脚踏实地，一步一个脚印。</p><p>总是和朋友开玩笑说，自己空有一身本领，却无处施展。归根结底，造成这种境地的原因还是缺少远虑。人人都向往自由职业、梦想自由财务，却很少想过怎么为之努力奋斗，而我就被包括到了其中。</p><p>从此刻起，提升自身认知，学习理财，学习英语，实践想法，这不再是一个简单的口号，而是迎接我即将到来的“六月”的礼物。</p><p><em><strong>“我只管努力，其他的交给天意！”</strong></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;乘风而起，浮尘而行，蹉跎莫遣韶光老！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;白驹转瞬，年过半载。突如其来的疫情打乱了全部的计划， 在当前这个经济萧条，资金动荡的大环境下，导致向来乐享天命的我多了一丝忧愁。也就是这一丝忧愁尤如我前行路上的鸣钟，在
      
    
    </summary>
    
      <category term="心情随笔" scheme="http://fcwalkers.com/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>算法学习-排序</title>
    <link href="http://fcwalkers.com/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/"/>
    <id>http://fcwalkers.com/2020/04/02/algorithm/算法学习-排序/</id>
    <published>2020-04-01T16:00:00.000Z</published>
    <updated>2021-04-26T07:05:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="排序稳定性"><a class="markdownIt-Anchor" href="#排序稳定性"></a> 排序稳定性</h3><p>已知序列 r，排序前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 领先于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">r_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>&lt;</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i&lt;j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>)。当排序后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>　仍领先于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">r_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>，则所用排序方法是<strong>稳定的</strong>;反之，则称排序方法<strong>不稳定</strong>。</p><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/WX20200312-172502@2x.png" style="height:200px;"><h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3><p>冒泡排序(Bubble Sort)是一种简单的排序算法，它重复地遍历要排序的数列，每次两两比较相邻记录，如果第一个元素比第二个元素大，则交换他们位置。同理继续比较第二个与第三个元素，重复这个操作直到所有最大元素排到最右侧为止。<br><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/maopao.webp" alt="冒泡排序示意图" style="height:200px;"><span class="image-caption">冒泡排序示意图</span></p><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 冒泡排序 * @param nums 序列 * @param numsSize 序列大小 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (nums) &#123;        <span class="hljs-keyword">int</span> i, j;        printNums(nums, numsSize);        boolean flag = TRUE; <span class="hljs-comment">// 当序列前面元素都小于后面元素时说明排序已完成，不需要进行无意义的循环，所以增加 flag 标识结束循环操作</span>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; numsSize - <span class="hljs-number">1</span> &amp;&amp; flag; i++) &#123; <span class="hljs-comment">// 倒数第二次比较就可以完成所有排序，所以用i &lt; numsSize - 1 代替 i &lt; numsSize 可以少循环一次</span>            flag = FALSE;            <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; numsSize - i - <span class="hljs-number">1</span>; j++) &#123; <span class="hljs-comment">// i &lt; numsSize - i - 1 是因为 j 要与 j + 1 比较</span>                <span class="hljs-keyword">if</span> (newNums[j] &gt; newNums[j + <span class="hljs-number">1</span>]) &#123;                    <span class="hljs-keyword">int</span> temp = newNums[j + <span class="hljs-number">1</span>];                    newNums[j + <span class="hljs-number">1</span>] = newNums[j];                    newNums[j] = temp;                    flag = TRUE;                    printNums(nums, numsSize);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h4><p>最好的情况，序列本身是有序的，可以推断出算法进行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次比较，没有数据交换，时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br>最坏的情况，序列本身是逆序的，当：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">i=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次<br>…<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">i=n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br>总共比较了</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><mi>n</mi></munderover><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n)=\sum^{n}_{i=2}(i-1)=1+2+3+...+(n-1)=\frac{(1+n-1)(n-1)}{2}=\frac{n(n-1)}{2}=\frac{1}{2}n^2-\frac{1}{2}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>次，根据复杂度推导原则，去掉常数和最高项等其复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度"></a> 空间复杂度</h4><p>空间很杂度就是在交换元素时 temp 临时变量所占的内存空间。<br>最好情况，是序列已排好序，则空间复杂度为 0;<br>最坏情况，是序列本身逆序，则空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br>所以算法平均空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h4 id="稳定性"><a class="markdownIt-Anchor" href="#稳定性"></a> 稳定性</h4><p>冒泡排序是稳定的原地排序算法。</p><h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3><p>选择排序的原理是，先从给定序列中选出一个最小元素 min (通常是无序区间第一个元素)，然后与后面元素进行比较，选出最小元素与之交换，min 位置前面就变成了有序区间，min 位置后面则是无序区间，继续在无序区间重复前面操作直到全部变成有序区间后，排序完成。</p><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/xuanze.gif" alt="选择排序示意图" style="height:200px;"><span class="image-caption">选择排序示意图</span><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 选择排序(每次找出最小元素与数组第一个元素交换) * @param nums 序列 * @param numsSize 序列大小 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">chooseSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-keyword">int</span> i, j;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;            <span class="hljs-keyword">int</span> temp;            <span class="hljs-keyword">int</span> min = i;            <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; numsSize; j++) &#123;                <span class="hljs-keyword">if</span> (newNums[j] &lt; newNums[min]) min = j;            &#125;            temp = newNums[i];            newNums[i] = newNums[min];            newNums[min] = temp;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度-2"><a class="markdownIt-Anchor" href="#时间复杂度-2"></a> 时间复杂度</h4><p>该算法最大特点就是交换移动数据次数很少，可以节约相应时间。但是它的比较次数无论是最好或最差情况下都是一样多，当<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次　<br>…<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时，比较 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次　<br>总共比较了</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n)=\sum^{n-1}_{i=1}(n-i)=(n-1)+(n-2)+...+2+1=\frac{n(n-1)}{2}=\frac{1}{2}n^2-\frac{1}{2}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>次，根据复杂度推导原则，去掉常数和最高项等其复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h4 id="稳定性-2"><a class="markdownIt-Anchor" href="#稳定性-2"></a> 稳定性</h4><p>由于选择元素之后发生交换操作，所以很可能把前面元素交换到后面，所以该排序算法是不稳定的。</p><h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3><p>插入排序采用<code>in-place</code>在数组上实现的算法，<br><strong>具体步骤是</strong>：</p><ol><li>从第一个元素开始，认为该元素是有序序列，取出下一个元素作为临时元素，在有序序列中从后向前逐一比较。</li><li>如果有序序列中元素大于临时元素，则将该元素向后移动一位。</li><li>如果该元素小于等于临时元素，则将临时元素插入到该位置，此时有序序列长度增加一。</li><li>临时元素索引加一继续作为临时元素，重复前面步骤，直到临时元素索引超出序列长度，排序完成。</li></ol><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/charu.gif" alt="插入排序示意图" style="height:300px;width: 655px;"><span class="image-caption">插入排序示意图</span><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 插入排序 * @param nums 序列 * @param numsSize 序列大小 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-keyword">int</span> i, j;        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; numsSize; i++) &#123;            <span class="hljs-keyword">if</span> (newNums[i - <span class="hljs-number">1</span>] &gt; newNums[i]) &#123;                <span class="hljs-keyword">int</span> temp = newNums[i];                <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; newNums[j] &gt; temp; j--) &#123;                    newNums[j + <span class="hljs-number">1</span>] = newNums[j];                &#125;                newNums[j + <span class="hljs-number">1</span>] = temp;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度-3"><a class="markdownIt-Anchor" href="#时间复杂度-3"></a> 时间复杂度</h4><p>对于 n 个元素，外层循环执行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(n)=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次，内层循环，当：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 时，执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 次<br>…<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次<br>总共执行了</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><mi>i</mi><mo>=</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><msup><mi>n</mi><mn>2</mn></msup><mo>−</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n)=\sum^{n-1}_{i=1}i=1+2+...+(n-1)=\frac{n(n-1)}{2}=\frac{1}{2}n^2-\frac{1}{2}n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>次，根据复杂度推导原则，去掉常数和最高项等其复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h4 id="空间复杂度-2"><a class="markdownIt-Anchor" href="#空间复杂度-2"></a> 空间复杂度</h4><p>插入排序通常采用<code>in-place</code>排序，所以空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h4 id="稳定性-3"><a class="markdownIt-Anchor" href="#稳定性-3"></a> 稳定性</h4><p>因为排序比较时，当两个数相等时，不会进行移动，因此前后次序不会发生变化，所以该排序算法是稳定的。</p><h3 id="希尔排序"><a class="markdownIt-Anchor" href="#希尔排序"></a> 希尔排序</h3><p>希尔排序是 D.L.Shell 于 1959 年提出的一种排序算法，之前排序算法时间复杂度基本都是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，希尔排序是突破这个时间复杂度的第一批算法之一。</p><p>插入排序通常在小规模数据或是序列基本有序时十分高效，但是满足这两个条件是比较困难。希尔排序就是对插入排序的改进算法，<br><strong>基本思路是</strong>：</p><ul><li>将原有大量记录序列进行分组，侵割成若干个子序列。</li><li>在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，再对整个序列进行一次直接插入排序，完成排序。</li></ul><blockquote><p>所谓基本有序，指的是序列中较小元素基本在前面，较大元素基本在后面，不大不小元素基本在中间，如：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>9</mn></mrow><annotation encoding="application/x-tex">{2, 1, 3, 6, 4, 7, 5, 8, 9}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span></span></span></span></span><br>为了使整个序列基本有序，采取跳跃分割策略，<strong>将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列排序后整个序列基本有序，而不是局部有序</strong>。</p></blockquote><p><strong>步骤</strong>：<br>以增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi><mo>=</mo><mi>l</mi><mi>e</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">gap=length/2=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 方式计算，首先将序列可逻辑分成四组子序列 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>5</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[5,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>7</mn><mo separator="true">,</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[7,2]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>8</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[8,4]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mclose">]</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>，如下：<br><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/shellSort1.png" alt="希尔排序分组示意图" style="width:500px;"><span class="image-caption">希尔排序分组示意图</span></p><p>分别对各个子序列进行插入排序可得到逻辑子序列分别为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,5]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>2</mn><mo separator="true">,</mo><mn>7</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[2,7]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>4</mn><mo separator="true">,</mo><mn>8</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[4,8]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mclose">]</span></span></span></span>、 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>3</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[3,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span> 总序列为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>5</mn><mo separator="true">,</mo><mn>7</mn><mo separator="true">,</mo><mn>8</mn><mo separator="true">,</mo><mn>6</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,2,4,3,5,7,8,6]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">5</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">7</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">6</span><span class="mclose">]</span></span></span></span>，如图：<br><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/shellSort2.png" alt="希尔排序子序列排序示意图" style="width:500px;"><span class="image-caption">希尔排序子序列排序示意图</span></p><p>然后继续以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi><mo>=</mo><mi>g</mi><mi>a</mi><mi>p</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">gap=gap/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mord">/</span><span class="mord">2</span></span></span></span> &amp;&amp; <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mi>a</mi><mi>p</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">gap&gt;0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 方式计算，重复上述步骤。<br>最后根据得到的基本有序序列再一次进入直接插入排序，最终完成排序。</p><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 希尔排序 * @param nums 序列 * @param numSize 序列大小 * @return */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = numsSize / <span class="hljs-number">2</span>; gap &gt; <span class="hljs-number">0</span>; gap /= <span class="hljs-number">2</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; numsSize; i++) &#123;                <span class="hljs-keyword">if</span> (newNums[i - gap] &gt; newNums[i]) &#123;                    <span class="hljs-keyword">int</span> j;                    <span class="hljs-keyword">int</span> temp = newNums[i];                    <span class="hljs-keyword">for</span> (j = i - gap; j &gt;= <span class="hljs-number">0</span> &amp;&amp; newNums[j] &gt; temp; j -= gap) &#123;                        newNums[j + gap] = newNums[j];                    &#125;                    newNums[j + gap] = temp;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度-4"><a class="markdownIt-Anchor" href="#时间复杂度-4"></a> 时间复杂度</h4><p>希尔排序算法的时间复杂度与其增量<code>gap</code>设置有关，迄今为止还没有能证明出来的增量序列，不过有实验表明当增量序列为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^k-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，时间复杂度最坏情况为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>1.5</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^{1.5})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">.</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="稳定性-4"><a class="markdownIt-Anchor" href="#稳定性-4"></a> 稳定性</h4><p>虽然插入排序是稳定的，但是希尔排序在插入的时候是跳跃性插入的，有可能破坏其稳定性，所以希尔排序是不稳定的。</p><h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3><p>归并排序(Merging Sort) 就是将待排序的数分成两半后排好序，然后再将两个排好序的序列合并成一个有序序列。 归并排序是一个比较占用内存，但效率高的算法。<br><strong>基本原理是</strong>：<br>将有<code>n</code> 个元素的序列看成是<code>n</code> 个有序的子序列，每个子序列长度为<code>1</code>(一个元素认为它有序的)， 然后两两归并，…重复归并，直至得到一个长度为<code>n</code> 的有序序列为止，这种方法称为<strong>2路归并法</strong>。</p><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/guibing.webp" alt="归并排序示意图" style="height:200px;"><span class="image-caption">归并排序示意图</span><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 归并排序 * @param nums 序列 * @param numSize 序列大小 * @return */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;       mSort(newNums, <span class="hljs-number">0</span>, numSize - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *newNums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">if</span> (left &lt; right) &#123;        <span class="hljs-comment">// 将序列一分为二</span>        <span class="hljs-keyword">int</span> center = (left + right) / <span class="hljs-number">2</span>;        <span class="hljs-comment">// 排序左边数组</span>        mSort(newNums, left, center);        <span class="hljs-comment">// 排序右边数组</span>        mSort(newNums, center + <span class="hljs-number">1</span>, right);        <span class="hljs-comment">// 合并两个序列</span>        mSortMerge(newNums, left, center, right);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mSortMerge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *newNums, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> center, <span class="hljs-keyword">int</span> right)</span> </span>&#123;    <span class="hljs-keyword">int</span> i = left;    <span class="hljs-keyword">int</span> j = center + <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> *tempNums = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(newNums));    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++) &#123;        <span class="hljs-comment">// j &gt; right 时，表示右子序列元素全部放入到了临时数组(tempNums) 中，此时只剩下左子序列有元素，由于单侧子序列都是有序的，所以直接将左子序列元素顺序放入临时数组(tempNums)中即可。</span>        <span class="hljs-comment">// 反之，当 j &lt;= right 且 i &gt; center 时，表示左子序列元素全部放入到了临时数组中，此时只剩下右子序列有元素，所以直接将右子序列元素顺序放入临时数组中即可。</span>        <span class="hljs-comment">// 该操作通过递归函数重复调用直到排序完成为止</span>        <span class="hljs-keyword">if</span> (j &gt; right || newNums[i] &lt;= newNums[j])            tempNums[k] = newNums[i++];        <span class="hljs-keyword">else</span>            tempNums[k] = newNums[j++];    &#125;    <span class="hljs-comment">// 将排好序的临时数组元素复制到原数组中</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = left; k &lt;= right; k++) &#123;        newNums[k] = tempNums[k];    &#125;    <span class="hljs-built_in">free</span>(tempNums);&#125;</code></pre><p><strong>递归实现的执行步骤如下</strong>：</p><pre class="highlight"><code class>排序序列：54321------------------------------L-&gt;C-&gt;R：024分割序列：54321------------------------------L-&gt;C-&gt;R：012分割序列：543------------------------------L-&gt;C-&gt;R：001分割序列：54------------------------------L-&gt;C-&gt;R：001待排序序列：54序列中较小元素：4序列中较小元素：5排序完成序列：45------------------------------L-&gt;C-&gt;R：012待排序序列：453序列中较小元素：3序列中较小元素：4序列中较小元素：5排序完成序列：345------------------------------L-&gt;C-&gt;R：334分割序列：34------------------------------L-&gt;C-&gt;R：334待排序序列：34序列中较小元素：1序列中较小元素：2排序完成序列：34512------------------------------L-&gt;C-&gt;R：024待排序序列：34512序列中较小元素：1序列中较小元素：2序列中较小元素：3序列中较小元素：4序列中较小元素：5排序完成序列：12345</code></pre><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 归并排序(非递归实现) *  实现原理：首先将序列中每个元素作为子序列，把相临子序列两两配对排序; *  然后，再将两个排好序的子序列作为一个子序列，再对相临子序列进行排序，重复上面步骤直到排序完成 * @param nums 序列 * ‧param numSize 序列大小 */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">mergeSortNonRecursive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-comment">// 定义子序列的大小分别为 1、2、4、8...逐渐递增</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; numSize; i += i) &#123;            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;            <span class="hljs-keyword">int</span> center = left + i - <span class="hljs-number">1</span>;            <span class="hljs-keyword">int</span> right = center + i;            <span class="hljs-comment">// 对子序列时行两两合并</span>            <span class="hljs-keyword">while</span> (right &lt; numSize) &#123;                <span class="hljs-comment">// 合并两序列</span>                mSortMerge(newNums, left, center, right);                left = right + <span class="hljs-number">1</span>;                center = left + i - <span class="hljs-number">1</span>;                right = center + i;            &#125;            <span class="hljs-comment">// 因为不可能每个子序列的大小都刚好为</span>            <span class="hljs-comment">// i，所以可能存在遗漏元素没有合并，因此最后要对遗漏元素进行合并</span>            <span class="hljs-keyword">if</span> (left &lt; numSize &amp;&amp; center &lt; numSize) &#123;                mSortMerge(newNums, left, center, numSize - <span class="hljs-number">1</span>);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> newNums;&#125;</code></pre><h4 id="时间复杂度-5"><a class="markdownIt-Anchor" href="#时间复杂度-5"></a> 时间复杂度</h4><p>由于归并排序数据结构属于完全二杈树，而由完全二杈树的深度可知 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">T(n)=log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span> 次。排序最后要将临时数组元素复制到原数组中，此时 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 次。因此，总时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p><h4 id="稳定性-5"><a class="markdownIt-Anchor" href="#稳定性-5"></a> 稳定性</h4><p>归并排序中不存在跳跃，只有两两比较，因此是一种稳定排序。</p><h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3><p>所谓快速排序，也是一种采用分治思想的排序方法，其<strong>基本思路是</strong>：<br>首先，在要排序的序列(<code>nums</code>)中任意选取一个元素(通常选择第一个元素)，该元素被称为<code>中枢元素</code>。然后根据中枢元素进行排序，将小于等于中枢元素的元素放在中枢元素的左边，将大于等于中枢元素的元素放在中枢元素的右边。然后再把序列根据中枢元素位置(<code>pivot</code>)分割成两个子序列，即左子序列(<code>nums[low,pivot-1]</code>) 和右子序列(<code>nums[pivot+1,high]</code>)，继续重复前面步骤直到整个序列有序。</p><img src="/2020/04/02/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/kuaisu.jpeg" style="width:300px;" alt="快速排序示意图"><span class="image-caption">快速排序示意图</span><blockquote><p>上面整个排序过程的主要目的是选出中枢元素，然后将中枢元素交换到有序位置(即中枢元素大于其左侧所有元素，小于其右侧所有元素)，然后再将序列分割成左、右子序列，分别在两个序列中选出中枢元素继续交换到有序位置，直到序列大小最终被分割为 1 为止(当序列只有 1 个元素时，即可认为该序列有序)。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-comment">/** * 快速排序 * @param nums 序列 * @param numsSize 序列大小 * @date 2020-03-30 16:47 * @author Windus */</span><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> numsSize)</span> </span>&#123;    <span class="hljs-keyword">int</span> *newNums = nums;    <span class="hljs-keyword">if</span> (newNums) &#123;        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qSortRecursion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>;        qSortRecursion(newNums, <span class="hljs-number">0</span>, numsSize - <span class="hljs-number">1</span>);    &#125;<span class="hljs-keyword">return</span> newNums;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qSortRecursion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">if</span> (low &lt; high) &#123;        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>;        <span class="hljs-comment">// 获取中枢元素，并根据中枢将子序列排序</span>        <span class="hljs-keyword">int</span> pivot = partition(nums, low, high);        <span class="hljs-comment">// 对左子序列进行排序</span>        qSortRecursion(nums, low, pivot - <span class="hljs-number">1</span>);        <span class="hljs-comment">// 对右子序列进行排序</span>        qSortRecursion(nums, pivot + <span class="hljs-number">1</span>, high);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">int</span> pivot = low;    <span class="hljs-keyword">while</span> (low &lt; high) &#123;        <span class="hljs-comment">// 从左向右扫描比中枢元素大的元素</span>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= nums[high]) low++;        <span class="hljs-comment">// 从右向左扫描比中枢元素小的元素</span>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= nums[pivot]) high--;        <span class="hljs-comment">// 当左侧指针位置大于或等于右侧指针时，跳出循环，不进行左右元素交换(因为左指针元素已经小于等于中枢元素，不需要移动位置了)</span>        <span class="hljs-keyword">if</span> (low &gt;= high) <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// 交换两指针元素元素，使左指针元素小于右指针元素</span>        temp = nums[high];        nums[high] = nums[low];        nums[low] = temp;    &#125;    <span class="hljs-comment">// 交换中枢元素，使中枢元素处于有序位置</span>    temp = nums[high];    nums[high] = nums[pivot];    nums[pivot] = temp;    <span class="hljs-keyword">return</span> pivot;&#125;</code></pre><blockquote><p>中枢元素的选取直接影响快速排序性能，当中枢元素处于整个序列中间位置时最优，但在现实中，待排序序列极有可能是基本有序的，此时，如果固定选取某一元素作为中枢元素并不是好的排序办法。因此可以通过随机或取中间数的方法来选取中枢元素。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> pivot;<span class="hljs-comment">// 计算中间元素的下标</span><span class="hljs-keyword">int</span> m = (high - low) / <span class="hljs-number">2</span>;<span class="hljs-keyword">if</span>(nums[low] &gt; nums[high])    swap(nums, low, high); <span class="hljs-comment">// 交换左、右两侧元素，保证左侧元素较小</span><span class="hljs-keyword">if</span>(nums[m] &gt; nums[high])    swap(nums, high, m); <span class="hljs-comment">// 交换中间与右侧元素，保证中间较小 </span><span class="hljs-keyword">if</span>(nums[m] &gt; nums[low])    swap(nums, m, low); <span class="hljs-comment">// 交换中间与左侧元素，保证左侧元素较小</span><span class="hljs-comment">/* 此时 nums[low] 已经成为三个元素的中间值，用于当作中枢元素 */</span>pivot = low;</code></pre><h4 id="时间复杂度-6"><a class="markdownIt-Anchor" href="#时间复杂度-6"></a> 时间复杂度</h4><p>虽然快速排序的平均时间复杂度也是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，但是不需要像归并排序那样，需要一个临时数组辅助排序，这样可以节省掉一些空间消耗。同时也不需要像归并排序那样，把两部分有序子序列汇总到临时数组之后，再复制回源数组 ，这样也可以节省很多时间。</p><h4 id="稳定性-6"><a class="markdownIt-Anchor" href="#稳定性-6"></a> 稳定性</h4><p>该排序是不稳定的，因为在整个序列扫描时，中枢元素与 high 位置发生交换的时候，可能破坏其稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;排序稳定性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#排序稳定性&quot;&gt;&lt;/a&gt; 排序稳定性&lt;/h3&gt;
&lt;p&gt;已知序列 r，排序前 &lt;span class=&quot;katex&quot;&gt;&lt;span class=&quot;katex-mathml&quot;&gt;&lt;math
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习笔记" scheme="http://fcwalkers.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="排序" scheme="http://fcwalkers.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法" scheme="http://fcwalkers.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-复杂度分析</title>
    <link href="http://fcwalkers.com/2020/03/11/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%8D%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>http://fcwalkers.com/2020/03/11/algorithm/算法学习－复杂度分析/</id>
    <published>2020-03-10T16:00:00.000Z</published>
    <updated>2021-04-26T07:05:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="时间复杂度"><a class="markdownIt-Anchor" href="#时间复杂度"></a> 时间复杂度</h3><p>算法时间复杂度，即算法的时间量度，采用<strong>大O</strong>记法( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span> )：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p>表示随问题规模 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的增大，算法执行时间的增长率和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 的增长率相同，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 是问题规模 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的菶函数。<br>通常，随着 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 的增大，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 增长最慢的算法为最优算法。</p><blockquote><p>推导时间复杂度大 O 方法：</p><ol><li><strong>因为常数项对函数的增长速度影响不大，所以用常数 1 取代运行时间中的所有加法常数</strong>。如：<br> <br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">T(n) = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> // 把常数 2 用 1 取代，所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><br> </li><li><strong>因为高次项对于函数的增长速度的影响最大( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>3</mn></msup><mo>&gt;</mo><msup><mi>n</mi><mn>2</mn></msup><mo>&gt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">n^3 &gt; n^2 &gt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.853208em;vertical-align:-0.0391em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> )，所以在修改后的运行次数函数中，只保留最高项</strong>。如：<br> <br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>n</mi><mn>3</mn></msup><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mn>29</mn></mrow><annotation encoding="application/x-tex">T(n) = n^3 + n^2 + 29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">9</span></span></span></span> // 只保留最高项 n^3，所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>n</mi><mo>+</mo><mn>29</mn></mrow><annotation encoding="application/x-tex">T(n) = n + 29</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">9</span></span></span></span> // 只保留最高项 n，所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br> </li><li><strong>因为函数的阶数对函数的增长速度影响最显著，所以如果最高项存在且不是1，则去除与这个项相乘的常数</strong>。<br> <br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn><msup><mi>n</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">T(n) = 3n^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span> // 最高项存在且不是 1，所以去除相乘常数后时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ol></blockquote><h4 id="常数时间o1"><a class="markdownIt-Anchor" href="#常数时间o1"></a> 常数时间<code>O(1)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>,n = <span class="hljs-number">100</span>; <span class="hljs-comment">// 执行一次 时间复杂度 O(1)</span>sum = (<span class="hljs-number">1</span>+n) * n/<span class="hljs-number">2</span>;   <span class="hljs-comment">// 执行一次 时间复杂度 O(1)</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,sum);    <span class="hljs-comment">// 执行一次 时间复杂度 O(1)</span>&#125;</code></pre><p>函数 afunc 运行次数的函数是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">T(n) = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span>。根据大 O 推导方法，把常数项 3 改为 1。然后保留最高项，其最高项就是常数项，所以这个算法的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</p><h4 id="线性时间on"><a class="markdownIt-Anchor" href="#线性时间on"></a> 线性时间<code>O(n)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123; <span class="hljs-comment">// 循环次数 n ，时间复杂度为 O(n)</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!"</span>); <span class="hljs-comment">// 时间复杂度 O(1)</span>   &#125;&#125;</code></pre><p>循环的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，循环体内时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，则这个循环的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n × 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，根据推导方法第三步去掉最高项相乘的常数，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h4 id="平方时间on2"><a class="markdownIt-Anchor" href="#平方时间on2"></a> 平方时间<code>O(n^2)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++)&#123; <span class="hljs-comment">// 循环次数为 n，时间复杂度为 O(n)</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123; <span class="hljs-comment">// 循环次数为 n，时间复杂度为 O(n)</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!"</span>); <span class="hljs-comment">// 时间复杂度为 O(1)</span>        &#125;    &#125;&#125;</code></pre><p>此时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>n</mi><mo>×</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n × n × 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">int</span> i,j;    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123; <span class="hljs-comment">// 循环次数为 n，时间复杂度为 O(n)</span>        <span class="hljs-keyword">for</span>(j = i; j &lt; n; j++)&#123; <span class="hljs-comment">// 注意 j = i而不是0</span>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!"</span>); <span class="hljs-comment">// 时间复杂度为 O(1)</span>        &#125;    &#125;&#125;</code></pre><p>当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">i = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，内循环执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 次，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，执行了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>次，……当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = n -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>时，执行了 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 次。所以总执行次数为：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>1</mn><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo>=</mo><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>2</mn></mfrac><mo>+</mo><mfrac><mi>n</mi><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">n + ( n - 1 ) + ( n - 2 ) + ... + 1 = \frac{n ( n + 1 )}{ 2 } = \frac{ n^2 }{2} + \frac{ n }{ 2 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.177108em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.491108em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>用<strong>大O</strong>推导方法，保留最高阶项 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><msup><mi>n</mi><mn>2</mn></msup><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{ n^2 }{ 2 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，然后去除这个项相乘的常数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{ 1 }{ 2 }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，得出时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="对数时间ologn"><a class="markdownIt-Anchor" href="#对数时间ologn"></a> 对数时间<code>O(logn)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">int</span> count  = <span class="hljs-number">1</span>;<span class="hljs-keyword">while</span>(count &lt; n)&#123;    count =  count * <span class="hljs-number">2</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello Word!"</span>);&#125;&#125;</code></pre><p>从此例中可以看出当循环执行 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>x</mi></msup><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">2^x = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding="application/x-tex">x = log_2n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">n</span></span></span></span> 次时结束。所以时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> (<em>底数2可以省略</em>)</p><h4 id="指数时间o2n"><a class="markdownIt-Anchor" href="#指数时间o2n"></a> 指数时间<code>O(2^n)</code></h4><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">aFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> aFunc(n - <span class="hljs-number">1</span>) + aFunc( n - <span class="hljs-number">2</span> );    &#125;&#125;</code></pre><p>此代码可以看出，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mi mathvariant="normal">，</mi><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">T(0) = T(1) = 1，T(n) = T(n - 1) + T(n - 2) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>。通过归纳法证明，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n &gt;= 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mo stretchy="false">(</mo><mn>5</mn><mi mathvariant="normal">/</mi><mn>3</mn><msup><mo stretchy="false">)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">T(n) &lt; (5/3)^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">/</span><span class="mord">3</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>&gt;</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">n &gt; 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&gt;</mo><mo>=</mo><mo stretchy="false">(</mo><mn>3</mn><mi mathvariant="normal">/</mi><mn>2</mn><msup><mo stretchy="false">)</mo><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">T(n) &gt;= (3/2)^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">/</span><span class="mord">2</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>，所以简化后的时间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p><h4 id="常用时间复杂度"><a class="markdownIt-Anchor" href="#常用时间复杂度"></a> 常用时间复杂度</h4><img src="/2020/03/11/algorithm/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%8D%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/WX20200312-111638@2x.png" alt="图：常用的时间复杂度" style="height:200px;"><span class="image-caption">图：常用的时间复杂度</span><p>常用的时间复杂度所耗费时间从小到大依次是：</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><blockquote><p>时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，深入到函数进行分析。</p></blockquote><h3 id="空间复杂度"><a class="markdownIt-Anchor" href="#空间复杂度"></a> 空间复杂度</h3><p>空间复杂度是对一个算法在运行过程中临时战胜存储空间大小的量度。<br>计算公式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n) = O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>　<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 为问题规模，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 为语句关于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 所占存储空间的函数。</p><p>比如插入排序的空间复杂度是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，而一般递归算法就要有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的空间复杂度，因为每次递归都要存储返回信息。</p><blockquote><p>有时也可以用空间换时间的方法，如要判断某年是不是闰年，可以写一个算法，每次给一个年份来计算出结果，还有另一个方法就是，事先建立一个有 2050 个元素的数组，然后把所有年份按下标数字对应如果是闰年，此数组项值为1，反之为0。如此一来就可以实现闰年判断。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;时间复杂度&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#时间复杂度&quot;&gt;&lt;/a&gt; 时间复杂度&lt;/h3&gt;
&lt;p&gt;算法时间复杂度，即算法的时间量度，采用&lt;strong&gt;大O&lt;/strong&gt;记法( &lt;span class=&quot;katex&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习笔记" scheme="http://fcwalkers.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="算法" scheme="http://fcwalkers.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="复杂度" scheme="http://fcwalkers.com/tags/%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Unix编程学习笔记－文件和目录</title>
    <link href="http://fcwalkers.com/2020/02/27/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
    <id>http://fcwalkers.com/2020/02/27/Linux/Unix编程学习笔记－文件和目录/</id>
    <published>2020-02-26T16:00:00.000Z</published>
    <updated>2020-03-30T02:49:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数stat"><a class="markdownIt-Anchor" href="#函数stat"></a> 函数<code>stat</code></h3><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> pathname, struct stat *<span class="hljs-keyword">restrict</span> buf)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, struct stat *buf)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> pathname, struct stat *<span class="hljs-keyword">restrict</span> buf)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fstatat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> pathname, struct stat *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 这四个函数返回值：成功返回0;出错返回-1</span></code></pre><p>(1) 当给出 pathname 时：</p><ul><li>stat 函数将返回与此命名文件有关的信息结构。</li><li>fstat 函数获得已在描述符 fd 上打开文件的有关信息。</li><li>lstat 函数类似于 stat，但当命名文件是一个符号链接时，lstat 返回该符号链接的有关信息，而不是由该符号链接引用的文件信息。此外，当以降序遍历目录层次结构时，需要用到此函数。</li><li>fstatat 函数为一个相对于当前打开目录(由 fd 参数指向)的路径名返回文件统计信息。<ul><li><code>flag</code> 参数表示是否跟随一个符号链接。设置<code>AT_SYMLINK_NOFOLLOW</code>标志表示不会跟随符号链接，而是返回符号本身的信息。否则默认返回符号链接所指向的实际文件的信息。</li><li><code>fd</code> 参数值为<code>AT_FDCWD</code>,并且 pathname 参数是一个相对路径名，函数将会计算相对于当前目录的 pathname 参数;如果 pathname 是一个绝对路径，fd 参数就会被忽略。这两种情况，根据 flag 的取值，函数作用跟 stat 或 lstat 一样。</li></ul></li></ul><p>(2) buf 参数是一个指向<code>struct stat</code>结构的指针。结构的实际定义可能根据气体实现有所不同，但基本形式如下：</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> &#123;</span><span class="hljs-keyword">dev_t</span>       st_dev;     <span class="hljs-comment">/* ID of device containing file -文件所在设备的ID*/</span>      <span class="hljs-keyword">ino_t</span>       st_ino;     <span class="hljs-comment">/* inode number -inode节点号*/</span>        <span class="hljs-keyword">mode_t</span>      st_mode;    <span class="hljs-comment">/* protection -保护模式?*/</span>        <span class="hljs-keyword">nlink_t</span>     st_nlink;   <span class="hljs-comment">/* number of hard links -链向此文件的连接数(硬连接)*/</span>        <span class="hljs-keyword">uid_t</span>       st_uid;     <span class="hljs-comment">/* user ID of owner -user id*/</span>        <span class="hljs-keyword">gid_t</span>       st_gid;     <span class="hljs-comment">/* group ID of owner - group id*/</span>        <span class="hljs-keyword">dev_t</span>       st_rdev;    <span class="hljs-comment">/* device ID (if special file) -设备号，针对设备文件*/</span>        <span class="hljs-keyword">off_t</span>       st_size;    <span class="hljs-comment">/* total size, in bytes -文件大小，字节为单位*/</span>        <span class="hljs-keyword">blksize_t</span>   st_blksize; <span class="hljs-comment">/* blocksize for filesystem I/O -系统块的大小*/</span>        <span class="hljs-keyword">blkcnt_t</span>    st_blocks;  <span class="hljs-comment">/* number of blocks allocated -文件所占块数*/</span>        <span class="hljs-keyword">time_t</span>      st_atime;   <span class="hljs-comment">/* time of last access -最近存取时间*/</span>        <span class="hljs-keyword">time_t</span>      st_mtime;   <span class="hljs-comment">/* time of last modification -最近修改时间*/</span>        <span class="hljs-keyword">time_t</span>      st_ctime;   <span class="hljs-comment">/* time of last status change - */</span>&#125;</code></pre><p>使用 stat 函数最多的地方可能就是<code>ls -l</code>命令，用其可以获得有关文件的所有信息。</p><h3 id="文件类型"><a class="markdownIt-Anchor" href="#文件类型"></a> 文件类型</h3><p>Unix 的文件类型主要包括下列几种：</p><ul><li><p><code>普通文件( regular file )</code>最常用的文件类型，包含了某种形式的数据，数据或是二进制数据，但对于 UNIX 内核来说并无区别。对普通文件内容的解释由处理该文件的应用程序进行。</p><blockquote><p>值得注意的是二进制可执行文件。为了执行程序，内核必须理解其格式。所有二进制可执行文件都遵循一种标准化的格式，通过这种格式内核能够确定程序文本和数据的加载位置。</p></blockquote></li><li><p><code>目录文件( directory file )</code>包含了其他文件的名字以及指向与这些文件有关信息的指针。对一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件。进程必须通过系统函数才能更改目录。</p></li><li><p><code>块特殊文件( block special file )</code>提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行。</p><blockquote><p>FreeBSD 不再支持块特殊文件。对设置的所有访问需要通过字符特殊文件进行。</p></blockquote></li><li><p><code>字符特殊文件( character special file )</code>提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是志特殊文件。</p></li><li><p><code>FIFO</code>用于进程间通信，有时也称为<code>命名管道( named pipe )</code>。</p></li><li><p><code>套接字( socket )</code>用于进程间的网络通信。也可用于在一台宿主机上进程之间的非网络通信。</p></li><li><p><code>符号链接( symbolic link )</code>指向另一个文件。</p></li></ul><p>文件类型信息包含在 stat 结构的 st_mode 成员中，可以使用定义的宏确定文件类型，宏参数都是 stat 结构中的 st_mode 成员。</p><table><thead><tr><th>宏</th><th>文件类型</th></tr></thead><tbody><tr><td>S_ISREG()</td><td>普通文件</td></tr><tr><td>S_ISDIR()</td><td>目录文件</td></tr><tr><td>S_ISCHR()</td><td>字符特殊文件</td></tr><tr><td>S_ISBLK()</td><td>块特殊文件</td></tr><tr><td>S_ISFIFO()</td><td>管道或FIFO</td></tr><tr><td>S_ISLNK()</td><td>符号链接</td></tr><tr><td>S_ISSOCK()</td><td>套接字</td></tr></tbody></table><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"common/apue.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">buf</span>;</span>    <span class="hljs-keyword">int</span> r = stat(<span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_c.c"</span>, &amp;buf);    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">-1</span>) &#123;        <span class="hljs-keyword">if</span> (S_ISREG(buf.st_mode))            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"普通文件类型"</span>);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"程序出错，编号：%d"</span>, errno);    &#125;&#125;</code></pre><p>POSIX.1 允许实现将进程间通信(IPC)对象(如消息队列和信号量等)说明为文件。可以通过下列宏确定 IPC 对象的类型，它们的参数是指向 stat 结构的指针，而并非 st_mode。</p><table><thead><tr><th>宏</th><th>对象的类型</th></tr></thead><tbody><tr><td>S_TYPEISMQ()</td><td>消息队列</td></tr><tr><td>S_TYPEISSEM()</td><td>信号量</td></tr><tr><td>S_TYPEISSHM()</td><td>共享存储对象</td></tr></tbody></table><h3 id="函数access和faccessat"><a class="markdownIt-Anchor" href="#函数access和faccessat"></a> 函数<code>access</code>和<code>faccessat</code></h3><p>这两个是按实际用户ID和实际组ID进行访问权限测试的函数。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> mode)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">faccessat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> mode, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 两个函数的返回值：成功返回0; 失败返回-1</span></code></pre><p><code>mode</code>参数可选值：</p><ul><li><code>F_OK</code>测试文件存在</li><li><code>R_OK</code>测试读权限</li><li><code>W_OK</code>测试写权限</li><li><code>X_OK</code>测试执行权限</li></ul><p><strong>faccessat 函数与 access 函数在下面两种情况下是相同的：</strong></p><ol><li>pathname 参数为绝对路径</li><li>fd 参数取值为 AT_FDCWD 而 pathname 参数为相对路径，否则 faccessat 计算相对于打开目录(fd 参数指向)的 pathname。</li></ol><p><code>flag</code>参数，设置为 AT_EACCESS，访问检查调用进程的有效用户 ID 和有效组 ID，而不是实际用户 ID 和实际组 ID。</p><h3 id="文件权限"><a class="markdownIt-Anchor" href="#文件权限"></a> 文件权限</h3><p>所有文件类型都有访问权限，st_mode 值也包含了对文件的访问权限位。每个文件有9个访问权限位，可将它们分类3类：</p><ul><li><code>S_IRUSR</code> 用户读</li><li><code>S_IWUSR</code> 用户写</li><li><code>S_IXUSR</code> 用户执行</li></ul><hr><ul><li><code>S_IRGRP</code> 组读</li><li><code>S_IWGRP</code> 组写</li><li><code>S_IXGRP</code> 组执行</li></ul><hr><ul><li><code>S_IROTH</code> 其他读</li><li><code>S_IWOTH</code> 其他写</li><li><code>S_IXOTH</code> 其他执行</li></ul><h4 id="函数umask"><a class="markdownIt-Anchor" href="#函数umask"></a> 函数<code>umask</code></h4><p>函数为进程设置文件模式屏蔽字，并返回之前的值。即在创建新文件或目录时屏蔽掉希望新文件或目录不应有的访问权限。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt; // 返回值：设置前的文件创建权限</span></span><span class="hljs-keyword">mode_t</span> umask(<span class="hljs-keyword">mode_t</span> cmask);</code></pre><p><code>cmask</code>参数由 9 个访问权限位常量(S_IRUSR、S_IWUSR等)中的若干个按位“或”(<code>|</code>)构成。<br>在进程创建一个新文件或目录时，就一定会使用文件模式创建屏蔽字。</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// 0表示不设置任何屏蔽字，即使用默认屏蔽字</span>    umask(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> (creat(<span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/tttttttt.d"</span>, <span class="hljs-number">0777</span>) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"创建d文件失败"</span>);    &#125;    <span class="hljs-comment">// 设置用户读、用户写屏蔽字</span>    umask(S_IRUSR | S_IWUSR);    <span class="hljs-keyword">if</span> (creat(<span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/tttttttt.r"</span>, <span class="hljs-number">0777</span>) &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"创建r文件失败"</span>);    &#125;&#125;<span class="hljs-comment">// 在bash中查看文件权限</span>$ ll-rwxrwxrwx   <span class="hljs-number">1</span> windus  staff     <span class="hljs-number">0B</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span> <span class="hljs-number">13</span>:<span class="hljs-number">54</span> tttttttt.d---xrwxrwx   <span class="hljs-number">1</span> windus  staff     <span class="hljs-number">0B</span>  <span class="hljs-number">3</span>  <span class="hljs-number">3</span> <span class="hljs-number">13</span>:<span class="hljs-number">54</span> tttttttt.r</code></pre><p>UNIX 所有 shell 都有内置命令<code>umask</code>设置默认屏蔽字，<strong><a href="/2017/09/13/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/#%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90-umask">更多关于 umask 命令<sup>1</sup></a></strong>。</p><h4 id="函数chmod"><a class="markdownIt-Anchor" href="#函数chmod"></a> 函数<code>chmod</code></h4><p>这3个函数可以更改现有文件访问权限。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chmod</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchmod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchmodat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>chmod 函数在对定文件上进行操作。<br>fchmod 函数在对已打开文件进行操作。</p><p><strong>fchmodat 函数与 chmod 函数作用相同的两种情况：</strong></p><ol><li>pathname 参数为绝对路径。</li><li>fd 参数取值为 AT_FDCWD 而 pathname 参数为相对路径。</li></ol><p>否则，fchmodat 函数就是对于打开目录(fd 参数指向)的 pathname 进行操作。<br><code>flag</code>参数设置为 AT_SYMLINK_NOFOLLOW 时，fchmodat 并不会跟随符号链接。<br><code>mode</code>参数是除了文件的9个权限访问位常量外，还有下面6个常量的按位或组合：</p><ul><li><code>S_IRWXU</code> 用户(所有者)读、写和执行</li><li><code>S_IRWXG</code> 组读、写和执行</li><li><code>S_IRWXO</code> 其他读、写和执行</li><li><code>S_ISUID</code> 文件特殊权限 SUID 权限</li><li><code>S_ISGID</code> 文件特殊权限 SGID 权限</li><li><code>S_ISVTX</code> 文件特殊权限 SBIT 权限(粘着位)</li></ul><p><em><strong><a href="/2017/09/13/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/#%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90">更多关于文件特殊权限<sup>2</sup></a></strong></em></p><blockquote><p>为了改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或者该进程必须具有超级用户权限。</p></blockquote><h4 id="函数chown"><a class="markdownIt-Anchor" href="#函数chown"></a> 函数<code>chown</code></h4><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chown</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">uid_t</span> owner, <span class="hljs-keyword">gid_t</span> group)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">uid_t</span> owner, <span class="hljs-keyword">gid_t</span> group)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchownat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">uid_t</span> owner, <span class="hljs-keyword">gid_t</span> group, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lchown</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">uid_t</span> owner, <span class="hljs-keyword">gid_t</span> group)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>当操作的文件不是符号链接时，这4个函数作用类似。<br>当操作文件是符号链接时，lchown 和 fchownat(设置了 AT_SYMLINK_NOFOLLOW 标志)更改符号链接本身的所有者，而不是该符号链接所指向的文件所有者。<br>fchown 函数操作已打开(fd 参数指向)文件的所有者。既然它在一个已打开的文件上操作，就不能用于改变符号链接的所有者。</p><p><strong>fchownat、chown、lchown作用相同的两种情况：</strong></p><ol><li>pathname 参数为绝对路径。</li><li>fd 参数取值为 AT_FDCWD 而 pathname 参数为相对路径。</li></ol><p>如果 flag 参数清除了 AT_SYMLINK_NOFOLLOW 标志(即设置为 AT_SYMLINK_FOLLOW )，则 fchownat 与 chown 作用相同。<br>如果 fd 参数设置为打开目录的文件描述符，并且 pathname 参数是一个相对路径名，fchownat 函数将作用于打开的目录。</p><blockquote><p>基于 BSD 的系统规定只有超级用户才能更改一个文件的所有者，原因是防止用户改变其文件的所有者从而摆脱磁盘空间限额对他们的限制。System V 则允许任一用户更改他们所拥有的文件的所有者。<br>按照 POSIX.1 允许通过设置 _POSIX_CHOWN_RESTRICTED 的值在这两种形式的操作中选用一种。<br>对于 SOLARIS 10 HX 此功能是个配置选项，其默认值是施加限制。而 FreeBSD 8.0、Linux 3.2.0和Mac OS X 10.6.8则总对 chown 施加限制。</p></blockquote><p>若 _POSIX_CHOWN_RESTRICTED 对指定文件生效，则：</p><ol><li>只有超级用户进程能更改该文件的用户ID。</li><li>如果进程拥有此文件(其有效用户ID等于该文件的用户ID)，参数 ower 等于 -1 或文件的用户ID，并且参数 group 等于进程的有效组 ID 或进程的附属组 ID 之王，那么非超级用户进程可以一颗心该文件的组ID。</li></ol><blockquote><p>这意味着，当 _POSIX_CHOWN_RESTRICTED 有效时，不能更改其他用户文件的用户ID，可以一颗心你所拥有的文件的组 ID，但只能改到你所属的组。</p></blockquote><h3 id="文件长度与截断"><a class="markdownIt-Anchor" href="#文件长度与截断"></a> 文件长度与截断</h3><p>stat 结构成员 st_size 表示以字节为单位的文件长度，此字符只对普通文件、目录文件和符号链接有意义。</p><blockquote><p>FreeBSD、Mac OS X 10.6.8和 Solaris 10对管道也定义了文件长度，它表示可从该管道中读到的字节数。</p></blockquote><p>对于符号链接，文件长度是在文件名中的实际字节数，如下面例子，文件长度 10 就是路径名<code>private/tmp</code>的长度：</p><pre class="highlight"><code class="bash">$ ll /lrwxr-xr-x@  1 root  admin    11B 10 30 17:00 tmp -&gt; private/tmp</code></pre><p>大多数现代 UNIX 系统提供字段 st_blksize 和 st_blocks。其中，第一个是文件 I/O 块长度，第二个是所分配的实际块数。</p><p>为了截断文件可以调用函数<code>truncate</code>和<code>ftruncate</code>:</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">truncate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">off_t</span> length)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ftruncate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> length)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>这两个函数将一个现有文件长度截断为 lenth。如果该文件长度大于 length，则超过部分不能再访问;如果长度小于 length，文件长度将增加，其数据读作0(也就是可能在文件中创建了一个空洞)。</p><h3 id="函数link-unlink"><a class="markdownIt-Anchor" href="#函数link-unlink"></a> 函数<code>link</code>、<code>unlink</code></h3><p>创建一个指向现有文件的硬链接的方法是使用函数 link 或 linkat 函数：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *existingpath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newpath)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">linkat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> efd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *existingpath, <span class="hljs-keyword">int</span> nfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newpath, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>这两个函数创建一个新目录项 newpath，它引用现有文件 existingpath。如果 newpath 已经存在，则返回出错。函数只创建 newpath 中的最后一个分量，路径中的其他部分应当已经存在。</p><p>linkat 函数，现有文件是通过 efd 和existingpath 参数指定的，新的路径名是通过 nfd 和 newpath 参数指定。默认情况下，如果两个路径名中的任一个是相对路径，两个文件描述符中的任一个设置为 AT_FDCWD，相应的路径名就通过相对于当前目录进行计算。如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略。</p><p>当现有文件是符号链接时，flag 参数设置 AT_SYMLINK_FOLLOW 标志，则创建指向符号链接目标的链接;反之，则创建一个指向符号链接本身的链接。<br><strong><a href="/2017/09/29/Linux/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/#%E5%AE%9E%E6%97%B6%E8%BF%90%E8%A1%8C%E5%8C%BA-realtime-section">更多关于文件链接<sup>3</sup></a></strong></p><p>创建的链接可以通过 unlink 函数删除：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unlinkat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 返回值：成功返回0; 失败返回-1</span></code></pre><p>如果 pathname 参数是相对路径名，fd 文件描述符参数代表的目录的路径名。如果 fd 参数设置 AT_FDCWD，相当于调用当前工作目录路径。如果 pathname 参数是绝对路径名，fd 参数被忽略。</p><p>如果 pathname 是符号链接，那么 unlink 删除该符号链接，而不是删除由该链接所引用的文件。给出符号链接名的情况下，没有一个函数能删除由该链接所引用的文件。</p><p>如果文件系统支持，超级用户可以调用 unlink 删除一个指定目录，但通常应当使用 rmdir 函数。</p><p>flag 参数设置为 AT_REMOVEDIR 标志时，unlinkat 函数功能类似于 rmdir 命令一样删除目录;反之则与 unlink 函数功能相同。</p><p>也可以用 remove 函数解除对一个文件或目录的链接。对于文件，remove 的功能与 unlink 相同。对于目录，remove 的功能与 rmdir 相同。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p>删除文件链接，必须对包含该目录项的目录具有写和执行权限。如果对该目录设置了粘着位(SBIT)，则对该目录必须具有写权限，并且具备下面三个条件之一：</p><ul><li>拥有该文件</li><li>拥有该目录</li><li>具有超级用户权限</li></ul><blockquote><p>删除文件内容的两个条件：(1)当链接计数为0时，文件内容可以被删除　(2)没有进程打开了该文件，其内容才能被删除。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"common/apue.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> fd;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">buf</span>;</span>    <span class="hljs-keyword">char</span> *pathName = <span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c"</span>;    <span class="hljs-keyword">char</span> *newPathName = <span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test_link.c"</span>;    <span class="hljs-comment">// 第一步 测试未打开之前文件链接数</span>    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第二步 打开已存在的文件 测试链接数</span>    fd = open(pathName, O_RDONLY);    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第三步 关闭文件 测试链接数</span>    close(fd);    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第四步 创建硬链接 测试链接数</span>    link(pathName, newPathName);    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"4) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第五步 删除硬链接 测试链接数</span>    unlink(newPathName);    stat(pathName, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"5) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第六步 打开已存在的文件</span>    fd = open(pathName, O_RDONLY);    <span class="hljs-comment">// 第七步 删除文件 测试链接数 </span>    <span class="hljs-comment">// (此处我用 fstat 函数而非 stat，因为 unlilnk 已经删除文件名，所以不可以通过   文件名访问，</span>    <span class="hljs-comment">// 但是 fd 仍然是打开着的，文件内容还没有被真正删除，依旧可以使用 fd 获得文件信息。)</span>    unlink(pathName);    fstat(fd, &amp;buf);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"7) link=%d\t%s\n"</span>, buf.st_nlink, pathName);    <span class="hljs-comment">// 第八步 关闭文件 文件内容被删除</span>    close(fd);&#125;<span class="hljs-comment">// 返回结果</span>--------------------------------------------------------------------------<span class="hljs-number">1</span>) link=<span class="hljs-number">1</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">2</span>) link=<span class="hljs-number">1</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">3</span>) link=<span class="hljs-number">1</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">4</span>) link=<span class="hljs-number">2</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">5</span>) link=<span class="hljs-number">1</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c<span class="hljs-number">7</span>) link=<span class="hljs-number">0</span>/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.c</code></pre><blockquote><p>unlink 这种特性经常被程序用来确保即使是在程序崩溃时，它所创建的临时文件也不会遗留下来。进程用 open 或 creat 创建一个文件，然后立即调用 unlink，因为该文件仍旧是打开的，所以不会将其内容删除。只有当进程关闭该文件或终止时(内核关闭该进程所打开的全部文件)，该文件的内容才被删除。</p></blockquote><h3 id="函数rename和renameat"><a class="markdownIt-Anchor" href="#函数rename和renameat"></a> 函数<code>rename</code>和<code>renameat</code></h3><p>文件或目录可以用这两个函数进行重命名。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rename</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *oldname, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newname)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">renameat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> oldfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *oldname, <span class="hljs-keyword">int</span> newfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *newname)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><blockquote><p>ISO C 对文件定义了 rename 函数(C 标准不处理目录)。POSIX.1 扩展此定义，使其包含了目录和符号链接。</p></blockquote><h3 id="符号链接"><a class="markdownIt-Anchor" href="#符号链接"></a> 符号链接</h3><p>符号链接是对一个文件的间接指针，它与硬链接有所不同，硬链接直接指向文件的 i 节点。引入符号链接的原因是为了避开硬链接的一些限制：</p><ul><li>硬链接通常要求链接和文件位于同一文件系统中。</li><li>只有超级用户才能创建指向目录的硬链接(在底层文件系统支持的情况下)。</li></ul><p>当使用以名字引用文件的函数时，应当了解该函数是否处理符号链接，即该函数是否跟随符号链接到达它所链接的文件。下图中说明了各函数是否处理符号链接，图中没有列出 mkdir、mkinfo、mknod 和 rmdir 等函数，其原因是当路径名是符号链接时，它们都出错返回。以文件描述符作为参数的一些函数(如 fstat、fchmod等)也未列出，其原因是，对符号链接的处理是由返回文件描述符的函数(通常是 open )进行的。chown 是否跟随符号链接取决于实现，在所有现代的系统中，chown 函数都跟随符号链接。</p><blockquote><p>符号链接由 4.2BSD 引入，chown 最初并不跟随符号链接，现在，所有平台都实现了 lchown，它可以改变符号链接自身的所有权。</p></blockquote><img src="/2020/02/27/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/hsdfhljdcl1800.png" alt="各函数对符号链接的处理" style="height:400px;"><span class="image-caption">各函数对符号链接的处理</span><p>同时用 O_CREAT 和 O_EXCL 两者调用 open 函数时，若路径名引用符号链接，open 将出错返回，errno 设置为 EEXIST。这种处理方式的意图是堵塞一个安全性漏洞，以防止具有特权的进程被诱骗写错误的文件。</p><p>使用符号链接可能在文件系统中引入循环。大多数查找路径名的函数在这种情况发生时都出错返回，errno 值为 ELOOP。</p><pre class="highlight"><code class="bash"><span class="hljs-comment"># 创建一个新目录</span>$ mkdir<span class="hljs-comment"># 创建一个0长度的文件</span>$ touch foo/a<span class="hljs-comment"># 创建一个符号链接</span>$ ls -s ../foo foo/testdir<span class="hljs-comment"># 查看目录结构</span>$ ls -l foo-rw-r----- 1 sar 0 Jan 22 00:16 alrwxrwxrwx 1 sar 6 Jan 22 00:16 testdir -&gt; ../foo// 使用 Solaris 的标准函数 ftw(3) 以降序遍历文件结构，打印每个路径名，则输出是：foofoo/afoo/testdirfoo/testdir/afoo/testdir/testdirfoo/testdir/testdir/afoo/testdir/testdir/testdirfoo/testdir/testdir/testdir/a(更多行，直到函数出错返回，此时 errno 值为 ELOOP)</code></pre><blockquote><p>注意，Linux的 ftw 和 nftw 函数记录了所有看到的目录并避免多次得利处理一个目录，因此这两个函数不显示这种程序运行行为。</p></blockquote><p>想要消除这种循环，可以用 lstat 代替 stat 以阻止它跟随符号链接; 也可以用 unlink 文件 foo/testdir，因为 unlink 也不跟随符号链接。<br>但是如果创建了一个构成这种循环的硬链接，那么就很难消除它。<strong>这就是为什么 link 函数不允许构造指向目录的硬链接的原因</strong>。</p><h4 id="创建符号链接"><a class="markdownIt-Anchor" href="#创建符号链接"></a> 创建符号链接</h4><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">symlink</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *actualpath, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sympath)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">symlinkat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *actualpath, <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sympath)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p>函数创建一个指向 actualpath 的新目录项 sympath。在创建之前，并不要求 actualpath 已经存在。并且，actualpath 和 sympath 并不需要位于同一文件系统中。</p><p>symlinkat 函数与 symlink 函数功能类似，但 sympath 参数根据打开的文件描述符引用的目录(fd 参数)指定的，如果 sympath 参数指定的是绝对路径或者 fd 参数设置了 AT_FDCWD 值，那么 symlinkat 就等同于 symlink 函数。</p><h4 id="读取符号链接"><a class="markdownIt-Anchor" href="#读取符号链接"></a> 读取符号链接</h4><p>因为 open 函数跟随符号链接，所以需要有一种方法打开该链接本身，并读该链接中的名字的函数：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-keyword">ssize_t</span> readlink(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">restrict</span> pathname, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-keyword">size_t</span> bufsize);<span class="hljs-keyword">ssize_t</span> readlinkat(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* <span class="hljs-keyword">restrict</span> pathname, <span class="hljs-keyword">char</span> *<span class="hljs-keyword">restrict</span> buf, <span class="hljs-keyword">size_t</span> bufsize);<span class="hljs-comment">// 返回值：若成功，返回读取的字节数;若出错返回-1</span></code></pre><h3 id="文件的时间"><a class="markdownIt-Anchor" href="#文件的时间"></a> 文件的时间</h3><p>SUS 2008年版为了提高 stat 结构中时间字段的精度，从原来的秒提高到秒加上纳秒。每个文件属性所保存的实际精度依赖于文件系统的实现。对于时间戳记录在秒级的文件系统来说，纳秒这个字段就会被填充为0。对于时间戳的记录精度高于秒级的文件系统来说，不足秒的值被转换成纳秒并记录在纳秒这个字段中。</p><p>每个文件维护3个时间字段：</p><table><thead><tr><th>字段</th><th>说明</th><th>例子</th><th>ls(1)选项</th></tr></thead><tbody><tr><td>st_atim</td><td>文件数据的最后访问时间</td><td>read</td><td>-u</td></tr><tr><td>st_mtim</td><td>文件数据的最后修改时间</td><td>write</td><td>默认</td></tr><tr><td>st_ctim</td><td>i 节点状态的最后更改时间</td><td>chmod、chown</td><td>-c</td></tr></tbody></table><blockquote><p>状态更改时间是该文件的 i 节点最后一次被修改的时间。包括一颗心文件的访问权限、更改用户ID、更改链接数等操作。因为 i 节点中的所有信息都是与文件的实际内容分开存放的，所以需要单独记录更改 i 节点中信息的时间。系统并不维护对一个 i 节点的最后一次访问时间，所以 access 和 stat 函数并不更改这3个时间中的任何一个。</p></blockquote><p><strong><a href="/2017/09/13/Linux/%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/#%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4">更多关于文件时间<sup>4</sup></a></strong></p><h3 id="函数futimens-utimensat和utimes"><a class="markdownIt-Anchor" href="#函数futimens-utimensat和utimes"></a> 函数<code>futimens</code>、<code>utimensat</code>和<code>utimes</code></h3><p>修改文件的访问和修改时间可以使用这几个函数。其中 futimens 和 utimensat 函数可以指定纳秒级精度的时间戳。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">futimens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> struct timespec times[<span class="hljs-number">2</span>])</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">utimensat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> struct timespec times[<span class="hljs-number">2</span>], <span class="hljs-keyword">int</span> flag)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p>这两个函数<code>times</code>数组参数的第一个元素包含访问时间，第二元素包含修改时间。这两个时间是日历时间，自特定时间(1970年1月1日 00:00:00)以来所经过的秒数。不足秒的部分用纳秒表示。<br><strong>时间戳可以按下列4种方式之王进行指定：</strong></p><ol><li>如果 times 参数是一个空指针，则访问时间和修改时间两者都设置为当前时间。</li><li>如果 times 参数指向两个 timespec 结构的数组，任数组元素的 tv_nsec 字段的值为 UTIME_NOW，相应的时间戳就设置为当前时间，忽略相应的 tv_sec 字段。</li><li>如果 times 参数指向两个 timespec 结构的数组，任一数组元素的 tv_nsec 字段值为 UTIME_OMIT，相应的时间戳保持不变，忽略相应的 tv_sec 字段。</li><li>如果 times 参数指向两个 timespec 结构的数组，且 tv_nsec 字段的值为既不是 UTIME_NOW 也不是 UTIME_OMIT，相应的时间戳设置为相应的 tv_sec 和 tv_nsec 字段的值。</li></ol><p><strong>执行这些函数所要求的优先权取决于 times 参数的值：</strong></p><ul><li>如果 times 是一个空指针，或者任一 tv_nsec 字段设为 UTIME_NOW，则进程的有效用户ID必须等于该文件的所有者ID;进程对该文件必须具有写权限，或者进程是一个超级用户进程。</li><li>如果 times 是非空指针，并且任一 tv_nsec 字段值既不是 UTIME_NOW 也不是 UTIME_OMIT，则进程的有效用户ID必须等于该文件的所有者ID，或者进程必须是一个超级用户进程。对文件只具有写权限是不够的。</li><li>如果 times 是非空指针，并且两个 tv_nsec 字段的值都为 UTIME_OMIT，就不执行任何的权限检查。</li></ul><p><code>flag</code>参数设置 AT_SYMLINK_NOFOLLOW 标志，则符号链接本身的时间会被修改(如果路径名指向的是符号链接)。默认行为是跟随符号链接，并把文件的时间改成符号链接的时间。</p><p>上面两个函数都包含在 POSIX.1 中，第3个函数包含在 SUS 的 XSI 扩展选项中：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/time.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">utimes</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">const</span> struct timeval times[<span class="hljs-number">2</span>])</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p><code>times</code>参数包含两个时间戳(访问时间和修改时间)，元素的数组的指针，两个时间戳是用秒和微秒表示的。</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> &#123;</span><span class="hljs-keyword">time_t</span> tv_sec; <span class="hljs-comment">/* secons */</span><span class="hljs-keyword">long</span> tv_usec; <span class="hljs-comment">/* microseconds */</span>&#125;</code></pre><h3 id="函数mkdir-mkdirat和rmdir"><a class="markdownIt-Anchor" href="#函数mkdir-mkdirat和rmdir"></a> 函数<code>mkdir</code>、<code>mkdirat</code>和<code>rmdir</code></h3><p>用 mkdir 和 mkdirat 函数创建一个新的空目录。其中，<code>.</code>和<code>..</code>目录项是自动创建的。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mkdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">mkdirat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;出错返回-1</span></code></pre><blockquote><p>早期 UNIX 版本并没有 mkdir 函数，进程调用 mknod 函数创建一个新目录，但是只有超级用户进程才能使用 mknod 函数。</p></blockquote><p>用 rmdir 函数可以删除一个空目录(空目录只包含<code>.</code>和<code>..</code>目录)。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rmdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><h3 id="读文件"><a class="markdownIt-Anchor" href="#读文件"></a> 读文件</h3><p>早期系统每个目录项是16个字节，其中14个字节是文件名，2个字节是 i 节点编号。而对于4.2BSD，由于它允许更长的文件名，所以每个目录项的长度是可变的。因此，读目录的程序与系统相关，为了简化读目录 UNIX 包含了一套与目录有关的例程，它们是 POSIX.1 的一部分。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;dirent.h&gt;</span></span><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-function">DIR *<span class="hljs-title">fdopendir</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-comment">// 返回值：成功返回指针;失败返回 NULL</span><span class="hljs-function">struct dirent *<span class="hljs-title">readdir</span><span class="hljs-params">(DIR *dp)</span></span>;<span class="hljs-comment">// 返回值：成功返回指针;若在目录尾或出错返回 NULL</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rewinddir</span><span class="hljs-params">(DIR *dp)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dp)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">telldir</span><span class="hljs-params">(DIR *dp)</span></span>;<span class="hljs-comment">// 返回值：与 dp 关联的目录中的当前位置</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">seekdir</span><span class="hljs-params">(DIR *dp, <span class="hljs-keyword">long</span> loc)</span></span>;</code></pre><p>DIR 结构是一个内部结构，上述7个函数用这个内部结构保存当前正在被读的目录的有关信息。</p><p>由 opendir 和 fdopendir 返回的指向 DIR 结构的指针由另外5个函数使用。opendir 执行初始化操作，使第一个 readdir 返回目录中的第一个目录项。当 DIR 结构由 fdopendir 创建时，readdir 返回的第一项取决于传给 fdopendir 函数的文件描述符相关联的文件偏移量。</p><p>目录中各目录的顺序与实现有关，它们通常并不按字母顺序排序。</p><h3 id="函数chdir-fchdir和getcwd"><a class="markdownIt-Anchor" href="#函数chdir-fchdir和getcwd"></a> 函数<code>chdir</code>、<code>fchdir</code>和<code>getcwd</code></h3><p>每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点。当用户登录到 UNIX 系统时，其当前工作目录通常是口令文件( /etc/passwd )中该用户登录项的第6个字段——用户的起始目录(home directory)。当前工作目录是进程的一个属性，起始目录则是登录名的一个属性。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *pathname)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fchdir</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span></code></pre><p>进程调用这两个函数可以更改当前工作目录。因为当前目录是进程的一个属性，所以它只影响调用 chdir 的进程本身，而不影响其他进程。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"apue.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;    <span class="hljs-keyword">if</span> (chdir(<span class="hljs-string">"/tmp"</span>) &lt; <span class="hljs-number">0</span>)        err_sys(<span class="hljs-string">"chdir failed"</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"chdir to /tmp succeeded\n"</span>);    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-comment">// 调用程序测试</span>$ pwd /usr/lib$ mycd chdir to /tmp succeeded $ pwd /usr/lib</code></pre><p>从上示例代码中执行程序后，shell 的当前工作目录并没有改变。因为每个程序运行在独立的进程中，shell 的当前工作目录并不会随着程序调用 chdir 而改变。</p><p>系统内核并不保存该目录的完整路径名，只为每个进程只保存指向该目录 v 节点的指针等目录本身的信息。可以通过 getcwd 函数获取：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">char</span> *<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *buf, <span class="hljs-keyword">size_t</span> size)</span></span>;<span class="hljs-comment">// 返回值：成功返回 buf;失败返回 NULL</span></code></pre><p>该函数必须传递两个参数，一个是缓冲区地址 buf，该缓冲区必须有足够长度以容纳绝对路径名再加上一个终止 null 字节，否则返回出错;另一个是缓冲区长度 size(以字节为单位)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数stat&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#函数stat&quot;&gt;&lt;/a&gt; 函数&lt;code&gt;stat&lt;/code&gt;&lt;/h3&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;c&quot;&gt;&lt;span class
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习笔记" scheme="http://fcwalkers.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="http://fcwalkers.com/tags/Linux/"/>
    
      <category term="Unix 编程学习笔记" scheme="http://fcwalkers.com/tags/Unix-%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Unix编程学习笔记－文件IO</title>
    <link href="http://fcwalkers.com/2020/02/24/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6IO/"/>
    <id>http://fcwalkers.com/2020/02/24/Linux/Unix编程学习笔记－文件IO/</id>
    <published>2020-02-23T16:00:00.000Z</published>
    <updated>2020-03-04T09:53:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件io"><a class="markdownIt-Anchor" href="#文件io"></a> 文件IO</h3><p><code>不带缓冲的IO</code>，其中<code>不带缓冲</code>指的是每一个<code>read</code>、<code>write</code>都调用内核中的一个系统调用。不带缓冲的IO不是<code>ISO C</code>的组成部分，但是，它们是<code>POXSIX.1</code>和 <code>SUS</code>的组成部分。</p><h3 id="文件描述符"><a class="markdownIt-Anchor" href="#文件描述符"></a> 文件描述符</h3><p>文件描述符是一个非负整数，当打开一个现有文件或创建一个新文件时，内核向该进程返回一个文件描述符。当读写一个文件时，使用open或creat返回的文件描述符标识该文件，将其作为参数传送给read或write。所有打开的文件都通过文件描述符引用。</p><p>通常，UNIX 系统 shell 把文件描述符 0 与进程的标准输入关联，文件描述符 1 与标准输出关联，文件描述符 2 与标准错误关联。可以把它们替换成符号常量<code>STDIN_FILENO</code>、<code>STDOUT_FILENO</code>、<code>STDERR_FILENO</code>以提高可读性。这些常量定义在头文件<code>&lt;unistd.h&gt;</code>中。</p><h3 id="函数open和openat"><a class="markdownIt-Anchor" href="#函数open和openat"></a> 函数<code>open</code>和<code>openat</code></h3><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflag, ... <span class="hljs-comment">/* mode_t mode */</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">openat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflag, ... <span class="hljs-comment">/* mode_t mode */</span>)</span></span>;</code></pre><p><code>path</code>参数是要打开或创建文件的路径和文件名<br><code>oflag</code>参数用来说明此函数的多个选项(必须指定下列常量中一个且只能一个)</p><ul><li><code>O_RDONLY</code> 只读打开</li><li><code>O_WRONLY</code> 只写打开</li><li><code>O_RDWR</code> 读写打开</li><li><code>O_EXEC</code> 只执行打开</li><li><code>O_SEARCH</code> 只搜索打开(应用于目录)<br>用于在目录打开时验证它的搜索权限。对目录的文件描述符的后续操作就不需要再次检查对该目录的搜索权限。此常量支持系统较少。<br><strong>其他可选常量</strong></li><li><code>O_APPEND</code> 每次写时都追加到文件的尾端。</li><li><code>O_CLOEXEC</code> 把 FD_CLOEXEC 常量设置为文件描述符标志。</li><li><code>O_CREAT</code> 若此文件不存在则创建它。使用此选项时，oppen 和 openat 函数需同时说明最后一个参数 mode，用mode指定该新文件的访问权限。</li><li><code>O_DIRECTORY</code> 如果 path 引用的不是目录，则出错。</li><li><code>O_EXCL</code> 如果同时指定了 O_CREAT，而文件已经存，则出错。用此可以测试一个文件是否存在，如果不存在，则创建此文件，这使测试和创建成为一个原子操作。</li><li><code>O_NOCTTY</code> 如 path 引用的是终端设备，则不将该设备分配为此进程的控制终端。</li><li><code>O_NOFOLLOW</code> 如果 path 引用的是一个符号链接，则出错。</li><li><code>O_NONBLOCK</code> 如果 path 引用的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的 I/O 操作设置非阻塞方式。</li><li><code>O_SYNC</code> 使每次 write 等待物理 I/O 操作完成，包括由该 write 操作引起的文件属性更新所需的 I/O_TRUNC，于是也就不再需要单独的creat函数。</li><li><code>O_TRUNC</code> 如果此文件存在，而且为只写或读-写成功打开，则将其长度截断0。</li><li><code>O_TTY_INIT</code> 如果打开一个还未打开的终端设备，设置非标准 termios 参数值，使其符合 Single UNIX Specification。</li><li><code>O_DSYNC</code> 使每次 write 要等待物理 I/O 操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需要等待文件属性被更新。</li><li><code>O_RSYNC</code> 使第一个以文件描述符作为参数进行的 read 操作等待，直至所有对文件同一部分挂起的写操作完成。</li></ul><p><code>fd</code>参数把两个函数区分开，共有3种可能性：<br>(1) path 参数指定的是绝对路径名，在这种情况下，fd参数被忽略，openat 函数就相当于open 函数。<br>(2) path 参数指定的是相对路径名，fd参数指出了相对路径在文件系统中的开始地址。fd参数是通过打开相对路径名所在的目录来获取。<br>(3) path 参数指定了相对路径名，fd参数具有特殊值<code>AT_FDCWD</code>。在这种情况下路径名在当前工作目录中获取，openat 函数在操作上与open 函数类似。</p><hr><p>openat 函数是POSIX.1最新版本中新增的一类函数之一，希望解决两个问题：<br>(1) 让纯种可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。<br>(2) 可以避免<code>time-of-check-to-time-of-use(TOCTTOU)</code>错误。</p><hr><blockquote><p><code>TOCTTOU</code>错误是：如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间文件可能改变了，这样也就造成了第一个调用的结果就不再有效，使得程序最终的结果是错误的。</p></blockquote><ul><li><p><strong>文件名和路径截断</strong></p><p>如果<code>NAME_MAX</code>是14，而试图创建一个文件名包含15个字符的新文件，早期的<code>System V</code>版本允许这种使用方法，但问题将文件名截断为14个字符，而且不给出任何信息，而<code>BSD</code>类的系统则返回出错状态，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。无声无息的截断文件名会引起无法确定该文件的原始名以及无法判断该文件名是否被截断过等问题。</p><p>在<code>POSIX.1</code>中，常量<code>_POSIX_NO_TRUNC</code>决定是要截断过长的文件名或路径名，还是返回一个出错。不同文件系统的类型，此值可以变化。可以用<code>fpathconf</code>或<code>pathconf</code>来查询目录具体支持何种行为。</p><p>若<code>_POSIX_NO_TRUNC</code>有效，则在整个路径名超过<code>PATH_MAX</code>或路径名中的任一文件名超过<code>NAME_MAX</code>时，出错返回，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。</p><blockquote><p>大多数的现代文件系统支持文件名的最大长度可以为255.因为文件名通常比这个限制要短，因此对大多数应用程序来说这个限制还未出现什么问题。</p></blockquote></li></ul><h3 id="函数creat"><a class="markdownIt-Anchor" href="#函数creat"></a> 函数<code>creat</code></h3><p>创建新文件可以调用<code>creat</code>函数：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-comment">// 返回值：若成功，返回为只写打开的文件描述符;若出错，返回-1</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">mode_t</span> mode)</span></span>; </code></pre><p>此函数等效于：</p><pre class="highlight"><code class="c">open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</code></pre><blockquote><p>在早期的 UNIX 系统版本中，open 的第二个参数只能是0、1或2。无法打开一个尚未存在的文件，因此需要另一个系统调用creat以创建新文件.现在，open 函数提供了选项 O_CREAT 和 O_TRUNC，于是也就不再需要单独的creat函数。<br>creat 的一个不足之处是它以只写方式打开所创建的文件，在提供 open 的新版本之前，如果要创建一个临时文件，并要先写该文件，然后又读该文件，则必须先调用creat、close, 然后再调用open。现在则可如下直接调用open实现。</p></blockquote><pre class="highlight"><code class="c">open(path, O_RDWR | O_CREAT | O_TRUNC, mode);</code></pre><h3 id="函数close"><a class="markdownIt-Anchor" href="#函数close"></a> 函数<code>close</code></h3><p>close函数可以关闭一个打开的文件：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：成功返回0;失败返回-1</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;</code></pre><p>关闭一个文件时还会释放该进程加在该文件上的所有记录锁。当一个进程终止时，内核自动关闭它所有的打开文件，而不用显式地用 close 关闭打开文件。</p><h3 id="函数lseek"><a class="markdownIt-Anchor" href="#函数lseek"></a> 函数<code>lseek</code></h3><p>每个打开文件都有一个与其相关联的<code>当前文件偏移量</code>，通常是一个非负整数。系统默认情况，当打开一个文件时，除非指定<code>O_APPEND</code>选项，否则该偏移量被设置为<code>0</code>。<br>调用lseek函数可以显式地设置打开文件的偏移量：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：成功返回新的文件偏移量;失败返回-1</span><span class="hljs-keyword">off_t</span> lseek(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset, <span class="hljs-keyword">int</span> whence);</code></pre><p><code>offset</code> 参数的解释与参数<code>whence</code>的值有关：</p><ul><li>若 whence 是<code>SEEK_SET</code>，则将该文件的偏移量设置为距文件开始处 offset 个字节。</li><li>若 whence 是<code>SEEK_CUR</code>，则将该文件的偏移量设置为其当前值加 offset，offset 可为正或负。</li><li>若 whence 是<code>SEEK_END</code>，则将该文件的偏移量设置为文件长度加 offset，offset 可正可负。</li></ul><blockquote><p>对于普通文件，其偏移量必须是非负值，但某些设备允许负的偏移量。如果文件描述符指向的是一个管道、FIFO或网络套接字，则 lseek 返回-1，并将 errno 设置为 ESPIPE。</p></blockquote><p>因为偏移量可能是负值，所以在比较 lseek 的返回值时，不要比较它是否小于0，而要比较它是否等于-1。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"common/apue.h"</span></span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[]) &#123;    <span class="hljs-keyword">if</span> (lseek(STDIN_FILENO, <span class="hljs-number">0</span>, SEEK_CUR) == <span class="hljs-number">-1</span>) <span class="hljs-comment">// 与-1比较</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"cannot seek\n"</span>);    <span class="hljs-keyword">else</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"seek OK\n"</span>);    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre><pre class="highlight"><code class="bash">$ ./test.o &lt; /etc/passwd // 普通文件seek OK$ cat &lt; /etc/passwd | ./test.o // 管道返回-1cannot seek$ ./test.o &lt; /var/spool/cron/FIFO // FIFO返回-1cannot seek</code></pre><p>lseek 仅将当前的文件偏移量记录在内核中，它并不引起任何 I/O 操作，该偏移量用于下一个读或写操作。<br>文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，文件中没有被写过的字节都被读为0。文件中的空洞并不占用磁盘存储区。</p><h3 id="函数read"><a class="markdownIt-Anchor" href="#函数read"></a> 函数<code>read</code></h3><p>调用 read 函数可以从打开文件中读取数据。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：读到的字节数，若已到文件尾，返回0;若出错返回-1</span><span class="hljs-keyword">ssize_t</span> read(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbytes);</code></pre><h3 id="函数write"><a class="markdownIt-Anchor" href="#函数write"></a> 函数<code>write</code></h3><p>调用 write 函数向打开文件写数据。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：若成功，返回已写的字节数;若出错，返回-1</span><span class="hljs-keyword">ssize_t</span> write(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbytes);</code></pre><h3 id="原子操作"><a class="markdownIt-Anchor" href="#原子操作"></a> 原子操作</h3><p><code>场景:</code>假定有两个独立的进程A和B都对同一文件进行追加写操作。每个进程都已打开该文件，但未使用<code>O_APPEND</code>标志。此时，每个进程都有它自己的文件表项，但是共享一个 v 节点表项如下图：</p><img src="/2020/02/24/Linux/Unix%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%8D%E6%96%87%E4%BB%B6IO/fileio38.png" style="height:400px"><p>当进程 A 调用了 lseek 函数将该文件当前进程领衔量设置为 1500 字节(当前文件尾端处)。然后内核切换到进程 B 执行 lseek 函数，也将其对该文件的当前偏移量设置为 1500 字节(当前文件尾端处)。然后 B 调用 write 函数，将 B 的该文件当前文件偏移量增加至 1600。因为该文件的长度已经增加了，所以内核将 v 节点中的的当前文件长度更新为 1600。然后，内核切换到里程 A 调用 write 函数，就从其当前文件偏移量(1500)处开始将数据写入到文件。此时覆盖了进程 B 写入到该文件中的数据。</p><hr><p>上面场景中问题出在逻辑操作“先定位到文件尾端，然后写”，它使用了两个分开的函数调用。可以通过使用两个操作对其他进程而言成为一个原子操作的方法解决问题。<br>UNIX 系统为这样的操作提供了一种原子操作方法，即在打开文件时设置<code>O_APPEND</code>标志。这样使得内核在每次写操作之前，都将进程的当前偏移量设置到该文件的尾端处，于是在每次写之前就不再需要调用 lseek 函数。</p><h4 id="函数pread和pwrite"><a class="markdownIt-Anchor" href="#函数pread和pwrite"></a> 函数<code>pread</code>和<code>pwrite</code></h4><p>这两个函数是<code>SUS</code>扩展允许原子性定位并执行 I/O 的扩展函数。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-comment">// 返回值：读到的字节数，若已到文件尾，返回0;若出错，返回-1</span><span class="hljs-keyword">ssize_t</span> pread(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbytes, <span class="hljs-keyword">off_t</span> offset);<span class="hljs-comment">// 返回值：若成功，返回已写的字节数;若出错，返回-1</span><span class="hljs-keyword">ssize_t</span>　pwrite(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *buf, <span class="hljs-keyword">size_t</span> nbytes,<span class="hljs-keyword">off_t</span> offset);</code></pre><p>调用 pread 相当于调用 lseek 后调用 read，但是 pread 又与这种顺序调用有下列重要区别：</p><ul><li>调用 pread 时，无法中断其定位和读操作。</li><li>不更新当前文件偏移量</li></ul><p>调用 pwrite 也是类似的区别。</p><h3 id="函数dup和dup2"><a class="markdownIt-Anchor" href="#函数dup和dup2"></a> 函数<code>dup</code>和<code>dup2</code></h3><p>两个函数都可用来复制一个现有的文件描述符。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> fd2)</span></span>;<span class="hljs-comment">// 两函数的返回值：若成功，返回新的文件描述符;若出错，返回-1</span></code></pre><p>dup 函数返回的新文件描述符一定是当前可用文件描述符中的最小数值。<br>dup2 函数参数 fd 表示已经存在的打开的文件描述符，fd2 表示指定新的文件描述符，如果 fd2 等于 fd，直接返回;如果 fd2 存在并且打开，则先关闭(close)后重新打开;如果 fd2 不存在或者没有打开则打开 fd2，并且指向 fd 所指向的文件。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"common/apue.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;errno.h&gt;</span></span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[]) &#123;    <span class="hljs-keyword">int</span> fd, refd;    <span class="hljs-keyword">char</span> *buf = <span class="hljs-string">"dup2 stdout!\n"</span>;    fd = open(<span class="hljs-string">"/Users/windus/iwork/code/c_c++/algorithms_in_c/unix_test.txt"</span>, O_RDWR | O_CREAT, <span class="hljs-number">0644</span>);    <span class="hljs-keyword">if</span> (fd != <span class="hljs-number">-1</span>) &#123;<span class="hljs-comment">// 重定向标准输出到目标文件</span>        refd = dup2(fd, fileno(<span class="hljs-built_in">stdout</span>));        <span class="hljs-keyword">if</span> (refd != <span class="hljs-number">-1</span>) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"refd值：%d"</span>, refd);            write(refd, buf, <span class="hljs-built_in">strlen</span>(buf));            close(fd);        &#125;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"errno=%d\n"</span>, errno);    &#125;    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre><p>查看 unix_test.txt 文件内容如下：</p><pre class="highlight"><code class="bash">$ cat unix_test.txtdup2 stdoutrefd值：1    <span class="hljs-comment"># 从printf打印的信息也被写入进来</span></code></pre><p>从结果可以看出，由于标准输出文件描述符被复制为目标文件描述符，把标准输出重定向到目标文件。所以，原本应该到标准输出(stdout)的信息，也写入到了文件中。</p><h3 id="函数sync-fsync和fdatasync"><a class="markdownIt-Anchor" href="#函数sync-fsync和fdatasync"></a> 函数<code>sync</code>、<code>fsync</code>和<code>fdatasync</code></h3><p>传统的 UNIX 系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘 I/O 都通过缓冲区进行。当向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式被称为<strong>延迟写(delayed write)</strong>。当内核需要征用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。<br>为保证磁盘上实际文件系统与缓冲区中内容的一致性，UNIX 系统提供了<code>sync</code>、<code>fsync</code>和<code>fdatasync</code>三个函数。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fsync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fdatasync</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd)</span></span>;<span class="hljs-comment">// 返回值：成功返回0;出错返回-1</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sync</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><p>sync 只是将所有修改过的块缓冲区排入写队列，然后就返回，并不等待实际写磁盘操作结束。通常，称为 update 的系统守护进程周期性地调用(一般每隔30秒) sync 函数。这就保证了定期冲洗(flush)内核的块缓冲区。命令 sync<sup>(1)</sup>也调用 sync 函数。</p><p>fsync 函数只对由文件描述符 fd 指定的一个文件起作用，并且等待写磁盘操作结束才返回。fsync 可用于数据库这样需要确保修改过的块立即写到磁盘的应用程序。</p><p>fdatasync 函数类似于 fsync，但它只影响文件的数据部分。而 fsync 除数据外，还会同步更新文件的属性。</p><h3 id="函数fcntl"><a class="markdownIt-Anchor" href="#函数fcntl"></a> 函数<code>fcntl</code></h3><p>此函数可以修改已经打开文件的属性。</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><span class="hljs-comment">// 返回值：成功，则依赖于cmd;出错返回-1</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">int</span> cmd, ... <span class="hljs-comment">/* int arg */</span>)</span></span>;</code></pre><p><code>cmd</code>参数选项：<br>(1) <strong>复制一个已有的描述符</strong></p><ul><li><code>F_DUPFD</code> 复制文件描述符 fd。新文件打桩符作为函数值返回。它是尚未打开的各描述符中大于或等于第3个参数值(取为整型值)中各值的最小值。新描述第二符与 fd 共享同一文件表项。但是，有它自己的在套文件描述符标志，其 FD_CLOEXEC 文件描述符标志被清除(表示该描述符在 exec 时仍保持有效)。</li><li><code>F_DUPFD_CLOEXEC</code> 复制文件描述符，设置与新描述符关联的 FD_CLOEXEC 文件描述符标志的值，返回新文件描述符。</li></ul><p>(2) <strong>获取 / 设置文件描述符标志</strong></p><ul><li><p><code>F_GETFD</code> 对应于 fd 的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志 FD_CLOEXEC。</p></li><li><p><code>F_SETFD</code> 对 fd 设置文件描述符标志。新标志值按第3个参数(取为整型值)设置。</p><blockquote><p>很多现有与文件描述符标志有关的程序并不使用常量 FD_CLOEXEC，而是将此标志设置为0(系统默认，在 exec 时不关闭)或1(在 exec 时关闭)。</p></blockquote></li></ul><p>(3) <strong>获取 / 设置文件状态标志</strong></p><ul><li><code>F_GETFL</code> 对应于 fd 的文件状态标志作为函数值返回。即 open / openat 函数 oflag 参数中的常量所对应的状态。</li><li><code>F_SETFL</code> 将文件状态标志设置为第3个参数的值(取为整型值)。可以更改的标志有：<code>O_APPEND</code>、<code>O_NONBLOCK</code>、<code>O_SYNC</code>、<code>O_DSYNC</code>、<code>O_RSYNC</code>、<code>O_FSYNC</code>和<code>O_ASYNC</code>。</li></ul><p>(4) <strong>获取 / 设置异步I/O所有权</strong></p><ul><li><code>F_GETOWN</code> 获取当前接收 SIGIO 和 SIGURG 信号的进程 ID 或进程组 ID。</li><li><code>F_SETOWN</code> 设置接收 SIGIO 和 SIGURG 信号的进程 ID 或进程组 ID。正的 arg 指定一个进程 ID，负的 arg 表示等于 arg 绝对值的一个进程组 ID。</li></ul><p>(5) <strong>获取 / 设置记录锁</strong></p><ul><li><code>F_GETLK</code></li><li><code>F_SETLK</code></li><li><code>F_SETLKW</code></li></ul><h3 id="函数ioctl"><a class="markdownIt-Anchor" href="#函数ioctl"></a> 函数<code>ioctl</code></h3><h3 id="devfd"><a class="markdownIt-Anchor" href="#devfd"></a> <code>/dev/fd</code></h3><p>较新的系统都提供名为 /dev/fd 的目录，其目录项是名为0、1、2的文件。打开文件 /dev/fd/n 等效于复制描述符 n(假定描述符 n 是打开的)。</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 大多数系统忽略它所指定的mode，另外一些系统则要求 mode 必须是所引用的文件初始打开时所使用的打开模式的一个子集</span>fd = open(<span class="hljs-string">"/dev/fd/0"</span>, mode);<span class="hljs-comment">// 等效于</span>fd = dup(<span class="hljs-number">0</span>);</code></pre><p>由上可知描述符 0 和 fd 共享同一文件表项。若描述符 0 先前被打开为只读，那么也只能对 fd 进行读操作，即使设置其他模式，仍然无法改变。</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 0 描述符为只读，所以对于 O_RDWR 模式的 fd 也不能进行写操作</span>fd = open(<span class="hljs-string">"/dev/fd/0"</span>, O_RDWR);</code></pre><blockquote><p>Linux实现中的 /dev/fd 是个例外。它把文件描述符映射成指向底层物理文件的符号链接。如打开 /dev/fd/0 时，事实上正在打开与标准输入关联的文件，因此返回的新文件描述符的模式与 /dev/fd 文件描述符的模式其实并不相关。</p></blockquote><p>可以使用 /dev/fd 作为路径名参数调用 creat，这与调用 O_CREAT 作为第2个参数作用相同。</p><blockquote><p>在 Linux 上必须非常小心，因为 Linux 实现使用指向实际文件的符号链接，在 /dev/fd 文件上使用 creat 会导致底层文件被截断。</p></blockquote><p>像 mac 等一些系统提供路径名 /dev/stdin、/dev/stdout 和 /dev/stderr，这些等效于 /dev/fd/0、/dev/fd/1、/dev/fd/2。</p><p>/dev/fd 文件主要由 shell 使用，它允许使用路径名作为调用参数，如 cat 命令：</p><pre class="highlight"><code class="bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'abc'</span> | cat -abc<span class="hljs-comment"># 等效于</span>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'abc'</span> | cat /dev/fd/0abc</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件io&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#文件io&quot;&gt;&lt;/a&gt; 文件IO&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;不带缓冲的IO&lt;/code&gt;，其中&lt;code&gt;不带缓冲&lt;/code&gt;指的是每一个&lt;code&gt;read&lt;/code&gt;、&lt;c
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习笔记" scheme="http://fcwalkers.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Linux" scheme="http://fcwalkers.com/tags/Linux/"/>
    
      <category term="Unix 编程学习笔记" scheme="http://fcwalkers.com/tags/Unix-%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="http://fcwalkers.com/2019/10/15/c/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://fcwalkers.com/2019/10/15/c/C语言学习笔记/</id>
    <published>2019-10-14T16:00:00.000Z</published>
    <updated>2020-07-16T10:13:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><ul><li>char 字符型，点一个字节。</li><li>int 整型，通常代表机器中整数的自然长度。</li><li>short int 短整型，通常为16位(int可以省略)。</li><li>long int 长整型，通常为32位(int可以省略)。</li><li>float 单精度浮点型</li><li>double 双精度浮点型</li><li>long double 高精度的浮点数</li></ul><p><code>signed</code>和<code>unsigned</code>用于限定char类型和任何整型，<code>unsigned</code>类型的数值总是正值或0。</p><h2 id="常量"><a class="markdownIt-Anchor" href="#常量"></a> 常量</h2><p>语法：<code>#define 常量名 常量值</code></p><ul><li><strong>整数常量</strong><br>包含<code>int</code>和<code>long</code>类型常量。<code>long</code>类型以<code>l</code>或<code>L</code>结尾。<br>当一个整数无法用<code>int</code>表示时，也被当作<code>long</code>类型处理。<br>无符号常量以<code>u</code>或<code>U</code>结尾，无符号长整型使用<code>ul</code>或<code>UL</code>结尾。<br>前缀<code>0</code>表示八进制形式，<code>0x</code>表示十六进制形式。</li><li><strong>浮点数常量</strong><br>没有后缀的常量为<code>double</code>类型。<br>后缀加<code>f</code>或<code>F</code>表示<code>float</code>类型。<br>后缀加<code>l</code>或<code>L</code>表示<code>long double</code>类型。</li><li><strong>字符常量</strong><br>一个字符常量是一个整数，如<code>'0'</code>值为48，它与数值0无关。<br>转义字符通常只表示一个字符，如<code>'\013'</code>。<br>字符常量<code>'\0'</code>表示值为0的字符，即空字符(null)。</li><li><strong>字符串常量</strong><br>与字符常量的区别是字符串常量用<code>&quot; &quot;</code>双引号括起来。其实就是字符数组，内部使用<code>空字符('\0')</code>作为结尾，因此，字符串常量占据的存储单元比双引号内的字符数大1。</li><li><strong>枚举常量</strong><br>语法：<code>enum 枚举名 &#123;枚举列表&#125;</code><br>枚举常量是另外一种类型常量，是一个常量整型值的列表，如：<pre class="highlight"><code class="C"><span class="hljs-keyword">enum</span> boolean &#123;NO, YES&#125;;</code></pre>未显示声明的枚举，第一个枚举名的值为0，第二值为1，依此类推。<br>如果指定部分枚举值，未指定枚举值将向后递增。<pre class="highlight"><code class="c"><span class="hljs-keyword">enum</span> colors &#123;WHITE=<span class="hljs-number">0</span>,BLACK,RED,YELLOW&#125;BLACK--&gt;<span class="hljs-number">1</span>RED--&gt;<span class="hljs-number">2</span>YELLOW--&gt;<span class="hljs-number">3</span></code></pre></li></ul><p>常量表达式是仅仅包含常量的表达式。这种表达式只在编译时求值，而不在运行时求值。</p><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><p>变量必须先声明再使用，一个变量声明只能指定一种类型，后面可以有一个或多个该类型变量。如：int lower,upper…;<br>任何</p><ul><li><p><strong>外部变量</strong><br>定义在函数之外的变量叫做外部变量。由于定义在函数之外，因此可以在所有函数中使用。由于C语言不允许在一个函数中定义其它函数，因此函数本身是“外部的”。变量都可以使用<code>const</code>限定符限定为不可被修改变量。</p><blockquote><p>如果要在外部变量定义之前使用变量，或者外部变量的定义与变量的使用不在同一个源文件中，必须在相应变量声明中强制使用关键字<code>extern</code>。外部变量的定义中数组必须指定长度，但<code>extern</code>声明不一定要指定数组长度。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXSIZE 10;</span><span class="hljs-keyword">int</span> a;<span class="hljs-keyword">double</span> b[MAXSIZE]; </code></pre><pre class="highlight"><code class="c"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> a; <span class="hljs-comment">//使用a.c文件中的变量a</span><span class="hljs-keyword">extern</span> <span class="hljs-keyword">double</span> b[]; <span class="hljs-comment">//使用a.c文件中的b省略了数组大小</span></code></pre></li><li><p><strong>自动变量</strong><br>定义在函数内的变量叫做“局部变量”，也叫“自动变量”。由于定义在函数之内，因此只可以函数内使用，多次调用函数不保留前次调用时的赋值。</p></li><li><p><strong>静态变量</strong><br>用<code>static</code>修饰的变量，叫做静态变量。静态变量的存储方式与全局变量相同，都是静态存储方式。全局变量的作用域是整个源程序，即源程序源的所有文件中有效。静态变量作用域则是只在当前变量所在源文件中可以使用，其次静态变量的值在函数调用后一直保持不会消失。即使在函数中声明的，每次调用函数，其值都会保存上一次调用后值。</p></li><li><p><strong>寄存器变量</strong><br>使用<code>register</code>关键字声明的变量，叫做寄存器变量。<code>register</code>变量放在机器的寄存器中，这样可以使程序更小，执行速度更快。<code>register</code>声明只适用于自动变量或函数的形式参数形式：</p><pre class="highlight"><code class="c">test(<span class="hljs-keyword">register</span> variA,<span class="hljs-keyword">register</span> variB)&#123;<span class="hljs-keyword">register</span> <span class="hljs-keyword">int</span> variC;...&#125;</code></pre><blockquote><p>实际上，底层硬件环境对寄存器变量的使用会有一些限制。每个函数中只有很少的变量可以保存在寄存器中，且只允许某些变量类型的变量。编译器可以忽略过量的或不支持的寄存器变量声明，因此过量的寄存器变量声明并没有什么害处。但是注意，无论寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的。不同的机器，对寄存器变量的限制不同。</p></blockquote></li></ul><h2 id="运算符"><a class="markdownIt-Anchor" href="#运算符"></a> 运算符</h2><ul><li><p><strong>自述运算符</strong><br><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code><br><em><strong><code>c/c++</code>和<code>java</code>语言中取模运算(%)就是取余运算,而<a href="/2018/08/09/python/Python3%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95(v3.7)/#%E6%95%B4%E6%95%B0%E3%80%81%E6%B5%AE%E7%82%B9">python</a>则有些不同</strong></em></p></li><li><p><strong>关系运算符</strong><br><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>==</code>、<code>!=</code></p></li><li><p><strong>逻辑运算符</strong><br><code>||</code>、<code>&amp;&amp;</code>、<code>!</code></p></li><li><p><strong>按位运算符</strong><br>按位运算就是将数值转换为二进制位，然后进行运算得到最终值：<br><code>&amp;</code> 按位与(AND)</p><blockquote><p>运算规则是两个为真才为真 <code>1&amp;1=1, 1&amp;0=0, 0&amp;1=0, 0&amp;0=0</code>。如 <code>3</code> 二进制位是 <code>0000 0011</code>，<code>5</code> 的二进制位是 <code>0000 0101</code>，由按位与规则可得，<code>001 &amp; 101</code>等于<code>0000 0001</code>，最终值为<code>1</code>。</p></blockquote><p><strong>求模运算时当被除数为 2 的 n 方时，可以用按位与运算替换更高效，公式为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">%</mi><msup><mn>2</mn><mi>n</mi></msup><mo>=</mo><mi>a</mi><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a\%2^n=a\&amp;(2^n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">a</span><span class="mord">%</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>(不分前后也可以写成，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">&amp;</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">(2^n-1) \&amp; a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">&amp;</span><span class="mord mathdefault">a</span></span></span></span>) 即，</strong></p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>14</mn><mi mathvariant="normal">%</mi><mn>8</mn><mo>=</mo><mn>14</mn><mi mathvariant="normal">%</mi><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>14</mn><mi mathvariant="normal">&amp;</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mn>3</mn></msup><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mn>6</mn></mrow><annotation encoding="application/x-tex">14\%8=14\%2^3=14\&amp;(2^3-1)=6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">%</span><span class="mord">8</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9196679999999999em;vertical-align:-0.05556em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">%</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">&amp;</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span></span></span></span></span></p><p><code>|</code> 按位或(OR)</p><blockquote><p>运算规则是一个为真则为真<code>1|0=1, 1|1=1, 0|0=0, 0|1=1</code>。如<code>6</code>二进制位是<code>0000 0110</code>，<code>2</code> 的二进制位是<code>0000 0010</code>，由按位或规则可得，<code>110 | 010</code>等于<code>110</code>，最终值为<code>6</code>。</p></blockquote><p><code>^</code> 按位异或(XOR)</p><blockquote><p>运算规则是如果两个值不相同，则为真，相同则为假<code>1^0=1, 1^1=0, 0^1=1, 0^0=0</code>。如<code>5</code>二进制位是<code>0000 0101</code>，<code>9</code> 的二进制位是<code>0000 1001</code>，由按位异或规则可得，<code>0110 ^ 1001</code> 等于<code>1100</code>，最终值为<code>12</code></p></blockquote><p><code>&lt;&lt;</code>左位移</p><blockquote><p>运算规则是将左侧数值的二进制位向左移动右侧数值位。移动后右边补<code>0</code>，正数左边第一位补 <code>0</code>，负数补<code>1</code>，结果相当于乘以 2 的 n 次方。如：<code>5&lt;&lt;2</code>，就是<code>5</code>的二进制位向左移<code>2</code>位，即<code>0000 0101</code> 把<code>101</code>向左移两位得到<code>0001 0100</code>，最终值为<code>5</code>乘以 2 得 2 次方，等于<code>20</code>。</p></blockquote><p><code>&gt;&gt;</code>右位移</p><blockquote><p>运算规则是将左侧数值的二进制位向右移动右侧数值位。移动后正数第一位补<code>0</code>，负数补<code>1</code>，结果相当于除以 2 的 n 次方。如：<code>5&gt;&gt;2</code>，就是<code>5</code> 的进制位向右移动<code>2</code>位，即<code>0000 0101</code>把<code>101</code>右移两位后得到<code>0000 0001</code>，最终值为<code>5</code> 除以 2 得 2 次方，等于<code>1</code>。</p></blockquote><p><code>~</code>按位求反(一元运算符)</p><blockquote><p>运算规则是取位数值相反值<code>~0=1, ~1=0</code>。 如<code>5</code> 二进制位是<code>0000 0101</code>，取反后为<code>1111 1010</code>，最终值为<code>-6</code>。</p></blockquote></li><li><p><strong>自增运算符</strong><br><code>++</code> 可以作为前缀运算符，表示先作自增，后赋值;也可以作为后缀运算符，表示先赋值，再作自增。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> x, n;n = <span class="hljs-number">1</span>;x = ++n; <span class="hljs-comment">//x值为2,n为2</span>x = n++;　<span class="hljs-comment">//x值为2,n为3</span></code></pre></li><li><p><strong>自减运算符</strong><br><code>--</code> 用法同自增运算符</p></li><li><p><strong>三元运算符</strong><br><code>表达式 ? 表达式 : 表达式</code></p></li></ul><h2 id="流程控制"><a class="markdownIt-Anchor" href="#流程控制"></a> 流程控制</h2><ul><li><p><strong>if…else 语句</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">if</span> (表达式)语句<span class="hljs-keyword">else</span>语句</code></pre></li><li><p><strong>switch 语句</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">switch</span> (表达式) &#123;<span class="hljs-keyword">case</span> 常量表达式:语句  <span class="hljs-keyword">case</span> 常量表达式:语句  <span class="hljs-keyword">default</span>:语句 &#125;</code></pre><blockquote><p>注意，case后必须为整数值常量或常量表达式。</p></blockquote></li><li><p><strong>while 循环</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">while</span>(表达式)语句</code></pre><p>如果希望while循环体至少被执行一次可以使用<code>do...while</code>循环：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">do</span> 语句<span class="hljs-keyword">while</span> (表达式);</code></pre></li><li><p><strong>for 循环</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">for</span>(表达式<span class="hljs-number">1</span>;表达式<span class="hljs-number">2</span>;表达式<span class="hljs-number">3</span>)语句</code></pre></li><li><p><strong>break / continue 语句</strong><br>用于继续或结束循环语句。</p></li><li><p><strong>goto 语句</strong></p><pre class="highlight"><code class="c"><span class="hljs-keyword">for</span> ( ... )<span class="hljs-keyword">for</span> ( ... ) &#123;<span class="hljs-keyword">if</span> (disaster) <span class="hljs-keyword">goto</span> error;&#125; error:</code></pre><blockquote><p>大多数情况，使用goto语句比不使用goto语句程序段要难以理解和维护，少数情况除外。尽管该问题不太严重，但还是建议尽可能少的使用。</p></blockquote></li></ul><h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2><p>函数定义：<br><code>返回值类型 函数名(参数列表)&#123; 函数体 &#125;</code></p><blockquote><p>函数定义可以不带有<code>返回类型</code>，默认返回int类型。函数在源文件中出现的次序可以是任意的，只要保证一个函数不被分离到多个文件中即可。被调用函数通过<code>return 表达式</code>向调用者返回值，return后面表达式可以省略。</p></blockquote><h2 id="预处理器"><a class="markdownIt-Anchor" href="#预处理器"></a> 预处理器</h2><p>预处理器是编译过程中单独执行的第一个步骤，最常用的预处理器指令是<code>#include</code>和<code>#define</code>。</p><ul><li><p><strong>文件包含</strong><br>文件包含指令(<code>#include</code>)用于在编译期间把指定文件的内容包含进当前文件中。形式如下：<br><code>#include &quot;文件名&quot;</code><br>或<br><code>#include &lt;文件名&gt;</code>。</p><blockquote><p>当文件名用引号引起来(通常用于包含程序目录中的文件)，则在源文件所在位置查找该文件;如果该位置没有该文件或者文件名用尖括号括起来(通常用于包含编译器的类库路径里面的头文件)，则根据相应规则查找该文件，该规则同具体实现有关。如果某个包含文件内容发生了变化，那么所有依赖于该包含的文件的源文件都必须重新编译。</p></blockquote></li><li><p><strong>宏替换</strong><br>宏替换指令(<code>#define</code>)用于用任意字符序列替代一个标记。形式如下：<br><code>#define 标识符 记号序列</code></p><p>替换文本前后空格会被忽略，两次定义同一标识符是错误的，除非两次记号序列相同(所有空白分割符被认为是相同的)。<br>该定义的名字作用域从其定义点开始，到被编译的源文件末尾处结束。定义超过一行使用反斜杠(<code>\</code>)换行。</p><p>替换的文本可以是任意的，如：</p><pre class="highlight"><code class="c"><span class="hljs-comment">//为无限循环定义一个名字</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> forever for(;;) </span><span class="hljs-comment">//定义带参数宏</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max(A,B) ((A) &gt; (B) ? &lt; (A) : (B))</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> square(x) x * x </span>main()&#123;<span class="hljs-keyword">int</span> i, z;i = z = <span class="hljs-number">2</span>;max(++i,i++); <span class="hljs-comment">// 结果为4</span>square(z+<span class="hljs-number">1</span>); <span class="hljs-comment">// 结果为5</span>&#125;</code></pre><blockquote><p>宏定义也有一些缺陷，如上面<code>max</code>，它对每个参数执行两次自增操作。<code>square</code>没有增加括号而导致计算次序错误。</p></blockquote><p>可以通过<code>#undef</code>取消名字的宏定义：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> max</span></code></pre><p><code>#</code>运算符可以使得宏定义的实际参数替换为带引号的字符串：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> dprint(expr) printf(#expr + <span class="hljs-meta-string">"=%d"</span>)</span>调用结果x = <span class="hljs-number">4</span>,y = <span class="hljs-number">2</span>:dprint(x/y) --&gt; x/y=<span class="hljs-number">2</span> </code></pre><p><code>##</code>运算符可以使得宏定义的实际参数相连接：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> paste(x,y) x ## y</span>调用结果：paste(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) --&gt; <span class="hljs-number">12</span></code></pre></li><li><p><strong>条件编译</strong></p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 常量表达式</span>　文本<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> 常量表达式</span>　文本<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>　文本<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>当预处理器检测到常量表达式值为非0时，对相应表达式下面文本进行编译，后续表达式及文本将会被抛弃。常量表达式可以使用<code>define 标识符</code>或<code>define(标识符)</code>表达式，当<code>标识符</code>已经定义时，其值为1，否则为0。</p><pre class="highlight"><code class="c"><span class="hljs-comment">//检测HDR标识符，没有定义时将其定义</span><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> !defined(HDR)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HDR </span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>等价于<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> HDR</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HDR</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>如上所示，可以使用<code>#ifdef 标识符</code>和<code>#ifndef 标识符</code>控制指令替换<code>#if define 标识符</code>。</p></li><li><p><strong>预定义标识符</strong></p><table><thead><tr><th>识符</th><th>说明</th></tr></thead><tbody><tr><td>__LINE__</td><td>当前所在源文件行数的十进制常量</td></tr><tr><td>__FILE__</td><td>被编译的源文件名字的字符串</td></tr><tr><td>__DATE__</td><td>被编译的源文件编译日期的字符串，格式：“Mmm dd yyyy”</td></tr><tr><td>__TIME__</td><td>被编译的源文件编译时间的字符串，格式：“hh:mm:ss”</td></tr><tr><td>__STDC__</td><td>整型常量1（只有在遵循标准的实现中该标识符才被定义为1）</td></tr></tbody></table></li><li><p><strong>其他预处理指令</strong><br><strong><code>#line 常量　&quot;文件名&quot;</code></strong>　以十进制整型常量的形式定义下一行源代码的行号。其中<code>&quot;文件名&quot;</code>可以省略，表示设置当前编译的源文件。<br><strong><code>#error 信息</code></strong>　当预处理器遇到此指令时停止编译并输出定义的错误消息。通常与<code>#if...#endif</code>等指令一起使用。<br><strong><code>#pragam 记号序列</code></strong>　使处理器执行一个与具体实现相关的操作。无法识别的pragma(编译指示)将被忽略掉。<br><strong><code>#</code></strong>　空指令。预处理器行不执行任何操作。</p></li></ul><h2 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h2><p>为了便于记忆，指针的声明形式是在变量声明的基础上加一个<code>*</code>间接寻址或间接引用运算符：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> *p; <span class="hljs-comment">//声明一个int类型的指针*p</span></code></pre><p>通过一元运算符<code>&amp;</code>获取一个对象的地址：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;p = &amp;x;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,*p); --&gt; 打印<span class="hljs-number">1</span></code></pre><p>一元运算符<code>*</code>和<code>&amp;</code>的优先级比算术运算符优先级高，因此在进行算术运算时不需要加括号：</p><pre class="highlight"><code class="c">*p += <span class="hljs-number">1</span>;或++*p;或(*p)++;</code></pre><blockquote><p>语句<code>(*p)++</code>中的圆括号是必需的，否则，表达式将对p进行加一运算，而不是对ip指向的对象进行加一运算，原因在于一元运算符表达式遵循从右到左的顺序。</p></blockquote><p>由于指针也是变量，所以可以直接使用，而不必通过间接引用的方法使用：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> *pp;pp = ip; <span class="hljs-comment">//通过变量的形式将指针pp指向指针ip指向的对象</span></code></pre><p>同其他类型变量一样，指针也可以初始化，对指针有意义的初始化值只能是<code>0</code>或表示地址的表达式。C语言保证<code>0</code>永远不是有效的数据地址，因此，返回<code>0</code>可用来表示发生了异常事件。</p><blockquote><p>指针与整数之间不能相互转换，但<code>0</code>是唯一的例外。常量<code>0</code>可以赋值给指针，指针也可以与常量<code>0</code>进行比较。程序中通常使用<code>符号常量(NULL)</code>代替常量0，其定义在<code>stddef.h</code>头文件中。</p></blockquote><ul><li><p><strong>指针与函数参数</strong><br>C语言是以传值的方式将参数值传递给被调用函数，因此，被调用函数不能直接修改主调函数中变量的值。</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<span class="hljs-keyword">int</span> temp;temp = x;x = y;y = temp;&#125;调用：　swap(x,y);</code></pre><p>由于参数传递是传值方式，所以上述函数无法成功交换变量。可以通过将交换的变量的指针传递给被调用函数的方法实现该功能：</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *px,<span class="hljs-keyword">int</span> *py)</span></span>&#123;<span class="hljs-keyword">int</span> temp;temp = *px;*px = * py;*py = temp;&#125;调用：　swap(&amp;x,&amp;y);</code></pre></li><li><p><strong>指针与数组</strong><br>数组其实是由N个对象组成的集合，这些对象存储在相邻的内在区域中。因此可以将指针变量指向数组的每个对象。</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> a[<span class="hljs-number">10</span>];<span class="hljs-keyword">int</span> *pa;pa = &amp;a[<span class="hljs-number">0</span>]; <span class="hljs-comment">//将pa指向数组第0个元素</span></code></pre><p>根据指针运算的定义，<code>pa+1</code>指向数组下一个对象，<code>pa+i</code>指向pa所指向数组对象之后的第i个对象，<code>pa-i</code>指向pa所指向数组对象之前的第i个元素。<br>由于数组名所代表的就是该数组最开始的一个元素的地址，因此下面两等式作用相同：</p><pre class="highlight"><code class="c">pa = &amp;a[<span class="hljs-number">0</span>];或pa = a;</code></pre><p>由上面等式，对数组元素<code>a[i]</code>的引用也可以写成<code>*(a+i)</code>形式。实际上，在C语言计算<code>a[i]</code>元素时就是先将其转换成<code>*(a+i)</code>的形式，然后再求值。</p><blockquote><p>数组名和指针的不同之处在于，指针是一个变量，数组名却不是变量。因此语句<code>pa=a</code>和<code>pa++</code>是合法的，而<code>a=pa</code>和<code>a++</code>形式是非法的。</p></blockquote><p>当两个指针指向同一个数组的成员时，两个指针可以进行比较运算(==＝、!=、&lt;、&gt;=)：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">char</span> c[] = <span class="hljs-string">"hello"</span>;<span class="hljs-keyword">char</span> *pc1 = c;<span class="hljs-keyword">char</span> *pc2 = &amp;c[<span class="hljs-number">1</span>];运算：pc2 &gt; pc1 --&gt; True　<span class="hljs-comment">//比较运算返回True</span>pc2 - pc1 + <span class="hljs-number">1</span> --&gt; <span class="hljs-number">2</span> <span class="hljs-comment">//返回两指针指向的元素之间元素的数目</span></code></pre><blockquote><p>由上面代码可知，指向数组元素位越置靠前的指针，指针值越大。但是，指向不同数组的元素的指针之间的算术或比较运算没有意义。</p></blockquote><p>根据指针上面的特性，可以写出返回字符串长度函数的两个指针实现版本：</p><pre class="highlight"><code class="c"><span class="hljs-comment">/* strlen函数，返回客串s的长度 */</span>版本一：<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span>;*s != <span class="hljs-string">'\0'</span>;s++)n++;<span class="hljs-keyword">return</span> n;&#125;版本二：<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;<span class="hljs-keyword">char</span> *p = s;<span class="hljs-keyword">while</span> (*p != <span class="hljs-string">'\0'</span>)p++;<span class="hljs-keyword">return</span> p - s;&#125;</code></pre><blockquote><ul><li>指针算术运算具有一致辞性，如果处理的数据类型是比字符型占据更多的存储空间的浮点类型，并且p是一个指向浮点类型的指针，那么在执行<code>p++</code>后，p将指向下一个浮点数的地址。所有的指针运算都会自动考虑它所指向的对象长度。</li><li>有效的指针运算包括相同类型指针之间的赋值运算；指针同整数之间的加减法运算；指向相同数组中元素的两个指针间的减法或比较去处；将指针赋值为0或与0之间的比较运算。其他所有形式的指针运算都是非法的。</li></ul></blockquote><p>C语言数组可以使用花括号<code>&#123;&#125;</code>括起来初值表进行初始化。同时也支持多维数组，如果将二维数组作为参数传递给函数，函数的参数声明中可以不指定数组的行数，但必须指明数组的列数，因为，二维数组在内存中的排列方式是按行排列的，即第一行排完之后再排列第二行，依此类推。当给出数组的列数时，通过列数与行数的关系，即可找到对应的地址。</p><pre class="highlight"><code class="c">f (<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">2</span>][<span class="hljs-number">13</span>]);<span class="hljs-comment">//可以写成</span>f (<span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[][<span class="hljs-number">13</span>]);<span class="hljs-comment">//还可以写成</span>f (<span class="hljs-keyword">int</span> (*<span class="hljs-built_in">array</span>)[<span class="hljs-number">13</span>]);<span class="hljs-comment">//错误写法</span>f (<span class="hljs-keyword">int</span> *<span class="hljs-built_in">array</span>[<span class="hljs-number">13</span>]); --&gt; 因为[]的优先级高于*的优先级，如果声明时不使用()时，相当于声明了一个指向指针的一维数组。</code></pre><blockquote><p>由于指针本身也是变量，所以它也可以像其他变量一样被存储在数组中。因为<code>[]</code>优先级高于<code>*</code>的优先级，所以上例中<code>int *array[13];</code>相当于声明了一个指向指针的一维数组。</p></blockquote><p>指针数组与二维数组的区别是，二维数组是分配了固定存储空间(行*列)的，而指针数组只是定义了指定个数的指针，而没有对它们初始化，它们的初始化必须以显式的方式进行。因此，指针数组优于二维数组的重要一点是，指针数组每一行长度可以不同。</p><pre class="highlight"><code class="c"><span class="hljs-comment">//二维数组</span><span class="hljs-keyword">int</span> <span class="hljs-built_in">array</span>[<span class="hljs-number">10</span>][<span class="hljs-number">20</span>]; --&gt; 固定<span class="hljs-number">10</span>行<span class="hljs-number">20</span>列长度的二维数组<span class="hljs-comment">//指针数组　</span><span class="hljs-keyword">char</span> *monthName = &#123;<span class="hljs-string">"January"</span>,<span class="hljs-string">"February"</span>,<span class="hljs-string">"March"</span>&#125;; --&gt; 长度不固定的指针数组<span class="hljs-comment">//调用</span><span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];monthName[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]; --&gt;返回 J**monthName; --&gt;等价于下标方式 返回 J</code></pre></li><li><p><strong>命令行参数</strong><br>调用主函数数(<code>main</code>)时，有两个参数。第一个参数(<code>argc</code>)用于参数计数，表示运行程序时命令行中参数的个数;第二个参数(<code>argv</code>)，是一个指向字符串数组的指针，其中每个字符串对应一个参数。另外，ANSI标准要求，argv[argc]的值必须为一个空指针。main函数返回值为0表示正常退出，返回非0值表示代表程序异常退出。如echo程序，它将命令行参数回显在屏幕上的一行中，其中命令行中各参数之间用空格隔开：</p><pre class="highlight"><code class="bash"><span class="hljs-built_in">echo</span> hello, world<span class="hljs-comment"># 打印输出</span>hello, world</code></pre><pre class="highlight"><code class="c"><span class="hljs-comment">// 版本一：将argv看成是一个字符指针数组</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[]) &#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; argc; i++)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s%s"</span>, argv[i], (i &lt; argc - <span class="hljs-number">1</span>) ? <span class="hljs-string">" "</span> : <span class="hljs-string">""</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-comment">// 版本二：通过指针方式实现</span>main(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])&#123;<span class="hljs-keyword">while</span> (--argc &gt; <span class="hljs-number">0</span>)<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s%s"</span>, *++argv, (argc &gt; <span class="hljs-number">1</span>) ? <span class="hljs-string">" "</span> : <span class="hljs-string">""</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;注意：<span class="hljs-built_in">printf</span>的格式化参数也可以是表达式。如：<span class="hljs-built_in">printf</span>((argc&gt;<span class="hljs-number">1</span>) ? <span class="hljs-string">"%s "</span> : <span class="hljs-string">"%s"</span>, *++argv);</code></pre></li><li><p><strong>指向函数的指针</strong><br>C语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值。调用指向函数的指针时，它们是函数的地址，因为它们是函数，所以同数组名一样，前面不需要加<code>&amp;</code>运算符。<br>由于任何类型的指针都可以转换为<code>void *</code>类型，并且在将它转换回原来的类型时不会丢失信息，因此，函数指针数组参数的类型通常用void指针类型。定义形式：<br><code>类型 (*指针变量名) (参数列表)</code></p><blockquote><p>注意上面<code>(*指针变量名)</code>括号不能省略。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-comment">/* 实现operate()函数传入不同函数指针实现相关函数功能 */</span> <span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">double</span> (*nump)(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len))</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span></span>;<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span></span>;main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[]) &#123;<span class="hljs-keyword">double</span> num[] = &#123;<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">5.3</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">2</span>&#125;;<span class="hljs-keyword">int</span> len = <span class="hljs-number">8</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f"</span>, operate(num, len, min)); --&gt; <span class="hljs-number">1.5</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f"</span>, operate(num, len, max)); --&gt; <span class="hljs-number">5.3</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f"</span>, operate(num, len, avg)); --&gt; <span class="hljs-number">2.7875</span>&#125;<span class="hljs-comment">//获取数组最大值</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<span class="hljs-keyword">double</span> temp;temp = *num++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++, num++)<span class="hljs-keyword">if</span> (temp &lt; *num)temp = *num;<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-comment">// 获取数组最小值</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span> </span>&#123;<span class="hljs-keyword">double</span> temp;temp = *num++;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++, num++)<span class="hljs-keyword">if</span> (temp &gt; *num)temp = *num;<span class="hljs-keyword">return</span> temp;&#125;<span class="hljs-comment">//获取数组平均值</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">avg</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len)</span> </span>&#123;assert(len != <span class="hljs-number">0</span>);<span class="hljs-keyword">double</span> ti;ti = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++, num++)ti += *num;<span class="hljs-keyword">return</span> ti / len;&#125;<span class="hljs-comment">// 通过函数指针调用不同的方法</span><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">operate</span><span class="hljs-params">(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">double</span> (*nump)(<span class="hljs-keyword">double</span> *num, <span class="hljs-keyword">int</span> len))</span> </span>&#123;<span class="hljs-keyword">return</span> nump(num, len);&#125;</code></pre></li><li><p><strong>指针别名(Pointer aliasing)</strong><br>指两个及以上的指针指向同一数据，即不同的名字指针指向同一内在地址，则称一个指针是另一个指针的别名。如：</p><pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> *a = &amp;i;<span class="hljs-keyword">int</span> *b = &amp;i; <span class="hljs-comment">// 指针b是指针a别名</span></code></pre></li><li><p><strong><code>restrict</code>指针限定符</strong><br>该关键字是 C99 标准中新引入的一个指针类型修饰符，它只可应用于限定和约束指针，主要作用是限制指针别名，表明当前指针是访问一个数据对象的唯一方式，所有修改该指针所指向的内存中内容操作都必须通过该指针来修改，而不能通过其他途径修改。这样做的用处是帮助编译器更好的优化代码，生成更有效率的汇编代码。如果该指针与另外一个指针指向同一对象，将会导致未定义行为。</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 未加指针限定符的指针参数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a, <span class="hljs-keyword">int</span> *b)</span></span>&#123;*a = <span class="hljs-number">10</span>;*b = <span class="hljs-number">12</span>;<span class="hljs-keyword">return</span> *a + *b;&#125;<span class="hljs-comment">// 添加指针限定符的指针参数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-keyword">restrict</span> a, <span class="hljs-keyword">int</span> *<span class="hljs-keyword">restrict</span> b)</span></span>&#123;*a = <span class="hljs-number">10</span>;*b = <span class="hljs-number">12</span>;<span class="hljs-keyword">return</span> *a + *b;&#125;<span class="hljs-comment">// 调用两个方法</span><span class="hljs-keyword">int</span> i,j;add(&amp;i, &amp;j);  <span class="hljs-comment">// 返回值22，编译器无法确定内存是否被其他指针别名修改(即函数指针参数未设置 restrict 限定符)，无法作出优化</span>add2(&amp;i, &amp;j); <span class="hljs-comment">// 返回值22，生成的汇编代码会进行优化操作</span>add2(&amp;i, &amp;i); <span class="hljs-comment">// 返回值24，因为传递参数违反了 restrict 限定符对函数内部实现的约束(两个参数指向同一内存地址，导致互为指针别名)，导致未定义行为。</span></code></pre></li></ul><h2 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h2><p>结构是一个或多个变量的集合，这些变量可以是不同的类型。ANSI标准定义了定义了结构的赋值操作————结构可以拷贝、赋值、函数参数，函数返回值。声明形式如下：<br><code>struct 结构标记 &#123; 结构成员 &#125;</code></p><blockquote><p>结构成员、结构标记和普通变量(非成员)可以使用相同名字，而不会冲突，因为通过上下文分析可以对它们进行区分。</p></blockquote><p>struct声明定义了一种数据类型。在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其他基本类型的变量声明是相同的：</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>...&#125; x, y, z;</code></pre><p>如果结构声明的后面不带变量表，则不会为它分配存储空间，它仅仅描述了一个结构的模板或轮廓。如果结构声明中带有标记，就可以使用该标记定义结构实例：<br><code>struct 结构标记 结构名 [ = &#123;结构初始化值&#125; ]</code></p><p>上面结构初始化值可以省略，在表达式中可以使用<code>结构成员运算符(.)</code>引用某个特定结构中的成员:<br><code>结构名.成员</code></p><pre class="highlight"><code class="c"><span class="hljs-comment">// 声明结构</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> y;&#125;<span class="hljs-comment">// 定义结构实例</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pt</span> = &#123;</span><span class="hljs-number">100</span>,<span class="hljs-number">200</span>&#125;; --&gt; 可以通过花括号的方式进行初始化<span class="hljs-comment">// 引用结构成员</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,pt.x); --&gt; 打印<span class="hljs-number">100</span></code></pre><p>结构可以进行嵌套，例如：</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 声明嵌套结构</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">react</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pt1</span>;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pt2</span>;</span>&#125;<span class="hljs-comment">// 定义结构实例,并初始化</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rect</span> <span class="hljs-title">screen</span> = &#123;</span>&#123;<span class="hljs-number">100</span>, <span class="hljs-number">200</span>&#125;, --&gt; 花括号可以省略，但不建议&#123;<span class="hljs-number">300</span>, <span class="hljs-number">400</span>&#125;&#125;;<span class="hljs-comment">// 引用结构成员</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,screen.pt2.x); --&gt; 打印<span class="hljs-number">300</span></code></pre><p>结构类型的参数和其他类型的参数一样，都是值传递。因此，下面例子不会改变原结构 <strong>p1</strong> 的值：</p><pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> y;&#125;;main() &#123;<span class="hljs-function">struct point <span class="hljs-title">addpoint</span><span class="hljs-params">(struct point p1, struct point p2)</span></span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p1</span> = &#123;</span><span class="hljs-number">100</span>, <span class="hljs-number">200</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p2</span> = &#123;</span><span class="hljs-number">200</span>, <span class="hljs-number">300</span>&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">p</span> = <span class="hljs-title">addpoint</span>(<span class="hljs-title">p1</span>, <span class="hljs-title">p2</span>);</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%d\t%d"</span>, p.x, p.y); <span class="hljs-comment">// 打印300 500</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%d\t%d"</span>, p1.x, p1.y); <span class="hljs-comment">// 打印100 200 </span>&#125;<span class="hljs-function">struct point <span class="hljs-title">addpoint</span><span class="hljs-params">(struct point p1, struct point p2)</span> </span>&#123;p1.x += p2.x;p1.y += p2.y;<span class="hljs-keyword">return</span> p1;&#125;</code></pre><ul><li><p><strong>结构数组</strong><br>当有一组信息需要存储到结构体时，可以使用结构数组。结构数组和普通数组声明类似，就是在定义结构实例时增加一个<code>中括号[数组大小]</code>即可，如：</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">pa</span>[50];</span> <span class="hljs-comment">// 定义结构数组pa</span></code></pre><blockquote><p>当使非字符数组时，结尾不是以<code>\0</code>结束，所以不容易判断数组长度。通常有三种解决方法：</p><ul><li>手工计算，直接写入具体长度。缺点是不得扩展，当列表变更时，需要手动维护，不安全。</li><li>在初值表的结尾处加上一个空指针，然后遍历循环，直到讲到尾部的空指针为止。</li><li>使用编译时一元运算符<code>sizeof 对象</code>或<code>sizeof (类型名)</code>，它可以计算任一对象的长度，即指定对象或类型占用的存储空间字节数。因为数组的长度在编译时已经完全确定，它等于 <strong>数组项的长度 * 项数</strong>，因此，得出数组项数为 <strong>数组长度 / 数组项的长度</strong>。</li></ul></blockquote><p><code>sizeof</code>反回一个无符号整型值，其类型为<code>size_t</code>，该类定义在头文件&lt;stddef.h&gt;中。一般用法如下：</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 预处理器中的应用，如返回上面结构数组的大小</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PA_LENGTH (sizeof(pa) / sizeof(pa[0])) </span>或　<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PA_LENGTH (sizeof(pa) / sizeof(struct point))  --&gt; 两者作用相同，但当类型改变时此种写法需要同步修改，因此，建议使用前者方法。</span><span class="hljs-comment">// 同结构一样其他类型数组也可使用上面方法获取数组大小</span><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">12</span>,<span class="hljs-number">123</span>,<span class="hljs-number">1234</span>&#125;;<span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(a[<span class="hljs-number">0</span>]) --&gt; <span class="hljs-number">4</span>或<span class="hljs-keyword">sizeof</span>(a) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>) --&gt; <span class="hljs-number">4</span></code></pre></li><li><p><strong>结构指针</strong><br>当传递给函数的结构很大时，使用结构指针方式的效率比复制整个结构的效率高。结构指针和普通指针声明类似，如：</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 声明结构指针</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> *<span class="hljs-title">pp</span>;</span><span class="hljs-comment">// 访问结构成员</span>(*pp).x;(*pp).y;</code></pre><blockquote><p>上面示例，访问指针结构成员<code>(*pp).x</code>中的圆括号，是必需的。因为 <strong>结构成员运算符</strong>(<code>.</code>)的优先级高于 <strong>指针运算符</strong>(<code>*</code>)。</p></blockquote><p>结构指针使用频率非常高，为了用不用方便，C语言提供了另一种简写方式引用结构成员：<br><code>p-&gt;结构成员</code></p><pre class="highlight"><code class="c"><span class="hljs-comment">//声明结构数组指针*ppa和结构指针*pp</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> *<span class="hljs-title">ppa</span>, *<span class="hljs-title">pp</span>;</span><span class="hljs-comment">// 结构数组指针指向结构数组</span>ppa = pa;<span class="hljs-comment">// 结构指针指向结构数组第二项　</span>pp = &amp;pa[<span class="hljs-number">1</span>];ppa-&gt;y;  --&gt; <span class="hljs-number">200</span>pp-&gt;y;   --&gt; <span class="hljs-number">400</span><span class="hljs-comment">// 运算符 . 和 -&gt; 都是从左至右结合，所以下面表达式等价</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rect</span> <span class="hljs-title">r</span>, *<span class="hljs-title">rp</span> = &amp;<span class="hljs-title">r</span>;</span>r.pt1.x ;rp-&gt;pt1.x ;(r.pt1).x ;(rp-&gt;pt1).x ;</code></pre><blockquote><p>在所有运算符中，<strong>结构运算符</strong><code>.</code>、<code>-&gt;</code>、<strong>用于函数用的</strong><code>()</code>及<strong>用于下标的</strong><code>[]</code> 优先级最高。</p></blockquote></li><li><p><strong>自引用结构</strong><br>一个包含自身实例的结构是非法的，但将实例声明为指针是允许的。如：</p><pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> <span class="hljs-title">left</span>;</span> --&gt; 非法声明&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tnode</span> *<span class="hljs-title">left</span>;</span> --&gt; 合法声明&#125;<span class="hljs-comment">// 结构互相引用</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">t</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s</span> *<span class="hljs-title">p</span>;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">s</span> &#123;</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">t</span> *<span class="hljs-title">q</span>;</span>&#125;</code></pre></li></ul><h3 id="类型定义"><a class="markdownIt-Anchor" href="#类型定义"></a> 类型定义</h3><p>C语言可以通过<code>typedef</code>来建立新的数据类型名，形式如下：</p><p><code>typedef 类型 类型名</code></p><blockquote><p><code>typedef</code>声明的类型在变量名的位置出现，而不是紧接在关键字<code>typedef</code>之后。建议使用大写字母开头定义类型名，以示区分。<br><code>typedef</code>声明并没有创建一个新类型，只是为某个已存在的类型增加一个新的名称而已。</p></blockquote><pre class="highlight"><code class="c"><span class="hljs-comment">// 定义一个 String 类型</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">char</span> *String;<span class="hljs-comment">// 定义一个结构类型</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> <span class="hljs-title">Point</span>;</span>Point pp = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;pp.x; --&gt; <span class="hljs-number">5</span>pp.y; --&gt; <span class="hljs-number">6</span></code></pre><p><code>typedef</code>类似于<code>#define</code>语句，但<code>typedef</code>是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。如：</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 定义类型`PFI`是一个指向函数的指针，该函数接收两个`char *`类型的参数，返回`int`类型</span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*PFI)</span> <span class="hljs-params">(<span class="hljs-keyword">char</span> *, <span class="hljs-keyword">char</span> *)</span></span>;<span class="hljs-function">function <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *,<span class="hljs-keyword">char</span> *)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;PFI pfi = &amp;func;pfi(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>); --&gt; 返回<span class="hljs-number">0</span></code></pre><blockquote><p><code>typedef</code>除了表达方式更简洁之外，使用它还有两个重要原因。一是它可以使程序参数化，以提高程序的可移植性。如声明的数据类型同机器有关，当程序需要移植到其他机器上时，只需改变<code>typedef</code>类型定义就可以了。另一个原因是它可以为程序提供更好的说明性。如 <strong>PFI</strong> 类型明显比一个指向复杂结构的指针更容易让人理解。</p></blockquote><h3 id="联合"><a class="markdownIt-Anchor" href="#联合"></a> 联合</h3><p>联合实际上就是一个结构，只不过联合的不同成员都保存在同一个存储空间，也就是联合中所有成员相对于基地址的偏移量都为0，因此联合空间要大到足够容纳最“宽”的成员。</p><p>定义：<code>union 联合标记 &#123; 联合成员 &#125;</code></p><p>联合可以给任何一个成员赋值，但每次的赋值将会覆盖上一次赋值，因此读取的类型必须是最近一次存入的类型，否则其返回结果取决于计算机的具体实现。</p><pre class="highlight"><code class="c"><span class="hljs-comment">// 定义联合u</span><span class="hljs-keyword">union</span> myunion &#123;<span class="hljs-keyword">int</span> i;<span class="hljs-keyword">float</span> f;<span class="hljs-keyword">char</span> c;<span class="hljs-keyword">char</span> *pc;&#125; u;<span class="hljs-comment">// 赋值</span>u.i = <span class="hljs-number">10</span>; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%d"</span>, u.i); --&gt; <span class="hljs-number">10</span>u.c = <span class="hljs-string">'a'</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n%c"</span>, u.c); --&gt; <span class="hljs-function">a <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-string">"\n%d"</span>, u.i)</span></span>; --&gt; <span class="hljs-number">97</span> <span class="hljs-comment">// 因为 u.i 被最后一次 u.c 赋值覆盖，所以字符 'a' 对应的ASCII整数值为 97</span></code></pre><p>如同上示例，访问联合成员与访问结构成员方式相同：</p><p><code>联合.成员</code> 或 <code>联合指针-&gt;成员</code></p><h2 id="输入与输出"><a class="markdownIt-Anchor" href="#输入与输出"></a> 输入与输出</h2><ul><li><p><strong>格式化输出/输出</strong></p><p>输出函数：<code>int printf(char *format,...)</code></p><p>输入函数：<code>int scanf(char *format,...)</code></p><p>函数格式化参数以<code>%</code>开始，并以一个转换转换字符结束。在<code>%</code>和转换字符之间依次可以包含：</p><ul><li><code>负号</code>，用于指定被转换的参数按照左对齐的形式输出。</li><li><code>数</code>，用于指定最小字段宽度。</li><li><code>小数点</code>，用于将字段和精度分开。</li><li><code>数</code>，用于指定精度，即要打印的最大字符数、浮点数点后的位数、整型最少最少输出的数字数目。</li><li>字母<code>h</code>或<code>l</code>，表示将整数作为<code>short</code>类型或<code>long</code>类型打印。</li></ul></li></ul><table><thead><tr><th>转换符</th><th>描述</th></tr></thead><tbody><tr><td>d, i</td><td>int 类型;十进制数</td></tr><tr><td>o</td><td>int 类型，打印无符号八进制数(没有前导0)。</td></tr><tr><td>x, X</td><td>int 类型，打印无符号十六进制数(没有前导0x或0X)。</td></tr><tr><td>u</td><td>int 类型，打印无符号十进制数。</td></tr><tr><td>c</td><td>int 类型，单个字符。</td></tr><tr><td>s</td><td>char *类型，打印字符串。</td></tr><tr><td>f</td><td>double 类型十进制小数，精度默认为6。</td></tr><tr><td>e, E</td><td>double 类型，输入格式为指数形式，精度默认是6。如：m.dddddd e +/-。</td></tr><tr><td>g, G</td><td>double 类型，尾部的0和小数不打印。</td></tr><tr><td>p</td><td>void *类型。</td></tr><tr><td>%</td><td>打印 % 号。</td></tr></tbody></table><ul><li><p><strong>可变参数函数</strong><br>像<code>printf</code>函数一样，函数参数的数量和类型是可变的。使用<code>...</code>定义可变参数。<br>头文件<code>&lt;stdarg.h&gt;</code>中提供了<code>va_list</code>类型用于声明一个**参数指针(ap)**变量；宏<code>va_start</code>将<code>ap</code>针初始化为指向第一个无名参数的指针，参数表必须至少包括一个有名参数(如:char *format)，<code>va_start</code>将最后一个有名参数作为起点。<br>每次调用<code>va_arg</code>，该函数将返回一个参数，并将<code>ap</code>指向下一个参数。<code>va_arg</code>使用一个类型名来决定返回的对象类型、指针移动的步长。最后，在函数返回之前调用<code>va_end</code>以完成一些必要的清理工作。</p><pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myprintf</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fmt,...)</span></span>&#123;va_list ap;<span class="hljs-keyword">char</span> *p, *sval;<span class="hljs-keyword">int</span> ival;<span class="hljs-keyword">double</span> dval;va_start(ap, fmt);<span class="hljs-keyword">for</span> (p = fmt; *p; p++) &#123;<span class="hljs-keyword">if</span> (*p != <span class="hljs-string">'%'</span>) &#123;<span class="hljs-built_in">putchar</span>(*p);<span class="hljs-keyword">continue</span>;&#125;<span class="hljs-keyword">switch</span> (*++p) &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">'d'</span>:ival = va_arg(ap, <span class="hljs-keyword">int</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, ival);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-string">'f'</span>:dval = va_arg(ap, <span class="hljs-keyword">double</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f"</span>, dval);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-built_in">putchar</span>(*p);<span class="hljs-keyword">break</span>;&#125;&#125;&#125;</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#数据类型&quot;&gt;&lt;/a&gt; 数据类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;char 字符型，点一个字节。&lt;/li&gt;
&lt;li&gt;int 整型，通常代表机器中整数的自然长度。&lt;/li&gt;
&lt;li&gt;sho
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习笔记" scheme="http://fcwalkers.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="C" scheme="http://fcwalkers.com/tags/C/"/>
    
      <category term="C学习笔记" scheme="http://fcwalkers.com/tags/C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Lua学习笔记(v5.3)</title>
    <link href="http://fcwalkers.com/2019/07/29/Lua/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://fcwalkers.com/2019/07/29/Lua/Lua学习笔记/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-08-09T07:29:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>Lua是一门扩展式、动态类型的程序设计语言，它没有<code>main</code>程序的概念只能嵌入一个宿主程序中工作，特点是轻量、可扩展。</p></blockquote><h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2><ul><li><p><strong>nil类型</strong>，值为<code>nil</code>。</p></li><li><p><strong>boolean类型</strong>，值为<code>true</code>和<code>false</code>(<em><strong>nil</strong></em> 和 ***false***都会导致条件判断为假，其他任何值都为真，包括0和空字符串)。</p></li><li><p><strong>number类型</strong>，值为<code>整数</code>和<code>符点数</code>。</p></li><li><p><strong>string类型</strong>，值为一个不可变的字节序列。</p></li><li><p><strong>function类型</strong>，由 C 或 Lua 编写的函数。</p><pre class="highlight"><code class="Lua">形式一:<span class="hljs-function"><span class="hljs-keyword">function</span> 函数名...函数体...<span class="hljs-title">end</span>形式二:函数名 = <span class="hljs-title">function</span>...函数体...<span class="hljs-title">end</span></span></code></pre><p>函数可以通过三点<code>...</code>来接收可变参数:</p><pre class="highlight"><code class="Lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">study</span><span class="hljs-params">(a,b,...)</span></span>  <span class="hljs-built_in">print</span>(a,b)  <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">ipairs</span>&#123;...&#125; <span class="hljs-keyword">do</span>      <span class="hljs-built_in">print</span>(<span class="hljs-string">'可变参数'</span>,v)  <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span>study(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">'study'</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)</code></pre><p>同样，Lua函数也可有多个返回值用逗号<code>,</code>分割，也可在函数定义前使<code>local</code>关键字定义局部函数。</p></li><li><p><strong>userdata类型</strong>，表示任意存储在变量中的 C 数据结构(通常是 struct 和 指针)。</p></li><li><p><strong>thread类型</strong>，表示了一个独立的执行序列，被用于实现协程。</p></li><li><p><strong>table类型</strong>，表示一个关联数组，除了 <code>nil</code> 和 <code>NaN</code>(Not a Number 是一个特殊的数字，它用于表示未定义或表示不了的运算结果，比如 0/0。) 之外的所有 Lua 值 都可以做索引。除了<code>[ ]</code>的方方式外，Lua也提供了<code>.</code>操作符的方式访问表元素的语法糖。表中的值也可以是任意类型，即使是一个函数。</p><pre class="highlight"><code class="Lua"><span class="hljs-comment">-- 表索引遵循直接比较规则原则，即1.0==1为true，所以 a[1.0]=a[1]</span>&gt; a=&#123;&#125; <span class="hljs-comment">-- 初始化表</span>&gt; a[<span class="hljs-number">1.0</span>] = <span class="hljs-number">4</span>&gt; a[<span class="hljs-number">1</span>]<span class="hljs-number">4</span></code></pre><p>table其实就是一个Key Value的数据结构，它的元素形式可有多种，如：</p><pre class="highlight"><code class="Lua">a = &#123; [f(<span class="hljs-number">1</span>)] = g; <span class="hljs-string">"x"</span>, <span class="hljs-string">"y"</span>; x = <span class="hljs-number">1</span>, f(x), [<span class="hljs-number">30</span>] = <span class="hljs-number">23</span>; <span class="hljs-number">45</span> &#125;其形式等价于：a = &#123; [f(<span class="hljs-number">1</span>)] = g; [<span class="hljs-number">1</span>] = <span class="hljs-string">"x"</span>,[<span class="hljs-number">2</span>] = <span class="hljs-string">"y"</span>; [<span class="hljs-string">"x"</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">3</span>] = f(x), [<span class="hljs-number">30</span>] = <span class="hljs-number">23</span>; [<span class="hljs-number">4</span>]=<span class="hljs-number">45</span> &#125;</code></pre><blockquote><p>由上可以发现，Lua的索引下标是从<code>1</code>开始的，并且表中没有键的值会默认从下标1开始作为键。</p></blockquote></li></ul><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释</h3><p>– 单行注释<br>–[[<br>多行注释<br>]]</p><h3 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h3><p>Lua中的标识符，是由非数字开头的任意字母下划线和数字构成的非保留关键字的字符串，且大小写敏感。作为一个约定，程序应避免创建以下划线加一个或多个大写字母构成的名字 （例如 _VERSION）。</p><p>字符串可以用<code>单引号</code>和<code>双引号</code>括起，并且支持C类型的转义：’\a’ （响铃）， ‘\b’ （退格）， ‘\f’ （换页）， ‘\n’ （换行）， ‘\r’ （回车）， ‘\t’ （横项制表）， ‘\v’ （纵向制表）， ‘\’ （反斜杠）， ‘&quot;’ （双引号）， 以及 ‘’’ (单引号)</p><p>多行字符串通过<code>[[ ]]</code>来定义，如下几种定义完全相同：</p><pre class="highlight"><code class="Lua">a = <span class="hljs-string">'alo\n123"'</span>a = <span class="hljs-string">"alo\n123\""</span>a = <span class="hljs-string">'\97lo\10\04923"'</span> <span class="hljs-comment">-- \10 为换行编码</span>a = <span class="hljs-string">[[alo　123"]]</span>　<span class="hljs-comment">-- 采用多行定义语法</span>a = <span class="hljs-string">[==[alo123"]==]</span>　<span class="hljs-comment">-- 注意：开括号( [[ )后的换行符会被忽略</span></code></pre><ul><li><p>全局变量</p><p>所有没有显示声明为局部变量的变量全部为全局变量。</p></li><li><p>局部变量</p><p>变量前加<code>local</code>关键字为局部变量。</p></li><li><p>table 中的域</p></li></ul><blockquote><p>没有赋值的变量，默认值均为<code>nil</code></p></blockquote><h3 id="表达式"><a class="markdownIt-Anchor" href="#表达式"></a> 表达式</h3><ul><li><p><strong>数学操作符</strong></p><p><code>+</code> 加法<br><code>-</code> 减法<br><code>*</code> 乘法<br><code>/</code> 浮点除法<br><code>//</code> 向下取整除法<br><code>%</code> 取模<br><code>^</code> 乘方<br><code>-</code> 取负</p><p>乘方和浮点除法总是将整数转换为浮点数。</p></li><li><p><strong>位操作符</strong></p><p><code>&amp;</code> 按位与<br><code>|</code> 按位或<br><code>~</code> 按位异或<br><code>&gt;&gt;</code> 右移<br><code>&lt;&lt;</code> 左移<br><code>~</code> 按位非</p><p>所有的位操作都将操作数先转换为整数 ， 然后按位操作，其结果是一个整数。<br>对于右移和左移，均用零来填补空位。 移动的位数若为负，则向反方向位移； 若移动的位数的绝对值大于等于 整数本身的位数，其结果为零 （所有位都被移出）。</p></li><li><p><strong>比较操作符</strong></p><p><code>==</code> 等于<br><code>~=</code> 不等于<br><code>&lt;</code> 小于<br><code>&gt;</code> 大于<br><code>&lt;=</code> 小于等于<br><code>&gt;=</code> 大于等于</p></li><li><p><strong>逻辑操作符</strong></p><p><code>and</code>、<code>or</code>、<code>not</code><br>所有的逻辑操作符把 false 和 nil 都作为假， 而其它的一切都当作真。</p></li><li><p><strong>字符串连接操作符</strong></p><p>字符串的连接操作符写作两个点<code>..</code>。如果两个操作元素都是字符串或是数字，连接操作符将会把其转换成字符串，否则会调用元方法<code>__concat()</code>。</p></li><li><p><strong>取长度操作符</strong></p><p>取长度操作符写作一元前置符<code>#</code></p><pre class="highlight"><code class="Lua"><span class="hljs-keyword">local</span> t = &#123;  <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<span class="hljs-built_in">print</span>(#t)<span class="hljs-number">5</span></code></pre></li></ul><h3 id="语句"><a class="markdownIt-Anchor" href="#语句"></a> 语句</h3><ul><li><p><strong>代码块</strong></p><p>Lua可以采用<code>;</code>分割语句，或开始一个代码块，或者连续使用两个分号表示一个<code>空语句</code>。</p><p>函数调用和赋值语句都能以小括号开头，这可能让Lua语法产生歧义：</p><pre class="highlight"><code class="Lua">a = b + c(<span class="hljs-built_in">print</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>)(<span class="hljs-string">'done'</span>)</code></pre><p>从语法上说，可能有两种解释方式：</p><pre class="highlight"><code class="Lua">a = b + c(<span class="hljs-built_in">print</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>)(<span class="hljs-string">'done'</span>) 或a = b + c; (<span class="hljs-built_in">print</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>)(<span class="hljs-string">'done'</span>)</code></pre><p>解析器总是用第一种结构来解析， 它会将括号看成函数调用的参数传递开始处。 为了避免这种二义性， 在一条语句以小括号开头时，建议在前面放一个分号。</p><pre class="highlight"><code class="Lua">;(<span class="hljs-built_in">print</span> <span class="hljs-keyword">or</span> <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span>)(<span class="hljs-string">'done'</span>)</code></pre><p>一个代码块可以通过<code>do ... end</code>显示的被定界为单条语句，这种做法通常是为了控制内部变量声明的作用域，或是在一个语句块中间插入<code>return</code>。</p><p>Lua把代码块当成一个拥有不定参数的匿名函数，因此代码块内可以定义局部变量，它可以接收参数，返回若干值。</p></li><li><p><strong>赋值</strong></p></li></ul><p>Lua允许同时对多个变量赋值，等号左边放一个变量列表，右边放一个值列表，两边列表元素用<code>,</code>隔开，如果<br>值列表的数量多于变量列表，多余值将剔除;反之，则多余变量将被赋值为<code>nil</code>。</p><pre class="highlight"><code class="Lua">&gt; i = <span class="hljs-number">3</span> &gt; i,a[i],c = i+<span class="hljs-number">1</span>,<span class="hljs-number">20</span>&gt; <span class="hljs-built_in">print</span>(c)<span class="hljs-literal">nil</span></code></pre><ul><li><strong><code>if...else</code>语句</strong></li></ul><pre class="highlight"><code class="Lua"><span class="hljs-keyword">if</span> 表达式 <span class="hljs-keyword">then</span>    ...代码块...<span class="hljs-keyword">elseif</span> 表达式 <span class="hljs-keyword">then</span>     ...代码块...<span class="hljs-keyword">else</span>    ...代码块...<span class="hljs-keyword">end</span></code></pre><ul><li><strong><code>while</code>循环</strong></li></ul><pre class="highlight"><code class="Lua"><span class="hljs-keyword">while</span> 表达式 <span class="hljs-keyword">do</span>    ...代码块...<span class="hljs-keyword">end</span></code></pre><ul><li><strong><code>repeat</code>循环</strong></li></ul><pre class="highlight"><code class="Lua"><span class="hljs-keyword">repeat</span>    ...代码块...util 表达式</code></pre><ul><li><strong><code>for</code>循环</strong></li></ul><pre class="highlight"><code class="Lua"><span class="hljs-keyword">for</span> 变量=表达式<span class="hljs-number">1</span>, 表达式<span class="hljs-number">2</span> [,表达式<span class="hljs-number">3</span>] <span class="hljs-keyword">do</span>    ...代码块...<span class="hljs-keyword">end</span></code></pre><p>for语句将循环变量。 从<code>表达式1</code>值开始起，直到<code>表达式2</code>的值为止， 其步长为<code>表达式3</code>，默认步长为<code>1</code>。</p><pre class="highlight"><code class="Lua"><span class="hljs-keyword">for</span> a=<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">2</span> <span class="hljs-keyword">do</span>    <span class="hljs-built_in">print</span>(a)<span class="hljs-keyword">end</span></code></pre><p>for语句还有一种迭代方式<code>for...in</code>，每次迭代，迭代器函数都会被调用以产生一个新的值， 当这个值为 nil 时，循环停止。</p><pre class="highlight"><code class="Lua"><span class="hljs-keyword">for</span> 变量 <span class="hljs-keyword">in</span> 列表表达式　<span class="hljs-keyword">do</span>    ...代码块...<span class="hljs-keyword">end</span></code></pre><blockquote><p>循环语句可以通过<code>break</code>、<code>return</code>、<code>goto</code>来退出。只要 <code>goto</code> 没有进入一个新的局部变量的作用域，它可以跳转到任意可见<code>标签</code>(<code>::标签名::</code>)处。</p></blockquote><h2 id="元表及元方法"><a class="markdownIt-Anchor" href="#元表及元方法"></a> 元表及元方法</h2><p>Lua中的每个值都可以有一个<code>元表(metatable)</code>，这个表就是一个普通的<code>表(table)</code>，它用于定义在特定操作下的行为。当想要改变一个值在特定操作下的行为时，可以在它的元表中设置对应键(事件)的<code>元方法(metamethod)</code>。</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>__add</td><td>(+)加操作，如果任何不是数字的值（包括不能转换为数字的字符串）做加法， Lua 就会尝试调用元方法。</td></tr><tr><td>__sub</td><td>(-)减操作</td></tr><tr><td>__mul</td><td>(*)乘操作</td></tr><tr><td>__div</td><td>(/)除操作</td></tr><tr><td>__idiv</td><td>(//)向下取整操作</td></tr><tr><td>__pow</td><td>(^)次方操作</td></tr><tr><td>__mod</td><td>(%)余操作</td></tr><tr><td>__unm</td><td>(-)取负操作</td></tr><tr><td>__band</td><td>(&amp;)按位与操作</td></tr><tr><td>__bor</td><td>(|)按位或操作</td></tr><tr><td>__bxor</td><td>(~)按位异或操作</td></tr><tr><td>__bnot</td><td>(~)按位非操作</td></tr><tr><td>__shl</td><td>(&lt;&lt;)左位移操作</td></tr><tr><td>__shr</td><td>(&gt;&gt;)右位移操作</td></tr><tr><td>__concat</td><td>(…)连接操作</td></tr><tr><td>__len</td><td>(#)取长度操作</td></tr><tr><td>__eq</td><td>(==)等于操作</td></tr><tr><td>__lt</td><td>(&lt;)小于操作</td></tr><tr><td>__le</td><td>(&lt;=)小于等于操作</td></tr><tr><td>__index</td><td>索引 table[key]。 当 table 不是表或是表 table 中不存在 key 这个键时，这个事件被触发。 此时，会读出 table 相应的元方法。</td></tr><tr><td>__newindex</td><td>索引赋值 table[key] = value 。 和索引事件类似，它发生在 table 不是表或是表 table 中不存在 key 这个键的时候。 此时，会读出 table 相应的元方法。</td></tr><tr><td>__call</td><td>函数调用操作<code>func(args)</code>。当 Lua 尝试调用一个非函数的值的时候会触发这个事件 （即 func 不是一个函数）。 查找 func 的元方法， 如果找得到，就调用这个元方法， func 作为第一个参数传入，原来调用的参数（args）后依次排在后面。</td></tr><tr><td>__tostring</td><td>字符串输出</td></tr><tr><td>__metatable</td><td>保护元表。当调用<code>setmetatable</code>方法时，如果元表中包括此事件，则会抛出一个错误。同样，当调用<code>getmetatable</code>时，会返回此事件关联的值。</td></tr></tbody></table><h3 id="元表的使用"><a class="markdownIt-Anchor" href="#元表的使用"></a> 元表的使用</h3><ul><li><strong><code>__add</code></strong></li></ul><pre class="highlight"><code class="Lua">Set = &#123;&#125;　<span class="hljs-comment">-- 声明一个全局集合对象</span><span class="hljs-keyword">local</span> mt = &#123;&#125; <span class="hljs-comment">-- 声明一个局部元表</span><span class="hljs-comment">--[[-- 创建新集合，并设置元表为mt方法--]]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set.new</span><span class="hljs-params">(dataSet)</span></span><span class="hljs-keyword">local</span> reSet = &#123;&#125;<span class="hljs-built_in">setmetatable</span>(reSet,mt) <span class="hljs-comment">-- 设新集合元表为mt</span><span class="hljs-comment">-- 遍历传入数据集并将数据写入新集合中(键值相同)</span><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dataSet) <span class="hljs-keyword">do</span>reSet[i] = v <span class="hljs-keyword">end</span><span class="hljs-keyword">return</span> reSet;<span class="hljs-keyword">end</span><span class="hljs-comment">--[[-- 获取传入集合的并集方法--]]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set.union</span><span class="hljs-params">(dataSetA,dataSetB)</span></span><span class="hljs-keyword">local</span> reSet = Set.new&#123;&#125; <span class="hljs-comment">-- 创建新集合，相当于Set.new(&#123;&#125;)</span><span class="hljs-comment">-- 遍历A数据集</span><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dataSetA) <span class="hljs-keyword">do</span> reSet[i] = v<span class="hljs-keyword">end</span><span class="hljs-comment">-- 遍历B数据集</span><span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dataSetB) <span class="hljs-keyword">do</span> reSet[i] = v<span class="hljs-keyword">end</span><span class="hljs-keyword">return</span> reSet<span class="hljs-keyword">end</span><span class="hljs-comment">-- 测试new方法创建集合元表是为相同</span><span class="hljs-keyword">local</span> set1 = Set.new(&#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;)<span class="hljs-keyword">local</span> set2 = Set.new(&#123;[<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>,[<span class="hljs-number">4</span>]=<span class="hljs-number">2</span>&#125;)<span class="hljs-built_in">assert</span>(<span class="hljs-built_in">getmetatable</span>(set1) ~= <span class="hljs-built_in">getmetatable</span>(set2)) <span class="hljs-comment">-- 返回table: 0x7fa2a8c072e0，assertion failed! 说明两元表相同</span><span class="hljs-comment">-- 以加操作为例，原本table没有加操作，通过元表附予table加操作</span>mt.<span class="hljs-built_in">__add</span> = Set.union <span class="hljs-comment">-- 给元表增加__add事件，并将事件的行赋予Set.union</span><span class="hljs-keyword">local</span> set3 = set1 + set2 <span class="hljs-comment">-- 表之间可以相加，并且set3内容为set1和set2的并集 &#123;10,20,30,1,2&#125;</span></code></pre><blockquote><p>上例中<code>Set.union</code>就是元表的<code>元方法</code>，Lua中不同元素都有相同或不同的元表，在执行不同操作时选择元哪个元表，Lua按照以下步骤进行：<br>1、对于二元操作符，如果第一个操作数有元表，并且元表中有所需要的事件定义，如<code>__add</code>事件的定义，Lua就以这个元表的事件方法为元方法，而与第二个操作数无关；<br>2、对于二元操作符，如果第一个操作数有元表，但是元表中没有所需要的事件定义，如<code>__add</code>元方法定义，Lua就去查找第二个操作数的元表；<br>3、如果两个操作数都没有元表，或者都没有对应的元方法定义，Lua就抛出一个错误。</p></blockquote><ul><li><strong><code>__tostring</code></strong></li></ul><p>Lua中当表调用<code>tostring()</code>、<code>print()</code>等方法时会，会去寻找<code>__tostring</code>事件的元方法，可以通过自定义元方法实现个性打印。</p><pre class="highlight"><code class="Lua"><span class="hljs-comment">--[[-- 定义自符串输出方法--]]</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Set.toString</span><span class="hljs-params">(dataSet)</span></span><span class="hljs-keyword">local</span> tb = &#123;&#125;<span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(dataSet) <span class="hljs-keyword">do</span> tb[i] = v<span class="hljs-keyword">end</span><span class="hljs-keyword">return</span> <span class="hljs-string">'&#123;'</span> .. <span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(tb,<span class="hljs-string">','</span>) .. <span class="hljs-string">'&#125;'</span> <span class="hljs-comment">-- table.concat()返回列表的元素连接的字符串</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 设置元表mt的__tostring的元方法</span>mt.<span class="hljs-built_in">__tostring</span> = Set.toString<span class="hljs-comment">-- 直接打印集合set3</span><span class="hljs-built_in">print</span>(set3) &gt; &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;</code></pre><ul><li><strong><code>__metatable</code></strong></li></ul><p>Lua元素元表可以随时通过<code>setmetatable</code>方法修改，灵活方便同时也增加了风险，可以通<code>__metatable</code>事件，使元素元表受到保护不可被修改。当再次调用<code>setmetatable</code>方法时，将会抛出一个受保护的错误;当调用<code>getmetatable</code>方法时，会返回事件关联的值。</p><pre class="highlight"><code class="Lua"><span class="hljs-comment">-- 设置元表__matatable事件</span>mt.<span class="hljs-built_in">__metatable</span> = <span class="hljs-string">'不允许修改元表'</span><span class="hljs-built_in">print</span>(<span class="hljs-built_in">getmetatable</span>(set1)) <span class="hljs-comment">-- 获取元表返回设置的内容</span>&gt;&gt; 不允许修改元表<span class="hljs-built_in">setmetatable</span>(set1,&#123;&#125;) <span class="hljs-comment">-- 修改元表提示受保护元表不可以被改变</span>&gt;&gt; cannot change a protected metatable </code></pre><h2 id="模块"><a class="markdownIt-Anchor" href="#模块"></a> 模块</h2><p><em><strong>持续更新中…</strong></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lua是一门扩展式、动态类型的程序设计语言，它没有&lt;code&gt;main&lt;/code&gt;程序的概念只能嵌入一个宿主程序中工作，特点是轻量、可扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a clas
      
    
    </summary>
    
      <category term="软件开发" scheme="http://fcwalkers.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习笔记" scheme="http://fcwalkers.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Lua" scheme="http://fcwalkers.com/tags/Lua/"/>
    
      <category term="Lua学习笔记" scheme="http://fcwalkers.com/tags/Lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>这一世的缘</title>
    <link href="http://fcwalkers.com/2019/07/09/blog/%E8%BF%99%E4%B8%80%E4%B8%96%E7%9A%84%E7%BC%98/"/>
    <id>http://fcwalkers.com/2019/07/09/blog/这一世的缘/</id>
    <published>2019-07-08T16:00:00.000Z</published>
    <updated>2019-07-23T03:49:21.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="心情随笔" scheme="http://fcwalkers.com/categories/%E5%BF%83%E6%83%85%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
